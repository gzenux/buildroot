diff --git a/CHANGELOG-STM b/CHANGELOG-STM
new file mode 100644
index 0000000000..962cfbdf29
--- /dev/null
+++ b/CHANGELOG-STM
@@ -0,0 +1,555 @@
+#
+#  CHANGELOG
+#
+
+* Fri Oct  2 2009 Chris Smith <chris.smith@st.com> 45
+- [Add patch: u-boot-1.3.1_stm23_0045.patch]
+- Rebase on git tag stm23_45, see git repository for more details.
+
+* Mon Aug 10 2009 Chris Smith <chris.smith@st.com> 44
+- [Add patch: u-boot-1.3.1_stm23_0044.patch]
+- Rebase on git tag stm23_44, see git repository for more details.
+
+* Thu May 21 2009 Chris Smith <chris.smith@st.com> 43
+- [Add patch: u-boot-1.3.1_stm23_0043.patch]
+- Rebase on git tag stm23_43, see git repository for more details.
+
+* Tue Oct 14 2008 Sean McGoogan <Sean.McGoogan@st.com> 42
+- [Add patch: u-boot-1.3.1_stm23_0038-20081014.patch.gz; Bugzilla: 4465; Bugzilla: 4624; Bugzilla: 4726; Bugzilla: 4806; Bugzilla: 4828]
+- Added support for the MB680 (STx7105) board.
+  This includes support for the new SoC on the MB680 board, as well
+  as the following blocks: Serial (ASC), NOR Flash, NAND Flash, USB
+  (OHCI), and ST-GMAC + NS DP83865 PHY.  The following are not supported:
+  Serial Flash (SPI), PCI, SATA, EHCI, or any of the other blocks that
+  STMicroelectronics does not support in U-boot.
+- Added phase I support for STMicroelectronics' MB628 (STx7141)
+  This update provides initial (Phase I only) support for the MB628
+  board, which uses STMicroelectronics' STx7141 SoC device. Phase II
+  will be provided later.
+- Include support for latest EPLD revisions on MB618 (STx7111) boards.
+  The STMicroelectronics' MB618 (STx7111) board has undergone several EPLD
+  revisions in the firmware, and the previous version of U-Boot became
+  incompatible with the newer versions.
+  This update now supports version 06 (and later) of the EPLD firmware. As
+  a result of this change, all versions of the firmware prior to version
+  06 (specifically 04 and 05) are no longer supported.  Boards with
+  earlier versions of the supported firmware must upgrade to a later
+  version to use this patch to U-boot.
+  A new configuration macro "CONFIG_SH_NO_EPLD" now exists, which can be
+  used to instruct U-Boot to disregard the presence of a EPLD.  This is
+  useful for clones of the MB618, which do *not* have a EPLD.
+- Ensure Caches are always in Copy-Back mode (CCR.CB==1)
+  Prior to this fix, then the following was used: CCR.CB==CCR.WT==0.
+  That is, P0 and P3 are in Copy-Back, but P1 was in Write-Through mode.
+  However, Write-Through was effectively only enabled in P1 in 29-bit
+  mode. In 32-bit mode, the PMB[x].WT==0 dominates, ensuring that we
+  were actually in Copy-Back mode in 32-bit mode.
+  This update, will set: CCR.CB==1, CCR.WT==0, PMB[x].WT==0.  This will
+  always put all cached accesses (P0, P1 and P3) into Copy-Back mode,
+  in both 29-bit, and 32-bit modes.
+- Added a "progress indicator" when writing to NOR flash devices.
+  Modified the flash routines to print a dot (".") character for
+  every 16 KiB of data written to NOR flash, as a progress indicator.
+  This modification also tidied up some of the diagnostics, to make them
+  more consistent, e.g. the use of ellipsis ("...") and "done" strings.
+- Improvements to the "bdinfo" command's output for SH boards.
+  Tidied up the output from the "bdinfo" command for boards with SH
+  devices on them. The code is now structured better; duplicated code
+  was removed; and the field width of the various reported parameters
+  are now all consistent.
+- First attempt at using the new binary prefixes: Ki, Mi, Gi
+  This is a first attempt at modifying U-boot to use exclusively the IEC
+  recommended binary (2^10) prefixes (e.g. "Ki", "Mi", "Gi"), instead
+  of the disapproved SI decimal (10^3) prefixes (e.g. "k", "M", "G"),
+  for measuring units of computer memory, disk space, etc.
+  This is recommended by the addendum to IEC 60027-2, and the IEEE
+  1541-2002 standards.  The traditional SI prefixes should now only have
+  a base-10 meaning, and not have any base-2 meaning.
+  This modification has been aimed primarily at the SH architecture, and
+  all the relevant SH files have been changed appropriately. In addition,
+  most architecture agnostic source files have also been modified. As
+  a result, all code normally built on SH should now exclusively use
+  the appropriate prefixes correctly.
+- Print out the OUI with a field width of 6 (was 4)
+  The OUI is a 24-bit value, and so it requires a maximum of 6 character
+  positions to print it in hex. Previously it was only 4 character
+  positions. PHYs which have any bits set in the top octet resulted
+  in the output of the "mii info" command being unaligned. This update
+  fixes that annoyance.
+- Bug fix to include/asm-sh/st40reg.h (ST40_EMI_BANK_ENABLE)
+  Fixed a bug that the register offset for ST40_EMI_BANK_ENABLE was
+  incorrect.  Instead, an unused macro ST40_EMI_BANKNUMBER had this offset,
+  and this (unused macro) has now been removed.
+  This bug was originally reported in STMicroelectronics' bare-machine
+  tool-set as DDTS #INSbl28111.
+  This bug fix is required with boards that need to disable some of the
+  EMI banks, due to a lot of NOR flash being present on the board.
+- Bug-fix and refactoring of the (STM) ASC serial driver
+  This update is a refactoring of the drivers/serial/stm-asc.c ASC driver
+  file for the UART used by STMicroelectronics. This was primarily to
+  address some confusion/misdirection over the accuracy of the comments,
+  which had been reported a few times.  As a result, the comments are
+  now correct, and there is a comment for each function, which should
+  significantly address the maintainability of the file.
+  As a result of the tidying up, some functions have been deleted, and
+  (in some cases) recreated in a different guise, further improving the
+  readability and maintainability of the driver.
+  Code has been commented out, removing the support for the
+  anachronistically slower baud rates (below 9600). If required, it can
+  be re-enabled!
+  Finally, a bug was fixed which had previously resulted in baud rates
+  slower than 19200 being mis-configured with the wrong baud rate divisor.
+  This has now been fixed, and all supported baud rates have been tested.
+  The baud rates now supported are: 9600, 19200, 38400, 57600, 115200.
+- Added test code to put the PHY into loopback mode.
+  Added conditionally compiled code, such that if CONFIG_PHY_LOOPBACK
+  is defined, then stm-stmac.c will put the external PHY in loop-back
+  mode, for testing purposes. In addition, for all TX and RX packets,
+  the frame header will be dumped, to facilitate easier debugging.
+
+* Mon Sep 29 2008 Melwyn Lobo <melwyn.lobo@st.com> 41
+- [Add patch: u-boot-1.3.1_nmdk_008-ethernet-on-ndk20.patch]
+  Fixed bug for ethernet board on ndk20.
+
+* Fri Sep 26 2008 Melwyn Lobo <melwyn.lobo@st.com> 40
+- [Add patch: u-boot-1.3.1_nmdk_007-ifdef-removed.patch]
+  Added support for ethernet over usb for Davicom DM9601 dongle chip.
+  Fixed bugs for fifo reads, writes in bulk message transfers.
+- [Add patch: u-boot-1.3.1_nmdk_006-davicom-usb-ethernet-support.patch]
+  Added support for ethernet over usb for Davicom DM9601 dongle chip.
+  Fixed bugs for fifo reads, writes in bulk message transfers.
+
+* Tue Aug 26 2008 Kumar Bipin <kumar.bipin@st.com> 39
+- [Add patch: u-boot-1.3.1_nmdk_002-yaffs2-onenand.patch]
+  Added yaffs2 support.
+- [Add patch: u-boot-1.3.1_nmdk_003-fastboot.patch]
+  Added hw ecc and burst read for nand & onenand.
+- [Add patch: u-boot-1.3.1_nmdk_004-ethernet.patch]
+  Added ethernet support on ndk20.
+- [Add patch: u-boot-1.3.1_nmdk_005-usb.patch]
+  Added usb minimal support on ndk20.
+
+* Fri Aug 01 2008 Sean McGoogan <Sean.McGoogan@st.com> 38
+- [Add patch: u-boot-1.3.1_stm23_0036-20080801.patch.gz; Bugzilla: 4102; Bugzilla: 4173]
+- Support for the following two new boards: MB671 and CB102.
+  Both these boards uses STMicroelectronics' STx7200 chip.  This update
+  includes testing on both 29-bit and 32-bit (SE) modes.
+- Added support for all 256MB of LMI0 RAM (on MB671+CB102) in SE-mode.
+  The new MB671+CB102 boards have 256MB of memory in LMI0.  This update
+  has refactored the PMB code, such that there are now two contiguous
+  128MB PMB entries (instead of just the one) to map the entire 256MB
+  of LMI0 memory.  As a result, U-boot will now be located at 0x8FF00000
+  on boards with 256MB in LMI0 in SE mode.
+  The PMB refactoring has resulted in the following significant changes:
+  <p>PMB[0:1] is used to map main memory, and will mostly be used as
+  cached, except on initialization, and when passing control to the
+  linux kernel, where it will be un-cached.
+  <p>PMB[2:3] is an alias for PMB[0:1], except it is guaranteed to
+  always be UN-cached. This is required in order that we can safely
+  toggle the cacheability of PMB[0:1].
+  <p>PMB[0:1]  will map VA 0x80000000 .. 0x8fffffff.  (256MB)
+  <p>PMB[2:3]  will map VA 0x90000000 .. 0x9fffffff.  (256MB)
+  <p>PMB[4:15] will map VA 0xa0000000 .. 0xbfffffff.  (512MB)
+  <p>If sizeof(LMI) <= 128MB, then PMB[1] and PMB[3] are unused,
+  i.e. PMB[1].V == PMB[3].V == 0.
+  see include/asm-sh/pmb.h for further details.
+- A new U-boot command "pmb" has been added.
+  This new command, which when run, will display the state of all the
+  currently valid PMB entries, in SE-mode. When compiled with the macro
+  DEBUG defined, it will also verify adherence to the aforementioned
+  refactoring requirements of the PMB.
+- Fix incorrect probing of AMD (compatible) CFI flash devices.
+  Prior to this fix, CFI flash, compatible with the AMD command set,
+  may be miss-probed, and wrongly identified. This changes addresses
+  this issue.  Both INTEL and AMD compatible CFI flash devices should
+  now be correctly identified.
+  For further details, please see:
+  https://bugzilla.stlinux.com/show_bug.cgi?id=4102
+- Added support for latest revisions of SMSC LAN8700 devices.
+  The stm-stmac.c driver has been updated to be tolerant of minor
+  revision changes in the PHYID register for both the SMSC LAN8700
+  and the STMicroelectronics STe101p.
+- Bug fix: added 2 NOP instructions to cpu/sh/start.S
+  Added a couple of NOP instructions, to workaround the
+  problem reported in the following bugzilla report:
+  https://bugzilla.stlinux.com/show_bug.cgi?id=4173
+- Pad printed memory sizes with a field width of 3.
+  The function print_size() will now pad memory sizes to a field width of 3
+  (it was 2). This is required as a lot of boards now have > 99MB of RAM
+  on them, and the vertical alignments were inconsistent, when displaying
+  the capacity for a board with a lot of RAM, but a small amount of flash.
+- Improved debugging of cpu/sh/start.S.
+  Some additional descriptive symbols are now defined in cpu/sh/start.S,
+  which should facilitate easier debugging of this file.
+- Linux Kernel compatibility checking
+  Fixed a minor bug in lib_sh/sh_linux.c, whereby the wrong mode was
+  reported for both linux & U-boot, if the kernel was inappropriate.
+- Numerous minor changes.
+
+* Mon Jul 14 2008 Vinayak Pane <vinayak.pane@st.com> 37
+- [Add patch: u-boot-1.3.1_nmdk_001-ethernet.patch]
+  Added support for ethernet on ndk20 board. Modified CFG_ENV_OFFSET.
+
+* Tue Jun 10 2008 Sean McGoogan <Sean.McGoogan@st.com> 36
+- [Add patch: u-boot-1.3.1_stm23_0034-20080610.patch.gz; Bugzilla: 3665]
+- Added support for the MB618 (STx7111) MBoard.
+  This update includes support for serial, GMAC, USB, NAND & NOR flashes.
+  It has been tested on both 29-bit and 32-bit (SE) modes; both from GDB
+  and booting from NOR-flash.
+  It should be noted that the MB618 supports both NOR and NAND
+  flashes. However, only one may be visible any any one point. Hence,
+  it is necessary to re-configure and re-build U-boot, to swap between
+  NAND/NOR flash devices.
+- This is the first update that includes support for the new SH4-300
+  series family of CPU cores.
+- Ensure MMU coherency (with RTE) on SE mode-switching
+  Previously the code executed 8 NOP instructions, immediately after
+  entering 32-bit mode (SE=1).  However, this is not architecturally
+  guaranteed (on SH4-300 series cores). Executing an RTE instruction
+  instead, is guaranteed to preserve the MMU coherency, on all SH cores.
+  This update, replaces the eight NOPs, with an RTE instruction, to
+  ensure the MMU coherency, when mode-switching, in all cases.
+- Use the on-chip Watchdog to effect a (power-on) reset.
+  Prior to this change, the "reset" command was implemented by setting
+  SR.BL=1, and issuing a TRAPA instruction.  This update is to use
+  the on-chip watchdog timer instead, to effect a power-on-reset. All
+  "reset" commands for the SH family, will now use the watchdog as
+  the reset mechanism.  As a result of this change, the chip-specific
+  st?7???_reset() functions have been all been replaced by a single
+  sh_reset() function, which now resides in lib_sh/board.c.
+- Enable cachable address for NOR FLASH in 32-bit (SE) mode.
+  In 32-bit (SE-mode) added cached aliases for NOR FLASH (in addition
+  to the uncached) mappings. The memory map for NOR FLASH is now:
+  	Physical:	0x00000000
+  	UN-cached:	0xA0000000
+  	Cached	:	0xA8000000
+  Thus, one can program NOR flash using uncached addresses, and Boot
+  using cached addresses.
+- Bug fix for CFI FLASH devices.
+  Recent reliability improvement patches for CFI FLASH, in particular for
+  multi-bank devices, appeared to unintentionally break uni-bank FLASH
+  devices. This patch corrects this problem.  In particular it ensures
+  that CFI mode is enabled when required, and will use the correct RESET
+  command code when required.
+- Several minor changes to other files (mostly configuration) have
+  been made.  These were just to keep the code as "unified" as possible.
+
+* Wed May 14 2008 Sachin Verma <sachin.verma@st.com> 35
+- [Add patch: u-boot-1.3.1_nmdk.patch] 
+  U-boot updated for Nomadik. Added Support for 8820 board, and boot 
+  from MMC, OneNand.
+
+* Mon Apr  7 2008 Carl Shaw <carl.shaw@st.com> 34
+- [Add patch: u-boot-1.3.1-stmmac_fix.patch] 
+  fix MDIO bus write function
+
+* Tue Apr  1 2008 Carl Shaw <carl.shaw@st.com> 33
+- [Add patch: u-boot-1.3.1-sha1-header-fix.patch]
+  Change sha1.c which is shared between host and target so that during
+  the host tools phase it does not use asm-sh/string.h if the host
+  system does not have /usr/include/linux/string.h
+
+* Tue Mar 25 2008 Sean McGoogan <Sean.McGoogan@st.com> 32
+- [Update: 1.3.1] Updated to version 1.3.1 for ST40
+- [Add patch: u-boot-1.3.1-stm-20080319.patch.gz; Bugzilla: 3665]
+- Add support for the CB101 board. The CB101 board is now supported. This
+  has been tested (modulo SATA) on both 29-bit and 32-bit systems.
+- USB now works on both STb710x and STi7200 chips.  Added support for
+  USB Mass-Storage for the STi7200 chip. It should be noted that although
+  the STi7200 supports three USB Host Controllers, that only one may be
+  used. This is a current restriction of the generic U-boot sources, and
+  not the SH port.  Also tidied up the initialisation of USB (and SATA).
+  USB mass storage tested, on both 29-bit and 32-bit systems.
+- Added initial support for NAND FLASH on the ST40 Silicon.  Added
+  initial support added for NAND FLASH for the CB101 board with the
+  STx7200 silicon from STMicroelectronics. This has been tested for
+  both 29-bit and 32-bit environments, but only on the CB101, with both
+  (on-board) NAND chips.  Testing included using the JFFS2 file-system,
+  and the "mtdparts" environment variable to define partitions for
+  both NAND and NOR partitions.  Performance of this initial version is
+  sub-optimal. This version takes no advantage of the caches that are
+  available on the SuperH architecture.
+- Fix a putative DataToggle Error whilst performing BULK transfers.
+  There was a subtle bug with the way that the OHCI data toggle carry
+  bitfields were managed. It was possible for the HC and the remote
+  device to get out of step with the data toggle values, due to the fact
+  that the ED structures were re-used, without saving and restoring the
+  ED.C bitfield across this re-use.  This problem was only observed when
+  there were multiple (strictly greater than one) BOT USB Mass-Storage
+  devices present on the system. The system would sometimes hang, and
+  report timeouts. Simply adding or removing a device, or exchanging
+  the positions on the bus of two devices could invert the behaviour. It
+  initially looked like a random instability.  Due to the fact that only
+  a statically defined small number (eight) ED structures were available
+  to the HCD to manage all the devices, the EDs were regularly re-used, if
+  multiple devices were present. This resulted in the ED.C (toggleCarry)
+  bitfield potentially losing its value between two consecutive BULK
+  accesses to a single device, if the ED structure was temporarily
+  re-used to communicate with a different device. The following simple
+  command sequence was enough to provoke it: "usb reset;usb part". This
+  modification saves the ED.C bitfield in the usb_device structure, after
+  each transaction. It will then invert the hardware visible ED.C for new
+  BULK transfers, if a DataToggle error would have otherwise resulted.
+  It should be noted that CONTROL transfers were immune from this problem.
+- Fix to CFI flash, to support multi-bank devices better.  Fixed a
+  problem that occurs with multi-bank devices, whereby, a sector was
+  in the wrong mode, and the wrong data was accessed. Now explicit
+  calls are made to ensure the sector is in the correct mode prior
+  to accessing it.  This should address some of the inconsistencies,
+  and reliability issues that were sometimes observed with NOR FLASH
+  devices, especially with multi-bank devices.  Without this fix, the
+  "protection" status information for a given sector was indeterminate.
+- Minor change, so that if/when CFG_MONITOR_LEN changes in the
+  configuration file, then $monitor_sec and CFG_ENV_OFFSET will
+  automatically track, accordingly. Thus, it should be easier to change
+  correctly.
+- By default, CB101 and HMS1 now default to allocating 256kB for the
+  monitor (2 sectors), with the remaining boards allocating only 128kB
+  (1 sector). Typically, enabling USB will require 2 sectors.
+- Enabled CFG_FLASH_EMPTY_INFO for all STMicroelectronics boards.
+  This useful feature is now enabled, by default, for all supported
+  boards from STMicroelectronics. Note the "flinfo" command will be
+  slower as a result.
+- Experimental Performance improvement for OHCI USB.  Uncommenting the
+  following line will remove some delays in the USB sub-system. However,
+  it is possible that some of these removed delays may be actually
+  necessary on some hardware devices.  So, although this gives a
+  useful performance improvement, it does so at the potential risk of
+  reliability and stability.  This should be considered as an experiential
+  configuration, and not at all recommended for production or deployment
+  code, unless it has been thoroughly tested for your specific hardware.
+  Enabling this optimisation makes some assumptions, that may be totally
+  without any foundation.  If reliability or stability becomes an issue,
+  then please disable this configuration option, as a first step.
+  Use it at your own peril - strictly caveat emptor!
+	#define CONFIG_USB_AGGRESSIVE_MINIMAL_DELAYS
+- Ensure that LBA48 is used on both PATA and SATA by default. Also, ensure
+  that LBA's are stored in a 64-bit value (fixes compiler warnings).
+- Changed default IDE device from PATA to SATA on most boards.
+- The list of currently supported boards are:
+	mb411, mb442, mb448, mb519, hms1 and cb101.
+
+* Tue Mar 11 2008 Sachin Verma <sachin.verma@st.com> 31
+- [Add patch: nomadik-u-boot-8815-header_fix.patch]
+  Removed ST proprietary headers
+
+* Tue Mar 04 2008 David McKay <david.mckay@st.com> 30
+- [Add patch: nomadik-u-boot-8815-cmd_edit.patch]
+  Add command line editing
+- [Spec] Added release number to version string. 
+  Delete unused %%st_version macro
+  Added symbolic link to sources
+
+* Tue Feb  26 2008 Sachin Verma <sachin.verma@st.com> 29
+- [Add patch: nomadik-u-boot-8815-saveenv.patch]
+  Added saveenv functionality for ndk15 boards
+
+* Wed Feb  20 2008 Sachin Verma <sachin.verma@st.com> 28
+- [Update: 1.3.1] Updated to new version of u-boot.
+- [Add patch: nomadik-u-boot-v2.3beta-1.3.1.patch]
+  Support's NDK15 boards only
+- Support for NDK10 boards has been dropped
+
+* Fri Dec  7 2007 Sean McGoogan <Sean.McGoogan@st.com> 27
+- [Add patch: u-boot-1.2.0_stm23_0026_pmb_invalidate_fix_for_stb7109.patch]
+  Bug Fix: Can now correctly boot 32-bit kernels on the STb7109.
+
+* Thu Nov 22 2007 Sean McGoogan <Sean.McGoogan@st.com> 26
+- [Update: 1.2.0] Rebaselined to latest offical version of U-boot.
+- [Add patch: u-boot-1.2.0-stm-20071122.patch.gz]
+- Now supports both traditonal (29-bit) and the new Space Enhanced
+  (32-bit, or SE) addressing modes.
+- Most of the make target have been re-named, please read the top-level
+  "Makefile" for the new configuration names to use.
+- Older ST40-100 series CPU cores are no longer supported.
+- The list of currently supported boards are:
+  	mb411, mb442, mb448, and mb519.
+- Note the architecture has changed from "sh4" to "sh", so "-a=sh"
+  should be used for mkimage. Also, old ".ub" files need to be re-built
+  with tools/mkimage to be compatable with this release.
+
+* Wed Nov 14 2007 Stuart Menefy <stuart.menefy@st.com> 25
+- [Add patch: u-boot-mb519_7200_rel2.0.0-lmi-bandwidth.patch]
+  Updated settings for the mb519 LMI registers.
+
+* Thu Sep 24 2007 Stuart Menefy <stuart.menefy@st.com> 24
+- [Spec] Added architecture to package name so that we can have
+  different versions for different architectures co-exist. Note that
+  we need to use %%_stm_target_name instead of %%_stm_target_arch
+  otherwise we end up with different source packages for glibc/uclibc
+  builds. This also requires the arch name be added to the top level
+  U-Boot directory name.
+
+* Fri Sep 07 2007 Carl Shaw <carl.shaw@st.com> 23
+- [Add patch: u-boot-1.1.2_st2.0_0019-stx7200-mb519.patch]
+  Add support for MB519
+- [Add patch: u-boot-1.1.2_st2.0_0019-stx7200-mb519-both-macs.patch]
+  Add support for both on-board MACS and SMSC LAN8700 support
+
+* Thu Aug 30 2007 Carl Shaw <carl.shaw@st.com> 23 
+- [Add patch: u-boot-1.1.2_st2.0_0019-hms1_128m.patch]
+  Add 128M support for the HMS1 board
+
+* Wed Aug 29 2007 Angelo Castello <angelo.castello@st.com> 23
+- [Spec] Added flash individual block locking support.
+
+* Wed Aug  1 2007 Carl Shaw <carl.shaw@st.com> 23
+- [Spec] Use if_target_arch conditional
+
+* Thu Jul 19 2007 Giuseppe Cavallaro <peppe.cavallaro@st.com> 23
+- [Spec] ported on uClibc build system.
+
+* Thu Jul 19 2007 Angelo Castello <angelo.castello@st.com> 22
+- [Add patch: u-boot-1.1.2_stm23ear_0020_multiple_bank.patch Bugzilla: 1774; 
+  Bugzilla: 1494] Support for flash multiple bank memory layout. Back compatible with
+  flash sigle bank.
+* Mon Jul 9 2007 Sachin Verma <sachin.verma@st.com> 21
+- [Add patch: nomadik-u-boot-v2.3alpha-1.1.5.patch]
+  Updated for latest ARM nomadik patch.
+
+* Mon May 14 2007 Stuart Menefy <stuart.menefy@st.com> 20
+- [Add patch: u-boot-1.1.2_st2.0_0019-stb7100ref-128m.patch; Bugzilla: 1763; Bugzilla: 1845]
+  Support for STB7100ref with 128M LMI SYS.
+
+* Mon May 14 2007 Stuart Menefy <stuart.menefy@st.com> 19
+- [Add patch: u-boot-1.1.2_st2.0_0017-hms1.patch] Basic HMS1 board support
+- [Add patch: u-boot-1.1.2_st2.0_0017-stm-sata-7109c3.patch; Bugzilla: 1370]
+  Fix detection of 7109c3 so that SATA works.
+- [Add patch: u-boot-1.1.2_st2.0_0017-hms1-7109c3-emi.patch; Bugzilla: 1580]
+  Update EMI settings for 7109c3 on HMS1.  
+
+* Fri Feb 16 2007 David McKay <david.mckay@st.com> 18
+- [Update: 1.1.5] Added in ARM nomadik support 
+
+* Sat Oct 14 2006 Stuart Menefy <stuart.menefy@st.com> 17
+- Updated for 2.2 distribution with new build number style version,
+  which allows removal of release from external names. Also
+  renamed to u-boot-source and removed arch from name.
+
+* Wed Aug 30 2006 Stuart Menefy <stuart.menefy@st.com> 17
+- Added u-boot-1.1.2_st2.0-14-remove_coprocessor_mem.patch
+
+* Wed Aug 30 2006 Stuart Menefy <stuart.menefy@st.com> 16
+- Added requirement for host-filesystem package
+
+* Mon Aug 28 2006 David McKay <david.mckay@st.com>
+- Applied patch to fix problems with make 3.81
+
+* Fri Aug 18 2006 Carl Shaw <carl.shaw@st.com> 15
+- Added patch u-boot-stlinux-2.0.piofix.patch from Bugzilla 795
+
+* Wed Aug 16 2006 Carl Shaw <carl.shaw@st.com> 15
+- Updated to latest ST version
+- Added gcc4 build fixes
+- Incremented release number to 15
+
+* Fri May 19 2006 Andy Sturges <andy.sturges@st.com>
+- New features:
+-  support stb7109 cut2 silicon
+- Bug fixes:
+-  stb7100 cut 3.xand stb7109 cut2 run PLL1 at 400MHz
+-  cfi flash driver hw protect code modified to reduce protect cycles used
+-  unaligned access in itest function fixed
+-  u-boot-stlinux-2.0-stb7100refcut31.patch merged into main patchfile
+
+* Wed Mar 29 2006 Stuart Menefy <stuart.menefy@st.com>
+- Added u-boot-stlinux-2.0-stb7100refcut31.patch
+
+* Fri Mar 10 2006 Andy Sturges <andy.sturges@st.com>
+- New features:
+-  support cut stb7100 cut3.1 silicon
+-  added tools for accessing/chaning u-boot environment from target Linux system (see STM/ev)
+-  added some examples for updating u-boot from u-boot and kernel from Linux system
+-  add CONFIG_ZERO_BOOTDELAY_CHECK incase bootdelay is set to 0
+- Boards added 
+-  stb7109eref
+- Bug fix
+-  itest.l producing incorrect result
+-  stb7100mboard: monitor_base was set to FLASH_BASE in default config 
+-  traviata: fix monitor_sec in default environment
+-  flash write is disabled before calling Linux kernel
+
+* Fri Dec 14 2005 Andy Sturges <andy.sturges@st.com>
+- rename setupenv as localenv
+- Fix mkenv for stb7100
+- Fix for kscript to add uversion
+
+* Fri Dec 9 2005 Andy Sturges <andy.sturges@st.com>
+- New features:
+-  Command line history/editing
+- Boards added 
+-   traviata
+_ New config targets to configure options:
+-   stb7100ref_27_config
+-   stb7100ref_30_config
+- stb710x based boards (stb7100mboard, stb7100ref) now detect chip version and 
+  configure memory system as required.  No longer necessary to change config file.
+- Added STM script directory with:
+-   builduboot          for building uboot binaries for all variants
+-   buildenv/mkenv      for creating standard env for downloading to board
+-   buildlinux/mklinux  for creating u-boot images from linux kernels 
+-   kscript             kermit script for supporting initialisation of boards
+-     setupub           shell wrapper for doing a initial serial setup of u-boot on a board
+-     netsetupub        shell wrapper for doing a network setup of u-boot on a board
+- Added disk support to stm8010mboard
+- Other updates:
+-  Increased CFG_CBSIZE to 1024 for all targets (longer command lines)
+-  Updated memory configs for sh4 targets inline with .cmd files on web
+-  Fixed booting from flash for sti5301 targets (got broken in last release)
+-  sti5528 targets now get clock info from config register
+-  Examples directory now builds correctly for SH4 targets i.e. now support u-boot apps
+-  st220eval default serial output is now com0 
+-  Added better error handling to lost udp packets for NFS
+
+* Fri Oct 7 2005 Andy Sturges <andy.sturges@st.com>
+- Added stb7100ref
+- Fixed stb7100 cut2 emi ethernet problems
+
+* Thu Sep 29 2005 Andy Sturges <andy.sturges@st.com>
+- More tidying of config files
+- Changes for stb7100mboard:
+--  Added support for stb7100 cut 1.3, cut 2.0 and stx7109 cut 1.0  
+--  Added ide disk boot: EMI & SATA
+--  bdinfo displays clock settings for stb7100mboard
+--  baudrate calculation uses clock setting read from config regs
+- Changes to espresso & st220eval:
+--  Added ide disk boot
+
+* Fri Sep 16 2005 Carl Shaw <carl.shaw@st.com>
+- Changed installation directory
+
+* Fri Sep 9 2005 Andy Sturges <andy.sturges@st.com>
+- Updated patch:
+-- Added stm8010mboard target
+-- small fix for 911x autoconf timeout
+-- added STEM ethernet support to stb7100mboard
+* Thu Aug 11 2005 Andy Sturges <andy.sturges@st.com>
+- Updated patch:
+-- Fix st220eval config file for failing writing to flash and flash organisation
+-- re-apply TMU fix which got lost in last release
+-- Tidy stb7100mboard config file for flash organisation.
+-- Tidy sti5301mb390 config file for flash organisation  (puts env at 1st sector - same as mb424)
+-- Tidy st40rastarter flash config flash organisation (reduces size of binary image)
+-- remove unused memory configs from sti5301mb390 & sti5301mb424
+
+* Fri Jul 15 2005 Andy Sturges <andy.sturges@st.com>
+- Updated patch:
+-- Added smc911x ethernet driver, enabled in sti5301mb424
+-- updated memory configs for mb390 and mb424 to the standard clocking
+-- trap handler for sti5301 causes reset.
+ 
+* Mon Jul 11 2005 Andy Sturges <andy.sturges@st.com>
+- Updated patch:
+-- fixes problems with using RTC clock as input to TMU for SH4-1xx platforms as
+-  causing flash write problems.
+-- Updated cfi_flash driver.
+-- Fixes various config header file issues.
+-- Adds command line support for ST200 platforms. 
+-- Changed default uart port for MB390 to be uart0.
+
+* Mon Jun  6 2005 Carl Shaw <carl.shaw@st.com>
+- Automatically removed dependency opt-out line and removed binaries in the source
+- tree as they made the package uninstallable
+
+* Mon May 23 2005 Stuart Menefy <stuart.menefy@st.com>
+- First version
diff --git a/MAKEALL b/MAKEALL
index a02412b80d..5f58efc23d 100755
--- a/MAKEALL
+++ b/MAKEALL
@@ -655,6 +655,58 @@ LIST_blackfin="		\
 	bf561-ezkit	\
 "
 
+#########################################################################
+## SuperH SH4 Systems
+#########################################################################
+
+LIST_sh="		\
+	mb411		\
+	mb448		\
+	mb442_27	\
+	mb442_30	\
+	mb442_27_128	\
+	mb442_30_128	\
+	mb442se_27	\
+	mb442se_30	\
+	mb442se_27_128	\
+	mb442se_30_128	\
+	hms1		\
+	hms1_128	\
+	mb519		\
+	mb519se		\
+	mb618		\
+	mb618se		\
+	hdk7111		\
+	hdk7111se	\
+	mb671		\
+	mb671se		\
+	mb680		\
+	mb680se		\
+	pdk7105		\
+	pdk7105se	\
+	ipidtv7105	\
+	ipidtv7105se	\
+	mb704		\
+	mb704se		\
+	5197cab		\
+	5197cabse	\
+	cb101		\
+	cb101se		\
+	cb102		\
+	cb102se		\
+"
+
+#########################################################################
+## STMicroelectronics ST200 Systems
+#########################################################################
+
+LIST_st200="		\
+	sti5301mb390	\
+	sti5301mb424	\
+	stm8010mboard	\
+	traviata	\
+"
+
 #-----------------------------------------------------------------------
 
 #----- for now, just run PPC by default -----
@@ -689,6 +741,8 @@ do
 	mips|mips_el| \
 	nios|nios2| \
 	ppc|5xx|5xxx|512x|8xx|8220|824x|8260|83xx|85xx|86xx|4xx|7xx|74xx| \
+	sh| \
+	st200| \
 	x86|I486|TSEC)
 			for target in `eval echo '$LIST_'${arg}`
 			do
diff --git a/Makefile b/Makefile
index 1ff80b50d9..d6837c264b 100644
--- a/Makefile
+++ b/Makefile
@@ -152,6 +152,12 @@ endif
 ifeq ($(ARCH),avr32)
 CROSS_COMPILE = avr32-linux-
 endif
+ifeq ($(ARCH),sh)
+CROSS_COMPILE = sh4-linux-
+endif
+ifeq ($(ARCH),st200)
+CROSS_COMPILE = st231-linux-
+endif
 endif
 endif
 
@@ -2658,6 +2664,226 @@ bf561-ezkit_config:	unconfig
 atstk1002_config	:	unconfig
 	@$(MKCONFIG) $(@:_config=) avr32 at32ap atstk1000 atmel at32ap7000
 
+#========================================================================
+# SuperH
+#========================================================================
+#########################################################################
+## SuperH SH4
+#########################################################################
+
+mb411_config :		unconfig
+	@mkdir -p $(obj)include
+	@echo "#define CONFIG_SH_STB7100 1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_MB411   1" >>$(obj)include/config.h
+	@$(MKCONFIG) -a mb411 sh sh mb411 st stb7100
+
+mb442_27_config \
+mb442_30_config \
+mb442_27_128_config \
+mb442_30_128_config \
+mb442se_27_config \
+mb442se_30_config \
+mb442se_27_128_config \
+mb442se_30_128_config : 	unconfig
+	@mkdir -p $(obj)include $(obj)board/st/mb442
+	@echo "#define CONFIG_SH_STB7100   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_MB442     1" >>$(obj)include/config.h
+	$(if $(findstring 27,$@), \
+	@echo "#define INPUT_CLOCK_RATE    27" >>$(obj)include/config.h)
+	$(if $(findstring 30,$@), \
+	@echo "#define INPUT_CLOCK_RATE    30" >>$(obj)include/config.h)
+	$(if $(findstring 128,$@), \
+	@echo "#define CONFIG_SH_MB442_128 1" >>$(obj)include/config.h)
+	$(if $(findstring se,$@), \
+	@echo "#define CONFIG_SH_SE_MODE   1" >>$(obj)include/config.h)
+	$(if $(findstring se,$@), \
+	@echo "TEXT_BASE = 0x83F00000" >$(obj)board/st/mb442/config.tmp)
+	@$(MKCONFIG) -a mb442 sh sh mb442 st stb7100
+
+mb448_config :		unconfig
+	@mkdir -p $(obj)include
+	@echo "#define CONFIG_SH_STB7100   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_MB448     1" >>$(obj)include/config.h
+	@$(MKCONFIG) -a mb448 sh sh mb448 st stb7100
+
+hms1_config \
+hms1_128_config :		unconfig
+	@mkdir -p $(obj)include
+	@echo "#define CONFIG_SH_STB7100   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_HMS1      1" >>$(obj)include/config.h
+	$(if $(findstring 128,$@), \
+	@echo "#define CONFIG_SH_HMS1_128  1" >>$(obj)include/config.h)
+	@$(MKCONFIG) -a hms1 sh sh hms1 st stb7100
+
+mb519_config \
+mb519se_config :		unconfig
+	@mkdir -p $(obj)include $(obj)board/st/mb519
+	@echo "#define CONFIG_SH_STX7200   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_MB519     1" >>$(obj)include/config.h
+	$(if $(findstring se,$@), \
+	@echo "#define CONFIG_SH_SE_MODE   1" >>$(obj)include/config.h)
+	$(if $(findstring se,$@), \
+	@echo "TEXT_BASE = 0x87F00000" >$(obj)board/st/mb519/config.tmp)
+	@$(MKCONFIG) -a mb519 sh sh mb519 st stx7200
+
+mb618_config \
+mb618se_config :		unconfig
+	@mkdir -p $(obj)include $(obj)board/st/mb618
+	@echo "#define CONFIG_SH_STX7111   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_MB618     1" >>$(obj)include/config.h
+	$(if $(findstring se,$@), \
+	@echo "#define CONFIG_SH_SE_MODE   1" >>$(obj)include/config.h)
+	$(if $(findstring se,$@), \
+	@echo "TEXT_BASE = 0x87F00000" >$(obj)board/st/mb618/config.tmp)
+	@$(MKCONFIG) -a mb618 sh sh mb618 st stx7111
+
+hdk7111_config \
+hdk7111se_config :		unconfig
+	@mkdir -p $(obj)include $(obj)board/st/hdk7111
+	@echo "#define CONFIG_SH_STX7111   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_HDK7111   1" >>$(obj)include/config.h
+	$(if $(findstring se,$@), \
+	@echo "#define CONFIG_SH_SE_MODE   1" >>$(obj)include/config.h)
+	$(if $(findstring se,$@), \
+	@echo "TEXT_BASE = 0x8FF00000" >$(obj)board/st/hdk7111/config.tmp)
+	@$(MKCONFIG) -a hdk7111 sh sh hdk7111 st stx7111
+
+mb628_config \
+mb628se_config :		unconfig
+	@mkdir -p $(obj)include $(obj)board/st/mb628
+	@echo "#define CONFIG_SH_STX7141   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_MB628     1" >>$(obj)include/config.h
+	$(if $(findstring se,$@), \
+	@echo "#define CONFIG_SH_SE_MODE   1" >>$(obj)include/config.h)
+	$(if $(findstring se,$@), \
+	@echo "TEXT_BASE = 0x83900000" >$(obj)board/st/mb628/config.tmp)
+	@$(MKCONFIG) -a mb628 sh sh mb628 st stx7141
+
+mb671_config \
+mb671se_config :		unconfig
+	@mkdir -p $(obj)include $(obj)board/st/mb671
+	@echo "#define CONFIG_SH_STX7200   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_MB671     1" >>$(obj)include/config.h
+	$(if $(findstring se,$@), \
+	@echo "#define CONFIG_SH_SE_MODE   1" >>$(obj)include/config.h)
+	$(if $(findstring se,$@), \
+	@echo "TEXT_BASE = 0x8FF00000" >$(obj)board/st/mb671/config.tmp)
+	@$(MKCONFIG) -a mb671 sh sh mb671 st stx7200
+
+mb680_config \
+mb680se_config :		unconfig
+	@mkdir -p $(obj)include $(obj)board/st/mb680
+	@echo "#define CONFIG_SH_STX7105   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_MB680     1" >>$(obj)include/config.h
+	$(if $(findstring se,$@), \
+	@echo "#define CONFIG_SH_SE_MODE   1" >>$(obj)include/config.h)
+	$(if $(findstring se,$@), \
+	@echo "TEXT_BASE = 0x8FF00000" >$(obj)board/st/mb680/config.tmp)
+	@$(MKCONFIG) -a mb680 sh sh mb680 st stx7105
+
+pdk7105_config \
+pdk7105se_config :		unconfig
+	@mkdir -p $(obj)include $(obj)board/st/pdk7105
+	@echo "#define CONFIG_SH_STX7105   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_PDK7105   1" >>$(obj)include/config.h
+	$(if $(findstring se,$@), \
+	@echo "#define CONFIG_SH_SE_MODE   1" >>$(obj)include/config.h)
+	$(if $(findstring se,$@), \
+	@echo "TEXT_BASE = 0x8FF00000" >$(obj)board/st/pdk7105/config.tmp)
+	@$(MKCONFIG) -a pdk7105 sh sh pdk7105 st stx7105
+
+ipidtv7105_config \
+ipidtv7105se_config :		unconfig
+	@mkdir -p $(obj)include $(obj)board/st/pdk7105
+	@echo "#define CONFIG_SH_STX7105    1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_IPIDTV7105 1" >>$(obj)include/config.h
+	$(if $(findstring se,$@), \
+	@echo "#define CONFIG_SH_SE_MODE    1" >>$(obj)include/config.h)
+	$(if $(findstring se,$@), \
+	@echo "TEXT_BASE = 0x8FF00000" >$(obj)board/st/pdk7105/config.tmp)
+	@$(MKCONFIG) -a ipidtv7105 sh sh pdk7105 st stx7105
+
+mb704_config \
+mb704se_config :		unconfig
+	@mkdir -p $(obj)include $(obj)board/st/mb704
+	@echo "#define CONFIG_SH_STX5197   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_MB704     1" >>$(obj)include/config.h
+	$(if $(findstring se,$@), \
+	@echo "#define CONFIG_SH_SE_MODE   1" >>$(obj)include/config.h)
+	$(if $(findstring se,$@), \
+	@echo "TEXT_BASE = 0x83F00000" >$(obj)board/st/mb704/config.tmp)
+	@$(MKCONFIG) -a mb704 sh sh mb704 st stx5197
+
+5197cab_config \
+5197cabse_config :		unconfig
+	@mkdir -p $(obj)include $(obj)board/st/5197cab
+	@echo "#define CONFIG_SH_STX5197   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_5197CAB   1" >>$(obj)include/config.h
+	$(if $(findstring se,$@), \
+	@echo "#define CONFIG_SH_SE_MODE   1" >>$(obj)include/config.h)
+	$(if $(findstring se,$@), \
+	@echo "TEXT_BASE = 0x83F00000" >$(obj)board/st/5197cab/config.tmp)
+	@$(MKCONFIG) -a 5197cab sh sh 5197cab st stx5197
+
+cb101_config \
+cb101se_config :		unconfig
+	@mkdir -p $(obj)include $(obj)board/st/cb101
+	@echo "#define CONFIG_SH_STX7200   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_CB101     1" >>$(obj)include/config.h
+	$(if $(findstring se,$@), \
+	@echo "#define CONFIG_SH_SE_MODE   1" >>$(obj)include/config.h)
+	$(if $(findstring se,$@), \
+	@echo "TEXT_BASE = 0x87F00000" >$(obj)board/st/cb101/config.tmp)
+	@$(MKCONFIG) -a cb101 sh sh cb101 st stx7200
+
+cb102_config \
+cb102se_config :		unconfig
+	@mkdir -p $(obj)include $(obj)board/st/cb102
+	@echo "#define CONFIG_SH_STX7200   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_SH_CB102     1" >>$(obj)include/config.h
+	$(if $(findstring se,$@), \
+	@echo "#define CONFIG_SH_SE_MODE   1" >>$(obj)include/config.h)
+	$(if $(findstring se,$@), \
+	@echo "TEXT_BASE = 0x8FF00000" >$(obj)board/st/cb102/config.tmp)
+	@$(MKCONFIG) -a cb102 sh sh cb102 st stx7200
+
+
+#========================================================================
+# STMicroelectronics ST200
+#========================================================================
+#########################################################################
+## STMicroelectronics ST231
+#########################################################################
+
+sti5301mb390_config		: 	unconfig
+	@mkdir -p $(obj)include
+	@echo "#define CONFIG_STM_MB390   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_STM_STI5301 1" >>$(obj)include/config.h
+	@echo "#define CONFIG_STM_ST231   1" >>$(obj)include/config.h
+	@$(MKCONFIG) -a sti5301mb390 st200 st231 sti5301mb390 st sti5301
+
+sti5301mb424_config		: 	unconfig
+	@mkdir -p $(obj)include
+	@echo "#define CONFIG_STM_MB424   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_STM_STI5301 1" >>$(obj)include/config.h
+	@echo "#define CONFIG_STM_ST231   1" >>$(obj)include/config.h
+	@$(MKCONFIG) -a sti5301mb424 st200 st231 sti5301mb424 st sti5301
+
+stm8010mboard_config		:	unconfig
+	@mkdir -p $(obj)include
+	@echo "#define CONFIG_STM_STM8010_MBOARD   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_STM_STM8010 1" >>$(obj)include/config.h
+	@echo "#define CONFIG_STM_ST231   1" >>$(obj)include/config.h
+	@$(MKCONFIG) -a stm8010mboard st200 st231 stm8010mboard st stm8010
+
+traviata_config		:	unconfig
+	@mkdir -p $(obj)include
+	@echo "#define CONFIG_STM_TRAVIATA   1" >>$(obj)include/config.h
+	@echo "#define CONFIG_STM_STM8010 1" >>$(obj)include/config.h
+	@echo "#define CONFIG_STM_ST231   1" >>$(obj)include/config.h
+	@$(MKCONFIG) -a traviata st200 st231 traviata st stm8010
+
+
 #########################################################################
 #########################################################################
 #########################################################################
diff --git a/README b/README
index 3dad5fc726..cb683cf8b6 100644
--- a/README
+++ b/README
@@ -152,6 +152,8 @@ Directory Hierarchy:
   - pxa		Files specific to Intel XScale PXA CPUs
   - s3c44b0	Files specific to Samsung S3C44B0 CPUs
   - sa1100	Files specific to Intel StrongARM SA1100 CPUs
+  - sh          Files specific to SuperH (SH) CPUs
+  - st231       Files specific to STMicroelectronics ST200 series CPUs
 - disk		Code for disk drive partition handling
 - doc		Documentation (don't expect too much)
 - drivers	Commonly used device drivers
@@ -166,6 +168,8 @@ Directory Hierarchy:
 - lib_mips	Files generic to MIPS	 architecture
 - lib_nios	Files generic to NIOS	 architecture
 - lib_ppc	Files generic to PowerPC architecture
+- lib_sh	Files generic to SuperH  architecture
+- lib_st200	Files generic to ST200   architecture
 - libfdt 	Library files to support flattened device trees
 - net		Networking code
 - post		Power On Self Test
diff --git a/board/sc520_cdp/sc520_cdp_asm.S b/board/sc520_cdp/sc520_cdp_asm.S
index be7b2bb482..7f70d65d5f 100644
--- a/board/sc520_cdp/sc520_cdp_asm.S
+++ b/board/sc520_cdp/sc520_cdp_asm.S
@@ -76,8 +76,8 @@ done:   movb	$0x88, %al
 	jmp 	*%ebp		     /* return to caller */
 
 
-.globl __show_boot_progress
-__show_boot_progress:
+.globl show_boot_progress
+show_boot_progress:
 	out	%al, $0x80
 	xchg	%al, %ah
 	movw	$0x680, %dx
diff --git a/board/sc520_spunk/sc520_spunk_asm.S b/board/sc520_spunk/sc520_spunk_asm.S
index 8b3410399b..0127076db1 100644
--- a/board/sc520_spunk/sc520_spunk_asm.S
+++ b/board/sc520_spunk/sc520_spunk_asm.S
@@ -73,8 +73,8 @@ done:   movl    $0xfffefc32,%edx
 	jmp 	*%ebp		     /* return to caller */
 
 
-.globl __show_boot_progress
-__show_boot_progress:
+.globl show_boot_progress
+show_boot_progress:
 	movl    $0xfffefc32,%edx
 	xorw    $0xffff, %ax
 	movw    %ax,(%edx)
diff --git a/board/st/5197cab/5197cab.c b/board/st/5197cab/5197cab.c
new file mode 100644
index 0000000000..2b22d5a0f7
--- /dev/null
+++ b/board/st/5197cab/5197cab.c
@@ -0,0 +1,110 @@
+/*
+ * (C) Copyright 2009 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/stx5197reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+
+#define PIO_BASE  0xfd120000	/* Base of PIO block in COMMs block */
+
+
+	/* Alternate Function Output Selection accessors */
+#define ALT_SELn(n,alt)		( (((alt)>>(n))&1)<<(8*(n)) )
+#define ALT_SEL(alt)		( ALT_SELn(1,(alt)) | ALT_SELn(0,(alt)) )
+#define ALT_MASK(port,pin,alt)	( ALT_SEL(alt) << ((((port)&1)?16:0)+((pin)&7)) )
+#define ALTFOP(reg,port,pin,alt)			\
+	do {						\
+		reg &= ~ALT_MASK((port),(pin), 0x3);	\
+		reg |=  ALT_MASK((port),(pin),(alt));	\
+	} while(0)
+
+
+extern void flashWriteEnable (void)
+{
+	/* Enable Vpp for writing to flash */
+}
+
+extern void flashWriteDisable (void)
+{
+	/* Disable Vpp for writing to flash */
+}
+
+
+#ifdef CONFIG_STM_ASC_SERIAL
+static void configSerial (void)
+{
+	unsigned long sysconf;
+
+#if (CFG_STM_ASC_BASE == CFG_STM_ASC2_BASE)
+	/* Setup PIO of ASC device */
+	SET_PIO_ASC(PIO_PORT(1), 2, 3, 5, 4);  /* UART2 - AS0 */
+	/* Route UART2 via PIO1 for TX, RX, CTS & RTS */
+	sysconf = *STX5197_HD_CONF_MON_CONFIG_CONTROL_F;
+	ALTFOP(sysconf,1,2,1);		/* PIO1[2] AltFunction = 1 */
+	ALTFOP(sysconf,1,3,1);		/* PIO1[3] AltFunction = 1 */
+	ALTFOP(sysconf,1,4,1);		/* PIO1[4] AltFunction = 1 */
+	ALTFOP(sysconf,1,5,1);		/* PIO1[5] AltFunction = 1 */
+	*STX5197_HD_CONF_MON_CONFIG_CONTROL_F = sysconf;
+#elif (CFG_STM_ASC_BASE == CFG_STM_ASC3_BASE)
+	/* Setup PIO of ASC device */
+	SET_PIO_ASC(PIO_PORT(2), 0, 1, 2, 5);  /* UART3 - AS1 */
+	/* Route UART3 via PIO2 for TX, RX, CTS & RTS */
+	sysconf = *STX5197_HD_CONF_MON_CONFIG_CONTROL_G;
+	ALTFOP(sysconf,2,0,1);		/* PIO2[0] AltFunction = 1 */
+	ALTFOP(sysconf,2,1,1);		/* PIO2[1] AltFunction = 1 */
+	ALTFOP(sysconf,2,2,1);		/* PIO2[2] AltFunction = 1 */
+	ALTFOP(sysconf,2,5,1);		/* PIO2[5] AltFunction = 1 */
+	*STX5197_HD_CONF_MON_CONFIG_CONTROL_G = sysconf;
+#else
+#error Unknown serial port configuration!
+#endif
+}
+#endif /* CONFIG_STM_ASC_SERIAL */
+
+
+extern int board_init (void)
+{
+#ifdef CONFIG_STM_ASC_SERIAL
+	configSerial ();
+#endif /* CONFIG_STM_ASC_SERIAL */
+
+	return 0;
+}
+
+
+extern int checkboard (void)
+{
+	printf ("\n\nBoard: STx5197-CAB"
+#ifdef CONFIG_SH_SE_MODE
+		"  [32-bit mode]"
+#else
+		"  [29-bit mode]"
+#endif
+		"\n");
+
+	return 0;
+}
diff --git a/board/st/5197cab/5197cab.romgen b/board/st/5197cab/5197cab.romgen
new file mode 100644
index 0000000000..08fa12fe20
--- /dev/null
+++ b/board/st/5197cab/5197cab.romgen
@@ -0,0 +1,781 @@
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+/* PEEK(0xfdc00300) (used target peek value 0x00000100) */
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+POKE32(0xfdc00300, 0x000000f0)
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+POKE32(0xfdc00300, 0x0000000f)
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+/* PEEK(0xfdc00300) (used target peek value 0x00000000) */
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+WHILE_NE32(0xfdc00300, 0x00000100, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.MODE_CONTROL
+*/
+POKE32(0xfdc00110, 0x00000001)
+
+
+/*
+sti5197_system_services_regs.MODE_CONTROL
+*/
+/* PEEK(0xfdc00110) (used target peek value 0x00000001) */
+
+
+/*
+sti5197_system_services_regs.MODE_CONTROL
+*/
+WHILE_NE32(0xfdc00110, 0x00000001, 0x00000001)
+
+
+/*
+sti5197_system_services_regs.PLLA_CONFIG1
+*/
+POKE32(0xfdc00004, 0x00002000)
+
+
+/*
+sti5197_system_services_regs.PLLB_CONFIG1
+*/
+POKE32(0xfdc0000c, 0x00002000)
+
+
+/*
+sti5197_system_services_regs.PLLA_CONFIG1
+*/
+POKE32(0xfdc00004, 0x00002000)
+
+
+/*
+sti5197_system_services_regs.PLLA_CONFIG0
+*/
+POKE32(0xfdc00000, 0x00002303)
+
+
+/*
+sti5197_system_services_regs.PLLB_CONFIG1
+*/
+POKE32(0xfdc0000c, 0x00002000)
+
+
+/*
+sti5197_system_services_regs.PLLB_CONFIG0
+*/
+POKE32(0xfdc00008, 0x00002803)
+
+
+/*
+sti5197_system_services_regs.CPU_CLK_CONFIG0
+*/
+POKE32(0xfdc00090, 0x0000366c)
+
+
+/*
+sti5197_system_services_regs.CPU_CLK_CONFIG1
+*/
+POKE32(0xfdc00094, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.CPU_CLK_CONFIG2
+*/
+POKE32(0xfdc00098, 0x00000053)
+
+
+/*
+sti5197_system_services_regs.LMI_CLK_CONFIG0
+*/
+POKE32(0xfdc000a0, 0x0000cccc)
+
+
+/*
+sti5197_system_services_regs.LMI_CLK_CONFIG1
+*/
+POKE32(0xfdc000a4, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.LMI_CLK_CONFIG2
+*/
+POKE32(0xfdc000a8, 0x00000075)
+
+
+/*
+sti5197_system_services_regs.BLLITER_CLK_CONFIG0
+*/
+POKE32(0xfdc000ac, 0x0000366c)
+
+
+/*
+sti5197_system_services_regs.BLLITER_CLK_CONFIG1
+*/
+POKE32(0xfdc000b0, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.BLLITER_CLK_CONFIG2
+*/
+POKE32(0xfdc000b4, 0x00000053)
+
+
+/*
+sti5197_system_services_regs.SYSTEM_CLK_CONFIG0
+*/
+POKE32(0xfdc000b8, 0x0000739c)
+
+
+/*
+sti5197_system_services_regs.SYSTEM_CLK_CONFIG1
+*/
+POKE32(0xfdc000bc, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.SYSTEM_CLK_CONFIG2
+*/
+POKE32(0xfdc000c0, 0x00000014)
+
+
+/*
+sti5197_system_services_regs.FDMA_PLL_CLK_CONFIG0
+*/
+POKE32(0xfdc000c4, 0x00000aaa)
+
+
+/*
+sti5197_system_services_regs.FDMA_PLL_CLK_CONFIG1
+*/
+POKE32(0xfdc000c8, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.FDMA_PLL_CLK_CONFIG2
+*/
+POKE32(0xfdc000cc, 0x00000071)
+
+
+/*
+sti5197_system_services_regs.AV_CLK_CONFIG0
+*/
+POKE32(0xfdc000d0, 0x00003c78)
+
+
+/*
+sti5197_system_services_regs.AV_CLK_CONFIG1
+*/
+POKE32(0xfdc000d4, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.AV_CLK_CONFIG2
+*/
+POKE32(0xfdc000d8, 0x00000013)
+
+
+/*
+sti5197_system_services_regs.SPARE_PLL_CLK_CONFIG0
+*/
+POKE32(0xfdc000dc, 0x00003c78)
+
+
+/*
+sti5197_system_services_regs.SPARE_PLL_CLK_CONFIG1
+*/
+POKE32(0xfdc000e0, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.SPARE_PLL_CLK_CONFIG2
+*/
+POKE32(0xfdc000e4, 0x00000013)
+
+
+/*
+sti5197_system_services_regs.ETHERNET_CLK_CONFIG0
+*/
+POKE32(0xfdc000e8, 0x00003c78)
+
+
+/*
+sti5197_system_services_regs.ETHERNET_CLK_CONFIG1
+*/
+POKE32(0xfdc000ec, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.ETHERNET_CLK_CONFIG2
+*/
+POKE32(0xfdc000f0, 0x00000013)
+
+
+/*
+sti5197_system_services_regs.ST40_ICK_CLK_CONFIG0
+*/
+POKE32(0xfdc000f4, 0x00000aaa)
+
+
+/*
+sti5197_system_services_regs.ST40_ICK_CLK_CONFIG1
+*/
+POKE32(0xfdc000f8, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.ST40_ICK_CLK_CONFIG2
+*/
+POKE32(0xfdc000fc, 0x00000071)
+
+
+/*
+sti5197_system_services_regs.ST40_PCK_CLK_CONFIG0
+*/
+POKE32(0xfdc00100, 0x0000cccc)
+
+
+/*
+sti5197_system_services_regs.ST40_PCK_CLK_CONFIG1
+*/
+POKE32(0xfdc00104, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.ST40_PCK_CLK_CONFIG2
+*/
+POKE32(0xfdc00108, 0x00000075)
+
+
+/*
+sti5197_system_services_regs.PLL_SELECT_CFG
+*/
+POKE32(0xfdc00180, 0x00000844)
+
+
+/*
+sti5197_system_services_regs.PLL_SELECT_CFG .ALT_TRANSPORT_SELECT [offset 12, size 1]
+*/
+/* PEEK(0xfdc00180) (used target peek value 0x00000844) */
+
+
+/*
+sti5197_system_services_regs.PLL_SELECT_CFG .ALT_TRANSPORT_SELECT [offset 12, size 1]
+*/
+POKE32(0xfdc00180, 0x00001844)
+
+
+/*
+sti5197_system_services_regs.PLL_SELECT_CFG .ALT_TRANSPORT_SELECT [offset 12, size 1]
+*/
+UPDATE32(0xfdc00180, 0xffffefff, 0x00001000)
+
+
+/*
+sti5197_system_services_regs.PLLA_CONFIG1
+*/
+/* PEEK(0xfdc00004) (used target peek value 0x00002000) */
+
+
+/*
+sti5197_system_services_regs.PLLA_CONFIG1
+*/
+POKE32(0xfdc00004, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.PLLB_CONFIG1
+*/
+/* PEEK(0xfdc0000c) (used target peek value 0x00002000) */
+
+
+/*
+sti5197_system_services_regs.PLLB_CONFIG1
+*/
+POKE32(0xfdc0000c, 0x00000000)
+DELAY(200)
+DELAY(20)
+
+
+/*
+sti5197_system_services_regs.PLLA_CONFIG1
+*/
+/* PEEK(0xfdc00004) (used target peek value 0x00008000) */
+DELAY(20)
+
+
+/*
+sti5197_system_services_regs.PLLB_CONFIG1
+*/
+/* PEEK(0xfdc0000c) (used target peek value 0x00008000) */
+
+
+/*
+sti5197_system_services_regs.SPARE1_CLK_SETUP0
+*/
+POKE32(0xfdc00014, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.PCM_CLK_SETUP0
+*/
+POKE32(0xfdc00020, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.SPDIF_CLK_SETUP0
+*/
+POKE32(0xfdc00030, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.SC_CLK_SETUP0
+*/
+POKE32(0xfdc00040, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.PIX_CLK_SETUP0
+*/
+POKE32(0xfdc00054, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.FDMA_FS_CLK_SETUP0
+*/
+POKE32(0xfdc00060, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.AUX_CLK_SETUP0
+*/
+POKE32(0xfdc00070, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.USB_CLK_SETUP0
+*/
+POKE32(0xfdc00080, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.FSA_SETUP
+*/
+POKE32(0xfdc00010, 0x00000f08)
+
+
+/*
+sti5197_system_services_regs.FSB_SETUP
+*/
+POKE32(0xfdc00050, 0x00000f08)
+
+
+/*
+sti5197_system_services_regs.FSA_SETUP
+*/
+POKE32(0xfdc00010, 0x00000f18)
+
+
+/*
+sti5197_system_services_regs.FSB_SETUP
+*/
+POKE32(0xfdc00050, 0x00000f18)
+
+
+/*
+sti5197_system_services_regs.SPARE1_CLK_SETUP0
+*/
+POKE32(0xfdc00014, 0x00000af1)
+
+
+/*
+sti5197_system_services_regs.SPARE1_CLK_SETUP1
+*/
+POKE32(0xfdc00018, 0x00001c72)
+
+
+/*
+sti5197_system_services_regs.DCO_MODE_CFG
+*/
+POKE32(0xfdc00170, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.PCM_CLK_SETUP0
+*/
+POKE32(0xfdc00020, 0x00000af3)
+
+
+/*
+sti5197_system_services_regs.PCM_CLK_SETUP1
+*/
+POKE32(0xfdc00024, 0x00003c00)
+
+
+/*
+sti5197_system_services_regs.DCO_MODE_CFG
+*/
+POKE32(0xfdc00170, 0x00000001)
+
+
+/*
+sti5197_system_services_regs.DCO_MODE_CFG
+*/
+POKE32(0xfdc00170, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.SPDIF_CLK_SETUP0
+*/
+POKE32(0xfdc00030, 0x00000b31)
+
+
+/*
+sti5197_system_services_regs.SPDIF_CLK_SETUP1
+*/
+POKE32(0xfdc00034, 0x00004dea)
+
+
+/*
+sti5197_system_services_regs.DCO_MODE_CFG
+*/
+POKE32(0xfdc00170, 0x00000001)
+
+
+/*
+sti5197_system_services_regs.SC_CLK_SETUP0
+*/
+POKE32(0xfdc00040, 0x00000af1)
+
+
+/*
+sti5197_system_services_regs.SC_CLK_SETUP1
+*/
+POKE32(0xfdc00044, 0x00001c72)
+
+
+/*
+sti5197_system_services_regs.DCO_MODE_CFG
+*/
+POKE32(0xfdc00170, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.PIX_CLK_SETUP0
+*/
+POKE32(0xfdc00054, 0x00000af1)
+
+
+/*
+sti5197_system_services_regs.PIX_CLK_SETUP1
+*/
+POKE32(0xfdc00058, 0x00001c72)
+
+
+/*
+sti5197_system_services_regs.DCO_MODE_CFG
+*/
+POKE32(0xfdc00170, 0x00000001)
+
+
+/*
+sti5197_system_services_regs.FDMA_FS_CLK_SETUP0
+*/
+POKE32(0xfdc00060, 0x00000a39)
+
+
+/*
+sti5197_system_services_regs.FDMA_FS_CLK_SETUP1
+*/
+POKE32(0xfdc00064, 0x00003334)
+
+
+/*
+sti5197_system_services_regs.AUX_CLK_SETUP0
+*/
+POKE32(0xfdc00070, 0x00000af1)
+
+
+/*
+sti5197_system_services_regs.AUX_CLK_SETUP1
+*/
+POKE32(0xfdc00074, 0x00001c72)
+
+
+/*
+sti5197_system_services_regs.USB_CLK_SETUP0
+*/
+POKE32(0xfdc00080, 0x00000ab3)
+
+
+/*
+sti5197_system_services_regs.USB_CLK_SETUP1
+*/
+POKE32(0xfdc00084, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.FSA_SETUP
+*/
+POKE32(0xfdc00010, 0x00000f10)
+
+
+/*
+sti5197_system_services_regs.FSB_SETUP
+*/
+POKE32(0xfdc00050, 0x00000f10)
+DELAY(200)
+
+
+/*
+sti5197_system_services_regs.MODE_CONTROL
+*/
+POKE32(0xfdc00110, 0x00000002)
+
+
+/*
+sti5197_system_services_regs.MODE_CONTROL
+*/
+/* PEEK(0xfdc00110) (used target peek value 0x00000002) */
+
+
+/*
+sti5197_system_services_regs.MODE_CONTROL
+*/
+WHILE_NE32(0xfdc00110, 0x00000002, 0x00000002)
+
+
+/*
+LMI.LMI_MIM0
+*/
+POKE32(0xfe000008, 0x061c0203)
+
+
+/*
+LMI.LMI_STR
+*/
+POKE32(0xfe000018, 0x3ff27e7a)
+
+
+/*
+LMI.LMI_SDRA0
+*/
+POKE32(0xfe000030, 0x10001a00)
+
+
+/*
+LMI.LMI_SDRA1
+*/
+POKE32(0xfe000038, 0x10001a00)
+DELAY(200)
+
+
+/*
+LMI.LMI_SCR
+*/
+POKE32(0xfe000010, 0x00000003)
+
+
+/*
+LMI.LMI_SCR
+*/
+POKE32(0xfe000010, 0x00000001)
+
+
+/*
+LMI.LMI_SCR
+*/
+POKE32(0xfe000010, 0x00000002)
+
+
+/*
+LMI.LMI_SDMR0
+*/
+POKE32(0xfe000048, 0x00000400)
+
+
+/*
+LMI.LMI_SDMR1
+*/
+POKE32(0xfe000050, 0x00000400)
+DELAY(200)
+
+
+/*
+LMI.LMI_SDMR0
+*/
+POKE32(0xfe000048, 0x00000133)
+
+
+/*
+LMI.LMI_SDMR1
+*/
+POKE32(0xfe000050, 0x00000133)
+DELAY(200)
+
+
+/*
+LMI.LMI_SCR
+*/
+POKE32(0xfe000010, 0x00000002)
+
+
+/*
+LMI.LMI_SCR
+*/
+POKE32(0xfe000010, 0x00000004)
+
+
+/*
+LMI.LMI_SCR
+*/
+POKE32(0xfe000010, 0x00000004)
+
+
+/*
+LMI.LMI_SCR
+*/
+POKE32(0xfe000010, 0x00000004)
+
+
+/*
+LMI.LMI_SDMR0
+*/
+POKE32(0xfe000048, 0x00000033)
+
+
+/*
+LMI.LMI_SDMR1
+*/
+POKE32(0xfe000050, 0x00000033)
+
+
+/*
+LMI.LMI_SCR
+*/
+POKE32(0xfe000010, 0x00000000)
+
+
+/*
+LMI.LMI_COC_UPPER
+*/
+POKE32(0xfe00002c, 0x00330000)
+
+
+/*
+LMI.LMI_COC_LOWER
+*/
+POKE32(0xfe000028, 0x0003e000)
+
+
+/*
+sti5197_hd_config_monitor_regs.CONFIG_CONTROL_H
+*/
+/* PEEK(0xfd901014) (used target peek value 0x00000000) */
+
+
+/*
+sti5197_hd_config_monitor_regs.CONFIG_CONTROL_H
+*/
+POKE32(0xfd901014, 0x00000000)
+
+
+/*
+sti5197_hd_config_monitor_regs.CONFIG_CONTROL_M
+*/
+/* PEEK(0xfd901048) (used target peek value 0x000000c0) */
+
+
+/*
+sti5197_hd_config_monitor_regs.CONFIG_CONTROL_M
+*/
+POKE32(0xfd901048, 0x400000c0)
+
+
+/*
+LMI.LMI_MIM1
+*/
+POKE32(0xfe00000c, 0x00000075)
+
+
+/*
+sti5197_hd_config_monitor_regs.CONFIG_CONTROL_C
+*/
+/* PEEK(0xfd901000) (used target peek value 0x00000000) */
+
+
+/*
+sti5197_hd_config_monitor_regs.CONFIG_CONTROL_C
+*/
+POKE32(0xfd901000, 0x00800000)
+
+
+/*
+sti5197_system_services_regs.CLOCK_OBSERVATION_CFG
+*/
+POKE32(0xfdc00188, 0x0000002a)
+
+
+/*
+sti5197_hs_config_monitor_regs.CONFIG_MONITOR_A
+*/
+/* PEEK(0xfd002008) (used target peek value 0x38472000) */
+
+
+/*
+sti5197_hd_config_monitor_regs.CONFIG_MONITOR_G
+*/
+/* PEEK(0xfd901030) (used target peek value 0x00001279) */
+
+
+/*
+sti5197_hd_config_monitor_regs.CONFIG_MONITOR_J
+*/
+/* PEEK(0xfd90103c) (used target peek value 0x8ac30000) */
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+/* PEEK(0xfdc00300) (used target peek value 0x00000000) */
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+POKE32(0xfdc00300, 0x00000100)
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+/* PEEK(0xfdc00300) (used target peek value 0x00000100) */
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+WHILE_NE32(0xfdc00300, 0x00000100, 0x00000100)
+
+
+/*
+st40_ccn_regs.CCN_CCR
+*/
+POKE32(0xff00001c, 0x8000090d)
diff --git a/board/st/5197cab/Makefile b/board/st/5197cab/Makefile
new file mode 100644
index 0000000000..c99b16c9c9
--- /dev/null
+++ b/board/st/5197cab/Makefile
@@ -0,0 +1,52 @@
+#
+# (C) Copyright 2007 STMicroelectronics.
+# Stuart Menefy <stuart.menefy@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+SOBJS	= init-$(BOARD).o
+
+COBJS	= $(BOARD).o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/st/5197cab/config.mk b/board/st/5197cab/config.mk
new file mode 100644
index 0000000000..d83a0ae674
--- /dev/null
+++ b/board/st/5197cab/config.mk
@@ -0,0 +1,43 @@
+#
+# (C) Copyright 2009 STMicroelectronics.
+# Sean McGoogan <Sean.McGoogan@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# STx5197-CAB board:
+#
+#	Valid values for TEXT_BASE are:
+#
+#	0x8FF00000	29-bit mode (Traditional Mode)
+#	0x83F00000	32-bit mode (Space-Enhancement Mode)
+#
+# Note:	Alternative definitions of TEXT_BASE are put into
+#	'config.tmp' from the top-level 'Makefile'.
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+# Installs at LMI0 BASE + 63MB in P1 (cachable)
+TEXT_BASE = 0x8FF00000
+endif
+
+PLATFORM_LDFLAGS +=
diff --git a/board/st/5197cab/init-5197cab.S b/board/st/5197cab/init-5197cab.S
new file mode 100644
index 0000000000..07eb584f09
--- /dev/null
+++ b/board/st/5197cab/init-5197cab.S
@@ -0,0 +1,82 @@
+#include "asm/stx5197reg.h"
+#include "../../../cpu/sh/init_ram.S"
+
+/*
+ * This is derived from STMicroelectronics gnu toolchain example:
+ *   sh-superh-elf/examples/os21/romdynamic/memory_mb704.S
+ */
+
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *	opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+/*
+ * For compatibility with old poke table code, we define some of the
+ * new names, to map onto the old names. Ultimately, the old poke table
+ * code will be updated to the "new order", and we can just delete
+ * the following mappings.
+ */
+#define POKE8(A, VAL)				POKE_CHAR(A, VAL)
+#define POKE16(A, VAL)				POKE_SHORT(A, VAL)
+#define POKE32(A, VAL)				POKE_LONG(A, VAL)
+#define OR32(A, VAL)				OR_LONG(A, VAL)
+#define UPDATE32(A, AND, OR)			UPDATE_LONG(A, AND, OR)
+#define POKE_UPDATE32(A1, A2, AND, SHIFT, OR)	POKE_UPDATE_LONG(A1, A2, AND, SHIFT, OR)
+#define WHILE_NE32(A, AND, VAL)			WHILE_NE(A, AND, VAL)
+#define DELAY(VAL)				/* do nothing */
+
+
+	.section .data.init, "a"
+
+	.balign 32
+
+__memory_setup_table:
+
+
+	/*
+	 * include the appropriate set of "GDB pokes", (usually) generated
+	 * using the "romgen" utility, from a known good target-pack.
+	 *
+	 * This file may be regenerated by connecting your specific board
+	 * to an STMC2 (note: currently it must be version 2) and then
+	 * executing the following command (redirecting the output):
+	 *
+	 * host% romgen --target-connect --show-comment <stmc2>:mb704:st40
+	 *
+	 * Where "<stmc2>" should be replaced with the IP address
+	 * (or the DNS name) of the STMC2 box.  Also the "mb704" should
+	 * substituted if you have a custom target-pack connect command.
+	 *
+	 * Note: The connect command used with "romgen", should connect
+	 * only in 29-bit mode - even if U-Boot will be built for 32-bit mode.
+	 * That is, do not use the "seuc=1" (or similar) option with "romgen".
+	 */
+#include "5197cab.romgen"
+
+
+#ifdef CONFIG_SH_SE_MODE
+	/*
+	 * Note that we also manually need to move the LMI base addresses to
+	 * their 32-bit SE mode locations as defined in the datasheet and change the
+	 * 'upper bound addresses' (in row attribute registers) for the LMIs.
+	 * CTRL_M.LMI_MEM_BASE_ADDR_SIG = 0x40 [11:4]
+	 */
+	UPDATE32(STX5197_HD_CONF_MON_CONFIG_CONTROL_M, 0xfffff00f, (0x40 << 4))
+
+	/*
+	 * Change LMI upper bound addresses
+	 * Upper LMI addr = 0x40000000 + 64MiB = 0x44000000
+	 */
+	UPDATE32(ST40_LMI_SDRA0_0(), 0x001fffff, 0x44000000)
+	UPDATE32(ST40_LMI_SDRA1_0(), 0x001fffff, 0x44000000)
+#endif	/* CONFIG_SH_SE_MODE */
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/st/cb101/Makefile b/board/st/cb101/Makefile
new file mode 100644
index 0000000000..e71bce43bb
--- /dev/null
+++ b/board/st/cb101/Makefile
@@ -0,0 +1,54 @@
+#
+# (C) Copyright 2007 STMicroelectronics.
+# Stuart Menefy <stuart.menefy@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+SOBJS-y	= init-$(BOARD).o
+
+COBJS-y	+= $(BOARD).o
+COBJS-$(CONFIG_CMD_NAND) += nand.o
+
+
+SRCS	:= $(SOBJS-y:.o=.S) $(COBJS-y:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS-y))
+SOBJS	:= $(addprefix $(obj),$(SOBJS-y))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/st/cb101/cb101.c b/board/st/cb101/cb101.c
new file mode 100644
index 0000000000..1a3b11c50f
--- /dev/null
+++ b/board/st/cb101/cb101.c
@@ -0,0 +1,173 @@
+/*
+ * (C) Copyright 2007 STMicroelectronics.
+ *
+ * Stuart Menefy <stuart.menefy@st.com>
+ * Martin Lesniak <martin.lesniak@st.com> - added cb101 support
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/soc.h>
+#include <asm/stx7200reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+void flashWriteEnable(void)
+{
+	/*  Enable vpp for writing to flash */
+}
+
+void flashWriteDisable(void)
+{
+	/*  Disable vpp for writing to flash */
+}
+
+
+#define PIO_BASE  0xfd020000
+
+
+static void configPIO(void)
+{
+	/*  Setup PIO of ASC device */
+	SET_PIO_ASC(PIO_PORT(4), 3, 2, 4, 5);  /* UART2 - AS0 */
+	SET_PIO_ASC(PIO_PORT(5), 4, 3, 5, 6);  /* UART3 - AS1 */
+
+#ifdef CONFIG_DRIVER_NETSTMAC
+	/* Reset the on-board STe101P PHY */
+	SET_PIO_PIN(PIO_PORT(4), 7, STPIO_OUT);
+	STPIO_SET_PIN(PIO_PORT(4), 7, 1);
+	udelay(1);
+	STPIO_SET_PIN(PIO_PORT(4), 7, 0);
+	udelay(1);
+	STPIO_SET_PIN(PIO_PORT(4), 7, 1);
+#endif	/* CONFIG_DRIVER_NETSTMAC */
+
+#if defined(CONFIG_CMD_NAND)
+	/*  Setup PIO for NAND FLASH devices: Ready/Not_Busy */
+	SET_PIO_PIN(PIO_PORT(2), 7, STPIO_IN);
+#endif	/* CONFIG_CMD_NAND */
+}
+
+
+#if defined(CONFIG_CMD_NAND)
+static void nand_emi_init(void)
+{
+	/* setup the EMI configuration for the 2 banks
+	 * containing NAND flash devices. */
+
+	/* NAND FLASH in EMI Bank #1 (128MB) */
+	*ST40_EMI_BANK1_EMICONFIGDATA0 = 0x04100e99;
+	*ST40_EMI_BANK1_EMICONFIGDATA1 = 0x04000200;
+	*ST40_EMI_BANK1_EMICONFIGDATA2 = 0x04000200;
+	*ST40_EMI_BANK1_EMICONFIGDATA3 = 0x00000000;
+
+	/* NAND FLASH in EMI Bank #2 (1GB) */
+	*ST40_EMI_BANK2_EMICONFIGDATA0 = 0x04100e99;
+	*ST40_EMI_BANK2_EMICONFIGDATA1 = 0x04000200;
+	*ST40_EMI_BANK2_EMICONFIGDATA2 = 0x04000200;
+	*ST40_EMI_BANK2_EMICONFIGDATA3 = 0x00000000;
+}
+#endif	/* CONFIG_CMD_NAND */
+
+
+int board_init(void)
+{
+	unsigned long sysconf;
+
+	/* Serial port set up */
+	/* Route UART2&3 or SCI inputs instead of DVP to pins: conf_pad_dvp = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG40;
+	sysconf &= ~(1<<16);
+	*STX7200_SYSCONF_SYS_CFG40 = sysconf;
+
+	/* Route UART2&3/SCI outputs instead of DVP to pins: conf_pad_pio[1]=0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<25);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* No idea, more routing: conf_pad_pio[0] = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<24);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* Route UART2 (inputs and outputs) instead of SCI to pins: ssc2_mux_sel = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<2);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* conf_pad_pio[4] = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<28);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* Route UART3 (inputs and outputs) instead of SCI to pins: ssc3_mux_sel = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<3);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* conf_pad_clkobs = 1 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf |= (1<<14);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* I2C and USB related routing */
+	/* bit4: ssc4_mux_sel = 0 (treat SSC4 as I2C) */
+	/* bit26: conf_pad_pio[2] = 0 route USB etc instead of DVO */
+	/* bit27: conf_pad_pio[3] = 0 DVO output selection (probably ignored) */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~((1<<27)|(1<<26)|(1<<4));
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* Enable SOFT_JTAG mode.
+	 * Taken from OS21, but is this correct?
+	 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG33;
+	sysconf |= (1<<6);
+	sysconf &= ~((1<<0)|(1<<1)|(1<<2)|(1<<3));
+	*STX7200_SYSCONF_SYS_CFG33 = sysconf;
+
+#if defined(CONFIG_CMD_NAND)
+	nand_emi_init();
+#endif	/* CONFIG_CMD_NAND */
+
+	configPIO();
+
+	return 0;
+}
+
+int checkboard (void)
+{
+	printf ("\n\nBoard: cb101"
+#ifdef CONFIG_SH_SE_MODE
+		"  [32-bit mode]"
+#else
+		"  [29-bit mode]"
+#endif
+		"\n");
+
+#ifdef CONFIG_DRIVER_NETSTMAC
+#if defined(CONFIG_STMAC_MAC0)
+	/* On-board PHY (MII0) in MII mode, using MII_CLK */
+	stx7200_configure_ethernet(0, 0, 0, 0);
+#endif	/* CONFIG_STMAC_MAC0 */
+#endif	/* CONFIG_DRIVER_NETSTMAC */
+	return 0;
+}
diff --git a/board/st/cb101/config.mk b/board/st/cb101/config.mk
new file mode 100644
index 0000000000..37f427bdd9
--- /dev/null
+++ b/board/st/cb101/config.mk
@@ -0,0 +1,43 @@
+#
+# (C) Copyright 2007 STMicroelectronics.
+# Stuart Menefy <stuart.menefy@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# CB101 board:
+#
+#	Valid values for TEXT_BASE are:
+#
+#	0x8FF00000	29-bit mode (Traditional Mode)
+#	0x87F00000	32-bit mode (Space-Enhancement Mode)
+#
+# Note:	Alternative definitions of TEXT_BASE are put into
+#	'config.tmp' from the top-level 'Makefile'.
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+# Installs at LMI0 BASE + 127MB in P1 (cachable)
+TEXT_BASE = 0x8FF00000
+endif
+
+PLATFORM_LDFLAGS +=
diff --git a/board/st/cb101/init-cb101.S b/board/st/cb101/init-cb101.S
new file mode 100644
index 0000000000..2898a408b8
--- /dev/null
+++ b/board/st/cb101/init-cb101.S
@@ -0,0 +1,388 @@
+
+#include "asm/stx7200reg.h"
+#include "../../../cpu/sh/init_ram.S"
+
+/*
+ * This is derived from STMicroelectronics gnu toolchain example:
+ *   sh-superh-elf/examples/os21/romdynamic/memory_mb519.S
+ */
+
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *       opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+
+	.section .data.init, "a"
+
+	.balign 32
+
+__memory_setup_table:
+
+  /* ----- STx7200 Clocks ----- */
+
+  /* Set CLOCKGENA PLL0 into BYPASS... */
+  OR_LONG(STX7200_CLOCKGENA_PLL0_CFG, 0x00100000)
+
+  /* Power down CLOCKGENA PLL0... */
+  OR_LONG(STX7200_CLOCKGENA_POWER_CFG, 0x00000001)
+
+  /* Configure CLOCKGENA PLL0... */
+  UPDATE_LONG(STX7200_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x03 | (0x23 << 8) | (0x00 << 16))
+
+  /* Enable CLOCKGENA PLL0... */
+  UPDATE_LONG(STX7200_CLOCKGENA_POWER_CFG, 0xfffffffe, 0)
+
+  /* Wait for CLOCKGENA PLL0 to lock... */
+  WHILE_NE(STX7200_CLOCKGENA_PLL0_CFG, 0x80000000, 0x80000000)
+
+  /* Clear CLOCKGENA PLL0 from BYPASS... */
+  UPDATE_LONG(STX7200_CLOCKGENA_PLL0_CFG, 0xffefffff, 0)
+
+  /* Set CLOCKGENA PLL1 into BYPASS... */
+  OR_LONG(STX7200_CLOCKGENA_PLL1_CFG, 0x00100000)
+
+  /* Power down CLOCKGENA PLL1... */
+  OR_LONG(STX7200_CLOCKGENA_POWER_CFG, 0x00000002)
+
+  /* Configure CLOCKGENA PLL1... */
+  UPDATE_LONG(STX7200_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x01 | (0x0f << 8))
+
+  /* Enable CLOCKGENA PLL1... */
+  UPDATE_LONG(STX7200_CLOCKGENA_POWER_CFG, 0xfffffffd, 0)
+
+  /* Wait for CLOCKGENA PLL1 to lock... */
+  WHILE_NE(STX7200_CLOCKGENA_PLL1_CFG, 0x80000000,  0x80000000)
+
+  /* Clear CLOCKGENA PLL1 from BYPASS... */
+  UPDATE_LONG(STX7200_CLOCKGENA_PLL1_CFG, 0xffefffff, 0)
+
+  /* Set CLOCKGENA PLL2 into BYPASS... */
+  OR_LONG(STX7200_CLOCKGENA_PLL2_CFG, 0x00100000)
+
+  /* Power down CLOCKGENA PLL2... */
+  OR_LONG(STX7200_CLOCKGENA_POWER_CFG, 0x00000004)
+
+  /* Configure CLOCKGENA PLL2... */
+  UPDATE_LONG(STX7200_CLOCKGENA_PLL2_CFG, 0xfff80000, 0x03 | (0x28 << 8) | (0x00 << 16))
+
+  /* Enable CLOCKGENA PLL2... */
+  UPDATE_LONG(STX7200_CLOCKGENA_POWER_CFG, 0xfffffffb, 0)
+
+  /* Wait for CLOCKGENA PLL2 to lock... */
+  WHILE_NE(STX7200_CLOCKGENA_PLL2_CFG, 0x80000000,  0x80000000)
+
+  /* Clear CLOCKGENA PLL2 from BYPASS... */
+  UPDATE_LONG(STX7200_CLOCKGENA_PLL2_CFG, 0xffefffff, 0)
+
+  /* Set CLOCKGENB PLL0 into BYPASS... */
+  OR_LONG(STX7200_CLOCKGENB_PLL0_CFG, 0x00100000)
+
+  /* Power down CLOCKGENB PLL0... */
+  OR_LONG(STX7200_CLOCKGENB_POWER_CFG, 0x00008000)
+
+  /* Configure CLOCKGENB PLL0... */
+  UPDATE_LONG(STX7200_CLOCKGENB_PLL0_CFG, 0xfff80000, 0x03 | (0x28 << 8) | (0x00 << 16))
+
+  /* Enable CLOCKGENB PLL0... */
+  UPDATE_LONG(STX7200_CLOCKGENB_POWER_CFG, 0xffff7fff, 0)
+
+  /* Wait for CLOCKGENB PLL0 to lock... */
+  WHILE_NE(STX7200_CLOCKGENB_PLL0_CFG, 0x80000000, 0x80000000)
+
+  /* Clear CLOCKGENB PLL0 from BYPASS... */
+  UPDATE_LONG(STX7200_CLOCKGENB_PLL0_CFG, 0xffefffff, 0)
+
+  /* Power down PLL... */
+  OR_LONG(STX7200_SYSCONF_SYS_CFG11, 0x00001000)
+
+  /* Configure PLL... */
+  /* Set LMI clock to 666MHz */
+  UPDATE_LONG(STX7200_SYSCONF_SYS_CFG11, 0xfffff001, (0x05 << 9) | (0x6f << 1))
+  /* On PCB rev A, we have a limitation on LMI1: Reset LMI clock to 400MHz */
+  IF(0xa5020000, 0x000000ff, 0x0000000a, UPDATE_LONG(STX7200_SYSCONF_SYS_CFG11, 0xfffff001, (0x03 << 9) | (0x28 << 1)))
+
+  /* Enable CLOCKGENA PLL1... */
+  UPDATE_LONG(STX7200_SYSCONF_SYS_CFG11, 0xffffefff, 0)
+
+  /* Wait for CLOCKGENA PLL1 to lock... (polarity inverted on lock bit) */
+  WHILE_NE(STX7200_SYSCONF_SYS_STA03, 0x00000001, 0)
+
+  /* ----- STx7200 Sysconf ----- */
+
+  /* Exit from reset */
+  OR_LONG(STX7200_SYSCONF_SYS_CFG11, 0x00000001)
+  OR_LONG(STX7200_SYSCONF_SYS_CFG15, 0x00000001)
+
+  /* Check both DLL on LMI0 are locked */
+  WHILE_NE(STX7200_SYSCONF_SYS_STA03, (1 << 10) | (1 << 20), (1 << 10) | (1 << 20))
+
+  /* Check both DLL on LMI1 are locked */
+  WHILE_NE(STX7200_SYSCONF_SYS_STA05, (1 << 10) | (1 << 20), (1 << 10) | (1 << 20))
+
+  /* Adjust proga, progb, zoutproga, and receiver mode for LMI0 */
+  POKE_LONG(STX7200_SYSCONF_SYS_CFG12, 0xa2007801 | (0x0 << 1) | (0x7 << 4) | (0x7 << 7) | (0x0 << 10))
+
+  /* Adjust proga, progb, zoutproga, and receiver mode for LMI1 */
+  POKE_LONG(STX7200_SYSCONF_SYS_CFG16, 0xa2007801 | (0x0 << 1) | (0x7 << 4) | (0x7 << 7) | (0x0 << 10))
+
+  /* Enable AutoPrecharge */
+  OR_LONG(STX7200_SYSCONF_SYS_CFG38, 0x00030000)
+  OR_LONG(STX7200_SYSCONF_SYS_CFG39, 0x00030000)
+
+  /* Force DLL1 and DLL2 commands of LMI0 */
+  POKE_LONG(STX7200_SYSCONF_SYS_CFG13, 0x00000002)
+  POKE_LONG(STX7200_SYSCONF_SYS_CFG14, 0x00000002)
+
+  /* Force DLL1 and DLL2 commands of LMI1 */
+  POKE_LONG(STX7200_SYSCONF_SYS_CFG17, 0x00000002)
+  POKE_LONG(STX7200_SYSCONF_SYS_CFG18, 0x00000002)
+
+  /* ----- STx7200 EMI configuration ----- */
+
+  POKE_LONG(ST40_EMI_BANK_ENABLE, 0x00000005)
+
+  /* NOTE: bits [0,5] define bottom address bits [22,27] of bank */
+  POKE_LONG(ST40_EMI_BANK0_BASEADDRESS, 0x00000000)
+  POKE_LONG(ST40_EMI_BANK1_BASEADDRESS, 0x00000008)
+  POKE_LONG(ST40_EMI_BANK2_BASEADDRESS, 0x0000000c)
+  POKE_LONG(ST40_EMI_BANK3_BASEADDRESS, 0x00000010)
+  POKE_LONG(ST40_EMI_BANK4_BASEADDRESS, 0x00000014)
+
+  /* Bank #0 - NOR FLASH (32MiB) at address 0x00000000 -> 0x01ffffff */
+  POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA0, 0x04320691)
+  POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA1, 0x8F122300)
+  POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA2, 0x8F122300)
+  POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
+
+  /* Bank #1 - NAND FLASH (128MiB), at address 0x02000000 -> 0x02FFFFFF */
+#if 0
+  /* this code has been moved to nand_emi_init() in board/cb101/cb101.c */
+  POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA0, 0x04100e99);
+  POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA1, 0x04000200);
+  POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA2, 0x04000200);
+  POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA3, 0x00000000);
+#endif
+
+  /* Bank #2 - NAND FLASH (1GB), at address 0x03000000 -> 0x03FFFFFF */
+#if 0
+  /* this code has been moved to nand_emi_init() in board/cb101/cb101.c */
+  POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA0, 0x04100e99);
+  POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA1, 0x04000200);
+  POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA2, 0x04000200);
+  POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA3, 0x00000000);
+#endif
+
+  /* Bank #3 - unused, at address 0x04000000 -> 0x04FFFFFF */
+
+  /* Bank #4 - unused, at address 0x05000000 -> 0x05FFFFFF */
+
+  /* Program other EMI registers */
+  POKE_LONG(ST40_EMI_GENCFG, 0x00000050)
+
+  /* ----- STx7200 LMI0 configuration ----- */
+
+  /* "Refresh Interval" is set equal to 0xA28=2600 => 2600*3ns=7.8us */
+/*POKE_LONG(ST40_LMI_MIM_0(0), 0x0a28015b)*/ /* OLD */
+  POKE_LONG(ST40_LMI_MIM_0(0), 0x0a28035b)
+/*POKE_LONG(ST40_LMI_MIM_1(0), 0xffff1010)*/ /* OLD */
+  POKE_LONG(ST40_LMI_MIM_1(0), 0x000000b0)
+
+  POKE_LONG(ST40_LMI_STR_0(0), 0xcb2cab5b)
+  POKE_LONG(ST40_LMI_STR_1(0), 0x000002d6)
+
+  /* lmi base address 0x08000000 + 128MiB 13x10 */
+  POKE_LONG(ST40_LMI_SDRA0_0(0), 0x10000a00)
+
+  /* lmi base address 0x08000000 + 128MiB 13x10 */
+  POKE_LONG(ST40_LMI_SDRA1_0(0), 0x10000a00)
+
+  /* Enable clock with NOP command */
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020023)
+  /* Wait NOP command for 400 nsec */
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+
+  /* Precharge all */
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020022)
+  /* Wait NOP command for 400 nsec */
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+
+  /* Issue EMRS2 */
+  POKE_LONG(ST40_LMI_SDMR0(0), 0x00000800)
+
+  /* Issue EMRS3 */
+  POKE_LONG(ST40_LMI_SDMR0(0), 0x00000c00)
+
+  /* Issue EMRS1 to enable DLL */
+  POKE_LONG(ST40_LMI_SDMR0(0), 0x00000400)
+
+  /* Issue MRS with DLL reset(0), CAS 5(0), Write recovery 6(0), Sequentiel(0), Burst lengh 8 */
+  POKE_LONG(ST40_LMI_SDMR0(0), 0x00002353)
+
+  /* Wait NOP command for 400 nsec */
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+
+  /* Precharge all */
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020022)
+  /* 2 CBR (auto refresh) */
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020024)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020024)
+
+  /* Issue MRS with CAS 5(0), Write recovery 6(0), Sequentiel(0), Burst lengh 8 */
+  POKE_LONG(ST40_LMI_SDMR0(0), 0x00002253)
+
+  /* Issue EMRS1 for OCD calibration default */
+  POKE_LONG(ST40_LMI_SDMR0(0), 0x000007c4)
+
+  /* Issue EMRS1 for OCD calibration exit */
+  POKE_LONG(ST40_LMI_SDMR0(0), 0x00000444)
+
+  /* Enable auto refresh */
+  POKE_LONG(ST40_LMI_MIM_0(0), 0x0a28035b)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+
+  POKE_LONG(ST40_LMI_GCC_0(0), 0x00382003)
+
+  /* ----- STx7200 LMI1 configuration ----- */
+
+  /* "Refresh Interval" is set equal to 0xA28=0d2600 => 2600*3ns=7.8us */
+  POKE_LONG(ST40_LMI_MIM_0(1), 0x0a28015b)
+  POKE_LONG(ST40_LMI_MIM_1(1), 0x000000b0)
+
+  POKE_LONG(ST40_LMI_STR_0(1), 0xcb2cab5b)
+  POKE_LONG(ST40_LMI_STR_1(1), 0x000002d6)
+
+  /* lmi base address 0x18000000 + 64MiB 13x10 (all 128MiB are not visible in 29bits mode) */
+  POKE_LONG(ST40_LMI_SDRA0_0(1), 0x1c000a00)
+
+  /* lmi base address 0x18000000 + 64MiB 13x10 (all 128MiB are not visible in 29bits mode) */
+  POKE_LONG(ST40_LMI_SDRA1_0(1), 0x1c000a00)
+
+  /* Enable clock with NOP command */
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020023)
+  /* Wait NOP command for 400 nsec */
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+
+  /* Precharge all */
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020022)
+  /* Wait NOP command for 400 nsec */
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+
+  /* Issue EMRS2 */
+  POKE_LONG(ST40_LMI_SDMR0(1), 0x00000800)
+
+  /* Issue EMRS3 */
+  POKE_LONG(ST40_LMI_SDMR0(1), 0x00000c00)
+
+  /* Issue EMRS1 to enable DLL */
+  POKE_LONG(ST40_LMI_SDMR0(1), 0x00000400)
+
+  /* Issue MRS with DLL reset(1), CAS 5(1), Write recovery 6(1), Sequentiel(1), Burst lengh 8 */
+  POKE_LONG(ST40_LMI_SDMR0(1), 0x00002353)
+
+  /* Wait NOP command for 400 nsec */
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+
+  /* Precharge all */
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020022)
+  /* 2 CBR (auto refresh) */
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020024)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020024)
+
+  /* Issue MRS with CAS 5(1), Write recovery 6(1), Sequentiel(1), Burst lengh 8 */
+  POKE_LONG(ST40_LMI_SDMR0(1), 0x00002253)
+
+  /* Issue EMRS1 for OCD calibration default */
+  POKE_LONG(ST40_LMI_SDMR0(1), 0x000007c4)
+
+  /* Issue EMRS1 for OCD calibration exit */
+  POKE_LONG(ST40_LMI_SDMR0(1), 0x00000444)
+
+  /* Enable auto refresh */
+  POKE_LONG(ST40_LMI_MIM_0(1), 0x0a28035b)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+
+  POKE_LONG(ST40_LMI_GCC_0(1), 0x00382003)
+
+#ifdef CONFIG_SH_SE_MODE
+  /*
+   * Note that we also manually need to move the LMI0 and LMI1 base addresses to
+   * their 32-bit SE mode locations as defined in the datasheet and change the
+   * 'upper bound addresses' (in row attribute registers) for the LMIs.
+   */
+  UPDATE_LONG(STX7200_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
+  UPDATE_LONG(STX7200_SYSCONF_SYS_CFG39, 0xFFFFFF00, 0x00000080)
+  POKE_LONG(ST40_LMI_SDRA0_0(0), 0x48000a00)
+  POKE_LONG(ST40_LMI_SDRA1_0(0), 0x48000a00)
+  POKE_LONG(ST40_LMI_SDRA0_0(1), 0x88000a00)
+  POKE_LONG(ST40_LMI_SDRA1_0(1), 0x88000a00)
+#endif	/* CONFIG_SH_SE_MODE */
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/st/cb101/nand.c b/board/st/cb101/nand.c
new file mode 100644
index 0000000000..4731b253da
--- /dev/null
+++ b/board/st/cb101/nand.c
@@ -0,0 +1,101 @@
+/*
+ * (C) Copyright 2006 DENX Software Engineering
+ * (C) Copyright 2008-2009 STMicroelectronics, Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <nand.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+#include <asm/stx7200reg.h>
+
+#define PIO_BASE  0xfd020000
+
+
+/*
+ * hardware specific access to control-lines
+ *	CL -> Emi_Addr(17)
+ *	AL -> Emi_Addr(18)
+ *	nCE is handled by EMI (not s/w controlable)
+ */
+static void cb101_hwcontrol(struct mtd_info *mtdinfo, int cmd)
+{
+	struct nand_chip* this = (struct nand_chip *)(mtdinfo->priv);
+
+	switch(cmd) {
+
+	case NAND_CTL_SETCLE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (1u << 17));
+		break;
+
+	case NAND_CTL_CLRCLE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(1u << 17));
+		break;
+
+	case NAND_CTL_SETALE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (1u << 18));
+		break;
+
+	case NAND_CTL_CLRALE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(1u << 18));
+		break;
+	}
+}
+
+
+/*
+ * hardware specific access to the Ready/not_Busy signal.
+ * Signal is routed through GPIO port#2, pin #7.
+ */
+static int cb101_device_ready(struct mtd_info *mtd)
+{
+	int ret = STPIO_GET_PIN(PIO_PORT(2), 7);
+	return ret;
+}
+
+
+/*
+ * Board-specific NAND initialization. The following members of the
+ * argument are board-specific (per include/linux/mtd/nand.h):
+ * - IO_ADDR_R?: address to read the 8 I/O lines of the flash device
+ * - IO_ADDR_W?: address to write the 8 I/O lines of the flash device
+ * - hwcontrol: hardwarespecific function for accesing control-lines
+ * - dev_ready: hardwarespecific function for  accesing device ready/busy line
+ * - enable_hwecc?: function to enable (reset)  hardware ecc generator. Must
+ *   only be provided if a hardware ECC is available
+ * - eccmode: mode of ecc, see defines
+ * - chip_delay: chip dependent delay for transfering data from array to
+ *   read regs (tR)
+ * - options: various chip options. They can partly be set to inform
+ *   nand_scan about special functionality. See the defines for further
+ *   explanation
+ * Members with a "?" were not set in the merged testing-NAND branch,
+ * so they are not set here either.
+ */
+extern int board_nand_init(struct nand_chip *nand)
+{
+	nand->hwcontrol = cb101_hwcontrol;
+	nand->dev_ready = cb101_device_ready;
+	nand->eccmode = NAND_ECC_SOFT;
+	nand->chip_delay = 25;
+	nand->options = NAND_NO_AUTOINCR;
+	return 0;
+}
diff --git a/board/st/cb102/Makefile b/board/st/cb102/Makefile
new file mode 100644
index 0000000000..c99b16c9c9
--- /dev/null
+++ b/board/st/cb102/Makefile
@@ -0,0 +1,52 @@
+#
+# (C) Copyright 2007 STMicroelectronics.
+# Stuart Menefy <stuart.menefy@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+SOBJS	= init-$(BOARD).o
+
+COBJS	= $(BOARD).o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/st/cb102/cb102.c b/board/st/cb102/cb102.c
new file mode 100644
index 0000000000..f6ecd278cc
--- /dev/null
+++ b/board/st/cb102/cb102.c
@@ -0,0 +1,146 @@
+/*
+ * (C) Copyright 2007-2008 STMicroelectronics.
+ *
+ * Stuart Menefy <stuart.menefy@st.com>
+ * Martin Lesniak <martin.lesniak@st.com> - added cb101 support
+ * Sean McGoogan <Sean.McGoogan@st.com> - added cb102 support
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/soc.h>
+#include <asm/stx7200reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+void flashWriteEnable(void)
+{
+	/* Enable Vpp for writing to flash */
+	/* Not under software control on this board. */
+}
+
+void flashWriteDisable(void)
+{
+	/* Disable Vpp for writing to flash */
+	/* Not under software control on this board. */
+}
+
+
+#define PIO_BASE  0xfd020000
+
+
+static void configPIO(void)
+{
+	/*  Setup PIO of ASC device */
+	SET_PIO_ASC(PIO_PORT(4), 3, 2, 4, 5);  /* UART2 - AS0 */
+	SET_PIO_ASC(PIO_PORT(5), 4, 3, 5, 6);  /* UART3 - AS1 */
+
+#ifdef CONFIG_DRIVER_NETSTMAC
+	/* Reset the on-board SMSC LAN8700 PHY */
+	SET_PIO_PIN(PIO_PORT(4), 7, STPIO_OUT);
+	STPIO_SET_PIN(PIO_PORT(4), 7, 1);
+	udelay(1);
+	STPIO_SET_PIN(PIO_PORT(4), 7, 0);
+	udelay(1000);
+	STPIO_SET_PIN(PIO_PORT(4), 7, 1);
+#endif	/* CONFIG_DRIVER_NETSTMAC */
+}
+
+
+int board_init(void)
+{
+	unsigned long sysconf;
+
+	/* Serial port set up */
+	/* Route UART2&3 or SCI inputs instead of DVP to pins: conf_pad_dvp = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG40;
+	sysconf &= ~(1<<16);
+	*STX7200_SYSCONF_SYS_CFG40 = sysconf;
+
+	/* Route UART2&3/SCI outputs instead of DVP to pins: conf_pad_pio[1]=0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<25);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* No idea, more routing: conf_pad_pio[0] = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<24);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* Route UART2 (inputs and outputs) instead of SCI to pins: ssc2_mux_sel = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<2);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* conf_pad_pio[4] = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<28);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* Route UART3 (inputs and outputs) instead of SCI to pins: ssc3_mux_sel = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<3);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* conf_pad_clkobs = 1 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf |= (1<<14);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* I2C and USB related routing */
+	/* bit4: ssc4_mux_sel = 0 (treat SSC4 as I2C) */
+	/* bit26: conf_pad_pio[2] = 0 route USB etc instead of DVO */
+	/* bit27: conf_pad_pio[3] = 0 DVO output selection (probably ignored) */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~((1<<27)|(1<<26)|(1<<4));
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* Enable SOFT_JTAG mode.
+	 * Taken from OS21, but is this correct?
+	 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG33;
+	sysconf |= (1<<6);
+	sysconf &= ~((1<<0)|(1<<1)|(1<<2)|(1<<3));
+	*STX7200_SYSCONF_SYS_CFG33 = sysconf;
+
+	configPIO();
+
+	return 0;
+}
+
+int checkboard (void)
+{
+	printf ("\n\nBoard: cb102"
+#ifdef CONFIG_SH_SE_MODE
+		"  [32-bit mode]"
+#else
+		"  [29-bit mode]"
+#endif
+		"\n");
+
+#ifdef CONFIG_DRIVER_NETSTMAC
+#if defined(CONFIG_STMAC_MAC0)
+	/* On-board PHY (MII0) in MII mode, using MII_CLK */
+	stx7200_configure_ethernet (0, 0, 0, 0);
+#endif	/* CONFIG_STMAC_MAC0 */
+#endif	/* CONFIG_DRIVER_NETSTMAC */
+	return 0;
+}
diff --git a/board/st/cb102/config.mk b/board/st/cb102/config.mk
new file mode 100644
index 0000000000..fb571b3ed1
--- /dev/null
+++ b/board/st/cb102/config.mk
@@ -0,0 +1,44 @@
+#
+# (C) Copyright 2007-2008 STMicroelectronics.
+# Stuart Menefy <stuart.menefy@st.com>
+# Sean McGoogan <Sean.McGoogan@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# CB102 board:
+#
+#	Valid values for TEXT_BASE are:
+#
+#	0x97F00000	29-bit mode (Traditional Mode)
+#	0x8FF00000	32-bit mode (Space-Enhancement Mode)
+#
+# Note:	Alternative definitions of TEXT_BASE are put into
+#	'config.tmp' from the top-level 'Makefile'.
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+# Installs at LMI0 BASE + 255MB in P1 (cachable)
+TEXT_BASE = 0x97F00000
+endif
+
+PLATFORM_LDFLAGS +=
diff --git a/board/st/cb102/init-cb102.S b/board/st/cb102/init-cb102.S
new file mode 100644
index 0000000000..70a7a058c9
--- /dev/null
+++ b/board/st/cb102/init-cb102.S
@@ -0,0 +1,426 @@
+
+#include "asm/stx7200reg.h"
+#include "../../../cpu/sh/init_ram.S"
+
+/*
+ * This is derived from STMicroelectronics gnu toolchain example:
+ *   sh-superh-elf/examples/os21/romdynamic/memory_mb671.S
+ */
+
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *       opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+#ifndef CONFIG_STM_NEW_POKE_TABLE_PARADIGM
+/*
+ * For compatibility with old poke table code, we define some of the
+ * new names, to map onto the old names. Ultimately, the old poke table
+ * code will be updated to the "new order", and we can just delete
+ * the following mappings.
+ */
+#define POKE8(A, VAL)				POKE_CHAR(A, VAL)
+#define POKE16(A, VAL)				POKE_SHORT(A, VAL)
+#define POKE32(A, VAL)				POKE_LONG(A, VAL)
+#define OR32(A, VAL)				OR_LONG(A, VAL)
+#define UPDATE32(A, AND, OR)			UPDATE_LONG(A, AND, OR)
+#define POKE_UPDATE32(A1, A2, AND, SHIFT, OR)	POKE_UPDATE_LONG(A1, A2, AND, SHIFT, OR)
+#define WHILE_NE32(A, AND, VAL)			WHILE_NE(A, AND, VAL)
+#define DELAY(VAL)				/* do nothing */
+#endif /* CONFIG_STM_NEW_POKE_TABLE_PARADIGM */
+
+
+	.section .data.init, "a"
+
+	.balign 32
+
+__memory_setup_table:
+
+	/* ----- STx7200 Clocks ----- */
+
+	/* Set CLOCKGENA PLL0 into BYPASS... */
+	OR32(STX7200_CLOCKGENA_PLL0_CFG, 0x00100000)
+
+	/* Power down CLOCKGENA PLL0... */
+	OR32(STX7200_CLOCKGENA_POWER_CFG, 0x00000001)
+
+	/* Configure CLOCKGENA PLL0... to 900MHz */
+	UPDATE32(STX7200_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x01 | (0x0f << 8))
+
+	/* Enable CLOCKGENA PLL0... */
+	UPDATE32(STX7200_CLOCKGENA_POWER_CFG, 0xfffffffe, 0)
+
+	/* Wait for CLOCKGENA PLL0 to lock... */
+	WHILE_NE32(STX7200_CLOCKGENA_PLL0_CFG, 0x80000000, 0x80000000)
+
+	/* Clear CLOCKGENA PLL0 from BYPASS... */
+	UPDATE32(STX7200_CLOCKGENA_PLL0_CFG, 0xffefffff, 0)
+
+	/* Set CLOCKGENA PLL1 into BYPASS... */
+	OR32(STX7200_CLOCKGENA_PLL1_CFG, 0x00100000)
+
+	/* Power down CLOCKGENA PLL1... */
+	OR32(STX7200_CLOCKGENA_POWER_CFG, 0x00000002)
+
+	/* Configure CLOCKGENA PLL1... */
+	UPDATE32(STX7200_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x01 | (0x0f << 8))
+
+	/* Enable CLOCKGENA PLL1... */
+	UPDATE32(STX7200_CLOCKGENA_POWER_CFG, 0xfffffffd, 0)
+
+	/* Wait for CLOCKGENA PLL1 to lock... */
+	WHILE_NE32(STX7200_CLOCKGENA_PLL1_CFG, 0x80000000, 0x80000000)
+
+	/* Clear CLOCKGENA PLL1 from BYPASS... */
+	UPDATE32(STX7200_CLOCKGENA_PLL1_CFG, 0xffefffff, 0)
+
+	/* Set CLOCKGENA PLL2 into BYPASS... */
+	OR32(STX7200_CLOCKGENA_PLL2_CFG, 0x00100000)
+
+	/* Power down CLOCKGENA PLL2... */
+	OR32(STX7200_CLOCKGENA_POWER_CFG, 0x00000004)
+
+	/* Configure CLOCKGENA PLL2... */
+	UPDATE32(STX7200_CLOCKGENA_PLL2_CFG, 0xfff80000, 0x03 | (0x28 << 8) | (0x00 << 16))
+
+	/* Enable CLOCKGENA PLL2... */
+	UPDATE32(STX7200_CLOCKGENA_POWER_CFG, 0xfffffffb, 0)
+
+	/* Wait for CLOCKGENA PLL2 to lock... */
+	WHILE_NE32(STX7200_CLOCKGENA_PLL2_CFG, 0x80000000,  0x80000000)
+
+	/* Clear CLOCKGENA PLL2 from BYPASS... */
+	UPDATE32(STX7200_CLOCKGENA_PLL2_CFG, 0xffefffff, 0)
+
+	/* Set CLOCKGENB PLL0 into BYPASS... */
+	OR32(STX7200_CLOCKGENB_PLL0_CFG, 0x00100000)
+
+	/* Power down CLOCKGENB PLL0... */
+	OR32(STX7200_CLOCKGENB_POWER_CFG, 0x00008000)
+
+	/* Configure CLOCKGENB PLL0... */
+	UPDATE32(STX7200_CLOCKGENB_PLL0_CFG, 0xfff80000, 0x03 | (0x28 << 8) | (0x00 << 16))
+
+	/* Enable CLOCKGENB PLL0... */
+	UPDATE32(STX7200_CLOCKGENB_POWER_CFG, 0xffff7fff, 0)
+
+	/* Wait for CLOCKGENB PLL0 to lock... */
+	WHILE_NE32(STX7200_CLOCKGENB_PLL0_CFG, 0x80000000, 0x80000000)
+
+	/* Clear CLOCKGENB PLL0 from BYPASS... */
+	UPDATE32(STX7200_CLOCKGENB_PLL0_CFG, 0xffefffff, 0)
+
+	/* Power down PLL... */
+	OR32(STX7200_SYSCONF_SYS_CFG11, 0x00001000)
+
+#ifdef SLOW_LMI
+	/* Set LMI clock to 666MHz */
+	UPDATE32(STX7200_SYSCONF_SYS_CFG11, 0xfffff001, (0x05 << 9) | (0x6f << 1))
+#else	/* !SLOW_LMI */
+	/* Set LMI clock to 800MHz */
+	UPDATE32(STX7200_SYSCONF_SYS_CFG11, 0xfffff001, (0x03 << 9) | (0x50 << 1))
+#endif	/* SLOW_LMI */
+
+	/* Enable CLOCKGENA PLL1... */
+	UPDATE32(STX7200_SYSCONF_SYS_CFG11, 0xffffefff, 0)
+
+	/* Wait for CLOCKGENA PLL1 to lock... */
+#ifdef CONFIG_STM_NEW_POKE_TABLE_PARADIGM
+	IF_EQ32(1, STX7200_SYSCONF_DEVICEID_0, 0x0fffffff, 0x0d437041)
+	  WHILE_NE32(STX7200_SYSCONF_SYS_STA03, 0x00000001, 1)
+	ELSE(1)
+	  /* On cut 1 polarity inverted on lock bit */
+	  WHILE_NE32(STX7200_SYSCONF_SYS_STA03, 0x00000001, 0)
+	ENDIF(1)
+#else /* CONFIG_STM_NEW_POKE_TABLE_PARADIGM */
+	IF_DEVID(STX7200_CUT1)
+	  /* On cut 1 polarity inverted on lock bit */
+	  WHILE_NE32(STX7200_SYSCONF_SYS_STA03, 0x00000001, 0)
+	ENDIF
+	IF_DEVID(STX7200_CUT2)
+	  WHILE_NE32(STX7200_SYSCONF_SYS_STA03, 0x00000001, 1)
+	ENDIF
+#endif /* CONFIG_STM_NEW_POKE_TABLE_PARADIGM */
+
+	/* ----- STx7200 Sysconf ----- */
+
+	/* PLI_CLOCK_ENABLE set to 0 */
+	UPDATE32(STX7200_SYSCONF_SYS_CFG58, ~(1 << 0), 0)
+
+	/* LMI sub-sys & pl exit from reset */
+	OR32(STX7200_SYSCONF_SYS_CFG11, 0x1 | (1 << 27))
+	OR32(STX7200_SYSCONF_SYS_CFG15, 0x1 | (1 << 27))
+
+	/* Delay ~ 200 uS (assumes 400MHz CPU clock) */
+	DELAY(200 * 400)
+
+	/* PLI_CLOCK_ENABLE set to 1 */
+	OR32(STX7200_SYSCONF_SYS_CFG58, (1 << 0))
+
+	/* Check both DLL on LMI0 are locked */
+	WHILE_NE32(STX7200_SYSCONF_SYS_STA03, (1 << 10) | (1 << 20), (1 << 10) | (1 << 20))
+
+	/* Check both DLL on LMI1 are locked */
+	WHILE_NE32(STX7200_SYSCONF_SYS_STA05, (1 << 10) | (1 << 20), (1 << 10) | (1 << 20))
+
+	/* Adjust proga, progb, zoutproga, and receiver mode for LMI0 */
+	POKE32(STX7200_SYSCONF_SYS_CFG12, 0xa2007801 | (0x7 << 1) | (0x0 << 4) | (0x0 << 7) | (0x0 << 10))
+
+	/* Adjust proga, progb, zoutproga, and receiver mode for LMI1 */
+	POKE32(STX7200_SYSCONF_SYS_CFG16, 0xa2007801 | (0x7 << 1) | (0x0 << 4) | (0x0 << 7) | (0x0 << 10))
+
+	/* Enable AutoPrecharge */
+	POKE32(STX7200_SYSCONF_SYS_CFG38, 0x000ffd08)
+	POKE32(STX7200_SYSCONF_SYS_CFG39, 0x000ffd18)
+
+	/* Force DLL1 and DLL2 command of LMI0 */
+	POKE32(STX7200_SYSCONF_SYS_CFG13, 0x00000002)
+	POKE32(STX7200_SYSCONF_SYS_CFG14, 0x00000002)
+
+	/* Force DLL1 and DLL2 command of LMI1 */
+	POKE32(STX7200_SYSCONF_SYS_CFG17, 0x00000002)
+	POKE32(STX7200_SYSCONF_SYS_CFG18, 0x00000002)
+
+	/* Set cfg55 and cfg56 */
+	POKE32(STX7200_SYSCONF_SYS_CFG55, 0x03fc2004 | (0 << 10) | (0x7 << 7))
+	POKE32(STX7200_SYSCONF_SYS_CFG56, 0x03fc2004 | (0 << 10) | (0x7 << 7))
+
+	/* PDL offsets
+	 # -11=1F5 => 42=0x07D7EBF5, 43=0x000001F5
+	 # -21=1EB => 42=0x07afd7eb, 43=0x000001eb
+	 #sysconf.SYSCONF_CFG42.poke(0x07D7EBF5)
+	 #sysconf.SYSCONF_CFG43.poke(0x000001F5)
+	 */
+
+	/* TO BE UPDATED FOR 7200/MB671 */
+	POKE32(STX7200_SYSCONF_SYS_CFG42, 0x00000000)
+	POKE32(STX7200_SYSCONF_SYS_CFG43, 0x00000000)
+
+	POKE32(STX7200_SYSCONF_SYS_CFG44, 0x00000000)
+	POKE32(STX7200_SYSCONF_SYS_CFG45, 0x00000000)
+
+	/* ----- STx7200 EMI configuration ----- */
+
+	POKE32(ST40_EMI_BANK_ENABLE, 0x00000005)
+
+	/* NOTE: bits [0,5] define bottom address bits [22,27] of bank */
+	POKE32(ST40_EMI_BANK0_BASEADDRESS, 0x00000000)
+	POKE32(ST40_EMI_BANK1_BASEADDRESS, 0x00000008)
+	POKE32(ST40_EMI_BANK2_BASEADDRESS, 0x0000000c)
+	POKE32(ST40_EMI_BANK3_BASEADDRESS, 0x00000010)
+	POKE32(ST40_EMI_BANK4_BASEADDRESS, 0x00000014)
+
+	/* Bank 0 - On-board 32MiB Flash at address 0x00000000 -> 0x01ffffff */
+	POKE32(ST40_EMI_BANK0_EMICONFIGDATA0, 0x001016d1)
+	POKE32(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
+	POKE32(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
+	POKE32(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
+
+	/* Bank 1 - Not configured */
+	/* Bank 2 - Not configured */
+	/* Bank 3 - Not configured */
+	/* Bank 4 - Not configured */
+
+	/* Program other EMI registers */
+	POKE32(ST40_EMI_GENCFG, 0x00000050)
+
+	/* ----- STx7200 LMI0 configuration ----- */
+
+	/* "Refresh Interval" is set equal to 0xA28=2600 => 2600*3ns=7.8us */
+	POKE32(ST40_LMI_MIM_0(0), 0x07f6015b)
+	POKE32(ST40_LMI_MIM_1(0), 0x000000b0)
+
+	POKE32(ST40_LMI_STR_0(0), 0xcd2db41b)
+	POKE32(ST40_LMI_STR_1(0), 0x002202d6)
+
+	/* lmi base address 0x08000000 + 256MiB */
+	POKE32(ST40_LMI_SDRA0_0(0), 0x18001a20)
+
+	/* lmi base address 0x08000000 + 256MiB */
+	POKE32(ST40_LMI_SDRA1_0(0), 0x18001a20)
+
+	/* Delay ~ 200 uS (assumes 400MHz CPU clock) */
+	DELAY(200 * 400)
+
+	/* Enable clock with NOP command */
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020023)
+	/* Wait NOP command for 400 nsec */
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+
+	/* Precharge all */
+	POKE32(ST40_LMI_SCR_0(0), 0x00020022)
+	/* Wait NOP command for 400 nsec */
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+
+	/* Issue EMRS2 */
+	POKE32(ST40_LMI_SDMR0(0), 0x00010000)
+
+	/* Issue EMRS3 */
+	POKE32(ST40_LMI_SDMR0(0), 0x00018000)
+
+	/* Issue EMRS1 to enable DLL */
+	POKE32(ST40_LMI_SDMR0(0), 0x00008004)
+
+	/* Issue MRS with DLL reset, CAS 5, Write recovery 6, Sequentiel, Burst lengh 8 */
+	POKE32(ST40_LMI_SDMR0(0), 0x00000b53)
+
+	/* Wait NOP command for 400 nsec */
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+
+	/* Precharge all */
+	POKE32(ST40_LMI_SCR_0(0), 0x00020022)
+	/* 2 CBR (auto refresh) */
+	POKE32(ST40_LMI_SCR_0(0), 0x00020024)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020024)
+
+	/* Issue MRS with CAS 5, Write recovery 6, Sequentiel, Burst lengh 8 */
+	POKE32(ST40_LMI_SDMR0(0), 0x00000a53)
+
+	/* Enable auto refresh */
+	POKE32(ST40_LMI_MIM_0(0), 0x07f6035b)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(0), 0x00020021)
+
+	POKE32(ST40_LMI_GCC_0(0), 0x00000000)
+
+	/* ----- STx7200 LMI1 configuration ----- */
+
+	POKE32(ST40_LMI_MIM_0(1), 0x07f6015b)
+	POKE32(ST40_LMI_MIM_1(1), 0x000000b0)
+
+	/* SDRAM Timing Register */
+	POKE32(ST40_LMI_STR_0(1), 0xcd2db41b)
+	POKE32(ST40_LMI_STR_1(1), 0x002202d6)
+
+	/* SDRAM Row Attribute 0 */
+	/* lmi base address 0x18000000 + 64MiB */
+	POKE32(ST40_LMI_SDRA0_0(1), 0x1c001a20)
+
+	/* SDRAM Row Attribute 1 */
+	/* lmi base address 0x18000000 + 64MiB */
+	POKE32(ST40_LMI_SDRA1_0(1), 0x1c001a20)
+
+	/* Delay ~ 200 uS (assumes 400MHz CPU clock) */
+	DELAY(200 * 400)
+
+	/* Enable clock with NOP command */
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020023)
+	/* Wait NOP command for 400 nsec */
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+
+	/* Precharge all */
+	POKE32(ST40_LMI_SCR_0(1), 0x00020022)
+	/* Wait NOP command for 400 nsec */
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+
+	/* Issue EMRS2 */
+	POKE32(ST40_LMI_SDMR0(1), 0x00010000)
+
+	/* Issue EMRS3 */
+	POKE32(ST40_LMI_SDMR0(1), 0x00018000)
+
+	/* Issue EMRS1 to enable DLL */
+	POKE32(ST40_LMI_SDMR0(1), 0x00008004)
+
+	/* Issue MRS with DLL reset, CAS 5, Write recovery 6, Sequentiel, Burst lengh 8 */
+	POKE32(ST40_LMI_SDMR0(1), 0x00000b53)
+
+	/* Wait NOP command for 400 nsec */
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+
+	/* Precharge all */
+	POKE32(ST40_LMI_SCR_0(1), 0x00020022)
+	/* 2 CBR (auto refresh) */
+	POKE32(ST40_LMI_SCR_0(1), 0x00020024)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020024)
+
+	/* Issue MRS with CAS 5, Write recovery 6, Sequentiel, Burst lengh 8 */
+	POKE32(ST40_LMI_SDMR0(1), 0x00000a53)
+
+	/* Enable auto refresh */
+	POKE32(ST40_LMI_MIM_0(1), 0x07f6035b)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(1), 0x00020021)
+
+	POKE32(ST40_LMI_GCC_0(1), 0x00000000)
+
+#ifdef CONFIG_SH_SE_MODE
+	/*
+	 * Note that we also manually need to move the LMI0 and LMI1 base addresses to
+	 * their 32-bit SE mode locations as defined in the datasheet and change the
+	 * 'upper bound addresses' (in row attribute registers) for the LMIs.
+	 */
+	UPDATE_LONG(STX7200_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
+	UPDATE_LONG(STX7200_SYSCONF_SYS_CFG39, 0xFFFFFF00, 0x00000080)
+	POKE_LONG(ST40_LMI_SDRA0_0(0), 0x50001a00)
+	POKE_LONG(ST40_LMI_SDRA1_0(0), 0x50001a00)
+	POKE_LONG(ST40_LMI_SDRA0_0(1), 0x90001a00)
+	POKE_LONG(ST40_LMI_SDRA1_0(1), 0x90001a00)
+#endif	/* CONFIG_SH_SE_MODE */
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/st/cb103/cb103.romgen b/board/st/cb103/cb103.romgen
new file mode 100644
index 0000000000..5a1c8b746f
--- /dev/null
+++ b/board/st/cb103/cb103.romgen
@@ -0,0 +1,1580 @@
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfd704000) (used target peek value 0x2d437041) */
+/* PEEK(0xa5020000) (used target peek value 0x000b000b) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+/* PEEK(0xfd700000) (used target peek value 0x80101400) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+POKE32(0xfd700000, 0x80101400)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfd70001c) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+POKE32(0xfd70001c, 0x00000001)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+/* PEEK(0xfd700000) (used target peek value 0x00181400) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+POKE32(0xfd700000, 0x00180f01)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfd70001c) (used target peek value 0x00000001) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+POKE32(0xfd70001c, 0x00000000)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+/* PEEK(0xfd700000) (used target peek value 0x80100f01) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+WHILE_NE32(0xfd700000, 0x80000000, 0x80000000)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+/* PEEK(0xfd700000) (used target peek value 0x80100f01) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+POKE32(0xfd700000, 0x80000f01)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+/* PEEK(0xfd700004) (used target peek value 0x80100a00) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+POKE32(0xfd700004, 0x80100a00)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfd70001c) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+POKE32(0xfd70001c, 0x00000002)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+/* PEEK(0xfd700004) (used target peek value 0x00180a00) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+POKE32(0xfd700004, 0x00180f01)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfd70001c) (used target peek value 0x00000002) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+POKE32(0xfd70001c, 0x00000000)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+/* PEEK(0xfd700004) (used target peek value 0x80100f01) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+WHILE_NE32(0xfd700004, 0x80000000, 0x80000000)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+/* PEEK(0xfd700004) (used target peek value 0x80100f01) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+POKE32(0xfd700004, 0x80000f01)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+/* PEEK(0xfd700008) (used target peek value 0x80102803) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+POKE32(0xfd700008, 0x80102803)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfd70001c) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+POKE32(0xfd70001c, 0x00000004)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+/* PEEK(0xfd700008) (used target peek value 0x00182803) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+POKE32(0xfd700008, 0x00182803)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfd70001c) (used target peek value 0x00000004) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+POKE32(0xfd70001c, 0x00000000)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+/* PEEK(0xfd700008) (used target peek value 0x80102803) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+WHILE_NE32(0xfd700008, 0x80000000, 0x80000000)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+/* PEEK(0xfd700008) (used target peek value 0x80102803) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+POKE32(0xfd700008, 0x80002803)
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+/* PEEK(0xfd70103c) (used target peek value 0x80102803) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+POKE32(0xfd70103c, 0x80102803)
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_POWER_CFG
+*/
+/* PEEK(0xfd701058) (used target peek value 0x00007ff8) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_POWER_CFG
+*/
+POKE32(0xfd701058, 0x0000fff8)
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+/* PEEK(0xfd70103c) (used target peek value 0x00182803) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+POKE32(0xfd70103c, 0x00182803)
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_POWER_CFG
+*/
+/* PEEK(0xfd701058) (used target peek value 0x0000fff8) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_POWER_CFG
+*/
+POKE32(0xfd701058, 0x00007ff8)
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+/* PEEK(0xfd70103c) (used target peek value 0x80102803) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+WHILE_NE32(0xfd70103c, 0x80000000, 0x80000000)
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+/* PEEK(0xfd70103c) (used target peek value 0x80102803) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+POKE32(0xfd70103c, 0x80002803)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+/* PEEK(0xfd70412c) (used target peek value 0x00000d28) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+POKE32(0xfd70412c, 0x00001d28)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+/* PEEK(0xfd70412c) (used target peek value 0x00001d28) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+POKE32(0xfd70412c, 0x000016c0)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+/* PEEK(0xfd70412c) (used target peek value 0x000016c0) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+POKE32(0xfd70412c, 0x000006c0)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfd704000) (used target peek value 0x2d437041) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA03
+*/
+/* PEEK(0xfd704014) (used target peek value 0x1e04402b) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA03
+*/
+WHILE_NE32(0xfd704014, 0x00000001, 0x00000001)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfd704000) (used target peek value 0x2d437041) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfd704000) (used target peek value 0x2d437041) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA01
+*/
+/* PEEK(0xfd70400c) (used target peek value 0x00000040) */
+/* PEEK(0xa5000000) (used target peek value 0x00110011) */
+/* PEEK(0xa5020000) (used target peek value 0x000b000b) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfd704000) (used target peek value 0x2d437041) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+/* PEEK(0xfd700000) (used target peek value 0x80000f01) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+/* PEEK(0xfd700004) (used target peek value 0x80000f01) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+/* PEEK(0xfd700008) (used target peek value 0x80002803) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+/* PEEK(0xfd70103c) (used target peek value 0x80002803) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+/* PEEK(0xfd70412c) (used target peek value 0x000006c0) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_MUX_CFG
+*/
+/* PEEK(0xfd70000c) (used target peek value 0x00000071) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
+*/
+/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_DIV2_CFG
+*/
+/* PEEK(0xfd701050) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
+*/
+/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
+*/
+/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_DIV2_CFG
+*/
+/* PEEK(0xfd701050) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
+*/
+/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_MUX_CFG
+*/
+/* PEEK(0xfd70000c) (used target peek value 0x00000071) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
+*/
+/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_DIV2_CFG
+*/
+/* PEEK(0xfd701050) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_DIV2_CFG
+*/
+/* PEEK(0xfd701050) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_DIV2_CFG
+*/
+/* PEEK(0xfd701050) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
+*/
+/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG58
+*/
+/* PEEK(0xfd7041e8) (used target peek value 0x00000001) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG58
+*/
+POKE32(0xfd7041e8, 0x00000000)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+POKE32(0xfd70412c, 0x080006a1)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG15
+*/
+POKE32(0xfd70413c, 0x08000001)
+DELAY(200)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG58
+*/
+/* PEEK(0xfd7041e8) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG58
+*/
+POKE32(0xfd7041e8, 0x00000001)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA03
+*/
+/* PEEK(0xfd704014) (used target peek value 0x1e175c6b) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA03
+*/
+WHILE_NE32(0xfd704014, 0x00100400, 0x00100400)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA05
+*/
+/* PEEK(0xfd70401c) (used target peek value 0x1e179572) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA05
+*/
+WHILE_NE32(0xfd70401c, 0x00100400, 0x00100400)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG12
+*/
+POKE32(0xfd704130, 0xa200687f)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG16
+*/
+POKE32(0xfd704140, 0xa200687f)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG38
+*/
+POKE32(0xfd704198, 0x002ffd08)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG39
+*/
+POKE32(0xfd70419c, 0x002ffd18)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG13
+*/
+POKE32(0xfd704134, 0x00020000)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG14
+*/
+POKE32(0xfd704138, 0x00000000)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG17
+*/
+POKE32(0xfd704144, 0x00020000)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG18
+*/
+POKE32(0xfd704148, 0x00000000)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG55
+*/
+POKE32(0xfd7041dc, 0x07fc0284)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG56
+*/
+POKE32(0xfd7041e0, 0x07fc0284)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG42
+*/
+POKE32(0xfd7041a8, 0x07b7dbed)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG43
+*/
+POKE32(0xfd7041ac, 0x980001ed)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG44
+*/
+POKE32(0xfd7041b0, 0x87b7dbed)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG45
+*/
+POKE32(0xfd7041b4, 0x180001ed)
+/* PEEK(0xfd70412c) (used target peek value 0x080006a1) */
+/* PEEK(0xfd704130) (used target peek value 0xa200687f) */
+/* PEEK(0xfd704134) (used target peek value 0x00020000) */
+/* PEEK(0xfd704138) (used target peek value 0x00000000) */
+/* PEEK(0xfd70413c) (used target peek value 0x08000001) */
+/* PEEK(0xfd704140) (used target peek value 0xa200687f) */
+/* PEEK(0xfd704144) (used target peek value 0x00020000) */
+/* PEEK(0xfd704148) (used target peek value 0x00000000) */
+/* PEEK(0xfd704198) (used target peek value 0x002ffd08) */
+/* PEEK(0xfd70419c) (used target peek value 0x002ffd18) */
+/* PEEK(0xfd7041a8) (used target peek value 0x07b7dbed) */
+/* PEEK(0xfd7041ac) (used target peek value 0x980001ed) */
+/* PEEK(0xfd7041b0) (used target peek value 0x87b7dbed) */
+/* PEEK(0xfd7041b4) (used target peek value 0x180001ed) */
+/* PEEK(0xfd7041cc) (used target peek value 0x00000000) */
+/* PEEK(0xfd7041d0) (used target peek value 0x00000000) */
+/* PEEK(0xfd7041d4) (used target peek value 0x00000000) */
+/* PEEK(0xfd7041d8) (used target peek value 0x00000000) */
+/* PEEK(0xfd7041dc) (used target peek value 0x07fc0284) */
+/* PEEK(0xfd7041e0) (used target peek value 0x07fc0284) */
+
+
+/*
+st40_emi_regs.EMI_BANK_ENABLE
+*/
+POKE32(0xfdf00860, 0x00000005)
+
+
+/*
+st40_emi_regs.EMI_BANK0_BASEADDRESS
+*/
+POKE32(0xfdf00800, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_BASEADDRESS
+*/
+POKE32(0xfdf00810, 0x00000008)
+
+
+/*
+st40_emi_regs.EMI_BANK2_BASEADDRESS
+*/
+POKE32(0xfdf00820, 0x0000000c)
+
+
+/*
+st40_emi_regs.EMI_BANK3_BASEADDRESS
+*/
+POKE32(0xfdf00830, 0x00000010)
+
+
+/*
+st40_emi_regs.EMI_BANK4_BASEADDRESS
+*/
+POKE32(0xfdf00840, 0x00000014)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA0
+*/
+POKE32(0xfdf00100, 0x001016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA1
+*/
+POKE32(0xfdf00108, 0x9d200000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA2
+*/
+POKE32(0xfdf00110, 0x9d220000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA3
+*/
+POKE32(0xfdf00118, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA0
+*/
+POKE32(0xfdf00180, 0x002046f9)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA1
+*/
+POKE32(0xfdf00188, 0xa5a00000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA2
+*/
+POKE32(0xfdf00190, 0xa5a20000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA3
+*/
+POKE32(0xfdf00198, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA0
+*/
+POKE32(0xfdf00200, 0x042086f1)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA1
+*/
+POKE32(0xfdf00208, 0x8a002200)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA2
+*/
+POKE32(0xfdf00210, 0x8a004200)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA3
+*/
+POKE32(0xfdf00218, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_GENCFG
+*/
+POKE32(0xfdf00028, 0x00000050)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfdd18008, 0x07f6015b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_1
+*/
+POKE32(0xfdd1800c, 0xffff0500)
+
+
+/*
+st40_lmigp_regs.LMI_STR_0
+*/
+POKE32(0xfdd18018, 0xcd2db41b)
+
+
+/*
+st40_lmigp_regs.LMI_STR_1
+*/
+POKE32(0xfdd1801c, 0x002202d6)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA0_0
+*/
+POKE32(0xfdd18030, 0x18001a20)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA1_0
+*/
+POKE32(0xfdd18038, 0x18001a20)
+DELAY(200000)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020023)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd18048, 0x00010000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd18048, 0x00018000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd18048, 0x00008004)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd18048, 0x00000b53)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd18048, 0x00000a53)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfdd18008, 0x07f6035b)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_GCC_0
+*/
+POKE32(0xfdd18028, 0x00000000)
+POKE32(0xa8000000, 0x00000000)
+POKE32(0xa8000000, 0xaaaaaaaa)
+/* PEEK(0xa8000000) (used target peek value 0xaaaaaaaa) */
+POKE32(0xa8001000, 0x00000000)
+POKE32(0xa8001000, 0x55555555)
+/* PEEK(0xa8001000) (used target peek value 0x55555555) */
+POKE32(0xa8002000, 0x00000000)
+POKE32(0xa8002000, 0x12345678)
+/* PEEK(0xa8002000) (used target peek value 0x12345678) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfdd19008, 0x07f6015b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_1
+*/
+POKE32(0xfdd1900c, 0xffff0500)
+
+
+/*
+st40_lmigp_regs.LMI_STR_0
+*/
+POKE32(0xfdd19018, 0xcd2db41b)
+
+
+/*
+st40_lmigp_regs.LMI_STR_1
+*/
+POKE32(0xfdd1901c, 0x002202d6)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA0_0
+*/
+POKE32(0xfdd19030, 0x1c001a20)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA1_0
+*/
+POKE32(0xfdd19038, 0x1c001a20)
+DELAY(200000)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020023)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd19048, 0x00010000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd19048, 0x00018000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd19048, 0x00008004)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd19048, 0x00000b53)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd19048, 0x00000a53)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfdd19008, 0x07f6035b)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_GCC_0
+*/
+POKE32(0xfdd19028, 0x00000000)
+POKE32(0xb8000000, 0x00000000)
+POKE32(0xb8000000, 0xaaaaaaaa)
+/* PEEK(0xb8000000) (used target peek value 0xaaaaaaaa) */
+POKE32(0xb8001000, 0x00000000)
+POKE32(0xb8001000, 0x55555555)
+/* PEEK(0xb8001000) (used target peek value 0x55555555) */
+POKE32(0xb8002000, 0x00000000)
+POKE32(0xb8002000, 0x12345678)
+/* PEEK(0xb8002000) (used target peek value 0x12345678) */
+
+
+/*
+st40_ccn_regs.CCN_CCR
+*/
+POKE32(0xff00001c, 0x8000090d)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG05
+*/
+/* PEEK(0xfd704114) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG05
+*/
+POKE32(0xfd704114, 0x00000000)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG09
+*/
+/* PEEK(0xfd704124) (used target peek value 0x00000a8c) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG09
+*/
+POKE32(0xfd704124, 0x08000a8c)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG29
+*/
+/* PEEK(0xfd704174) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG28
+*/
+POKE32(0xfd704170, 0x00004001)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG29
+*/
+/* PEEK(0xfd704174) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG29
+*/
+POKE32(0xfd704174, 0x00000001)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG29
+*/
+/* PEEK(0xfd704174) (used target peek value 0x00000001) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG29
+*/
+POKE32(0xfd704174, 0x00000000)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG05
+*/
+/* PEEK(0xfd704114) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG05
+*/
+POKE32(0xfd704114, 0x00000000)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG09
+*/
+/* PEEK(0xfd704124) (used target peek value 0x08000a8c) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG09
+*/
+POKE32(0xfd704124, 0x08000a8c)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG27
+*/
+/* PEEK(0xfd70416c) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG26
+*/
+POKE32(0xfd704168, 0x00004001)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG27
+*/
+/* PEEK(0xfd70416c) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG27
+*/
+POKE32(0xfd70416c, 0x00000001)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG27
+*/
+/* PEEK(0xfd70416c) (used target peek value 0x00000001) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG27
+*/
+POKE32(0xfd70416c, 0x00000000)
diff --git a/board/st/cb103/init-cb103.S b/board/st/cb103/init-cb103.S
new file mode 100644
index 0000000000..5c979f2739
--- /dev/null
+++ b/board/st/cb103/init-cb103.S
@@ -0,0 +1,77 @@
+#include "asm/stx7200reg.h"
+#include "../../../cpu/sh/init_ram.S"
+
+/*
+ * This is derived from STMicroelectronics gnu toolchain example:
+ *   sh-superh-elf/examples/os21/romdynamic/memory_mb671.S
+ */
+
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *	opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+/*
+ * For compatibility with old poke table code, we define some of the
+ * new names, to map onto the old names. Ultimately, the old poke table
+ * code will be updated to the "new order", and we can just delete
+ * the following mappings.
+ */
+#define POKE8(A, VAL)				POKE_CHAR(A, VAL)
+#define POKE16(A, VAL)				POKE_SHORT(A, VAL)
+#define POKE32(A, VAL)				POKE_LONG(A, VAL)
+#define OR32(A, VAL)				OR_LONG(A, VAL)
+#define UPDATE32(A, AND, OR)			UPDATE_LONG(A, AND, OR)
+#define POKE_UPDATE32(A1, A2, AND, SHIFT, OR)	POKE_UPDATE_LONG(A1, A2, AND, SHIFT, OR)
+#define WHILE_NE32(A, AND, VAL)			WHILE_NE(A, AND, VAL)
+#define DELAY(VAL)				/* do nothing */
+
+
+	.section .data.init, "a"
+
+	.balign 32
+
+__memory_setup_table:
+
+	/*
+	 * include the appropriate set of "GDB pokes", (usually) generated
+	 * using the "romgen" utility, from a known good target-pack.
+	 *
+	 * This file may be regenerated by connecting your specific board
+	 * to an STMC2 (note: currently it must be version 2) and then
+	 * executing the following command (redirecting the output):
+	 *
+	 * host% romgen --target-connect --show-comment <stmc2>:cb103:st40
+	 *
+	 * Where "<stmc2>" should be replaced with the IP address
+	 * (or the DNS name) of the STMC2 box.  Also the "cb103" should
+	 * substituted if you have a custom target-pack connect command.
+	 *
+	 * Note: The connect command used with "romgen", should connect
+	 * only in 29-bit mode - even if U-Boot will be built for 32-bit mode.
+	 * That is, do not use the "seuc=1" (or similar) option with "romgen".
+	 */
+#include "cb103.romgen"
+
+#ifdef CONFIG_SH_SE_MODE
+	/*
+	 * Note that we also manually need to move the LMI0 and LMI1 base addresses to
+	 * their 32-bit SE mode locations as defined in the datasheet and change the
+	 * 'upper bound addresses' (in row attribute registers) for the LMIs.
+	 */
+	UPDATE_LONG(STX7200_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
+	UPDATE_LONG(STX7200_SYSCONF_SYS_CFG39, 0xFFFFFF00, 0x00000080)
+	POKE_LONG(ST40_LMI_SDRA0_0(0), 0x50001a00)
+	POKE_LONG(ST40_LMI_SDRA1_0(0), 0x50001a00)
+	POKE_LONG(ST40_LMI_SDRA0_0(1), 0x90001a00)
+	POKE_LONG(ST40_LMI_SDRA1_0(1), 0x90001a00)
+#endif	/* CONFIG_SH_SE_MODE */
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/st/hdk7111/Makefile b/board/st/hdk7111/Makefile
new file mode 100644
index 0000000000..e71bce43bb
--- /dev/null
+++ b/board/st/hdk7111/Makefile
@@ -0,0 +1,54 @@
+#
+# (C) Copyright 2007 STMicroelectronics.
+# Stuart Menefy <stuart.menefy@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+SOBJS-y	= init-$(BOARD).o
+
+COBJS-y	+= $(BOARD).o
+COBJS-$(CONFIG_CMD_NAND) += nand.o
+
+
+SRCS	:= $(SOBJS-y:.o=.S) $(COBJS-y:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS-y))
+SOBJS	:= $(addprefix $(obj),$(SOBJS-y))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/st/hdk7111/config.mk b/board/st/hdk7111/config.mk
new file mode 100644
index 0000000000..3ef944d4c8
--- /dev/null
+++ b/board/st/hdk7111/config.mk
@@ -0,0 +1,43 @@
+#
+# (C) Copyright 2009 STMicroelectronics.
+# Sean McGoogan <Sean.McGoogan@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# HDK-7111 board:
+#
+#	Valid values for TEXT_BASE are:
+#
+#	0x9BF00000	29-bit mode (Traditional Mode)
+#	0x8FF00000	32-bit mode (Space-Enhancement Mode)
+#
+# Note:	Alternative definitions of TEXT_BASE are put into
+#	'config.tmp' from the top-level 'Makefile'.
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+# Installs at LMI0 BASE + 255MB in P1 (cachable)
+TEXT_BASE = 0x9BF00000
+endif
+
+PLATFORM_LDFLAGS +=
diff --git a/board/st/hdk7111/hdk7111.c b/board/st/hdk7111/hdk7111.c
new file mode 100644
index 0000000000..35b00c2ce2
--- /dev/null
+++ b/board/st/hdk7111/hdk7111.c
@@ -0,0 +1,114 @@
+/*
+ * (C) Copyright 2008-2009 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/soc.h>
+#include <asm/stx7111reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+
+void flashWriteEnable(void)
+{
+	/* Enable Vpp for writing to flash */
+	/* Vpp is tied HIGH, so nothing to be done */
+}
+
+void flashWriteDisable(void)
+{
+	/* Disable Vpp for writing to flash */
+	/* Vpp is tied HIGH, so nothing can be done */
+}
+
+static void configEthernet(void)
+{
+	/* Setup PIO for the PHY's reset */
+	SET_PIO_PIN(PIO_PORT(1),6,STPIO_OUT);	/* PHY_RES is on PIO1[6] */
+
+	/* Finally, just toggle the PHY Reset pin */
+	STPIO_SET_PIN(PIO_PORT(1), 6, 0);	/* Assert PHY_RES */
+	udelay(100);				/* small delay (100us) */
+	STPIO_SET_PIN(PIO_PORT(1), 6, 1);	/* de-assert PHY_RES */
+}
+
+#if defined(CONFIG_SPI)
+static void configSpi(void)
+{
+#if defined(CONFIG_SOFT_SPI)
+	/* Configure SPI Serial Flash for PIO "bit-banging" */
+
+	/* SPI is on PIO2[2:0], with CS on PIO6[7] */
+	SET_PIO_PIN(PIO_PORT(2),0,STPIO_OUT);	/* SPI_CLK */
+	SET_PIO_PIN(PIO_PORT(2),1,STPIO_OUT);	/* SPI_DOUT */
+	SET_PIO_PIN(PIO_PORT(2),2,STPIO_IN);	/* SPI_DIN */
+	SET_PIO_PIN(PIO_PORT(6),7,STPIO_OUT);	/* SPI_NOTCS */
+
+	/* drive outputs with sensible initial values */
+	STPIO_SET_PIN(PIO_PORT(6), 7, 1);	/* deassert SPI_NOCS */
+	STPIO_SET_PIN(PIO_PORT(2), 0, 1);	/* assert SPI_CLK */
+	STPIO_SET_PIN(PIO_PORT(2), 1, 0);	/* deassert SPI_DOUT */
+#else
+#error Still to impliment SPI via SSC for the STx7111.
+#endif	/* CONFIG_SOFT_SPI */
+}
+#endif	/* CONFIG_SPI */
+
+static void configPIO(void)
+{
+	/* Setup PIO of ASC device */
+#if CFG_STM_ASC_BASE == ST40_ASC2_REGS_BASE	/* UART #2 */
+	SET_PIO_ASC(PIO_PORT(4), 3, 2, 4, 5);	/* UART2 - AS0 */
+#else
+#error Unsure which UART to configure!
+#endif	/* CFG_STM_ASC_BASE == ST40_ASC2_REGS_BASE */
+
+	/* Configure & Reset the Ethernet PHY */
+	configEthernet();
+
+#if defined(CONFIG_SPI)
+	/* Configure for SPI Serial Flash */
+	configSpi();
+#endif	/* CONFIG_SPI */
+}
+
+extern int board_init(void)
+{
+	configPIO();
+
+	return 0;
+}
+
+int checkboard (void)
+{
+	printf ("\n\nBoard: STx7111-HDK"
+#ifdef CONFIG_SH_SE_MODE
+		"  [32-bit mode]"
+#else
+		"  [29-bit mode]"
+#endif
+		"\n");
+
+	return 0;
+}
diff --git a/board/st/hdk7111/hdk7111.romgen b/board/st/hdk7111/hdk7111.romgen
new file mode 100644
index 0000000000..a269c33c61
--- /dev/null
+++ b/board/st/hdk7111/hdk7111.romgen
@@ -0,0 +1,1867 @@
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x2d43b041) */
+/* PEEK(0xfe00d060) (used target peek value 0x00000000) */
+/* PEEK(0xfe00d05c) (used target peek value 0x01100110) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x2d43b041) */
+/* PEEK(0xfe00d05c) (used target peek value 0x01100110) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+POKE32(0xfe213014, 0x00000000)
+
+
+/*
+stx7111_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+POKE32(0xfe213024, 0x00000000)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_ENABLE_FB
+*/
+/* PEEK(0xfe21301c) (used target peek value 0x00000000) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_ENABLE_FB
+*/
+WHILE_NE32(0xfe21301c, 0xffffffff, 0x00000000)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_ENABLE_FB
+*/
+/* PEEK(0xfe213020) (used target peek value 0x00000000) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_ENABLE_FB
+*/
+WHILE_NE32(0xfe213020, 0xffffffff, 0x00000000)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80001402) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x80101402)
+
+
+/*
+stx7111_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000000) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000001)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x00181402) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x00180f01)
+
+
+/*
+stx7111_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000001) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000000)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80100f01) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_CFG
+*/
+WHILE_NE32(0xfe213000, 0x80000000, 0x80000000)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80100f01) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x80000f01)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x80102803)
+
+
+/*
+stx7111_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000000) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000002)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x00182803) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x00182803)
+
+
+/*
+stx7111_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000002) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000000)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80102803) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_CFG
+*/
+WHILE_NE32(0xfe213004, 0x80000000, 0x80000000)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80102803) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x80002803)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_DIV0_CFG
+*/
+POKE32(0xfe213b00, 0x00000001)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_DIV1_CFG
+*/
+POKE32(0xfe213b04, 0x00000001)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_DIV2_CFG
+*/
+POKE32(0xfe213b08, 0x00000001)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_DIV3_CFG
+*/
+POKE32(0xfe213b0c, 0x00000003)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0LS_DIV4_CFG
+*/
+POKE32(0xfe213a10, 0x00000000)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_DIV5_CFG
+*/
+POKE32(0xfe213b14, 0x00000007)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0LS_DIV6_CFG
+*/
+POKE32(0xfe213a18, 0x00000000)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0LS_DIV7_CFG
+*/
+POKE32(0xfe213a1c, 0x00000000)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_DIV8_CFG
+*/
+POKE32(0xfe213b20, 0x00000003)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_DIV9_CFG
+*/
+POKE32(0xfe213b24, 0x00000003)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_DIV10_CFG
+*/
+POKE32(0xfe213b28, 0x00000003)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_DIV11_CFG
+*/
+POKE32(0xfe213b2c, 0x00000003)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_DIV12_CFG
+*/
+POKE32(0xfe213b30, 0x00000002)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0LS_DIV13_CFG
+*/
+POKE32(0xfe213a34, 0x00000011)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_DIV14_CFG
+*/
+POKE32(0xfe213b38, 0x0000000b)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_DIV15_CFG
+*/
+POKE32(0xfe213b3c, 0x00000007)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_DIV16_CFG
+*/
+POKE32(0xfe213b40, 0x00000003)
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_DIV17_CFG
+*/
+POKE32(0xfe213b44, 0x00000003)
+POKE32(0xfe702010, 0x00000004)
+
+
+/*
+stx7111_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+POKE32(0xfe213014, 0xa6aa59aa)
+
+
+/*
+stx7111_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+POKE32(0xfe213024, 0x0000000a)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x00000d28) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x00001d28)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x00001d28) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x000016a0)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000016a0) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x000006a0)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA3
+*/
+/* PEEK(0xfe001014) (used target peek value 0x101005a6) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA3
+*/
+WHILE_NE32(0xfe001014, 0x00000001, 0x00000000)
+
+
+/*
+stx7111_clockgenb_regs.CLOCKGENB_LOCK
+*/
+POKE32(0xfe000010, 0x0000c0de)
+
+
+/*
+stx7111_clockgenb_regs.CLOCKGENB_CRISTAL_SEL
+*/
+POKE32(0xfe0000b8, 0x00000000)
+
+
+/*
+stx7111_clockgenb_regs.CLOCKGENB_LOCK
+*/
+POKE32(0xfe000010, 0x0000c1a0)
+
+
+/*
+stx7111_audio_regs.AUDCFG_FSYNA_CFG
+*/
+/* PEEK(0xfe210000) (used target peek value 0x00000000) */
+
+
+/*
+stx7111_audio_regs.AUDCFG_FSYNA_CFG
+*/
+POKE32(0xfe210000, 0x00000000)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG40
+*/
+POKE32(0xfe0011a0, 0x00000000)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a10) (used target peek value 0x00000000) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a18) (used target peek value 0x00000000) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a1c) (used target peek value 0x00000000) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b04) (used target peek value 0x00000001) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b08) (used target peek value 0x00000001) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b00) (used target peek value 0x00000001) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b20) (used target peek value 0x00000003) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b24) (used target peek value 0x00000003) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b28) (used target peek value 0x00000003) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+/* PEEK(0xfe213024) (used target peek value 0x0000000a) */
+/* PEEK(0xfe213b40) (used target peek value 0x00000003) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+/* PEEK(0xfe213024) (used target peek value 0x0000000a) */
+/* PEEK(0xfe213b44) (used target peek value 0x00000003) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b14) (used target peek value 0x00000007) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b2c) (used target peek value 0x00000003) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b30) (used target peek value 0x00000002) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a34) (used target peek value 0x00000011) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b38) (used target peek value 0x0000000b) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x0000292c) */
+
+
+/*
+stx7111_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b3c) (used target peek value 0x00000007) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000006a0) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x00000006) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG04
+*/
+POKE32(0xfe001110, 0x00000002)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000006a0) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x080006a1)
+DELAY(200)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x00000002) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG04
+*/
+POKE32(0xfe001110, 0x00000006)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA3
+*/
+/* PEEK(0xfe001014) (used target peek value 0x1015f5ee) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_STA3
+*/
+WHILE_NE32(0xfe001014, 0x00100400, 0x00100400)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200687f)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG38
+*/
+POKE32(0xfe001198, 0x002ffe0c)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x00200000)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG14
+*/
+POKE32(0xfe001138, 0x00000000)
+/* PEEK(0xfe00d060) (used target peek value 0x00000000) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x07fc22c4)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG42
+*/
+POKE32(0xfe0011a8, 0x07bbddee)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG43
+*/
+POKE32(0xfe0011ac, 0x180001ee)
+
+
+/*
+st40_emi_regs.EMI_BANK_ENABLE
+*/
+POKE32(0xfe700860, 0x00000005)
+
+
+/*
+st40_emi_regs.EMI_BANK0_BASEADDRESS
+*/
+POKE32(0xfe700800, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_BASEADDRESS
+*/
+POKE32(0xfe700810, 0x00000010)
+
+
+/*
+st40_emi_regs.EMI_BANK2_BASEADDRESS
+*/
+POKE32(0xfe700820, 0x00000018)
+
+
+/*
+st40_emi_regs.EMI_BANK3_BASEADDRESS
+*/
+POKE32(0xfe700830, 0x0000001A)
+
+
+/*
+st40_emi_regs.EMI_BANK4_BASEADDRESS
+*/
+POKE32(0xfe700840, 0x0000001c)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA0
+*/
+POKE32(0xfe700100, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA1
+*/
+POKE32(0xfe700108, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA2
+*/
+POKE32(0xfe700110, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA3
+*/
+POKE32(0xfe700118, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA0
+*/
+POKE32(0xfe700140, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA1
+*/
+POKE32(0xfe700148, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA2
+*/
+POKE32(0xfe700150, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA3
+*/
+POKE32(0xfe700158, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA0
+*/
+POKE32(0xfe700180, 0x002046f9)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA1
+*/
+POKE32(0xfe700188, 0xa5a00000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA2
+*/
+POKE32(0xfe700190, 0xa5a20000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA3
+*/
+POKE32(0xfe700198, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA0
+*/
+POKE32(0xfe7001c0, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA1
+*/
+POKE32(0xfe7001c8, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA2
+*/
+POKE32(0xfe7001d0, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA3
+*/
+POKE32(0xfe7001d8, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA0
+*/
+POKE32(0xfe700200, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA1
+*/
+POKE32(0xfe700208, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA2
+*/
+POKE32(0xfe700210, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA3
+*/
+POKE32(0xfe700218, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_GENCFG
+*/
+POKE32(0xfe700028, 0x00000000)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x080006a1) */
+/* PEEK(0xfe00d060) (used target peek value 0x00000000) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30017b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_1
+*/
+POKE32(0xfe90100c, 0xffff0500)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_1
+*/
+/* PEEK(0xfe90100c) (used target peek value 0xffff0500) */
+
+
+/*
+st40_lmigp_regs.LMI_STR_0
+*/
+POKE32(0xfe901018, 0xcf35b424)
+
+
+/*
+st40_lmigp_regs.LMI_STR_1
+*/
+POKE32(0xfe90101c, 0x00242e58)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA0_0
+*/
+POKE32(0xfe901030, 0x2c001e20)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA1_0
+*/
+POKE32(0xfe901038, 0x2c001e20)
+DELAY(200000)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020023)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00010000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00018000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00008006)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00000b63)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00000a63)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00008386)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00008006)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+/* PEEK(0xfe901008) (used target peek value 0x0b30017b) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30037b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+/* PEEK(0xfe901008) (used target peek value 0x0b30037b) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30037b)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_GCC_0
+*/
+POKE32(0xfe901028, 0x00000000)
+POKE32(0xfe2410fc, 0x00000001)
+POKE32(0xfe20a0ec, 0x00000002)
+POKE32(0xfe20a0f0, 0x00000005)
+POKE32(0xfe20a0f4, 0x00000003)
+POKE32(0xfe20a0f8, 0x00000003)
+POKE32(0xfe20a1ec, 0x00000002)
+POKE32(0xfe20a1f0, 0x00000005)
+POKE32(0xfe20a1f4, 0x00000003)
+POKE32(0xfe20a1f8, 0x00000003)
+POKE32(0xfe20a2ec, 0x00000002)
+POKE32(0xfe20a2f0, 0x00000005)
+POKE32(0xfe20a2f4, 0x00000003)
+POKE32(0xfe20a2f8, 0x00000003)
+POKE32(0xfe20a3ec, 0x00000002)
+POKE32(0xfe20a3f0, 0x00000005)
+POKE32(0xfe20a3f4, 0x00000003)
+POKE32(0xfe20a3f8, 0x00000003)
+POKE32(0xfe20aefc, 0x00000005)
+POKE32(0xfe540034, 0x00000003)
+POKE32(0xfe540038, 0x00000000)
+POKE32(0xfe540110, 0x00010303)
+POKE32(0xfe540114, 0x00000000)
+POKE32(0xfe20bb04, 0x00000005)
+POKE32(0xfe20bb08, 0x00000003)
+POKE32(0xfe20bb10, 0x00000002)
+POKE32(0xfe20bb24, 0x00000005)
+POKE32(0xfe20bb28, 0x00000003)
+POKE32(0xfe20bb2c, 0x00000003)
+POKE32(0xfe20bb30, 0x00000002)
+POKE32(0xfe20bb44, 0x00000005)
+POKE32(0xfe20bb48, 0x00000003)
+POKE32(0xfe20bb4c, 0x00000004)
+POKE32(0xfe20bb50, 0x00000002)
+POKE32(0xfe20bb84, 0x00000005)
+POKE32(0xfe20bb88, 0x00000003)
+POKE32(0xfe20bb8c, 0x00000003)
+POKE32(0xfe20bb90, 0x00000002)
+POKE32(0xfe231010, 0x00000008)
+POKE32(0xfe231080, 0x00000221)
+POKE32(0xfd101824, 0x0003c000)
+POKE32(0xfd102024, 0x0003c000)
+/* PEEK(0xfe001180) (used target peek value 0x00000015) */
+POKE32(0xfe001180, 0x00000005)
+POKE32(0xfe1fff04, 0x00254608)
+/* PEEK(0xfe001180) (used target peek value 0x00000005) */
+POKE32(0xfe001180, 0x00000001)
+POKE32(0xfe401744, 0x0025c005)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x2d43b041) */
+/* PEEK(0xfe00d05c) (used target peek value 0x01100110) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG25
+*/
+POKE32(0xfe001164, 0x00000001)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG25
+*/
+POKE32(0xfe001164, 0x00000000)
+
+
+/*
+st40_ccn_regs.CCN_CCR
+*/
+POKE32(0xff00001c, 0x8000090d)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG09
+*/
+/* PEEK(0xfe001124) (used target peek value 0x205265c0) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG09
+*/
+POKE32(0xfe001124, 0x285265c0)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG05
+*/
+/* PEEK(0xfe001114) (used target peek value 0x3f800000) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG05
+*/
+POKE32(0xfe001114, 0x3f800000)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd0) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG26
+*/
+POKE32(0xfe001168, 0xfe804001)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd0) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG27
+*/
+POKE32(0xfe00116c, 0x00001fd1)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd1) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG27
+*/
+POKE32(0xfe00116c, 0x00001fd0)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG09
+*/
+/* PEEK(0xfe001124) (used target peek value 0x285265c0) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG09
+*/
+POKE32(0xfe001124, 0x285265c0)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG05
+*/
+/* PEEK(0xfe001114) (used target peek value 0x3f800000) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG05
+*/
+POKE32(0xfe001114, 0x3f800000)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcc) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG28
+*/
+POKE32(0xfe001170, 0xfe604001)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcc) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG29
+*/
+POKE32(0xfe001174, 0x00001fcd)
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcd) */
+
+
+/*
+stx7111_sysconf_regs.SYSCONF_CFG29
+*/
+POKE32(0xfe001174, 0x00001fcc)
diff --git a/board/st/hdk7111/init-hdk7111.S b/board/st/hdk7111/init-hdk7111.S
new file mode 100644
index 0000000000..5f476551ba
--- /dev/null
+++ b/board/st/hdk7111/init-hdk7111.S
@@ -0,0 +1,77 @@
+#include "asm/stx7111reg.h"
+#include "../../../cpu/sh/init_ram.S"
+
+/*
+ * This is derived from STMicroelectronics gnu toolchain example:
+ *   sh-superh-elf/examples/os21/romdynamic/memory_mb680.S
+ */
+
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *	opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+/*
+ * For compatibility with old poke table code, we define some of the
+ * new names, to map onto the old names. Ultimately, the old poke table
+ * code will be updated to the "new order", and we can just delete
+ * the following mappings.
+ */
+#define POKE8(A, VAL)				POKE_CHAR(A, VAL)
+#define POKE16(A, VAL)				POKE_SHORT(A, VAL)
+#define POKE32(A, VAL)				POKE_LONG(A, VAL)
+#define OR32(A, VAL)				OR_LONG(A, VAL)
+#define UPDATE32(A, AND, OR)			UPDATE_LONG(A, AND, OR)
+#define POKE_UPDATE32(A1, A2, AND, SHIFT, OR)	POKE_UPDATE_LONG(A1, A2, AND, SHIFT, OR)
+#define WHILE_NE32(A, AND, VAL)			WHILE_NE(A, AND, VAL)
+#define DELAY(VAL)				/* do nothing */
+
+
+	.section .data.init, "a"
+
+	.balign 32
+
+__memory_setup_table:
+
+	/*
+	 * include the appropriate set of "GDB pokes", (usually) generated
+	 * using the "romgen" utility, from a known good target-pack.
+	 *
+	 * This file may be regenerated by connecting your specific board
+	 * to an STMC2 (note: currently it must be version 2) and then
+	 * executing the following command (redirecting the output):
+	 *
+	 * host% romgen --target-connect --show-comment <stmc2>:hdk7111:st40
+	 *
+	 * Where "<stmc2>" should be replaced with the IP address
+	 * (or the DNS name) of the STMC2 box.  Also the "hdk7111" should
+	 * substituted if you have a custom target-pack connect command.
+	 *
+	 * Note: The connect command used with "romgen", should connect
+	 * only in 29-bit mode - even if U-Boot will be built for 32-bit mode.
+	 * That is, do not use the "seuc=1" (or similar) option with "romgen".
+	 */
+#include "hdk7111.romgen"
+
+#ifdef CONFIG_SH_SE_MODE
+	/*
+	 * Note that we also manually need to move the LMI base addresses to
+	 * their 32-bit SE mode locations as defined in the datasheet and change the
+	 * 'upper bound addresses' (in row attribute registers) for the LMIs.
+	 */
+	UPDATE32(STX7111_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
+	/* Change LMI upper bound addresses
+	 * Upper LMI addr=0x40000000 + 256MiB=0x50000000
+	 */
+	UPDATE32(ST40_LMI_SDRA0_0(), 0x001FFFFF, (0x50000000 & 0xFFE00000))
+	UPDATE32(ST40_LMI_SDRA1_0(), 0x001FFFFF, (0x50000000 & 0xFFE00000))
+#endif	/* CONFIG_SH_SE_MODE */
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/st/hdk7111/nand.c b/board/st/hdk7111/nand.c
new file mode 100644
index 0000000000..39b28c8edb
--- /dev/null
+++ b/board/st/hdk7111/nand.c
@@ -0,0 +1,121 @@
+/*
+ * (C) Copyright 2006 DENX Software Engineering
+ * (C) Copyright 2008-2009 STMicroelectronics, Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <nand.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+#include <asm/stx7111reg.h>
+#include <asm/stm-nand.h>
+
+
+/*
+ * hardware specific access to control-lines for "bit-banging".
+ *	CL -> Emi_Addr(17)
+ *	AL -> Emi_Addr(18)
+ *	nCE is handled by EMI (not s/w controlable)
+ */
+#ifndef CFG_NAND_FLEX_MODE	/* for "bit-banging" (c.f. STM "flex-mode")  */
+static void hdk7111_hwcontrol(struct mtd_info *mtdinfo, int cmd)
+{
+	struct nand_chip* this = (struct nand_chip *)(mtdinfo->priv);
+
+	switch(cmd) {
+
+	case NAND_CTL_SETCLE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (1u << 17));
+		break;
+
+	case NAND_CTL_CLRCLE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(1u << 17));
+		break;
+
+	case NAND_CTL_SETALE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (1u << 18));
+		break;
+
+	case NAND_CTL_CLRALE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(1u << 18));
+		break;
+	}
+}
+#endif /* CFG_NAND_FLEX_MODE */
+
+
+/*
+ * hardware specific access to the Ready/not_Busy signal.
+ * Signal is routed through the EMI NAND Controller block.
+ */
+#ifndef CFG_NAND_FLEX_MODE	/* for "bit-banging" (c.f. STM "flex-mode")  */
+static int hdk7111_device_ready(struct mtd_info *mtd)
+{
+	/* extract bit 1: status of RBn pin on boot bank */
+	return ((*ST40_EMI_NAND_RBN_STA) & (1ul<<1)) ? 1 : 0;
+}
+#endif /* CFG_NAND_FLEX_MODE */
+
+
+/*
+ * Board-specific NAND initialization. The following members of the
+ * argument are board-specific (per include/linux/mtd/nand.h):
+ * - IO_ADDR_R?: address to read the 8 I/O lines of the flash device
+ * - IO_ADDR_W?: address to write the 8 I/O lines of the flash device
+ * - hwcontrol: hardware specific function for accessing control-lines
+ * - dev_ready: hardware specific function for accessing device ready/busy line
+ * - enable_hwecc?: function to enable (reset)  hardware ecc generator. Must
+ *   only be provided if a hardware ECC is available
+ * - eccmode: mode of ecc, see defines
+ * - chip_delay: chip dependent delay for transferring data from array to
+ *   read regs (tR)
+ * - options: various chip options. They can partly be set to inform
+ *   nand_scan about special functionality. See the defines for further
+ *   explanation
+ * Members with a "?" were not set in the merged testing-NAND branch,
+ * so they are not set here either.
+ */
+extern int board_nand_init(struct nand_chip *nand)
+{
+	nand->eccmode       = NAND_ECC_SOFT;
+	nand->options       = NAND_NO_AUTOINCR;
+
+#ifdef CFG_NAND_FLEX_MODE	/* for STM "flex-mode" (c.f. "bit-banging") */
+	nand->select_chip   = stm_flex_select_chip;
+	nand->dev_ready     = stm_flex_device_ready;
+	nand->hwcontrol     = stm_flex_hwcontrol;
+	nand->read_byte     = stm_flex_read_byte;
+	nand->write_byte    = stm_flex_write_byte;
+	nand->read_buf      = stm_flex_read_buf;
+	nand->write_buf     = stm_flex_write_buf;
+#else				/* for "bit-banging" (c.f. STM "flex-mode")  */
+	nand->dev_ready     = hdk7111_device_ready;
+	nand->hwcontrol     = hdk7111_hwcontrol;
+#endif /* CFG_NAND_FLEX_MODE */
+
+#if 1
+	/* Enable the following to use a Bad Block Table (BBT) */
+	nand->options      |= NAND_USE_FLASH_BBT;
+	nand->scan_bbt      = stm_nand_default_bbt;
+#endif
+
+	return 0;
+}
diff --git a/board/st/hms1/Makefile b/board/st/hms1/Makefile
new file mode 100644
index 0000000000..80745c0b7c
--- /dev/null
+++ b/board/st/hms1/Makefile
@@ -0,0 +1,52 @@
+#
+# (C) Copyright 2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+SOBJS	= init-$(BOARD).o
+
+COBJS	= $(BOARD).o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/st/hms1/config.mk b/board/st/hms1/config.mk
new file mode 100644
index 0000000000..aff8d30e65
--- /dev/null
+++ b/board/st/hms1/config.mk
@@ -0,0 +1,30 @@
+#
+# (C) Copyright 2005
+# Andy Sturges (andy.sturges@st.com)
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# HMS1 board
+#
+
+# Installs at SDRAM BASE  + 31M in cache region
+TEXT_BASE = 0x86F00000
+PLATFORM_LDFLAGS +=
diff --git a/board/st/hms1/hms1.c b/board/st/hms1/hms1.c
new file mode 100644
index 0000000000..82726d9e48
--- /dev/null
+++ b/board/st/hms1/hms1.c
@@ -0,0 +1,163 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/soc.h>
+#include <asm/stb7100reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+#if defined CFG_JFFS_CUSTOM_PART
+#include <jffs2/jffs2.h>
+#endif
+
+void stb7100_clocks(void);
+
+#define EPLD_ATAPI *(volatile unsigned char *)(0xa3900000)
+
+#define LED *(volatile unsigned char *)(0xa2000000 + 0x00100010)
+
+void flashWriteEnable(void)
+{
+}
+
+void flashWriteDisable(void)
+{
+}
+
+#define PIO_BASE  0xb8024000
+
+static void configPIO(void)
+{
+  SET_PIO_ASC(PIO_BASE, 3, 2, 4, 5);
+}
+
+#if defined(CONFIG_CMD_IDE)
+
+#ifdef CONFIG_SH_STB7100_IDE
+static void stb7100mboard_init_ide(void)
+{
+  EPLD_ATAPI = 1; /* Enable ATAPI mode of EMI */
+}
+#endif
+
+#endif
+
+int board_init(void)
+{
+	unsigned long sysconf;
+	/* Route UART2 instead of SCI to PIO4 */
+	/* Set ssc2_mux_sel = 0 */
+	sysconf = *STB7100_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<3);
+	*STB7100_SYSCONF_SYS_CFG07 = sysconf;
+
+	configPIO();
+
+#if defined(CONFIG_CMD_IDE)
+#ifdef CONFIG_SH_STB7100_IDE
+	stb7100mboard_init_ide();
+#endif
+#ifdef CONFIG_SH_STB7100_SATA
+	stb7100_sata_init();
+#endif
+#endif
+
+	return 0;
+}
+
+int checkboard (void)
+{
+	printf ("\n\nBoard: HMS1"
+#ifdef CONFIG_SH_SE_MODE
+		"  [32-bit mode]"
+#else
+		"  [29-bit mode]"
+#endif
+		"\n");
+
+	LED = 1;
+
+	return 0;
+}
+
+#if defined CFG_JFFS_CUSTOM_PART
+
+/*
+ * jffs2_part_info - get information about a JFFS2 partition
+ *
+ * @part_num: number of the partition you want to get info about
+ * @return:   struct part_info* in case of success, 0 if failure
+ *
+ * Reads env variable jff2part for partition info
+ *
+ */
+
+static struct part_info part;
+static int current_part = -1;
+
+struct part_info* jffs2_part_info(int part_num) {
+	void *jffs2_priv_saved = part.jffs2_priv;
+
+	printf("jffs2_part_info: part_num=%i\n",part_num);
+
+	if (current_part == part_num)
+		return &part;
+
+	/* u-boot partition                                                 */
+	if(part_num==0){
+		ulong offset, size=0;
+		char *f;
+
+		if ((f=getenv("jffs2part"))) {
+			char *p;
+			offset = simple_strtoul(f, &p, 16);
+			size   = simple_strtoul(p+1, NULL, 16);
+		}
+
+		if (size) {
+			memset(&part, 0, sizeof(part));
+
+			part.offset=offset;
+			part.size=size;
+
+			/* Mark the struct as ready */
+			current_part = part_num;
+
+			printf("part.offset = 0x%08x\n",(unsigned int)part.offset);
+			printf("part.size   = 0x%08x\n",(unsigned int)part.size);
+		}
+	}
+
+	if (current_part == part_num) {
+/*QQQ-HACK:	part.usr_priv = &current_part;	*/
+		part.jffs2_priv = jffs2_priv_saved;
+		return &part;
+	}
+
+	printf("jffs2_part_info: end of partition table\n");
+	return 0;
+}
+#endif
diff --git a/board/st/hms1/init-hms1.S b/board/st/hms1/init-hms1.S
new file mode 100644
index 0000000000..ee5a59de77
--- /dev/null
+++ b/board/st/hms1/init-hms1.S
@@ -0,0 +1,224 @@
+
+#include "asm/stb7100reg.h"
+#include "../../../cpu/sh/init_ram.S"
+
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *       opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+
+	.section .data.init, "a"
+
+	.balign 32
+
+__memory_setup_table:
+
+	/*
+	 * CLOCKGENA setup PLL0
+	 */
+
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0xc0de)
+	OR_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0x00100000)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff7ffff, 0)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x06 | (0x3b << 8) | (0x0 << 16))
+	OR_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0x00080000)
+	WHILE_NE(STB7100_CLOCKGENA_PLL0_STATUS, 0x00000001, 0x00000001)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xffefffff, 0)
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0x0)
+
+	/*
+	 * CLOCKGENA setup PLL1
+	 */
+
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0xc0de)
+	POKE_LONG(STB7100_CLOCKGENA_PLL1_BYPASS, 0x00000002)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff7ffff, 0)
+#if CONFIG_SH_STB7100_V1_1
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0x85 << 8) | (0x0 << 16))
+#else
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x09 | (0x80 << 8) | (0x1 << 16)) /* 384MHz */
+	IF_DEVID(STB7100_CUT3) /* 400MHz */
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0xc8 << 8) | (0x0 << 16))
+	ENDIF
+	IF_DEVID(STB7109_CUT2) /* 400MHz */
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0xc8 << 8) | (0x0 << 16))
+	ENDIF
+	IF_DEVID(STB7109_CUT3) /* 400MHz */
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0xc8 << 8) | (0x0 << 16))
+	ENDIF
+#endif
+	OR_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0x00080000)
+	WHILE_NE(STB7100_CLOCKGENA_PLL1_STATUS, 0x00000001, 0x00000001)
+	POKE_LONG(STB7100_CLOCKGENA_PLL1_BYPASS, 0x00000000)
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0x0)
+
+	/*
+	 * SYSCONF setup
+	 */
+	IF_DEVID(STB7109_CUT1)
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG11, 0x0807fec0)
+	ELSE
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG11, 0x0d7fd4ea)
+	  WHILE_NE(STB7100_SYSCONF_SYS_STA12, (1 << 9) | (1 << 19), (1 << 9) | (1 << 19))
+	ENDIF
+	WHILE_NE(STB7100_SYSCONF_SYS_STA13, (1 << 9) | (1 << 19), (1 << 9) | (1 << 19))
+
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG12, 0x4000000f | (0xf << 12) | (0xf << 23))
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG13, 0x4000000f | (0xf << 12) | (0xf << 23))
+
+#ifdef  CONFIG_SH_STB7100_V1_1
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG14, (1 << 18) | (0x5a << 20))
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG15, (1 << 19) | (0xa9 << 20))
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG20, (1 << 18) | (0x5a << 20))
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG21, (1 << 19) | (0xa9 << 20))
+#else
+	IF_DEVID(STB7100_CUT1)
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG14, (1 << 18) | (0x50 << 20))
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG15, (1 << 19) | (0x40 << 20))
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG20, (1 << 18) | (0x50 << 20))
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG21, (1 << 19) | (0x40 << 20))
+	ENDIF
+#endif
+	/*
+	 * LMI SYS setup
+	 */
+#ifdef CONFIG_SH_STB7100_V1_1
+	POKE_LONG(ST40_LMI_MIM_0(SYS), 0x061a0247)
+	POKE_LONG(ST40_LMI_MIM_1(SYS), 0x01010000)
+#else
+	/*POKE_LONG(ST40_LMI_MIM_0(SYS), 0x061a0247)*/
+	POKE_LONG(ST40_LMI_MIM_0(SYS), 0x861a0247)
+	POKE_LONG(ST40_LMI_MIM_1(SYS), 0x01010022)
+#endif
+	POKE_LONG(ST40_LMI_STR(SYS), 0x35b06455)
+
+#if CONFIG_SH_HMS1_128
+	POKE_LONG(ST40_LMI_SDRA0(SYS), 0x0c001a00)
+	POKE_LONG(ST40_LMI_SDRA1(SYS), 0x0c001a00)
+#else
+	POKE_LONG(ST40_LMI_SDRA0(SYS), 0x08001900)
+	POKE_LONG(ST40_LMI_SDRA1(SYS), 0x08001900)
+#endif
+
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000003)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000002)
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000402)
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000133)
+
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000002)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000033)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000000)
+
+#if CONFIG_SH_HMS1_128
+	POKE_LONG(SH4_CCN_CCR, 0x8000090d)
+#endif
+
+	/*
+	 * LMI VID setup
+	 */
+#ifdef CONFIG_SH_STB7100_V1_1
+	POKE_LONG(ST40_LMI_MIM_0(VID), 0x061a0247)
+	POKE_LONG(ST40_LMI_MIM_1(VID), 0x01010000)
+#else
+	/*POKE_LONG(ST40_LMI_MIM_0(VID), 0x061a0247)*/
+	POKE_LONG(ST40_LMI_MIM_0(VID), 0x861a0247)
+	POKE_LONG(ST40_LMI_MIM_1(VID), 0x01010022)
+#endif
+	POKE_LONG(ST40_LMI_STR(VID), 0x35b06455)
+	POKE_LONG(ST40_LMI_SDRA0(VID), 0x14001900)
+	POKE_LONG(ST40_LMI_SDRA1(VID), 0x14001900)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000003)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000002)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000402)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000133)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000002)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000033)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000000)
+
+	/*
+	 * EMI setup
+	 */
+	POKE_LONG(ST40_EMI_BANK_ENABLE, 0x00000005)
+	POKE_LONG(ST40_EMI_BANK0_BASEADDRESS, 0x00000000)
+	POKE_LONG(ST40_EMI_BANK1_BASEADDRESS, 0x00000004)
+	POKE_LONG(ST40_EMI_BANK2_BASEADDRESS, 0x00000008)
+	POKE_LONG(ST40_EMI_BANK3_BASEADDRESS, 0x0000000a)
+	POKE_LONG(ST40_EMI_BANK4_BASEADDRESS, 0x0000000c)
+	/* FLASH */
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA0, 0x001016d1)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
+	/* STEM Module */
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA0, 0x041086f1)
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA1, 0x93001111)
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA2, 0x91001111)
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA3, 0x00000000)
+#if 0
+	/* DVBCI */
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA0, 0x002046f9)
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA1, 0xa5a00000)
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA2, 0xa5a20000)
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA3, 0x00000000)
+#endif
+	/* ATAPI */
+#if defined(CONFIG_SH_STB7100_V1_1)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA0, 0x00021791)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA1, 0x08004141)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA2, 0x08004141)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA3, 0x00000000)
+#else
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA0, 0x00200791)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA1, 0x0c006700)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA2, 0x0c006700)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA3, 0x00000000)
+#endif
+
+#if 0
+	/* EPLD & LAN91C111 */
+
+	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA0, 0x042086f1)
+	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA1, 0x88112111)
+	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA2, 0x88112211)
+	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA3, 0x00000000)
+#endif
+
+	/* Program other EMI registers */
+	IF_DEVID(STB7100_CUT1)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
+	ENDIF
+	IF_DEVID(STB7100_CUT2)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000050)
+	ENDIF
+	IF_DEVID(STB7100_CUT3)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000050)
+	ENDIF
+	IF_DEVID(STB7109_CUT1)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
+	ENDIF
+	IF_DEVID(STB7109_CUT2)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
+	ENDIF
+	IF_DEVID(STB7109_CUT3)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
+	ENDIF
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/st/mb411/Makefile b/board/st/mb411/Makefile
new file mode 100644
index 0000000000..80745c0b7c
--- /dev/null
+++ b/board/st/mb411/Makefile
@@ -0,0 +1,52 @@
+#
+# (C) Copyright 2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+SOBJS	= init-$(BOARD).o
+
+COBJS	= $(BOARD).o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/st/mb411/config.mk b/board/st/mb411/config.mk
new file mode 100644
index 0000000000..5f44ec6ff0
--- /dev/null
+++ b/board/st/mb411/config.mk
@@ -0,0 +1,30 @@
+#
+# (C) Copyright 2005
+# Andy Sturges (andy.sturges@st.com)
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# MB411 (STb7100 Mboard) board
+#
+
+# Installs at SDRAM BASE  + 31M in cache region
+TEXT_BASE = 0x85F00000
+PLATFORM_LDFLAGS +=
diff --git a/board/st/mb411/init-mb411.S b/board/st/mb411/init-mb411.S
new file mode 100644
index 0000000000..52def4d4bd
--- /dev/null
+++ b/board/st/mb411/init-mb411.S
@@ -0,0 +1,209 @@
+
+#include "asm/stb7100reg.h"
+#include "../../../cpu/sh/init_ram.S"
+
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *       opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+
+	.section .data.init, "a"
+
+	.balign 32
+
+__memory_setup_table:
+
+	/*
+	 * CLOCKGENA setup PLL0
+	 */
+
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0xc0de)
+	OR_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0x00100000)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff7ffff, 0)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x06 | (0x3b << 8) | (0x0 << 16))
+	OR_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0x00080000)
+	WHILE_NE(STB7100_CLOCKGENA_PLL0_STATUS, 0x00000001, 0x00000001)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xffefffff, 0)
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0x0)
+
+	/*
+	 * CLOCKGENA setup PLL1
+	 */
+
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0xc0de)
+	POKE_LONG(STB7100_CLOCKGENA_PLL1_BYPASS, 0x00000002)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff7ffff, 0)
+#if CONFIG_SH_STB7100_V1_1
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0x85 << 8) | (0x0 << 16))
+#else
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x09 | (0x80 << 8) | (0x1 << 16)) /* 384MHz */
+	IF_DEVID(STB7100_CUT3) /* 400MHz */
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0xc8 << 8) | (0x0 << 16))
+	ENDIF
+	IF_DEVID(STB7109_CUT2) /* 400MHz */
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0xc8 << 8) | (0x0 << 16))
+	ENDIF
+	IF_DEVID(STB7109_CUT3) /* 400MHz */
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0xc8 << 8) | (0x0 << 16))
+	ENDIF
+#endif
+	OR_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0x00080000)
+	WHILE_NE(STB7100_CLOCKGENA_PLL1_STATUS, 0x00000001, 0x00000001)
+	POKE_LONG(STB7100_CLOCKGENA_PLL1_BYPASS, 0x00000000)
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0x0)
+
+	/*
+	 * SYSCONF setup
+	 */
+	IF_DEVID(STB7109_CUT1)
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG11, 0x0807fec0)
+	ELSE
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG11, 0x080780c0)
+	  WHILE_NE(STB7100_SYSCONF_SYS_STA12, (1 << 9) | (1 << 19), (1 << 9) | (1 << 19))
+	ENDIF
+	WHILE_NE(STB7100_SYSCONF_SYS_STA13, (1 << 9) | (1 << 19), (1 << 9) | (1 << 19))
+
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG12, 0x4000000f | (0xf << 12) | (0xf << 23))
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG13, 0x4000000f | (0xf << 12) | (0xf << 23))
+
+#ifdef  CONFIG_SH_STB7100_V1_1
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG14, (1 << 18) | (0x5a << 20))
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG15, (1 << 19) | (0xa9 << 20))
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG20, (1 << 18) | (0x5a << 20))
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG21, (1 << 19) | (0xa9 << 20))
+#else
+	IF_DEVID(STB7100_CUT1)
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG14, (1 << 18) | (0x50 << 20))
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG15, (1 << 19) | (0x40 << 20))
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG20, (1 << 18) | (0x50 << 20))
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG21, (1 << 19) | (0x40 << 20))
+	ENDIF
+#endif
+	/*
+	 * LMI SYS setup
+	 */
+#ifdef CONFIG_SH_STB7100_V1_1
+	POKE_LONG(ST40_LMI_MIM_0(SYS), 0x061a0247)
+	POKE_LONG(ST40_LMI_MIM_1(SYS), 0x01010000)
+#else
+	POKE_LONG(ST40_LMI_MIM_0(SYS), 0x061a0247)
+	POKE_LONG(ST40_LMI_MIM_1(SYS), 0x01010022)
+#endif
+	POKE_LONG(ST40_LMI_STR(SYS), 0x35b06455)
+
+	POKE_LONG(ST40_LMI_SDRA0(SYS), 0x08001900)
+	POKE_LONG(ST40_LMI_SDRA1(SYS), 0x08001900)
+
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000003)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000002)
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000402)
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000133)
+
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000002)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000033)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000000)
+
+	/*
+	 * LMI VID setup
+	 */
+#ifdef CONFIG_SH_STB7100_V1_1
+	POKE_LONG(ST40_LMI_MIM_0(VID), 0x061a0247)
+	POKE_LONG(ST40_LMI_MIM_1(VID), 0x01010000)
+#else
+	POKE_LONG(ST40_LMI_MIM_0(VID), 0x061a0247)
+	POKE_LONG(ST40_LMI_MIM_1(VID), 0x01010022)
+#endif
+	POKE_LONG(ST40_LMI_STR(VID), 0x35b06455)
+	POKE_LONG(ST40_LMI_SDRA0(VID), 0x14001900)
+	POKE_LONG(ST40_LMI_SDRA1(VID), 0x14001900)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000003)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000002)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000402)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000133)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000002)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000033)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000000)
+
+	/*
+	 * EMI setup
+	 */
+	POKE_LONG(ST40_EMI_BANK_ENABLE, 0x00000005)
+	POKE_LONG(ST40_EMI_BANK0_BASEADDRESS, 0x00000000)
+	POKE_LONG(ST40_EMI_BANK1_BASEADDRESS, 0x00000004)
+	POKE_LONG(ST40_EMI_BANK2_BASEADDRESS, 0x00000008)
+	POKE_LONG(ST40_EMI_BANK3_BASEADDRESS, 0x0000000a)
+	POKE_LONG(ST40_EMI_BANK4_BASEADDRESS, 0x0000000c)
+	/* FLASH */
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA0, 0x001016d1)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
+	/* STEM Module */
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA0, 0x041086f1)
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA1, 0x0e024400)
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA2, 0x0e024400)
+	POKE_LONG(ST40_EMI_BANK1_EMICONFIGDATA3, 0x00000000)
+	/* DVBCI */
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA0, 0x002046f9)
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA1, 0xa5a00000)
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA2, 0xa5a20000)
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA3, 0x00000000)
+	/* ATAPI */
+#if defined(CONFIG_SH_STB7100_V1_1)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA0, 0x00021791)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA1, 0x08004141)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA2, 0x08004141)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA3, 0x00000000)
+#else
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA0, 0x00021791)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA1, 0x0c006700)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA2, 0x0c006700)
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA3, 0x00000000)
+#endif
+
+	/* EPLD & LAN91C111 */
+
+	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA0, 0x042086f1)
+	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA1, 0x88112111)
+	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA2, 0x88112211)
+	POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA3, 0x00000000)
+
+	/* Program other EMI registers */
+	IF_DEVID(STB7100_CUT1)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
+	ENDIF
+	IF_DEVID(STB7100_CUT2)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000050)
+	ENDIF
+	IF_DEVID(STB7100_CUT3)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000050)
+	ENDIF
+	IF_DEVID(STB7109_CUT1)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
+	ENDIF
+	IF_DEVID(STB7109_CUT2)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
+	ENDIF
+	IF_DEVID(STB7109_CUT3)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
+	ENDIF
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/st/mb411/mb411.c b/board/st/mb411/mb411.c
new file mode 100644
index 0000000000..0038b2d68d
--- /dev/null
+++ b/board/st/mb411/mb411.c
@@ -0,0 +1,171 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/soc.h>
+#include <asm/stb7100reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+#if defined CFG_JFFS_CUSTOM_PART
+#include <jffs2/jffs2.h>
+#endif
+
+void stb7100_clocks(void);
+
+#define EPLD_FLASH *(volatile unsigned char *)(0xa3400000)
+#define EPLD_ATAPI *(volatile unsigned char *)(0xa3900000)
+
+#define LED *(volatile unsigned char *)(0xa2000000 + 0x00100010)
+
+void flashWriteEnable(void)
+{
+  /*  Enable vpp for writing to flash */
+  EPLD_FLASH = 3;	/* bits: 0 = VPP ON; 1 = RESET	*/
+}
+
+void flashWriteDisable(void)
+{
+  /*  Disable vpp for writing to flash */
+  EPLD_FLASH = 2;	/* bits: 0 = VPP ON; 1 = RESET	*/
+}
+
+#define PIO_BASE  0xb8020000
+
+static void configPIO(void)
+{
+  /*  Setup PIO of ASC device */
+  SET_PIO_ASC(PIO_PORT(4), 3, 2, 4, 5);  /* UART2 - AS0 */
+  SET_PIO_ASC(PIO_PORT(5), 0, 1, 2, 3);  /* UART3 - AS1 */
+}
+
+#if defined(CONFIG_CMD_IDE)
+
+#ifdef CONFIG_SH_STB7100_IDE
+static void stb7100mboard_init_ide(void)
+{
+  EPLD_ATAPI = 1; /* Enable ATAPI mode of EMI */
+}
+#endif
+
+#endif
+
+int board_init(void)
+{
+	unsigned long sysconf;
+	/* Route UART2 instead of SCI to PIO4 */
+	/* Set ssc2_mux_sel = 0 */
+	sysconf = *STB7100_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<3);
+	*STB7100_SYSCONF_SYS_CFG07 = sysconf;
+
+	configPIO();
+
+#if defined(CONFIG_CMD_IDE)
+#ifdef CONFIG_SH_STB7100_IDE
+	stb7100mboard_init_ide();
+#endif
+#ifdef CONFIG_SH_STB7100_SATA
+	stb7100_sata_init();
+#endif
+#endif
+
+	return 0;
+}
+
+int checkboard (void)
+{
+	printf ("\n\nBoard: STb7100-Mboard (MB411)"
+#ifdef CONFIG_SH_SE_MODE
+		"  [32-bit mode]"
+#else
+		"  [29-bit mode]"
+#endif
+		"\n");
+
+	LED = 1;
+
+	return 0;
+}
+
+
+#if defined CFG_JFFS_CUSTOM_PART
+
+/*
+ * jffs2_part_info - get information about a JFFS2 partition
+ *
+ * @part_num: number of the partition you want to get info about
+ * @return:   struct part_info* in case of success, 0 if failure
+ *
+ * Reads env variable jff2part for partition info
+ *
+ */
+
+static struct part_info part;
+static int current_part = -1;
+
+struct part_info* jffs2_part_info(int part_num) {
+	void *jffs2_priv_saved = part.jffs2_priv;
+
+	printf("jffs2_part_info: part_num=%i\n",part_num);
+
+	if (current_part == part_num)
+		return &part;
+
+	/* u-boot partition                                                 */
+	if(part_num==0){
+		ulong offset, size=0;
+		char *f;
+
+		if ((f=getenv("jffs2part"))) {
+			char *p;
+			offset = simple_strtoul(f, &p, 16);
+			size   = simple_strtoul(p+1, NULL, 16);
+		}
+
+		if (size) {
+			memset(&part, 0, sizeof(part));
+
+			part.offset=offset;
+			part.size=size;
+
+			/* Mark the struct as ready */
+			current_part = part_num;
+
+			printf("part.offset = 0x%08x\n",(unsigned int)part.offset);
+			printf("part.size   = 0x%08x\n",(unsigned int)part.size);
+		}
+	}
+
+	if (current_part == part_num) {
+/*QQQ-HACK:	part.usr_priv = &current_part;	*/
+		part.jffs2_priv = jffs2_priv_saved;
+		return &part;
+	}
+
+	printf("jffs2_part_info: end of partition table\n");
+	return 0;
+}
+#endif
diff --git a/board/st/mb442/Makefile b/board/st/mb442/Makefile
new file mode 100644
index 0000000000..80745c0b7c
--- /dev/null
+++ b/board/st/mb442/Makefile
@@ -0,0 +1,52 @@
+#
+# (C) Copyright 2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+SOBJS	= init-$(BOARD).o
+
+COBJS	= $(BOARD).o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/st/mb442/config.mk b/board/st/mb442/config.mk
new file mode 100644
index 0000000000..4e73ed4245
--- /dev/null
+++ b/board/st/mb442/config.mk
@@ -0,0 +1,43 @@
+#
+# (C) Copyright 2005
+# Andy Sturges (andy.sturges@st.com)
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# MB442 (STb7100REF or Coco) board
+#
+#	Valid values for TEXT_BASE are:
+#
+#	0x87F00000	29-bit mode (Traditional Mode)
+#	0x83F00000	32-bit mode (Space-Enhancement Mode)
+#
+# Note:	Alternative definitions of TEXT_BASE are put into
+#	'config.tmp' from the top-level 'Makefile'.
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+# Installs at SDRAM BASE  + 63M in P1 (cachable)
+TEXT_BASE = 0x87F00000
+endif
+
+PLATFORM_LDFLAGS +=
diff --git a/board/st/mb442/init-mb442.S b/board/st/mb442/init-mb442.S
new file mode 100644
index 0000000000..d8403ae143
--- /dev/null
+++ b/board/st/mb442/init-mb442.S
@@ -0,0 +1,230 @@
+
+#include "asm/stb7100reg.h"
+#include "../../../cpu/sh/init_ram.S"
+
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *       opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+
+	.section .data.init, "a"
+
+	.balign 32
+
+__memory_setup_table:
+
+	/*
+	 * CLOCKGENA setup PLL0
+	 */
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0xc0de)
+	OR_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0x00100000)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff7ffff, 0)
+#if (INPUT_CLOCK_RATE == 30)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x14 | (0xb1 << 8) | (0x0 << 16))
+#else
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x06 | (0x3b << 8) | (0x0 << 16))
+#endif
+	OR_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0x00080000)
+	WHILE_NE(STB7100_CLOCKGENA_PLL0_STATUS, 0x00000001, 0x00000001)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xffefffff, 0)
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0x0)
+	/*
+	 * CLOCKGENA setup PLL1
+	 */
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0xc0de)
+	POKE_LONG(STB7100_CLOCKGENA_PLL1_BYPASS, 0x00000002)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff7ffff, 0)
+	IF_DEVID(STB7100_CUT1) /* 266 MHz */
+#if (INPUT_CLOCK_RATE == 30)
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1e | (0x85 << 8) | (0x0 << 16))
+#else
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0x85 << 8) | (0x0 << 16))
+#endif
+	ELSE
+#if (INPUT_CLOCK_RATE == 30)   /* 384 MHz */
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x0a | (0x80 << 8) | (0x1 << 16))
+#else
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x09 | (0x80 << 8) | (0x1 << 16))
+#endif
+	ENDIF
+	IF_DEVID(STB7100_CUT3) /* 400MHz */
+#if (INPUT_CLOCK_RATE == 30)
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1e | (0xc8 << 8) | (0x0 << 16))
+#else
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0xc8 << 8) | (0x0 << 16))
+#endif
+	ENDIF
+	IF_DEVID(STB7109_CUT2) /* 400MHz */
+#if (INPUT_CLOCK_RATE == 30)
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1e | (0xc8 << 8) | (0x0 << 16))
+#else
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0xc8 << 8) | (0x0 << 16))
+#endif
+	ENDIF
+	IF_DEVID(STB7109_CUT3) /* 400MHz */
+#if (INPUT_CLOCK_RATE == 30)
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1e | (0xc8 << 8) | (0x0 << 16))
+#else
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0xc8 << 8) | (0x0 << 16))
+#endif
+	ENDIF
+	OR_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0x00080000)
+	WHILE_NE(STB7100_CLOCKGENA_PLL1_STATUS, 0x00000001, 0x00000001)
+	POKE_LONG(STB7100_CLOCKGENA_PLL1_BYPASS, 0x00000000)
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0x0)
+	/*
+	 * SYSCONF setup
+	 */
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG11, 0x0d7fd4ea)
+
+	WHILE_NE(STB7100_SYSCONF_SYS_STA12, (1 << 9) | (1 << 19), (1 << 9) | (1 << 19))
+	WHILE_NE(STB7100_SYSCONF_SYS_STA13, (1 << 9) | (1 << 19), (1 << 9) | (1 << 19))
+
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG12, 0x4000000f | (0xf << 12) | (0xf << 23))
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG13, 0x4000000f | (0xf << 12) | (0xf << 23))
+
+	IF_DEVID(STB7100_CUT1)
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG14, (1 << 18) | (0x5a << 20))
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG15, (1 << 19) | (0xa9 << 20))
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG20, (1 << 18) | (0x5a << 20))
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG21, (1 << 19) | (0xa9 << 20))
+	ENDIF
+
+	/*
+	 * LMI SYS setup
+	 */
+	POKE_LONG(ST40_LMI_MIM_0(SYS), 0x861a025f)
+	POKE_LONG(ST40_LMI_MIM_1(SYS), 0x01010022)
+
+	POKE_LONG(ST40_LMI_STR(SYS), 0x35b06455)
+
+#if CONFIG_SH_MB442_128
+	POKE_LONG(ST40_LMI_SDRA0(SYS), 0x0c001a00)
+	POKE_LONG(ST40_LMI_SDRA1(SYS), 0x0c001a00)
+#else
+	POKE_LONG(ST40_LMI_SDRA0(SYS), 0x08001900)
+	POKE_LONG(ST40_LMI_SDRA1(SYS), 0x08001900)
+#endif
+
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000003)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000002)
+
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000402)
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000133)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000002)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000033)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000000)
+
+	/*
+	 * LMI VID setup
+	 */
+	POKE_LONG(ST40_LMI_MIM_0(VID), 0x861a025f)
+	POKE_LONG(ST40_LMI_MIM_1(VID), 0x01010022)
+
+	POKE_LONG(ST40_LMI_STR(VID), 0x35b06455)
+	POKE_LONG(ST40_LMI_SDRA0(VID), 0x14001900)
+	POKE_LONG(ST40_LMI_SDRA1(VID), 0x14001900)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000003)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000002)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000402)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000133)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000002)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000033)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000000)
+
+#if CONFIG_SH_MB442_128
+       POKE_LONG(SH4_CCN_CCR, 0x8000090d)
+#endif
+
+	/*
+	 * EMI setup
+	 */
+	POKE_LONG(ST40_EMI_BANK_ENABLE, 0x00000005)
+
+	POKE_LONG(ST40_EMI_BANK0_BASEADDRESS, 0x00000000)
+	POKE_LONG(ST40_EMI_BANK1_BASEADDRESS, 0x00000004)
+	POKE_LONG(ST40_EMI_BANK2_BASEADDRESS, 0x00000008)
+	POKE_LONG(ST40_EMI_BANK3_BASEADDRESS, 0x0000000a)
+	POKE_LONG(ST40_EMI_BANK4_BASEADDRESS, 0x0000000c)
+	/* FLASH */
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA0, 0x001016d1)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
+	/* EPLD & LAN91C111 */
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA0, 0x042086f1)
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA1, 0x88112111)
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA2, 0x88112211)
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA3, 0x00000000)
+	/* ATAPI */
+
+	IF_DEVID(STB7100_CUT1)
+	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA0, 0x00021791)
+	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA1, 0x08004141)
+	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA2, 0x08004141)
+	ELSE
+	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA0, 0x00200791)
+	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA1, 0x0c006700)
+	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA2, 0x0c006700)
+	ENDIF
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA3, 0x00000000)
+
+	/* Program other EMI registers */
+
+	/* Program other EMI registers */
+	IF_DEVID(STB7100_CUT1)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
+	ENDIF
+	IF_DEVID(STB7100_CUT2)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000050)
+	ENDIF
+	IF_DEVID(STB7100_CUT3)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000050)
+	ENDIF
+	IF_DEVID(STB7109_CUT1)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
+	ENDIF
+	IF_DEVID(STB7109_CUT2)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
+	ENDIF
+	IF_DEVID(STB7109_CUT3)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
+	ENDIF
+
+#ifdef CONFIG_SH_SE_MODE
+  /*
+   * Note that we also manually need to move the System and Video LMI base
+   * addresses to their 32-bit SE mode locations as defined in the datasheet.
+   */
+        UPDATE_LONG(STB7100_SYSCONF_SYS_CFG36, 0xFF00FF00, 0x00600040)
+#ifdef CONFIG_SH_MB442_128
+        POKE_LONG(ST40_LMI_SDRA0_0(SYS), 0x48001a00)
+        POKE_LONG(ST40_LMI_SDRA1_0(SYS), 0x48001a00)
+#else
+        POKE_LONG(ST40_LMI_SDRA0_0(SYS), 0x44001900)
+        POKE_LONG(ST40_LMI_SDRA1_0(SYS), 0x44001900)
+#endif
+        POKE_LONG(ST40_LMI_SDRA0_0(VID), 0x64001900)
+        POKE_LONG(ST40_LMI_SDRA1_0(VID), 0x64001900)
+
+#endif	/* CONFIG_SH_SE_MODE */
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/st/mb442/mb442.c b/board/st/mb442/mb442.c
new file mode 100644
index 0000000000..ee5ea3a284
--- /dev/null
+++ b/board/st/mb442/mb442.c
@@ -0,0 +1,127 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/soc.h>
+#include <asm/stb7100reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+void stb7100_clocks(void);
+
+void flashWriteEnable(void)
+{
+  /* Enable Vpp for writing to flash */
+  /* QQQ - to do */
+}
+
+void flashWriteDisable(void)
+{
+  /* Disable Vpp for writing to flash */
+  /* QQQ - to do */
+}
+
+#define PIO_BASE  0xb8020000	/* Phys 0x18020000 */
+
+static void configPIO(void)
+{
+  /*  Setup PIO of ASC device */
+  SET_PIO_ASC(PIO_PORT(4), 3, 2, 4, 5);  /* UART2 - AS0 */
+  SET_PIO_ASC(PIO_PORT(5), 0, 1, 2, 3);  /* UART3 - AS1 */
+
+  /*  Setup up ethernet reset */
+#ifdef CONFIG_DRIVER_SMC91111
+  SET_PIO_PIN(PIO_PORT(2), 6, STPIO_OUT);
+#endif
+#ifdef CONFIG_DRIVER_NETSTMAC
+  SET_PIO_PIN(PIO_PORT(2), 4, STPIO_OUT);
+#endif
+}
+
+#if defined(CONFIG_CMD_IDE)
+
+#ifdef CONFIG_SH_STB7100_IDE
+static void stb7100ref_init_ide(void)
+{
+  /* Enable ATAPI mode of EMI */
+  /* QQQ - to do */
+}
+#endif
+
+#endif
+
+int board_init(void)
+{
+	unsigned long sysconf;
+	/* Route UART2 instead of SCI to PIO4 */
+	/* Set ssc2_mux_sel = 0 */
+	sysconf = *STB7100_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<3);
+	*STB7100_SYSCONF_SYS_CFG07 = sysconf;
+
+	configPIO();
+
+#ifdef CONFIG_DRIVER_SMC91111
+	/*  Reset ethernet chip */
+	STPIO_SET_PIN(PIO_PORT(2), 6, 0);
+	udelay(1000);
+	STPIO_SET_PIN(PIO_PORT(2), 6, 1);
+	udelay(1000);
+	STPIO_SET_PIN(PIO_PORT(2), 6, 0);
+#endif
+
+#ifdef CONFIG_DRIVER_NETSTMAC
+	/*  Reset ethernet chip */
+	STPIO_SET_PIN(PIO_PORT(2), 4, 1);
+	udelay(1000);
+	STPIO_SET_PIN(PIO_PORT(2), 4, 0);
+	udelay(2000);
+	STPIO_SET_PIN(PIO_PORT(2), 4, 1);
+#endif
+
+#if defined(CONFIG_CMD_IDE)
+#ifdef CONFIG_SH_STB7100_IDE
+	stb7100ref_init_ide();
+#endif
+#ifdef CONFIG_SH_STB7100_SATA
+	stb7100_sata_init();
+#endif
+#endif
+
+	return 0;
+}
+
+int checkboard (void)
+{
+	printf ("\n\nBoard: STb7100-Reference (MB442)"
+#ifdef CONFIG_SH_SE_MODE
+		"  [32-bit mode]"
+#else
+		"  [29-bit mode]"
+#endif
+		"\n");
+
+	return 0;
+}
diff --git a/board/st/mb448/Makefile b/board/st/mb448/Makefile
new file mode 100644
index 0000000000..80745c0b7c
--- /dev/null
+++ b/board/st/mb448/Makefile
@@ -0,0 +1,52 @@
+#
+# (C) Copyright 2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+SOBJS	= init-$(BOARD).o
+
+COBJS	= $(BOARD).o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/st/mb448/config.mk b/board/st/mb448/config.mk
new file mode 100644
index 0000000000..9db40e36fa
--- /dev/null
+++ b/board/st/mb448/config.mk
@@ -0,0 +1,30 @@
+#
+# (C) Copyright 2005
+# Andy Sturges (andy.sturges@st.com)
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# MB448 (STb7109EREF) board
+#
+
+# Installs at SDRAM BASE  + 31M in cache region
+TEXT_BASE = 0x85F00000
+PLATFORM_LDFLAGS +=
diff --git a/board/st/mb448/init-mb448.S b/board/st/mb448/init-mb448.S
new file mode 100644
index 0000000000..3b56fdec71
--- /dev/null
+++ b/board/st/mb448/init-mb448.S
@@ -0,0 +1,168 @@
+
+#include "asm/stb7100reg.h"
+#include "../../../cpu/sh/init_ram.S"
+
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *       opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+
+	.section .data.init, "a"
+
+	.balign 32
+
+__memory_setup_table:
+
+	/*
+	 * CLOCKGENA setup PLL0
+	 */
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0xc0de)
+	OR_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0x00100000)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff7ffff, 0)
+#if (INPUT_CLOCK_RATE == 30)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x14 | (0xb1 << 8) | (0x0 << 16))
+#else
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x06 | (0x3b << 8) | (0x0 << 16))
+#endif
+	OR_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0x00080000)
+	WHILE_NE(STB7100_CLOCKGENA_PLL0_STATUS, 0x00000001, 0x00000001)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL0_CFG, 0xffefffff, 0)
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0x0)
+	/*
+	 * CLOCKGENA setup PLL1
+	 */
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0xc0de)
+	POKE_LONG(STB7100_CLOCKGENA_PLL1_BYPASS, 0x00000002)
+	UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff7ffff, 0)
+	IF_DEVID(STB7100_CUT2)
+#if (INPUT_CLOCK_RATE == 30)
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x0a | (0x80 << 8) | (0x1 << 16))
+#else
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x09 | (0x80 << 8) | (0x1 << 16))
+#endif
+	ENDIF
+	IF_DEVID(STB7100_CUT1)
+#if (INPUT_CLOCK_RATE == 30)
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1e | (0x85 << 8) | (0x0 << 16))
+#else
+	  UPDATE_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x1b | (0x85 << 8) | (0x0 << 16))
+#endif
+	ENDIF
+	OR_LONG(STB7100_CLOCKGENA_PLL1_CFG, 0x00080000)
+	WHILE_NE(STB7100_CLOCKGENA_PLL1_STATUS, 0x00000001, 0x00000001)
+	POKE_LONG(STB7100_CLOCKGENA_PLL1_BYPASS, 0x00000000)
+	POKE_LONG(STB7100_CLOCKGENA_LOCK, 0x0)
+	/*
+	 * SYSCONF setup
+	 */
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG11, 0x080780c0)
+
+	WHILE_NE(STB7100_SYSCONF_SYS_STA12, (1 << 9) | (1 << 19), (1 << 9) | (1 << 19))
+	WHILE_NE(STB7100_SYSCONF_SYS_STA13, (1 << 9) | (1 << 19), (1 << 9) | (1 << 19))
+
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG12, 0x4000000f | (0xf << 12) | (0xf << 23))
+	POKE_LONG(STB7100_SYSCONF_SYS_CFG13, 0x4000000f | (0xf << 12) | (0xf << 23))
+
+	IF_DEVID(STB7100_CUT1)
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG14, (1 << 18) | (0x5a << 20))
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG15, (1 << 19) | (0xa9 << 20))
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG20, (1 << 18) | (0x5a << 20))
+	  POKE_LONG(STB7100_SYSCONF_SYS_CFG21, (1 << 19) | (0xa9 << 20))
+	ENDIF
+
+	/*
+	 * LMI SYS setup
+	 */
+	POKE_LONG(ST40_LMI_MIM_0(SYS), 0x061a0247)
+	POKE_LONG(ST40_LMI_MIM_1(SYS), 0x01010022)
+
+	POKE_LONG(ST40_LMI_STR(SYS), 0x35b06455)
+
+	POKE_LONG(ST40_LMI_SDRA0(SYS), 0x08001900)
+	POKE_LONG(ST40_LMI_SDRA1(SYS), 0x08001900)
+
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000003)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000002)
+
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000400)
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000133)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000002)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000004)
+	POKE_LONG(ST40_LMI_SDMR0(SYS), 0x00000033)
+	POKE_LONG(ST40_LMI_SCR(SYS), 0x00000000)
+
+	/*
+	 * LMI VID setup
+	 */
+	POKE_LONG(ST40_LMI_MIM_0(VID), 0x061a0247)
+	POKE_LONG(ST40_LMI_MIM_1(VID), 0x01010022)
+
+	POKE_LONG(ST40_LMI_STR(VID), 0x35b06455)
+	POKE_LONG(ST40_LMI_SDRA0(VID), 0x14001900)
+	POKE_LONG(ST40_LMI_SDRA1(VID), 0x14001900)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000003)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000001)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000002)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000402)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000133)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000002)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000004)
+	POKE_LONG(ST40_LMI_SDMR0(VID), 0x00000033)
+	POKE_LONG(ST40_LMI_SCR(VID), 0x00000000)
+	/*
+	 * EMI setup
+	 */
+	POKE_LONG(ST40_EMI_BANK_ENABLE, 0x00000005)
+
+	POKE_LONG(ST40_EMI_BANK0_BASEADDRESS, 0x00000000)
+	POKE_LONG(ST40_EMI_BANK1_BASEADDRESS, 0x00000004)
+	POKE_LONG(ST40_EMI_BANK2_BASEADDRESS, 0x00000008)
+	POKE_LONG(ST40_EMI_BANK3_BASEADDRESS, 0x0000000a)
+	POKE_LONG(ST40_EMI_BANK4_BASEADDRESS, 0x0000000c)
+	/* FLASH */
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA0, 0x001016d1)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
+	POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
+	/* EPLD & LAN91C111 */
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA0, 0x042086f1)
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA1, 0x88112111)
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA2, 0x88112211)
+	POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA3, 0x00000000)
+	/* ATAPI */
+
+	IF_DEVID(STB7100_CUT1)
+	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA0, 0x00021791)
+	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA1, 0x08004141)
+	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA2, 0x08004141)
+	ENDIF
+	IF_DEVID(STB7100_CUT2)
+	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA0, 0x00200791)
+	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA1, 0x0c006700)
+	  POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA2, 0x0c006700)
+	ENDIF
+	POKE_LONG(ST40_EMI_BANK3_EMICONFIGDATA3, 0x00000000)
+
+	/* Program other EMI registers */
+	IF_DEVID(STB7100_CUT1)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000010)
+	ENDIF
+	IF_DEVID(STB7100_CUT2)
+	  POKE_LONG(ST40_EMI_GENCFG, 0x00000050)
+	ENDIF
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/st/mb448/mb448.c b/board/st/mb448/mb448.c
new file mode 100644
index 0000000000..01628014b5
--- /dev/null
+++ b/board/st/mb448/mb448.c
@@ -0,0 +1,118 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/soc.h>
+#include <asm/stb7100reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+void stb7100_clocks(void);
+
+#define EPLD_FLASH *(volatile unsigned char *)(0xa3400000)
+#define EPLD_ATAPI *(volatile unsigned char *)(0xa3900000)
+
+#define LED *(volatile unsigned char *)(0xa2000000 + 0x00100010)
+
+void flashWriteEnable(void)
+{
+  /*  Enable vpp for writing to flash */
+  EPLD_FLASH = 3;	/* bits: 0 = VPP ON; 1 = RESET	*/
+}
+
+void flashWriteDisable(void)
+{
+  /*  Disable vpp for writing to flash */
+  EPLD_FLASH = 2;	/* bits: 0 = VPP ON; 1 = RESET	*/
+}
+
+#define PIO_BASE  0xb8020000
+#define PIO2_BASE  0xb8024000
+
+static void configPIO(void)
+{
+  /*  Setup PIO of ASC device */
+  SET_PIO_ASC(PIO_PORT(4), 3, 2, 4, 5);
+  /*  Setup up ethernet reset */
+  SET_PIO_PIN(PIO_PORT(2), 6, STPIO_OUT);
+}
+
+#if defined(CONFIG_CMD_IDE)
+
+#ifdef CONFIG_SH_STB7100_IDE
+static void stb7100ref_init_ide(void)
+{
+  EPLD_ATAPI = 1; /* Enable ATAPI mode of EMI */
+}
+#endif
+
+#endif
+
+int board_init(void)
+{
+	unsigned long sysconf;
+	/* Route UART2 instead of SCI to PIO4 */
+	/* Set ssc2_mux_sel = 0 */
+	sysconf = *STB7100_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<3);
+	*STB7100_SYSCONF_SYS_CFG07 = sysconf;
+
+	configPIO();
+
+#ifdef CONFIG_DRIVER_SMC91111
+	/*  Reset ethernet chip */
+	STPIO_SET_PIN(PIO_PORT(2), 6, 0);
+	udelay(1000);
+	STPIO_SET_PIN(PIO_PORT(2), 6, 1);
+	udelay(1000);
+	STPIO_SET_PIN(PIO_PORT(2), 6, 0);
+#endif
+
+#if defined(CONFIG_CMD_IDE)
+#ifdef CONFIG_SH_STB7100_IDE
+	stb7100ref_init_ide();
+#endif
+#ifdef CONFIG_SH_STB7100_SATA
+	stb7100_sata_init();
+#endif
+#endif
+
+	return 0;
+}
+
+int checkboard (void)
+{
+	printf ("\n\nBoard: STb7109E-Reference (MB448)"
+#ifdef CONFIG_SH_SE_MODE
+		"  [32-bit mode]"
+#else
+		"  [29-bit mode]"
+#endif
+		"\n");
+
+	LED = 1;
+
+	return 0;
+}
diff --git a/board/st/mb519/Makefile b/board/st/mb519/Makefile
new file mode 100644
index 0000000000..c99b16c9c9
--- /dev/null
+++ b/board/st/mb519/Makefile
@@ -0,0 +1,52 @@
+#
+# (C) Copyright 2007 STMicroelectronics.
+# Stuart Menefy <stuart.menefy@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+SOBJS	= init-$(BOARD).o
+
+COBJS	= $(BOARD).o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/st/mb519/config.mk b/board/st/mb519/config.mk
new file mode 100644
index 0000000000..cf00d781b5
--- /dev/null
+++ b/board/st/mb519/config.mk
@@ -0,0 +1,43 @@
+#
+# (C) Copyright 2007 STMicroelectronics.
+# Stuart Menefy <stuart.menefy@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# MB519 board:
+#
+#	Valid values for TEXT_BASE are:
+#
+#	0x8FF00000	29-bit mode (Traditional Mode)
+#	0x87F00000	32-bit mode (Space-Enhancement Mode)
+#
+# Note:	Alternative definitions of TEXT_BASE are put into
+#	'config.tmp' from the top-level 'Makefile'.
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+# Installs at LMI0 BASE + 127MB in P1 (cachable)
+TEXT_BASE = 0x8FF00000
+endif
+
+PLATFORM_LDFLAGS +=
diff --git a/board/st/mb519/init-mb519.S b/board/st/mb519/init-mb519.S
new file mode 100644
index 0000000000..5ca2c28da0
--- /dev/null
+++ b/board/st/mb519/init-mb519.S
@@ -0,0 +1,376 @@
+
+#include "asm/stx7200reg.h"
+#include "../../../cpu/sh/init_ram.S"
+
+/*
+ * This is derived from STMicroelectronics gnu toolchain example:
+ *   sh-superh-elf/examples/os21/romdynamic/memory_mb519.S
+ */
+
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *       opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+
+	.section .data.init, "a"
+
+	.balign 32
+
+__memory_setup_table:
+
+  /* ----- STx7200 Clocks ----- */
+
+  /* Set CLOCKGENA PLL0 into BYPASS... */
+  OR_LONG(STX7200_CLOCKGENA_PLL0_CFG, 0x00100000)
+
+  /* Power down CLOCKGENA PLL0... */
+  OR_LONG(STX7200_CLOCKGENA_POWER_CFG, 0x00000001)
+
+  /* Configure CLOCKGENA PLL0... */
+  UPDATE_LONG(STX7200_CLOCKGENA_PLL0_CFG, 0xfff80000, 0x03 | (0x23 << 8) | (0x00 << 16))
+
+  /* Enable CLOCKGENA PLL0... */
+  UPDATE_LONG(STX7200_CLOCKGENA_POWER_CFG, 0xfffffffe, 0)
+
+  /* Wait for CLOCKGENA PLL0 to lock... */
+  WHILE_NE(STX7200_CLOCKGENA_PLL0_CFG, 0x80000000, 0x80000000)
+
+  /* Clear CLOCKGENA PLL0 from BYPASS... */
+  UPDATE_LONG(STX7200_CLOCKGENA_PLL0_CFG, 0xffefffff, 0)
+
+  /* Set CLOCKGENA PLL1 into BYPASS... */
+  OR_LONG(STX7200_CLOCKGENA_PLL1_CFG, 0x00100000)
+
+  /* Power down CLOCKGENA PLL1... */
+  OR_LONG(STX7200_CLOCKGENA_POWER_CFG, 0x00000002)
+
+  /* Configure CLOCKGENA PLL1... */
+  UPDATE_LONG(STX7200_CLOCKGENA_PLL1_CFG, 0xfff80000, 0x01 | (0x0f << 8))
+
+  /* Enable CLOCKGENA PLL1... */
+  UPDATE_LONG(STX7200_CLOCKGENA_POWER_CFG, 0xfffffffd, 0)
+
+  /* Wait for CLOCKGENA PLL1 to lock... */
+  WHILE_NE(STX7200_CLOCKGENA_PLL1_CFG, 0x80000000,  0x80000000)
+
+  /* Clear CLOCKGENA PLL1 from BYPASS... */
+  UPDATE_LONG(STX7200_CLOCKGENA_PLL1_CFG, 0xffefffff, 0)
+
+  /* Set CLOCKGENA PLL2 into BYPASS... */
+  OR_LONG(STX7200_CLOCKGENA_PLL2_CFG, 0x00100000)
+
+  /* Power down CLOCKGENA PLL2... */
+  OR_LONG(STX7200_CLOCKGENA_POWER_CFG, 0x00000004)
+
+  /* Configure CLOCKGENA PLL2... */
+  UPDATE_LONG(STX7200_CLOCKGENA_PLL2_CFG, 0xfff80000, 0x03 | (0x28 << 8) | (0x00 << 16))
+
+  /* Enable CLOCKGENA PLL2... */
+  UPDATE_LONG(STX7200_CLOCKGENA_POWER_CFG, 0xfffffffb, 0)
+
+  /* Wait for CLOCKGENA PLL2 to lock... */
+  WHILE_NE(STX7200_CLOCKGENA_PLL2_CFG, 0x80000000,  0x80000000)
+
+  /* Clear CLOCKGENA PLL2 from BYPASS... */
+  UPDATE_LONG(STX7200_CLOCKGENA_PLL2_CFG, 0xffefffff, 0)
+
+  /* Set CLOCKGENB PLL0 into BYPASS... */
+  OR_LONG(STX7200_CLOCKGENB_PLL0_CFG, 0x00100000)
+
+  /* Power down CLOCKGENB PLL0... */
+  OR_LONG(STX7200_CLOCKGENB_POWER_CFG, 0x00008000)
+
+  /* Configure CLOCKGENB PLL0... */
+  UPDATE_LONG(STX7200_CLOCKGENB_PLL0_CFG, 0xfff80000, 0x03 | (0x28 << 8) | (0x00 << 16))
+
+  /* Enable CLOCKGENB PLL0... */
+  UPDATE_LONG(STX7200_CLOCKGENB_POWER_CFG, 0xffff7fff, 0)
+
+  /* Wait for CLOCKGENB PLL0 to lock... */
+  WHILE_NE(STX7200_CLOCKGENB_PLL0_CFG, 0x80000000, 0x80000000)
+
+  /* Clear CLOCKGENB PLL0 from BYPASS... */
+  UPDATE_LONG(STX7200_CLOCKGENB_PLL0_CFG, 0xffefffff, 0)
+
+  /* Power down PLL... */
+  OR_LONG(STX7200_SYSCONF_SYS_CFG11, 0x00001000)
+
+  /* Configure PLL... */
+  /* Set LMI clock to 666MHz */
+  UPDATE_LONG(STX7200_SYSCONF_SYS_CFG11, 0xfffff001, (0x05 << 9) | (0x6f << 1))
+  /* On PCB rev A, we have a limitation on LMI1: Reset LMI clock to 400MHz */
+  IF(0xa5020000, 0x000000ff, 0x0000000a, UPDATE_LONG(STX7200_SYSCONF_SYS_CFG11, 0xfffff001, (0x03 << 9) | (0x28 << 1)))
+
+  /* Enable CLOCKGENA PLL1... */
+  UPDATE_LONG(STX7200_SYSCONF_SYS_CFG11, 0xffffefff, 0)
+
+  /* Wait for CLOCKGENA PLL1 to lock... (polarity inverted on lock bit) */
+  WHILE_NE(STX7200_SYSCONF_SYS_STA03, 0x00000001, 0)
+
+  /* ----- STx7200 Sysconf ----- */
+
+  /* Exit from reset */
+  OR_LONG(STX7200_SYSCONF_SYS_CFG11, 0x00000001)
+  OR_LONG(STX7200_SYSCONF_SYS_CFG15, 0x00000001)
+
+  /* Check both DLL on LMI0 are locked */
+  WHILE_NE(STX7200_SYSCONF_SYS_STA03, (1 << 10) | (1 << 20), (1 << 10) | (1 << 20))
+
+  /* Check both DLL on LMI1 are locked */
+  WHILE_NE(STX7200_SYSCONF_SYS_STA05, (1 << 10) | (1 << 20), (1 << 10) | (1 << 20))
+
+  /* Adjust proga, progb, zoutproga, and receiver mode for LMI0 */
+  POKE_LONG(STX7200_SYSCONF_SYS_CFG12, 0xa2007801 | (0x0 << 1) | (0x7 << 4) | (0x7 << 7) | (0x0 << 10))
+
+  /* Adjust proga, progb, zoutproga, and receiver mode for LMI1 */
+  POKE_LONG(STX7200_SYSCONF_SYS_CFG16, 0xa2007801 | (0x0 << 1) | (0x7 << 4) | (0x7 << 7) | (0x0 << 10))
+
+  /* Enable AutoPrecharge */
+  OR_LONG(STX7200_SYSCONF_SYS_CFG38, 0x00030000)
+  OR_LONG(STX7200_SYSCONF_SYS_CFG39, 0x00030000)
+
+  /* Force DLL1 and DLL2 commands of LMI0 */
+  POKE_LONG(STX7200_SYSCONF_SYS_CFG13, 0x00000002)
+  POKE_LONG(STX7200_SYSCONF_SYS_CFG14, 0x00000002)
+
+  /* Force DLL1 and DLL2 commands of LMI1 */
+  POKE_LONG(STX7200_SYSCONF_SYS_CFG17, 0x00000002)
+  POKE_LONG(STX7200_SYSCONF_SYS_CFG18, 0x00000002)
+
+  /* ----- STx7200 EMI configuration ----- */
+
+  POKE_LONG(ST40_EMI_BANK_ENABLE, 0x00000005)
+
+  /* NOTE: bits [0,5] define bottom address bits [22,27] of bank */
+  POKE_LONG(ST40_EMI_BANK0_BASEADDRESS, 0x00000000)
+  POKE_LONG(ST40_EMI_BANK1_BASEADDRESS, 0x00000008)
+  POKE_LONG(ST40_EMI_BANK2_BASEADDRESS, 0x0000000c)
+  POKE_LONG(ST40_EMI_BANK3_BASEADDRESS, 0x00000010)
+  POKE_LONG(ST40_EMI_BANK4_BASEADDRESS, 0x00000014)
+
+  /* Bank 0 - On-board 32MiB Flash at address 0x00000000 -> 0x01ffffff */
+  POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA0, 0x001016d1)
+  POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
+  POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
+  POKE_LONG(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
+
+  /* Bank 2 - DVB-CI at address 0x03000000 -> 0x03FFFFFF */
+  POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA0, 0x002046f9)
+  POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA1, 0xa5a00000)
+  POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA2, 0xa5a20000)
+  POKE_LONG(ST40_EMI_BANK2_EMICONFIGDATA3, 0x00000000)
+
+  /* Bank 4 - EPLD Registers at address 0x05000000 -> 0x05FFFFFF */
+  POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA0, 0x042086f1)
+  POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA1, 0x8a002200)
+  POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA2, 0x8a004200)
+  POKE_LONG(ST40_EMI_BANK4_EMICONFIGDATA3, 0x00000000)
+
+  /* Program other EMI registers */
+  POKE_LONG(ST40_EMI_GENCFG, 0x00000050)
+
+  /* ----- STx7200 LMI0 configuration ----- */
+
+  /* "Refresh Interval" is set equal to 0xA28=2600 => 2600*3ns=7.8us */
+  POKE_LONG(ST40_LMI_MIM_0(0), 0x0a28015b)
+  POKE_LONG(ST40_LMI_MIM_1(0), 0x000000b0)
+
+  POKE_LONG(ST40_LMI_STR_0(0), 0xcb2cab5b)
+  POKE_LONG(ST40_LMI_STR_1(0), 0x000002d6)
+
+  /* lmi base address 0x08000000 + 128MiB 13x10 */
+  POKE_LONG(ST40_LMI_SDRA0_0(0), 0x10000a00)
+
+  /* lmi base address 0x08000000 + 128MiB 13x10 */
+  POKE_LONG(ST40_LMI_SDRA1_0(0), 0x10000a00)
+
+  /* Enable clock with NOP command */
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020023)
+  /* Wait NOP command for 400 nsec */
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+
+  /* Precharge all */
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020022)
+  /* Wait NOP command for 400 nsec */
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+
+  /* Issue EMRS2 */
+  POKE_LONG(ST40_LMI_SDMR0(0), 0x00000800)
+
+  /* Issue EMRS3 */
+  POKE_LONG(ST40_LMI_SDMR0(0), 0x00000c00)
+
+  /* Issue EMRS1 to enable DLL */
+  POKE_LONG(ST40_LMI_SDMR0(0), 0x00000400)
+
+  /* Issue MRS with DLL reset(0), CAS 5(0), Write recovery 6(0), Sequentiel(0), Burst lengh 8 */
+  POKE_LONG(ST40_LMI_SDMR0(0), 0x00002353)
+
+  /* Wait NOP command for 400 nsec */
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+
+  /* Precharge all */
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020022)
+  /* 2 CBR (auto refresh) */
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020024)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020024)
+
+  /* Issue MRS with CAS 5(0), Write recovery 6(0), Sequentiel(0), Burst lengh 8 */
+  POKE_LONG(ST40_LMI_SDMR0(0), 0x00002253)
+
+  /* Issue EMRS1 for OCD calibration default */
+  POKE_LONG(ST40_LMI_SDMR0(0), 0x000007c4)
+
+  /* Issue EMRS1 for OCD calibration exit */
+  POKE_LONG(ST40_LMI_SDMR0(0), 0x00000444)
+
+  /* Enable auto refresh */
+  POKE_LONG(ST40_LMI_MIM_0(0), 0x0a28035b)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(0), 0x00020021)
+
+  POKE_LONG(ST40_LMI_GCC_0(0), 0x00382003)
+
+  /* ----- STx7200 LMI1 configuration ----- */
+
+  /* "Refresh Interval" is set equal to 0xA28=0d2600 => 2600*3ns=7.8us */
+  POKE_LONG(ST40_LMI_MIM_0(1), 0x0a28015b)
+  POKE_LONG(ST40_LMI_MIM_1(1), 0x000000b0)
+
+  POKE_LONG(ST40_LMI_STR_0(1), 0xcb2cab5b)
+  POKE_LONG(ST40_LMI_STR_1(1), 0x000002d6)
+
+  /* lmi base address 0x18000000 + 64MiB 13x10 (all 128MiB are not visible in 29bits mode) */
+  POKE_LONG(ST40_LMI_SDRA0_0(1), 0x1c000a00)
+
+  /* lmi base address 0x18000000 + 64MiB 13x10 (all 128MiB are not visible in 29bits mode) */
+  POKE_LONG(ST40_LMI_SDRA1_0(1), 0x1c000a00)
+
+  /* Enable clock with NOP command */
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020023)
+  /* Wait NOP command for 400 nsec */
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+
+  /* Precharge all */
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020022)
+  /* Wait NOP command for 400 nsec */
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+
+  /* Issue EMRS2 */
+  POKE_LONG(ST40_LMI_SDMR0(1), 0x00000800)
+
+  /* Issue EMRS3 */
+  POKE_LONG(ST40_LMI_SDMR0(1), 0x00000c00)
+
+  /* Issue EMRS1 to enable DLL */
+  POKE_LONG(ST40_LMI_SDMR0(1), 0x00000400)
+
+  /* Issue MRS with DLL reset(1), CAS 5(1), Write recovery 6(1), Sequentiel(1), Burst lengh 8 */
+  POKE_LONG(ST40_LMI_SDMR0(1), 0x00002353)
+
+  /* Wait NOP command for 400 nsec */
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+
+  /* Precharge all */
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020022)
+  /* 2 CBR (auto refresh) */
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020024)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020024)
+
+  /* Issue MRS with CAS 5(1), Write recovery 6(1), Sequentiel(1), Burst lengh 8 */
+  POKE_LONG(ST40_LMI_SDMR0(1), 0x00002253)
+
+  /* Issue EMRS1 for OCD calibration default */
+  POKE_LONG(ST40_LMI_SDMR0(1), 0x000007c4)
+
+  /* Issue EMRS1 for OCD calibration exit */
+  POKE_LONG(ST40_LMI_SDMR0(1), 0x00000444)
+
+  /* Enable auto refresh */
+  POKE_LONG(ST40_LMI_MIM_0(1), 0x0a28035b)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+  POKE_LONG(ST40_LMI_SCR_0(1), 0x00020021)
+
+  POKE_LONG(ST40_LMI_GCC_0(1), 0x00382003)
+
+#ifdef CONFIG_SH_SE_MODE
+  /*
+   * Note that we also manually need to move the LMI0 and LMI1 base addresses to
+   * their 32-bit SE mode locations as defined in the datasheet and change the
+   * 'upper bound addresses' (in row attribute registers) for the LMIs.
+   */
+  UPDATE_LONG(STX7200_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
+  UPDATE_LONG(STX7200_SYSCONF_SYS_CFG39, 0xFFFFFF00, 0x00000080)
+  POKE_LONG(ST40_LMI_SDRA0_0(0), 0x48000a00)
+  POKE_LONG(ST40_LMI_SDRA1_0(0), 0x48000a00)
+  POKE_LONG(ST40_LMI_SDRA0_0(1), 0x88000a00)
+  POKE_LONG(ST40_LMI_SDRA1_0(1), 0x88000a00)
+#endif	/* CONFIG_SH_SE_MODE */
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/st/mb519/mb519.c b/board/st/mb519/mb519.c
new file mode 100644
index 0000000000..7db5570669
--- /dev/null
+++ b/board/st/mb519/mb519.c
@@ -0,0 +1,143 @@
+/*
+ * (C) Copyright 2007 STMicroelectronics.
+ *
+ * Stuart Menefy <stuart.menefy@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/soc.h>
+#include <asm/stx7200reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+#ifdef CONFIG_SH_SE_MODE
+#define EPLD_BASE		0xb5000000	/* Phys 0x05000000 */
+#else
+#define EPLD_BASE		0xa5000000
+#endif	/* CONFIG_SH_SE_MODE */
+
+#define EPLD_FlashCtrlAddr	SH4_WORD_REG(EPLD_BASE + 0x400000)
+
+void flashWriteEnable(void)
+{
+	/*  Enable vpp for writing to flash */
+	*EPLD_FlashCtrlAddr = 3;
+}
+
+void flashWriteDisable(void)
+{
+	/*  Disable vpp for writing to flash */
+	*EPLD_FlashCtrlAddr = 2;
+}
+
+#define PIO_BASE  0xfd020000
+
+static void configPIO(void)
+{
+  /*  Setup PIO of ASC device */
+  SET_PIO_ASC(PIO_PORT(4), 3, 2, 4, 5);  /* UART2 - AS0 */
+  SET_PIO_ASC(PIO_PORT(5), 4, 3, 5, 6);  /* UART3 - AS1 */
+}
+
+int board_init(void)
+{
+	unsigned long sysconf;
+
+	/* Serial port set up */
+	/* Route UART2&3 or SCI inputs instead of DVP to pins: conf_pad_dvp = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG40;
+	sysconf &= ~(1<<16);
+	*STX7200_SYSCONF_SYS_CFG40 = sysconf;
+
+	/* Route UART2&3/SCI outputs instead of DVP to pins: conf_pad_pio[1]=0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<25);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* No idea, more routing: conf_pad_pio[0] = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<24);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* Route UART2 (inputs and outputs) instead of SCI to pins: ssc2_mux_sel = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<2);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* conf_pad_pio[4] = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<28);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* Route UART3 (inputs and outputs) instead of SCI to pins: ssc3_mux_sel = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<3);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* conf_pad_clkobs = 1 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf |= (1<<14);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* I2C and USB related routing */
+	/* bit4: ssc4_mux_sel = 0 (treat SSC4 as I2C) */
+	/* bit26: conf_pad_pio[2] = 0 route USB etc instead of DVO */
+	/* bit27: conf_pad_pio[3] = 0 DVO output selection (probably ignored) */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~((1<<27)|(1<<26)|(1<<4));
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* Enable SOFT_JTAG mode.
+	 * Taken from OS21, but is this correct?
+	 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG33;
+	sysconf |= (1<<6);
+	sysconf &= ~((1<<0)|(1<<1)|(1<<2)|(1<<3));
+	*STX7200_SYSCONF_SYS_CFG33 = sysconf;
+
+	configPIO();
+
+	return 0;
+}
+
+int checkboard (void)
+{
+	printf ("\n\nBoard: STx7200-Reference (MB519)"
+#ifdef CONFIG_SH_SE_MODE
+		"  [32-bit mode]"
+#else
+		"  [29-bit mode]"
+#endif
+		"\n");
+
+#ifdef CONFIG_DRIVER_NETSTMAC
+#if defined(CONFIG_STMAC_MAC0)
+	/* On-board PHY (MII0), in MII mode, using its own clock  */
+	stx7200_configure_ethernet(0, 0, 1, 0);
+#elif defined(CONFIG_STMAC_MAC1)
+	/* External PHY board (MII1), in MII mode, using its own clock */
+	stx7200_configure_ethernet(1, 0, 1, 1);
+#endif
+#endif	/* CONFIG_DRIVER_NETSTMAC */
+
+	return 0;
+}
diff --git a/board/st/mb618/Makefile b/board/st/mb618/Makefile
new file mode 100644
index 0000000000..e71bce43bb
--- /dev/null
+++ b/board/st/mb618/Makefile
@@ -0,0 +1,54 @@
+#
+# (C) Copyright 2007 STMicroelectronics.
+# Stuart Menefy <stuart.menefy@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+SOBJS-y	= init-$(BOARD).o
+
+COBJS-y	+= $(BOARD).o
+COBJS-$(CONFIG_CMD_NAND) += nand.o
+
+
+SRCS	:= $(SOBJS-y:.o=.S) $(COBJS-y:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS-y))
+SOBJS	:= $(addprefix $(obj),$(SOBJS-y))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/st/mb618/config.mk b/board/st/mb618/config.mk
new file mode 100644
index 0000000000..ed07dd4503
--- /dev/null
+++ b/board/st/mb618/config.mk
@@ -0,0 +1,43 @@
+#
+# (C) Copyright 2008 STMicroelectronics.
+# Sean McGoogan <Sean.McGoogan@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# MB618 board:
+#
+#	Valid values for TEXT_BASE are:
+#
+#	0x93F00000	29-bit mode (Traditional Mode)
+#	0x87F00000	32-bit mode (Space-Enhancement Mode)
+#
+# Note:	Alternative definitions of TEXT_BASE are put into
+#	'config.tmp' from the top-level 'Makefile'.
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+# Installs at LMI0 BASE + 127MB in P1 (cachable)
+TEXT_BASE = 0x93F00000
+endif
+
+PLATFORM_LDFLAGS +=
diff --git a/board/st/mb618/init-mb618.S b/board/st/mb618/init-mb618.S
new file mode 100644
index 0000000000..5dd0fbf855
--- /dev/null
+++ b/board/st/mb618/init-mb618.S
@@ -0,0 +1,366 @@
+#include "asm/stx7111reg.h"
+#include "../../../cpu/sh/init_ram.S"
+
+/*
+ * This is derived from STMicroelectronics gnu toolchain example:
+ *   sh-superh-elf/examples/os21/romdynamic/memory_mb618.S
+ */
+
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *	opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+/*
+ * For compatibility with old poke table code, we define some of the
+ * new names, to map onto the old names. Ultimately, the old poke table
+ * code will be updated to the "new order", and we can just delete
+ * the following mappings.
+ */
+#define POKE8(A, VAL)				POKE_CHAR(A, VAL)
+#define POKE16(A, VAL)				POKE_SHORT(A, VAL)
+#define POKE32(A, VAL)				POKE_LONG(A, VAL)
+#define OR32(A, VAL)				OR_LONG(A, VAL)
+#define UPDATE32(A, AND, OR)			UPDATE_LONG(A, AND, OR)
+#define POKE_UPDATE32(A1, A2, AND, SHIFT, OR)	POKE_UPDATE_LONG(A1, A2, AND, SHIFT, OR)
+#define WHILE_NE32(A, AND, VAL)			WHILE_NE(A, AND, VAL)
+#define DELAY(VAL)				/* do nothing */
+
+
+	.section .data.init, "a"
+
+	.balign 32
+
+__memory_setup_table:
+
+	/* ----- STx7111 Clocks ----- */
+
+	/* Clockgen A initial setup */
+
+	/* Set PLL0 clock to 450MHz */
+	/* PLL0 of clockgenA = PLL1600 */
+
+	/* Set CLOCKGENA PLL0 into BYPASS... */
+//QQQ	OR32(STX7111_CLOCKGENA_PLL0_CFG, 0x00100000)
+
+	/* Power down CLOCKGENA PLL0... */
+//QQQ	OR32(STX7111_CLOCKGENA_POWER_CFG, 0x00000001)
+
+	/* Configure CLOCKGENA PLL0... */
+	UPDATE32(STX7111_CLOCKGENA_PLL0_CFG, 0xfff80000, (0xf << 8) | (0x01 & 0x7))
+
+	/* Enable CLOCKGENA PLL0... */
+	UPDATE32(STX7111_CLOCKGENA_POWER_CFG, 0xfffffffe, 0)
+
+	/* Wait for CLOCKGENA PLL0 to lock... */
+	WHILE_NE32(STX7111_CLOCKGENA_PLL0_CFG, 0x80000000, 0x80000000)
+
+	/* Clear CLOCKGENA PLL0 from BYPASS... */
+//QQQ	UPDATE32(STX7111_CLOCKGENA_PLL0_CFG, 0xffefffff, 0)
+
+	/* Set PLL1 clock to 800MHz */
+	/* PLL1 of clockgenA = PLL800 */
+
+	/* Set CLOCKGENA PLL1 into BYPASS... */
+//QQQ	OR32(STX7111_CLOCKGENA_PLL1_CFG, 0x00100000)
+
+	/* Power down CLOCKGENA PLL1... */
+//QQQ	OR32(STX7111_CLOCKGENA_POWER_CFG, 0x00000002)
+
+	/* Configure CLOCKGENA PLL1... */
+	UPDATE32(STX7111_CLOCKGENA_PLL1_CFG, 0xfff80000, (0x0 << 16) | (0x28 << 8) | (0x03))
+
+	/* Enable CLOCKGENA PLL1... */
+	UPDATE32(STX7111_CLOCKGENA_POWER_CFG, 0xfffffffd, 0)
+
+	/* Wait for CLOCKGENA PLL1 to lock... */
+	WHILE_NE32(STX7111_CLOCKGENA_PLL1_CFG, 0x80000000, 0x80000000)
+
+	/* Clear CLOCKGENA PLL1 from BYPASS... */
+//QQQ	UPDATE32(STX7111_CLOCKGENA_PLL1_CFG, 0xffefffff, 0)
+
+	/* Set dividers clocks */
+	POKE32(STX7111_CLOCKGENA_PLL1_DIV0_CFG, 0x00000001)
+	POKE32(STX7111_CLOCKGENA_PLL1_DIV1_CFG, 0x00000001)
+	POKE32(STX7111_CLOCKGENA_PLL1_DIV2_CFG, 0x00000001)
+	POKE32(STX7111_CLOCKGENA_PLL1_DIV3_CFG, 0x00000103)
+	POKE32(STX7111_CLOCKGENA_PLL0LS_DIV4_CFG, 0x00010100)
+	POKE32(STX7111_CLOCKGENA_PLL1_DIV5_CFG, 0x00000307)
+	POKE32(STX7111_CLOCKGENA_PLL0LS_DIV6_CFG, 0x00010100)
+	POKE32(STX7111_CLOCKGENA_PLL0LS_DIV7_CFG, 0x00010100)
+	POKE32(STX7111_CLOCKGENA_PLL1_DIV8_CFG, 0x00000103)
+	POKE32(STX7111_CLOCKGENA_PLL1_DIV9_CFG, 0x00000103)
+	POKE32(STX7111_CLOCKGENA_PLL1_DIV10_CFG, 0x00000103)
+	POKE32(STX7111_CLOCKGENA_PLL1_DIV11_CFG, 0x00000103)
+	POKE32(STX7111_CLOCKGENA_PLL1_DIV12_CFG, 0x00000103)
+	POKE32(STX7111_CLOCKGENA_PLL0LS_DIV13_CFG, 0x00000811)
+	POKE32(STX7111_CLOCKGENA_PLL1_DIV14_CFG, 0x0000050B)
+	POKE32(STX7111_CLOCKGENA_PLL1_DIV15_CFG, 0x00000307)
+	POKE32(STX7111_CLOCKGENA_PLL1_DIV16_CFG, 0x00000103)
+	POKE32(STX7111_CLOCKGENA_PLL1_DIV17_CFG, 0x00000103)
+
+	/* Set clock sources */
+	POKE32(STX7111_CLOCKGENA_CLKOPSRC_SWITCH_CFG, 0xA6AA59AA)
+	POKE32(STX7111_CLOCKGENA_CLKOPSRC_SWITCH_CFG2, 0x0000000A)
+
+	/* Clockgen D (LMI) initial setup (lmi2xfreq = 540) */
+	/* Power down PLL... */
+	OR32(STX7111_SYSCONF_SYS_CFG11, 0x00001000)
+
+	/* Configure PLL... */
+	UPDATE32(STX7111_SYSCONF_SYS_CFG11, 0xfffff001, (0x01 << 9) | (0x12 << 1))
+
+	/* Enable CLOCKGENA PLL1... */
+	UPDATE32(STX7111_SYSCONF_SYS_CFG11, 0xffffefff, 0)
+
+	/* Wait for CLOCKGENA PLL1 to lock... (polarity inverted on lock bit) */
+	WHILE_NE32(STX7111_SYSCONF_SYS_STA03, 0x00000001, 0)
+
+
+	/* ----- STX7111 SysConf ----- */
+	/* PLI_CLOCK_ENABLE set to 0 */
+	OR32(STX7111_SYSCONF_SYS_CFG04, ~(1 << 2))
+
+	/* LMI sub-sys & pl exit from reset */
+	OR32(STX7111_SYSCONF_SYS_CFG11, (0x00000001 | 1 << 27))
+
+	/* Delay ~ 200 microseconds (assume 30MHz CPU clock) */
+	DELAY(200 * 30)
+
+	/* PLI_CLOCK_ENABLE set to 1 */
+	OR32(STX7111_SYSCONF_SYS_CFG04, (1 << 2))
+
+	/* Check both DLL on LMI0 are locked */
+	WHILE_NE32(STX7111_SYSCONF_SYS_STA03, (1 << 10) | (1 << 20), (1 << 10) | (1 << 20))
+
+	/* Adjust proga, progb, zoutproga, and receiver mode for LMI0 */
+	POKE32(STX7111_SYSCONF_SYS_CFG12, (0xa2007801 | (0x7 << 1) | (0x0 << 4) | (0x0 << 7) | (0x0 << 10)))
+
+	/* Enable AutoPrecharge */
+	POKE32(STX7111_SYSCONF_SYS_CFG38, 0x000FFE0C)
+
+	/* Force DLL1 and DLL2 command of LMI0 */
+	POKE32(STX7111_SYSCONF_SYS_CFG13, 0x00000000)
+	POKE32(STX7111_SYSCONF_SYS_CFG14, 0x00000000)
+
+	/* Set cfg55 */
+#ifndef LMI_16BITS_MODE
+#define LMI_16BITS_MODE 0
+#endif
+	POKE32(STX7111_SYSCONF_SYS_CFG55, 0x03fc2004 | (LMI_16BITS_MODE << 10) | ((0x7 & 0x7) << 7))
+
+	/* PDL offsets */
+	POKE32(STX7111_SYSCONF_SYS_CFG42, 0x07D7EBF5)
+	POKE32(STX7111_SYSCONF_SYS_CFG43, 0x000001F5)
+
+	/* ----- STX7111 EMI configuration ----- */
+
+	POKE32(ST40_EMI_BANK_ENABLE, 0x00000005)
+
+	/* NOTE: bits [0,5] define bottom address bits [22,27] of bank */
+	POKE32(ST40_EMI_BANK0_BASEADDRESS, 0x00000000)
+	POKE32(ST40_EMI_BANK1_BASEADDRESS, 0x00000010)
+	POKE32(ST40_EMI_BANK2_BASEADDRESS, 0x00000012)
+	POKE32(ST40_EMI_BANK3_BASEADDRESS, 0x00000014)
+	POKE32(ST40_EMI_BANK4_BASEADDRESS, 0x0000001C)
+
+	/* Bank 0 - On-board 32MiB Flash at address 0x00000000 -> 0x01ffffff */
+	POKE32(ST40_EMI_BANK0_EMICONFIGDATA0, 0x001016d1)
+	POKE32(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
+	POKE32(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
+	POKE32(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)
+
+	/* Bank 1 - STEM 8 MiB 0x04000000 -> 0x047fffff */
+	POKE32(ST40_EMI_BANK1_EMICONFIGDATA0, 0x002016d1)
+	POKE32(ST40_EMI_BANK1_EMICONFIGDATA1, 0x9d222200)
+	POKE32(ST40_EMI_BANK1_EMICONFIGDATA2, 0x9d220044)
+	POKE32(ST40_EMI_BANK1_EMICONFIGDATA3, 0x00000000)
+
+	/* Bank 2 - DVB-CI at address 0x04000000 -> 0x04FFFFFF */
+	POKE32(ST40_EMI_BANK2_EMICONFIGDATA0, 0x002046f9)
+	POKE32(ST40_EMI_BANK2_EMICONFIGDATA1, 0xa5a00000)
+	POKE32(ST40_EMI_BANK2_EMICONFIGDATA2, 0xa5a20000)
+	POKE32(ST40_EMI_BANK2_EMICONFIGDATA3, 0x00000000)
+
+	/* Bank 3 - 32MiB Boards register and either DVBCI notCe2 or
+		STEM notCS1 (16MiB + 16MiB split bank) 0x05000000 -> 0x06ffffff
+	 */
+	POKE32(ST40_EMI_BANK3_EMICONFIGDATA0, 0x002016d1)
+	POKE32(ST40_EMI_BANK3_EMICONFIGDATA1, 0x9d222200)
+	POKE32(ST40_EMI_BANK3_EMICONFIGDATA2, 0x9d220044)
+	POKE32(ST40_EMI_BANK3_EMICONFIGDATA3, 0x00000000)
+
+	/* Bank 4 - EPLD Registers at address 0x07000000 -> 0x07FFFFFF */
+	POKE32(ST40_EMI_BANK4_EMICONFIGDATA0, 0x002016d1)
+	POKE32(ST40_EMI_BANK4_EMICONFIGDATA1, 0x9d222200)
+	POKE32(ST40_EMI_BANK4_EMICONFIGDATA2, 0x9d220044)
+	POKE32(ST40_EMI_BANK4_EMICONFIGDATA3, 0x00000000)
+
+	/* Program other EMI registers */
+	POKE32(ST40_EMI_GENCFG, 0x00000010)
+
+
+	/* ----- STX7111 LMI0 configuration ----- */
+
+	/* Configuring LMI0 for DDR2 SDRAM Elpida EDE5116AHBG-8E-E
+	 # Refresh interval compute (from Ignazio, 11jan08)
+	 # 300 MHz --->  T=3.4ns => MIM[28:16]=2038 ((2294-256)+ACo-3.4ns<+AH4-7.8us)
+	 # 330 MHz --->  T=3.1ns => MIM[28:16]=2260 ((2516-256)+ACo-3.1ns<+AH4-7.8us)
+	 # 360 MHz --->  T=2.8ns => MIM[28:16]=2529 ((2785-256)+ACo-2.8ns<+AH4-7.8us)
+	 # 400 MHz --->  T=2.5ns => MIM[28:16]=2864 ((3120-256)+ACo-2.5ns=7.8us)
+	 */
+#if LMI_16BITS_MODE == 0
+	POKE32(ST40_LMI_MIM_0(), (2038 << 16) | 0x0000017b)
+#else
+	POKE32(ST40_LMI_MIM_0(), (2038 << 16) | 0x0000013b)
+#endif
+	/* Note: refresh is enabled in later steps */
+
+	POKE32(ST40_LMI_MIM_1(), 0xffff0000)
+
+	/* SDRAM Timing Register
+	 # lmi.LMI_STR_0.poke(0x4c2db41b)
+	 # FCh, 19/mar/08: change according to Raffaele G feebacks
+	 #		1-cycle additional delay between RD and WR
+	 */
+	POKE32(ST40_LMI_STR_0(), 0xcc2db41b)
+	POKE32(ST40_LMI_STR_1(), 0x002202d6)
+
+	/* SDRAM Array Attribute Register
+	 # Upper LMI addr=0x0C000000 + 128MiB=0x14000000, 13x10
+	 */
+#if LMI_16BITS_MODE == 0
+	POKE32(ST40_LMI_SDRA0_0(), 0x14000a20)
+#else
+	POKE32(ST40_LMI_SDRA0_0(), 0x10000a20)
+#endif
+
+	/* SDRAM Array Attribute Register
+	 # Upper LMI addr=0x0C000000 + 128MiB=0x14000000, 13x10
+	 */
+#if LMI_16BITS_MODE == 0
+	POKE32(ST40_LMI_SDRA1_0(), 0x14000a20)
+#else
+	POKE32(ST40_LMI_SDRA1_0(), 0x10000a20)
+#endif
+
+	/* SDRAM Control Register */
+	/* Delay ~ 200 milliseconds (assume 450MHz CPU clock) */
+	DELAY(200000 * 450)
+
+	/* Enable clock with NOP command */
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020023)
+	/* Wait NOP command for 400 nsec */
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+
+	/* Precharge all */
+	POKE32(ST40_LMI_SCR_0(), 0x00020022)
+	/* Wait NOP command for 400 nsec */
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+
+	/* Issue EMRS2 */
+	POKE32(ST40_LMI_SDMR0(), 0x00010000)
+
+	/* Issue EMRS3 */
+	POKE32(ST40_LMI_SDMR0(), 0x00018000)
+
+	/* Issue EMRS1 to enable DLL */
+	POKE32(ST40_LMI_SDMR0(), 0x00008004)
+
+	/* Issue MRS with DLL reset, CAS 5, Write recovery 5, Sequentiel, Burst lengh 8
+	 # lmi.LMI_SDMR0_0.poke(0x00000953)
+	 # FCh, 19/mar/08: change according to Raffaele G feebacks
+	 */
+	POKE32(ST40_LMI_SDMR0(), 0x00000b53)
+
+	/* Wait NOP command for 400 nsec */
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+
+	/* Precharge all */
+	POKE32(ST40_LMI_SCR_0(), 0x00020022)
+	/* 2 CBR (auto refresh) */
+	POKE32(ST40_LMI_SCR_0(), 0x00020024)
+	POKE32(ST40_LMI_SCR_0(), 0x00020024)
+
+	/* Issue MRS with CAS 5, Write recovery 5, Sequentiel, Burst lengh 8
+	 # lmi.LMI_SDMR0_0.poke(0x00000853)
+	 # FCh, 19/mar/08: change according to Raffaele G feebacks
+	 */
+	POKE32(ST40_LMI_SDMR0(), 0x00000a53)
+
+	/* Issue EMRS1 for OCD calibration default */
+	/* lmi.LMI_SDMR0_0.poke(0x000007c4) */
+
+	/* Issue EMRS1 for OCD calibration exit */
+	/* lmi.LMI_SDMR0_0.poke(0x00000444) */
+
+	/* Enable auto refresh
+	 # lmi.LMI_MIM_0.poke(0x0c30037b)
+	 # FCh, 12/feb/08: cleaner to modify only refresh bit
+	 */
+	OR32(ST40_LMI_MIM_0(), (1 << 9))
+
+	/* DQS recovery mechanism (1=enabled)
+	 # lmi.LMI_MIM_0.poke(lmi.LMI_MIM_0.peek() | (1 << 5))
+	 # FCh, 14/jan/08, NO DQS recovery
+	 */
+	UPDATE32(ST40_LMI_MIM_0(), ~(1 << 5), 0)
+
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+	POKE32(ST40_LMI_SCR_0(), 0x00020021)
+
+	POKE32(ST40_LMI_GCC_0(), 0x00000000)
+
+#ifdef CONFIG_SH_SE_MODE
+	/*
+	 * Note that we also manually need to move the LMI base addresses to
+	 * their 32-bit SE mode locations as defined in the datasheet and change the
+	 * 'upper bound addresses' (in row attribute registers) for the LMIs.
+	 */
+	UPDATE_LONG(STX7111_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
+	UPDATE_LONG(STX7111_SYSCONF_SYS_CFG39, 0xFFFFFF00, 0x00000080)
+	/* Change LMI upper bound addresses
+	 * Upper LMI addr=0x40000000 + 128Mbytes=0x48000000, 13x10
+	 */
+	UPDATE32(ST40_LMI_SDRA0_0(), 0x001FFFFF, (0x48000000 & 0xFFE00000))
+	UPDATE32(ST40_LMI_SDRA1_0(), 0x001FFFFF, (0x48000000 & 0xFFE00000))
+#endif	/* CONFIG_SH_SE_MODE */
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/st/mb618/mb618.c b/board/st/mb618/mb618.c
new file mode 100644
index 0000000000..ab35eace83
--- /dev/null
+++ b/board/st/mb618/mb618.c
@@ -0,0 +1,225 @@
+/*
+ * (C) Copyright 2008 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/stx7111reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+#define PIO_BASE  0xfd020000	/* Base of PIO block in COMMs block */
+
+#ifndef CONFIG_SH_NO_EPLD
+#ifdef CONFIG_SH_SE_MODE
+#define EPLD_BASE		0xb6000000	/* Phys 0x06000000 */
+#else
+#define EPLD_BASE		0xa6000000
+#endif	/* CONFIG_SH_SE_MODE */
+
+#define EPLD_IDENT		0x00	/* READ: EPLD Identifier Register */
+#define EPLD_BANK		0x00	/* WRITE: EPLD Bank Register */
+#define EPLD_TEST		0x04	/* EPLD Test Register (Banked) */
+#define EPLD_CTRL		0x04	/* EPLD Control Register (Banked) */
+#define EPLD_SET_BANK_TEST	0x00	/* Bank = EPLD_TEST */
+#define EPLD_SET_BANK_CTRL	0x01	/* Bank = EPLD_CTRL */
+
+static inline void epld_write(unsigned long value, unsigned long offset)
+{
+	/* 8-bit write to EPLD registers */
+	writeb(value, EPLD_BASE + offset);
+}
+
+static inline unsigned long epld_read(unsigned long offset)
+{
+	/* 8-bit read from EPLD registers */
+	return readb(EPLD_BASE + offset);
+}
+#endif	/* CONFIG_SH_NO_EPLD */
+
+void flashWriteEnable(void)
+{
+	/* Enable Vpp for writing to flash */
+	STPIO_SET_PIN(PIO_PORT(3), 4, 1);
+}
+
+void flashWriteDisable(void)
+{
+	/* Disable Vpp for writing to flash */
+	STPIO_SET_PIN(PIO_PORT(3), 4, 0);
+}
+
+static void configPIO(void)
+{
+	/* Setup PIO of ASC device */
+	SET_PIO_ASC(PIO_PORT(4), 3, 2, 4, 5);  /* UART2 - AS0 */
+	SET_PIO_ASC(PIO_PORT(5), 0, 1, 2, 3);  /* UART3 - AS1 */
+
+	/* Setup up Vpp for NOR FLASH */
+	SET_PIO_PIN(PIO_PORT(3), 4, STPIO_OUT);
+}
+
+extern int board_init(void)
+{
+	configPIO();
+
+	return 0;
+}
+
+#if defined(CONFIG_DRIVER_NET_STM_GMAC) && !defined(CONFIG_SH_NO_EPLD)
+/*
+ * Reset the Ethernet PHY, via the EPLD.
+ * This code is only for EPLD version 06 or later.
+ */
+static inline void mb618_phy_reset06(void)
+{
+	/* set EPLD Bank = Ctrl */
+	epld_write(EPLD_SET_BANK_CTRL, EPLD_BANK);
+
+	/* Bring the PHY out of reset in MII mode */
+	epld_write(0x4 | 0, EPLD_CTRL);
+	epld_write(0x4 | 1, EPLD_CTRL);
+}
+#endif	/* defined(CONFIG_DRIVER_NET_STM_GMAC) && !defined(CONFIG_SH_NO_EPLD) */
+
+/*
+ * We have several EPLD versions, with slightly different memory
+ * maps and features:
+ *
+ * version 04:
+ * off  read        reset
+ *  0   Status      undef  (unused)
+ *  4   Ctrl        20     (unused)
+ *  8   Test        33
+ *  c   Ident       0      (should be 1 but broken)
+ * (note writes are broken)
+ *
+ * version 05:
+ * off  read     write       reset
+ *  0   Ident    Ctrl        45
+ *  4   Test     Test        55
+ *  8   IntStat  IntMaskSet  -
+ *  c   IntMask  IntMaskClr  0
+ *
+ * version 06:
+ * off        read       write         reset
+ *  0         Ident      Bank          46 (Bank register defaults to 0)
+ *  4 bank=0  Test       Test          55
+ *  4 bank=1  Ctrl       Ctrl          0e
+ *  4 bank=2  IntPri0    IntPri0  f9
+ *  4 bank=3  IntPri1    IntPri1  f0
+ *  8         IntStat    IntMaskSet    -
+ *  c         IntMask    IntMaskClr    00
+ *
+ * Ctrl register bits:
+ *  0 = Ethernet Phy notReset
+ *  1 = RMIInotMIISelect
+ *  2 = Mode Select_7111 (ModeSelect when D0 == 1)
+ *  3 = Mode Select_8700 (ModeSelect when D0 == 0)
+ *
+ *  The version 06 map is also applicable to later versions.
+ *
+ *  NOTE: U-Boot only supports version 06 or later of the EPLD.
+ *  Versions of the EPLD prior to this version are NOT supported!
+ */
+
+static int mb618_init_epld(void)
+{
+#ifdef CONFIG_SH_NO_EPLD
+	/* we ignore talking to the EPLD, tell the user */
+	printf("info: Disregarding any EPLD\n");
+
+#else	/* CONFIG_SH_NO_EPLD */
+	const unsigned char test_values[2] = {0xa4u, 0x2fu};
+	unsigned char epld_reg, inverted;
+	unsigned char epld_version, board_version;
+	int i;
+
+	/* set EPLD Bank = Test */
+	epld_write(EPLD_SET_BANK_TEST, EPLD_BANK);
+
+	/* for each test value ... */
+	for (i=0; i<sizeof(test_values)/sizeof(test_values[0]); i++) {
+		/* write (anything) to the test register */
+		epld_write(test_values[i], EPLD_TEST);
+		/* calculate what we expect back */
+		inverted = ~test_values[i];
+		/* now read it back */
+		epld_reg = epld_read(EPLD_TEST);
+		/* verify we got back an inverted result */
+		if (epld_reg != inverted) {
+			printf("Failed EPLD test (offset=%02x, %02x!=%02x)\n",
+				EPLD_TEST, epld_reg, inverted);
+			return 1;	/* Failure! */
+			}
+	}
+
+	/* Assume we can trust the ident register */
+	epld_reg      = epld_read(EPLD_IDENT);
+	board_version = (epld_reg >> 5) & 0x07u;
+	epld_version  = (epld_reg >> 0) & 0x1fu;
+
+	/* is it acceptable ? */
+	if (epld_version < 6) {
+		printf("Unsupported EPLD version (reg=0x%02x)\n",
+			epld_reg);
+		return 1;	/* Failure! */
+	}
+
+	/* display the board revision, and EPLD version */
+	printf("MB618: revision %c, EPLD version %02d\n",
+		board_version + 'A',
+		epld_version);
+
+	/* now perform the EPLD initializations we want */
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+	mb618_phy_reset06();
+#endif
+
+	/* set the Test register back to RESET conditions (for linux) */
+	/* set EPLD Bank = Test */
+	epld_write(EPLD_SET_BANK_TEST, EPLD_BANK);
+	/* write inverted 0x55, so it reads back as 0x55 */
+	epld_write(~0x55u, EPLD_TEST);
+
+#endif	/* CONFIG_SH_NO_EPLD */
+
+	/* return a "success" result */
+	return 0;
+}
+
+int checkboard (void)
+{
+	printf ("\n\nBoard: STx7111-Mboard (MB618)"
+#ifdef CONFIG_SH_SE_MODE
+		"  [32-bit mode]"
+#else
+		"  [29-bit mode]"
+#endif
+		"\n");
+
+	/*
+	 * initialize the EPLD.
+	 */
+	return mb618_init_epld();
+}
diff --git a/board/st/mb618/nand.c b/board/st/mb618/nand.c
new file mode 100644
index 0000000000..01426a6f42
--- /dev/null
+++ b/board/st/mb618/nand.c
@@ -0,0 +1,87 @@
+/*
+ * (C) Copyright 2006 DENX Software Engineering
+ * (C) Copyright 2008 STMicroelectronics, Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <nand.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+#include <asm/stx7111reg.h>
+
+
+/*
+ * hardware specific access to control-lines
+ *	CL -> Emi_Addr(17)
+ *	AL -> Emi_Addr(18)
+ *	nCE is handled by EMI (not s/w controlable)
+ */
+static void mb618_hwcontrol(struct mtd_info *mtdinfo, int cmd)
+{
+	struct nand_chip* this = (struct nand_chip *)(mtdinfo->priv);
+
+	switch(cmd) {
+
+	case NAND_CTL_SETCLE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (1u << 17));
+		break;
+
+	case NAND_CTL_CLRCLE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(1u << 17));
+		break;
+
+	case NAND_CTL_SETALE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (1u << 18));
+		break;
+
+	case NAND_CTL_CLRALE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(1u << 18));
+		break;
+	}
+}
+
+
+/*
+ * Board-specific NAND initialization. The following members of the
+ * argument are board-specific (per include/linux/mtd/nand.h):
+ * - IO_ADDR_R?: address to read the 8 I/O lines of the flash device
+ * - IO_ADDR_W?: address to write the 8 I/O lines of the flash device
+ * - hwcontrol: hardwarespecific function for accesing control-lines
+ * - dev_ready: hardwarespecific function for  accesing device ready/busy line
+ * - enable_hwecc?: function to enable (reset)  hardware ecc generator. Must
+ *   only be provided if a hardware ECC is available
+ * - eccmode: mode of ecc, see defines
+ * - chip_delay: chip dependent delay for transfering data from array to
+ *   read regs (tR)
+ * - options: various chip options. They can partly be set to inform
+ *   nand_scan about special functionality. See the defines for further
+ *   explanation
+ * Members with a "?" were not set in the merged testing-NAND branch,
+ * so they are not set here either.
+ */
+extern int board_nand_init(struct nand_chip *nand)
+{
+	nand->hwcontrol = mb618_hwcontrol;
+	nand->eccmode = NAND_ECC_SOFT;
+	nand->chip_delay = 25;
+	nand->options = NAND_NO_AUTOINCR;
+	return 0;
+}
diff --git a/board/st/mb628/Makefile b/board/st/mb628/Makefile
new file mode 100644
index 0000000000..e71bce43bb
--- /dev/null
+++ b/board/st/mb628/Makefile
@@ -0,0 +1,54 @@
+#
+# (C) Copyright 2007 STMicroelectronics.
+# Stuart Menefy <stuart.menefy@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+SOBJS-y	= init-$(BOARD).o
+
+COBJS-y	+= $(BOARD).o
+COBJS-$(CONFIG_CMD_NAND) += nand.o
+
+
+SRCS	:= $(SOBJS-y:.o=.S) $(COBJS-y:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS-y))
+SOBJS	:= $(addprefix $(obj),$(SOBJS-y))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/st/mb628/config.mk b/board/st/mb628/config.mk
new file mode 100644
index 0000000000..c23d0676ea
--- /dev/null
+++ b/board/st/mb628/config.mk
@@ -0,0 +1,56 @@
+#
+# (C) Copyright 2008-2009 STMicroelectronics.
+# Sean McGoogan <Sean.McGoogan@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# MB628 board:
+#
+#	Following are *Physical* Addresses:
+#
+#	Region		29-bit		32-bit		Size
+#	------		------		------		----
+#	LMI_BASE	0x0c000000	0x40000000	128MiB
+#	VIDEO_BASE	0x0c000000	0x40000000	  4MiB
+#	AUDIO_BASE	0x0c400000	0x40400000	  4MiB
+#	eSTB_BASE	0x0c800000	0x40800000	 50MiB
+#	eSTB_END	0x0f9fffff	0x439fffff	   ---
+#
+#
+#	Following are *Virtual* Addresses:
+#
+#	Valid values for TEXT_BASE are:
+#
+#	0x8F900000	29-bit mode (Traditional Mode)
+#	0x83900000	32-bit mode (Space-Enhancement Mode)
+#
+# Note:	Alternative definitions of TEXT_BASE are put into
+#	'config.tmp' from the top-level 'Makefile'.
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+# Installs at eSTB BASE + 49MB in P1 (cachable)
+TEXT_BASE = 0x8F900000
+endif
+
+PLATFORM_LDFLAGS +=
diff --git a/board/st/mb628/init-mb628.S b/board/st/mb628/init-mb628.S
new file mode 100644
index 0000000000..490cb3adcf
--- /dev/null
+++ b/board/st/mb628/init-mb628.S
@@ -0,0 +1,77 @@
+#include "asm/stx7141reg.h"
+#include "../../../cpu/sh/init_ram.S"
+
+/*
+ * This is derived from STMicroelectronics gnu toolchain example:
+ *   sh-superh-elf/examples/os21/romdynamic/memory_mb628.S
+ */
+
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *	opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+/*
+ * For compatibility with old poke table code, we define some of the
+ * new names, to map onto the old names. Ultimately, the old poke table
+ * code will be updated to the "new order", and we can just delete
+ * the following mappings.
+ */
+#define POKE8(A, VAL)				POKE_CHAR(A, VAL)
+#define POKE16(A, VAL)				POKE_SHORT(A, VAL)
+#define POKE32(A, VAL)				POKE_LONG(A, VAL)
+#define OR32(A, VAL)				OR_LONG(A, VAL)
+#define UPDATE32(A, AND, OR)			UPDATE_LONG(A, AND, OR)
+#define POKE_UPDATE32(A1, A2, AND, SHIFT, OR)	POKE_UPDATE_LONG(A1, A2, AND, SHIFT, OR)
+#define WHILE_NE32(A, AND, VAL)			WHILE_NE(A, AND, VAL)
+#define DELAY(VAL)				/* do nothing */
+
+
+	.section .data.init, "a"
+
+	.balign 32
+
+__memory_setup_table:
+
+	/*
+	 * include the appropriate set of "GDB pokes", (usually) generated
+	 * using the "romgen" utility, from a known good target-pack.
+	 *
+	 * This file may be regenerated by connecting your specific board
+	 * to an STMC2 (note: currently it must be version 2) and then
+	 * executing the following command (redirecting the output):
+	 *
+	 * host% romgen --target-connect --show-comment <stmc2>:mb628:estb
+	 *
+	 * Where "<stmc2>" should be replaced with the IP address
+	 * (or the DNS name) of the STMC2 box.  Also the "mb628" should
+	 * substituted if you have a custom target-pack connect command.
+	 *
+	 * Note: The connect command used with "romgen", should connect
+	 * only in 29-bit mode - even if U-Boot will be built for 32-bit mode.
+	 * That is, do not use the "seuc=1" (or similar) option with "romgen".
+	 */
+#include "mb628.romgen"
+
+#ifdef CONFIG_SH_SE_MODE
+	/*
+	 * Note that we also manually need to move the LMI0 and LMI1 base addresses to
+	 * their 32-bit SE mode locations as defined in the datasheet and change the
+	 * 'upper bound addresses' (in row attribute registers) for the LMIs.
+	 */
+	UPDATE32(STX7141_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
+	UPDATE32(STX7141_SYSCONF_SYS_CFG39, 0xFFFFFF00, 0x00000080)
+	UPDATE32(ST40_LMI_SDRA0_0(0), 0x001FFFFF, 0x48000000)
+	UPDATE32(ST40_LMI_SDRA1_0(0), 0x001FFFFF, 0x48000000)
+	UPDATE32(ST40_LMI_SDRA0_0(1), 0x001FFFFF, 0x88000000)
+	UPDATE32(ST40_LMI_SDRA1_0(1), 0x001FFFFF, 0x88000000)
+#endif	/* CONFIG_SH_SE_MODE */
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/st/mb628/mb628.c b/board/st/mb628/mb628.c
new file mode 100644
index 0000000000..8aa355c150
--- /dev/null
+++ b/board/st/mb628/mb628.c
@@ -0,0 +1,135 @@
+/*
+ * (C) Copyright 2008-2009 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/soc.h>
+#include <asm/stx7141reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+
+/* EPLD registers */
+#ifdef CONFIG_SH_SE_MODE
+#define EPLD_BASE		0xb5000000	/* Phys 0x05000000 */
+#else
+#define EPLD_BASE		0xa5000000
+#endif	/* CONFIG_SH_SE_MODE */
+#define EPLD_IDENT		0x00010000
+#define EPLD_TEST		0x00020000
+#define EPLD_FLASH		0x00050000
+
+
+static inline void epld_write(unsigned long value, unsigned long offset)
+{
+	/* 8-bit write to EPLD registers */
+	writeb(value, EPLD_BASE + offset);
+}
+
+static inline unsigned long epld_read(unsigned long offset)
+{
+	/* 8-bit read from EPLD registers */
+	return readb(EPLD_BASE + offset);
+}
+
+extern void flashWriteEnable(void)
+{
+	/* Enable Vpp for writing to flash */
+	epld_write(3, EPLD_FLASH);
+}
+
+extern void flashWriteDisable(void)
+{
+	/* Disable Vpp for writing to flash */
+	epld_write(2, EPLD_FLASH);
+}
+
+static void configPIO(void)
+{
+	unsigned long sysconf;
+
+	/* Setup PIO of ASC device */
+	SET_PIO_ASC(PIO_PORT(10), 0, 1, 2, 3);  /* ASC1 */
+	SET_PIO_ASC(PIO_PORT(6),  0, 1, 2, 3);  /* ASC2 */
+
+	/* Enable ASC UARTS */
+	sysconf = *STX7141_SYSCONF_SYS_CFG36;
+	/* CFG36[29] = 0 = UART1_CTRL_NOT_MII_SEL */
+	sysconf &= 1ul << 29;
+	/* CFG36[30] = 1 = UART2_CTS_SEL */
+	/* CFG36[31] = 1 = UART2_RXD_SEL */
+	sysconf |= 1ul << 30 | 1ul << 31;
+	*STX7141_SYSCONF_SYS_CFG36 = sysconf;
+
+	/* Route ASC1 via PIO[10] for TX, RX, CTS & RTS */
+	sysconf = *STX7141_SYSCONF_SYS_CFG46;
+	/* PIO10[0] Selector: CFG46[7:6]   = 3 */
+	/* PIO10[1] Selector: CFG46[9:8]   = 3 */
+	/* PIO10[2] Selector: CFG46[11:10] = 3 */
+	/* PIO10[3] Selector: CFG46[13:12] = 3 */
+	sysconf |= 3ul << 6 | 3ul << 8 | 3ul << 10 | 3ul << 12;
+	*STX7141_SYSCONF_SYS_CFG46 = sysconf;
+
+	/* Route ASC2 via PIO[6] for TX & RX */
+	sysconf = *STX7141_SYSCONF_SYS_CFG20;
+	/* PIO6[0] Selector: CFG20[28:27] = 3 */
+	/* PIO6[0] Selector: CFG20[30:29] = 3 */
+	sysconf |= 3ul << 27 | 3ul << 29;
+	*STX7141_SYSCONF_SYS_CFG20 = sysconf;
+
+	/* Route ASC2 via PIO[6] for CTS & RTS */
+	sysconf = *STX7141_SYSCONF_SYS_CFG25;
+	/* PIO6[0] Selector: CFG25[1:0] = 3 */
+	/* PIO6[0] Selector: CFG25[3:2] = 3 */
+	sysconf |= 3ul << 0 | 3ul << 2;
+	*STX7141_SYSCONF_SYS_CFG25 = sysconf;
+}
+
+extern int board_init(void)
+{
+	configPIO();
+
+#if defined(CONFIG_SH_STM_SATA)
+	stx7141_configure_sata ();
+#endif	/* CONFIG_SH_STM_SATA */
+
+	return 0;
+}
+
+extern int checkboard (void)
+{
+	unsigned version;
+
+	printf ("\n\nBoard: STx7141-Mboard (MB628)"
+#ifdef CONFIG_SH_SE_MODE
+		"  [32-bit mode]"
+#else
+		"  [29-bit mode]"
+#endif
+		"\n");
+
+	version = epld_read(EPLD_IDENT);
+	printf("mb628 EPLD version %02d\n", version);
+	return 0;
+}
diff --git a/board/st/mb628/mb628.romgen b/board/st/mb628/mb628.romgen
new file mode 100644
index 0000000000..6b96f992b6
--- /dev/null
+++ b/board/st/mb628/mb628.romgen
@@ -0,0 +1,2423 @@
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x0d43c041) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x0d43c041) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+POKE32(0xfe213014, 0x00000000)
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+POKE32(0xfe213024, 0x00000000)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_ENABLE_FB
+*/
+/* PEEK(0xfe21301c) (used target peek value 0x00000000) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_ENABLE_FB
+*/
+WHILE_NE32(0xfe21301c, 0xffffffff, 0x00000000)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_ENABLE_FB
+*/
+/* PEEK(0xfe213020) (used target peek value 0x00000000) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_ENABLE_FB
+*/
+WHILE_NE32(0xfe213020, 0xffffffff, 0x00000000)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80003805) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x80103805)
+
+
+/*
+stx7141_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000000) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000001)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x00183805) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x00180f01)
+
+
+/*
+stx7141_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000001) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000000)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80100f01) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+WHILE_NE32(0xfe213000, 0x80000000, 0x80000000)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80100f01) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x80000f01)
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+POKE32(0xfe213014, 0x00000000)
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+POKE32(0xfe213024, 0x00000000)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80004a05) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x80104a05)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_DIV0_CFG
+*/
+POKE32(0xfe213b00, 0x00000103)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_DIV1_CFG
+*/
+POKE32(0xfe213b04, 0x00000001)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_DIV2_CFG
+*/
+POKE32(0xfe213b08, 0x00000001)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_DIV3_CFG
+*/
+POKE32(0xfe213b0c, 0x00000001)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0LS_DIV4_CFG
+*/
+POKE32(0xfe213a10, 0x00010100)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0LS_DIV5_CFG
+*/
+POKE32(0xfe213a14, 0x00010100)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0LS_DIV6_CFG
+*/
+POKE32(0xfe213a18, 0x00010100)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0LS_DIV7_CFG
+*/
+POKE32(0xfe213a1c, 0x00010100)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_DIV8_CFG
+*/
+POKE32(0xfe213b20, 0x00000103)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_DIV9_CFG
+*/
+POKE32(0xfe213b24, 0x00000103)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_DIV10_CFG
+*/
+POKE32(0xfe213b28, 0x00000307)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_DIV11_CFG
+*/
+POKE32(0xfe213b2c, 0x00000103)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_DIV12_CFG
+*/
+POKE32(0xfe213b30, 0x00000102)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0LS_DIV13_CFG
+*/
+POKE32(0xfe213a34, 0x00000811)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_DIV14_CFG
+*/
+POKE32(0xfe213b38, 0x0000050b)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_DIV15_CFG
+*/
+POKE32(0xfe213b3c, 0x00000307)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_DIV16_CFG
+*/
+POKE32(0xfe213b40, 0x00000103)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_DIV17_CFG
+*/
+POKE32(0xfe213b44, 0x00000103)
+
+
+/*
+stx7141_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000000) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000002)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x00184a05) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x00182803)
+
+
+/*
+stx7141_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000002) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000000)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80102803) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+WHILE_NE32(0xfe213004, 0x80000000, 0x80000000)
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80102803) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x80002803)
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+POKE32(0xfe213014, 0xa6aa55aa)
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+POKE32(0xfe213024, 0x0000000a)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x00000d28) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x00001d28)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x00001d28) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x000016a0)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000016a0) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x000006a0)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA3
+*/
+/* PEEK(0xfe001014) (used target peek value 0x00000000) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA3
+*/
+WHILE_NE32(0xfe001014, 0x00000001, 0x00000000)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213a10) (used target peek value 0x00010100) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213a14) (used target peek value 0x00010100) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213a18) (used target peek value 0x00010100) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213a1c) (used target peek value 0x00010100) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213b04) (used target peek value 0x00000001) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213b08) (used target peek value 0x00000001) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213b0c) (used target peek value 0x00000001) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213b00) (used target peek value 0x00000103) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213b20) (used target peek value 0x00000103) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213b24) (used target peek value 0x00000103) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+/* PEEK(0xfe213024) (used target peek value 0x0000000a) */
+/* PEEK(0xfe213b40) (used target peek value 0x00000103) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+/* PEEK(0xfe213024) (used target peek value 0x0000000a) */
+/* PEEK(0xfe213b44) (used target peek value 0x00000103) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213b28) (used target peek value 0x00000307) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213b2c) (used target peek value 0x00000103) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213b30) (used target peek value 0x00000102) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213a34) (used target peek value 0x00000811) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213b38) (used target peek value 0x0000050b) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa55aa) */
+/* PEEK(0xfe213b3c) (used target peek value 0x00000307) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000006a0) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x00000006) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG04
+*/
+POKE32(0xfe001110, 0x00000002)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000006a0) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x081b06a1)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG15
+*/
+/* PEEK(0xfe00113c) (used target peek value 0x00000000) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG15
+*/
+POKE32(0xfe00113c, 0x081b0001)
+DELAY(200)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x00000002) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG04
+*/
+POKE32(0xfe001110, 0x00000006)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa000787f)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG16
+*/
+POKE32(0xfe001140, 0xa000787f)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG38
+*/
+POKE32(0xfe001198, 0x000f000c)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG39
+*/
+POKE32(0xfe00119c, 0x000f0014)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x0042000a)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG14
+*/
+POKE32(0xfe001138, 0x00000000)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG17
+*/
+POKE32(0xfe001144, 0x0042000a)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG18
+*/
+POKE32(0xfe001148, 0x00000000)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x0800239e)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG37
+*/
+POKE32(0xfe001194, 0x0800039e)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG42
+*/
+POKE32(0xfe0011a8, 0x0000d068)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG43
+*/
+POKE32(0xfe0011ac, 0x00000000)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG44
+*/
+POKE32(0xfe0011b0, 0x0000d068)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG45
+*/
+POKE32(0xfe0011b4, 0x00000000)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG51
+*/
+POKE32(0xfe0011cc, 0x00000000)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG52
+*/
+POKE32(0xfe0011d0, 0x00000000)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG53
+*/
+POKE32(0xfe0011d4, 0x00000000)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG54
+*/
+POKE32(0xfe0011d8, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK_ENABLE
+*/
+POKE32(0xfe700860, 0x00000005)
+
+
+/*
+st40_emi_regs.EMI_BANK0_BASEADDRESS
+*/
+POKE32(0xfe700800, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_BASEADDRESS
+*/
+POKE32(0xfe700810, 0x00000010)
+
+
+/*
+st40_emi_regs.EMI_BANK2_BASEADDRESS
+*/
+POKE32(0xfe700820, 0x00000012)
+
+
+/*
+st40_emi_regs.EMI_BANK3_BASEADDRESS
+*/
+POKE32(0xfe700830, 0x00000014)
+
+
+/*
+st40_emi_regs.EMI_BANK4_BASEADDRESS
+*/
+POKE32(0xfe700840, 0x0000001c)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA0
+*/
+POKE32(0xfe700100, 0x001016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA1
+*/
+POKE32(0xfe700108, 0x9d200000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA2
+*/
+POKE32(0xfe700110, 0x9d220000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA3
+*/
+POKE32(0xfe700118, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA0
+*/
+POKE32(0xfe700140, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA1
+*/
+POKE32(0xfe700148, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA2
+*/
+POKE32(0xfe700150, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA3
+*/
+POKE32(0xfe700158, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA0
+*/
+POKE32(0xfe700180, 0x002046f9)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA1
+*/
+POKE32(0xfe700188, 0xa5a00000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA2
+*/
+POKE32(0xfe700190, 0xa5a20000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA3
+*/
+POKE32(0xfe700198, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA0
+*/
+POKE32(0xfe7001c0, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA1
+*/
+POKE32(0xfe7001c8, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA2
+*/
+POKE32(0xfe7001d0, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA3
+*/
+POKE32(0xfe7001d8, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA0
+*/
+POKE32(0xfe700200, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA1
+*/
+POKE32(0xfe700208, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA2
+*/
+POKE32(0xfe700210, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA3
+*/
+POKE32(0xfe700218, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_GENCFG
+*/
+POKE32(0xfe700028, 0x00000000)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x081b06a1) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30013b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_1
+*/
+POKE32(0xfe90100c, 0xffff0500)
+
+
+/*
+st40_lmigp_regs.LMI_STR_0
+*/
+POKE32(0xfe901018, 0x4d2db41b)
+
+
+/*
+st40_lmigp_regs.LMI_STR_1
+*/
+POKE32(0xfe90101c, 0x00222ed6)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA0_0
+*/
+POKE32(0xfe901030, 0x14001a20)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA1_0
+*/
+POKE32(0xfe901038, 0x14001a20)
+DELAY(200000)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020023)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00010000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00018000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00008004)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00000b53)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00000a53)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+/* PEEK(0xfe901008) (used target peek value 0x0b30013b) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30033b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+/* PEEK(0xfe901008) (used target peek value 0x0b30033b) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30031b)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_GCC_0
+*/
+POKE32(0xfe901028, 0x00000000)
+POKE32(0xac000000, 0x00000000)
+POKE32(0xac000000, 0xaaaaaaaa)
+/* PEEK(0xac000000) (used target peek value 0xaaaaaaaa) */
+POKE32(0xac001000, 0x00000000)
+POKE32(0xac001000, 0x55555555)
+/* PEEK(0xac001000) (used target peek value 0x55555555) */
+POKE32(0xac002000, 0x00000000)
+POKE32(0xac002000, 0x12345678)
+/* PEEK(0xac002000) (used target peek value 0x12345678) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x081b06a1) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe902008, 0x0b30013b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_1
+*/
+POKE32(0xfe90200c, 0xffff0500)
+
+
+/*
+st40_lmigp_regs.LMI_STR_0
+*/
+POKE32(0xfe902018, 0x4d2db41b)
+
+
+/*
+st40_lmigp_regs.LMI_STR_1
+*/
+POKE32(0xfe90201c, 0x00222ed6)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA0_0
+*/
+POKE32(0xfe902030, 0x1c001a20)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA1_0
+*/
+POKE32(0xfe902038, 0x1c001a20)
+DELAY(200000)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020023)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe902048, 0x00010000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe902048, 0x00018000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe902048, 0x00008004)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe902048, 0x00000b53)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe902048, 0x00000a53)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+/* PEEK(0xfe902008) (used target peek value 0x0b30013b) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe902008, 0x0b30033b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+/* PEEK(0xfe902008) (used target peek value 0x0b30033b) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe902008, 0x0b30031b)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe902010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_GCC_0
+*/
+POKE32(0xfe902028, 0x00000000)
+POKE32(0xb4000000, 0x00000000)
+POKE32(0xb4000000, 0xaaaaaaaa)
+/* PEEK(0xb4000000) (used target peek value 0xaaaaaaaa) */
+POKE32(0xb4001000, 0x00000000)
+POKE32(0xb4001000, 0x55555555)
+/* PEEK(0xb4001000) (used target peek value 0x55555555) */
+POKE32(0xb4002000, 0x00000000)
+POKE32(0xb4002000, 0x12345678)
+/* PEEK(0xb4002000) (used target peek value 0x12345678) */
+POKE32(0xfe2410fc, 0x00000001)
+POKE32(0xfe20a0ec, 0x00000002)
+POKE32(0xfe20a0f0, 0x00000005)
+POKE32(0xfe20a0f4, 0x00000003)
+POKE32(0xfe20a0f8, 0x00000003)
+POKE32(0xfe20a1ec, 0x00000002)
+POKE32(0xfe20a1f0, 0x00000005)
+POKE32(0xfe20a1f4, 0x00000003)
+POKE32(0xfe20a1f8, 0x00000003)
+POKE32(0xfe20a2ec, 0x00000002)
+POKE32(0xfe20a2f0, 0x00000005)
+POKE32(0xfe20a2f4, 0x00000003)
+POKE32(0xfe20a2f8, 0x00000003)
+POKE32(0xfe20a3ec, 0x00000002)
+POKE32(0xfe20a3f0, 0x00000005)
+POKE32(0xfe20a3f4, 0x00000003)
+POKE32(0xfe20a3f8, 0x00000003)
+POKE32(0xfe20aefc, 0x00000005)
+POKE32(0xfe540034, 0x00000003)
+POKE32(0xfe540038, 0x00000000)
+POKE32(0xfe540110, 0x00010303)
+POKE32(0xfe540114, 0x00000000)
+POKE32(0xfe20bb04, 0x00000005)
+POKE32(0xfe20bb08, 0x00000003)
+POKE32(0xfe20bb0c, 0x00000000)
+POKE32(0xfe20bb10, 0x00000002)
+POKE32(0xfe20bb24, 0x00000005)
+POKE32(0xfe20bb28, 0x00000003)
+POKE32(0xfe20bb2c, 0x00000000)
+POKE32(0xfe20bb30, 0x00000002)
+POKE32(0xfe20bb44, 0x00000005)
+POKE32(0xfe20bb48, 0x00000003)
+POKE32(0xfe20bb4c, 0x00000000)
+POKE32(0xfe20bb50, 0x00000002)
+POKE32(0xfe20bb84, 0x00000005)
+POKE32(0xfe20bb88, 0x00000003)
+POKE32(0xfe20bb8c, 0x00000000)
+POKE32(0xfe20bb90, 0x00000002)
+POKE32(0xfe231010, 0x00000008)
+POKE32(0xfe231080, 0x00000221)
+POKE32(0xfd101024, 0x0003c000)
+POKE32(0xfd101824, 0x0003c000)
+POKE32(0xfd104d24, 0x0003c000)
+POKE32(0xfd102024, 0x0003c000)
+POKE32(0xfd103024, 0x0003c000)
+/* PEEK(0xfe001180) (used target peek value 0x00000015) */
+POKE32(0xfe001180, 0x00000015)
+POKE32(0xfe1fff04, 0x00254608)
+/* PEEK(0xfe001180) (used target peek value 0x00000015) */
+POKE32(0xfe001180, 0x00000015)
+POKE32(0xfe209000, 0x00000013)
+POKE32(0xfe209004, 0x00000003)
+POKE32(0xfe209008, 0x00000000)
+/* PEEK(0xfe00111c) (used target peek value 0x08081000) */
+POKE32(0xfe00111c, 0x080b1000)
+POKE32(0xfd117000, 0x0025c608)
+POKE32(0xfd111000, 0x00201004)
+POKE32(0xfd11f000, 0x0025c608)
+POKE32(0xfd119000, 0x00201004)
+/* PEEK(0xfe001180) (used target peek value 0x00000015) */
+POKE32(0xfe001180, 0x00000011)
+POKE32(0xfe401744, 0x0025c005)
+
+
+/*
+st40_ccn_regs.CCN_CCR
+*/
+POKE32(0xff00001c, 0x8000090d)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG40
+*/
+/* PEEK(0xfe0011a0) (used target peek value 0x00000004) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG40
+*/
+POKE32(0xfe0011a0, 0x00000000)
+POKE32(0xfe000010, 0x0000c0de)
+POKE32(0xfe0000b8, 0x00000000)
+POKE32(0xfe000010, 0x0000c1a0)
+/* PEEK(0xfe210000) (used target peek value 0x00000000) */
+POKE32(0xfe210000, 0x00000000)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG40
+*/
+/* PEEK(0xfe0011a0) (used target peek value 0x00000000) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG40
+*/
+POKE32(0xfe0011a0, 0x00000000)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+/* PEEK(0xfe001120) (used target peek value 0x00000001) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00002085) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+/* PEEK(0xfe001120) (used target peek value 0x00000001) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+POKE32(0xfe001120, 0x00008001)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+/* PEEK(0xfe001120) (used target peek value 0x00008001) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+/* PEEK(0xfe001120) (used target peek value 0x00008001) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+POKE32(0xfe001120, 0x00008011)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+/* PEEK(0xfe001120) (used target peek value 0x00008011) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+POKE32(0xfe001120, 0x0000a011)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+/* PEEK(0xfe001120) (used target peek value 0x0000a011) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+POKE32(0xfe001120, 0x0000a091)
+DELAY(360000)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+/* PEEK(0xfe001120) (used target peek value 0x0000a091) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+POKE32(0xfe001120, 0x0000a891)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+/* PEEK(0xfe001120) (used target peek value 0x0000a891) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+POKE32(0xfe001120, 0x0000a811)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+/* PEEK(0xfe001120) (used target peek value 0x0000a811) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+POKE32(0xfe001120, 0x0000a011)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+/* PEEK(0xfe001120) (used target peek value 0x0000a011) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+POKE32(0xfe001120, 0x00008011)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+/* PEEK(0xfe001120) (used target peek value 0x00008011) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG08
+*/
+POKE32(0xfe001120, 0x00008013)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG09
+*/
+/* PEEK(0xfe001124) (used target peek value 0x10000a8c) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG09
+*/
+POKE32(0xfe001124, 0x18000a8c)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcc) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG28
+*/
+POKE32(0xfe001170, 0xfe604001)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcc) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG29
+*/
+POKE32(0xfe001174, 0x00001fcd)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcd) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG29
+*/
+POKE32(0xfe001174, 0x00001fcc)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG09
+*/
+/* PEEK(0xfe001124) (used target peek value 0x18000a8c) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG09
+*/
+POKE32(0xfe001124, 0x18000a8c)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG05
+*/
+/* PEEK(0xfe001114) (used target peek value 0x3f800000) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG05
+*/
+POKE32(0xfe001114, 0x3f800000)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd0) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG26
+*/
+POKE32(0xfe001168, 0xfe804001)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd0) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG27
+*/
+POKE32(0xfe00116c, 0x00001fd1)
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd1) */
+
+
+/*
+stx7141_sysconf_regs.SYSCONF_CFG27
+*/
+POKE32(0xfe00116c, 0x00001fd0)
diff --git a/board/st/mb628/nand.c b/board/st/mb628/nand.c
new file mode 100644
index 0000000000..5f098e5bbb
--- /dev/null
+++ b/board/st/mb628/nand.c
@@ -0,0 +1,87 @@
+/*
+ * (C) Copyright 2006 DENX Software Engineering
+ * (C) Copyright 2008 STMicroelectronics, Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <nand.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+#include <asm/stx7141reg.h>
+
+
+/*
+ * hardware specific access to control-lines
+ *	CL -> Emi_Addr(17)
+ *	AL -> Emi_Addr(18)
+ *	nCE is handled by EMI (not s/w controlable)
+ */
+static void mb618_hwcontrol(struct mtd_info *mtdinfo, int cmd)
+{
+	struct nand_chip* this = (struct nand_chip *)(mtdinfo->priv);
+
+	switch(cmd) {
+
+	case NAND_CTL_SETCLE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (1u << 17));
+		break;
+
+	case NAND_CTL_CLRCLE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(1u << 17));
+		break;
+
+	case NAND_CTL_SETALE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (1u << 18));
+		break;
+
+	case NAND_CTL_CLRALE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(1u << 18));
+		break;
+	}
+}
+
+
+/*
+ * Board-specific NAND initialization. The following members of the
+ * argument are board-specific (per include/linux/mtd/nand.h):
+ * - IO_ADDR_R?: address to read the 8 I/O lines of the flash device
+ * - IO_ADDR_W?: address to write the 8 I/O lines of the flash device
+ * - hwcontrol: hardwarespecific function for accesing control-lines
+ * - dev_ready: hardwarespecific function for  accesing device ready/busy line
+ * - enable_hwecc?: function to enable (reset)  hardware ecc generator. Must
+ *   only be provided if a hardware ECC is available
+ * - eccmode: mode of ecc, see defines
+ * - chip_delay: chip dependent delay for transfering data from array to
+ *   read regs (tR)
+ * - options: various chip options. They can partly be set to inform
+ *   nand_scan about special functionality. See the defines for further
+ *   explanation
+ * Members with a "?" were not set in the merged testing-NAND branch,
+ * so they are not set here either.
+ */
+extern int board_nand_init(struct nand_chip *nand)
+{
+	nand->hwcontrol = mb618_hwcontrol;
+	nand->eccmode = NAND_ECC_SOFT;
+	nand->chip_delay = 25;
+	nand->options = NAND_NO_AUTOINCR;
+	return 0;
+}
diff --git a/board/st/mb671/Makefile b/board/st/mb671/Makefile
new file mode 100644
index 0000000000..c99b16c9c9
--- /dev/null
+++ b/board/st/mb671/Makefile
@@ -0,0 +1,52 @@
+#
+# (C) Copyright 2007 STMicroelectronics.
+# Stuart Menefy <stuart.menefy@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+SOBJS	= init-$(BOARD).o
+
+COBJS	= $(BOARD).o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/st/mb671/config.mk b/board/st/mb671/config.mk
new file mode 100644
index 0000000000..9870753188
--- /dev/null
+++ b/board/st/mb671/config.mk
@@ -0,0 +1,44 @@
+#
+# (C) Copyright 2007-2008 STMicroelectronics.
+# Stuart Menefy <stuart.menefy@st.com>
+# Sean McGoogan <Sean.McGoogan@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# MB671 board:
+#
+#	Valid values for TEXT_BASE are:
+#
+#	0x97F00000	29-bit mode (Traditional Mode)
+#	0x8FF00000	32-bit mode (Space-Enhancement Mode)
+#
+# Note:	Alternative definitions of TEXT_BASE are put into
+#	'config.tmp' from the top-level 'Makefile'.
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+# Installs at LMI0 BASE + 255MB in P1 (cachable)
+TEXT_BASE = 0x97F00000
+endif
+
+PLATFORM_LDFLAGS +=
diff --git a/board/st/mb671/init-mb671.S b/board/st/mb671/init-mb671.S
new file mode 100644
index 0000000000..9e2f9fd3d4
--- /dev/null
+++ b/board/st/mb671/init-mb671.S
@@ -0,0 +1,77 @@
+#include "asm/stx7200reg.h"
+#include "../../../cpu/sh/init_ram.S"
+
+/*
+ * This is derived from STMicroelectronics gnu toolchain example:
+ *   sh-superh-elf/examples/os21/romdynamic/memory_mb671.S
+ */
+
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *	opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+/*
+ * For compatibility with old poke table code, we define some of the
+ * new names, to map onto the old names. Ultimately, the old poke table
+ * code will be updated to the "new order", and we can just delete
+ * the following mappings.
+ */
+#define POKE8(A, VAL)				POKE_CHAR(A, VAL)
+#define POKE16(A, VAL)				POKE_SHORT(A, VAL)
+#define POKE32(A, VAL)				POKE_LONG(A, VAL)
+#define OR32(A, VAL)				OR_LONG(A, VAL)
+#define UPDATE32(A, AND, OR)			UPDATE_LONG(A, AND, OR)
+#define POKE_UPDATE32(A1, A2, AND, SHIFT, OR)	POKE_UPDATE_LONG(A1, A2, AND, SHIFT, OR)
+#define WHILE_NE32(A, AND, VAL)			WHILE_NE(A, AND, VAL)
+#define DELAY(VAL)				/* do nothing */
+
+
+	.section .data.init, "a"
+
+	.balign 32
+
+__memory_setup_table:
+
+	/*
+	 * include the appropriate set of "GDB pokes", (usually) generated
+	 * using the "romgen" utility, from a known good target-pack.
+	 *
+	 * This file may be regenerated by connecting your specific board
+	 * to an STMC2 (note: currently it must be version 2) and then
+	 * executing the following command (redirecting the output):
+	 *
+	 * host% romgen --target-connect --show-comment <stmc2>:mb671:st40
+	 *
+	 * Where "<stmc2>" should be replaced with the IP address
+	 * (or the DNS name) of the STMC2 box.  Also the "mb671" should
+	 * substituted if you have a custom target-pack connect command.
+	 *
+	 * Note: The connect command used with "romgen", should connect
+	 * only in 29-bit mode - even if U-Boot will be built for 32-bit mode.
+	 * That is, do not use the "seuc=1" (or similar) option with "romgen".
+	 */
+#include "mb671.romgen"
+
+#ifdef CONFIG_SH_SE_MODE
+	/*
+	 * Note that we also manually need to move the LMI0 and LMI1 base addresses to
+	 * their 32-bit SE mode locations as defined in the datasheet and change the
+	 * 'upper bound addresses' (in row attribute registers) for the LMIs.
+	 */
+	UPDATE_LONG(STX7200_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
+	UPDATE_LONG(STX7200_SYSCONF_SYS_CFG39, 0xFFFFFF00, 0x00000080)
+	POKE_LONG(ST40_LMI_SDRA0_0(0), 0x50001a00)
+	POKE_LONG(ST40_LMI_SDRA1_0(0), 0x50001a00)
+	POKE_LONG(ST40_LMI_SDRA0_0(1), 0x90001a00)
+	POKE_LONG(ST40_LMI_SDRA1_0(1), 0x90001a00)
+#endif	/* CONFIG_SH_SE_MODE */
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/st/mb671/mb671.c b/board/st/mb671/mb671.c
new file mode 100644
index 0000000000..073fe75a3d
--- /dev/null
+++ b/board/st/mb671/mb671.c
@@ -0,0 +1,149 @@
+/*
+ * (C) Copyright 2007-2009 STMicroelectronics.
+ *
+ * Stuart Menefy <stuart.menefy@st.com>
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/soc.h>
+#include <asm/stx7200reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+#ifdef CONFIG_SH_SE_MODE
+#define EPLD_BASE		0xb5000000	/* Phys 0x05000000 */
+#else
+#define EPLD_BASE		0xa5000000
+#endif	/* CONFIG_SH_SE_MODE */
+
+#define EPLD_FlashCtrlAddr	SH4_WORD_REG(EPLD_BASE + 0x400000)
+
+extern void flashWriteEnable(void)
+{
+	/*  Enable vpp for writing to flash */
+	*EPLD_FlashCtrlAddr = 3;
+}
+
+extern void flashWriteDisable(void)
+{
+	/*  Disable vpp for writing to flash */
+	*EPLD_FlashCtrlAddr = 2;
+}
+
+#define PIO_BASE  0xfd020000
+
+static void configPIO(void)
+{
+	/*  Setup PIO of ASC device */
+	SET_PIO_ASC(PIO_PORT(4), 3, 2, 4, 5);  /* UART2 - AS0 */
+	SET_PIO_ASC(PIO_PORT(5), 4, 3, 5, 6);  /* UART3 - AS1 */
+}
+
+extern int board_init(void)
+{
+	unsigned long sysconf;
+
+	/* Serial port set up */
+	/* Route UART2&3 or SCI inputs instead of DVP to pins: conf_pad_dvp = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG40;
+	sysconf &= ~(1<<16);
+	*STX7200_SYSCONF_SYS_CFG40 = sysconf;
+
+	/* Route UART2&3/SCI outputs instead of DVP to pins: conf_pad_pio[1]=0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<25);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* No idea, more routing: conf_pad_pio[0] = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<24);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* Route UART2 (inputs and outputs) instead of SCI to pins: ssc2_mux_sel = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<2);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* conf_pad_pio[4] = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<28);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* Route UART3 (inputs and outputs) instead of SCI to pins: ssc3_mux_sel = 0 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~(1<<3);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* conf_pad_clkobs = 1 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf |= (1<<14);
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* I2C and USB related routing */
+	/* bit4: ssc4_mux_sel = 0 (treat SSC4 as I2C) */
+	/* bit26: conf_pad_pio[2] = 0 route USB etc instead of DVO */
+	/* bit27: conf_pad_pio[3] = 0 DVO output selection (probably ignored) */
+	sysconf = *STX7200_SYSCONF_SYS_CFG07;
+	sysconf &= ~((1<<27)|(1<<26)|(1<<4));
+	*STX7200_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* Enable SOFT_JTAG mode.
+	 * Taken from OS21, but is this correct?
+	 */
+	sysconf = *STX7200_SYSCONF_SYS_CFG33;
+	sysconf |= (1<<6);
+	sysconf &= ~((1<<0)|(1<<1)|(1<<2)|(1<<3));
+	*STX7200_SYSCONF_SYS_CFG33 = sysconf;
+
+	configPIO();
+
+	return 0;
+}
+
+
+extern int checkboard (void)
+{
+	printf ("\n\nBoard: STx7200-Reference (MB671)"
+#ifdef CONFIG_SH_SE_MODE
+		"  [32-bit mode]"
+#else
+		"  [29-bit mode]"
+#endif
+		"\n");
+
+#ifdef CONFIG_DRIVER_NETSTMAC
+#if defined(CONFIG_STMAC_MAC0)
+	/* On-board PHY on MII0 in RMII mode, using MII_CLK */
+	stx7200_configure_ethernet (0, 1, 0, 0);
+#elif defined(CONFIG_STMAC_MAC1)
+	/* External PHY on MII1 in MII mode, using its own clock */
+	stx7200_configure_ethernet (1, 0, 1, 1);
+#endif
+#endif	/* CONFIG_DRIVER_NETSTMAC */
+
+#if defined(CONFIG_SH_STM_SATA)
+	stx7200_configure_sata ();
+#endif	/* CONFIG_SH_STM_SATA */
+
+	return 0;
+}
diff --git a/board/st/mb671/mb671.romgen b/board/st/mb671/mb671.romgen
new file mode 100644
index 0000000000..17b91e0bcb
--- /dev/null
+++ b/board/st/mb671/mb671.romgen
@@ -0,0 +1,1572 @@
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfd704000) (used target peek value 0x1d437041) */
+/* PEEK(0xa5020000) (used target peek value 0x000b000b) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+/* PEEK(0xfd700000) (used target peek value 0x80101400) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+POKE32(0xfd700000, 0x80101400)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfd70001c) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+POKE32(0xfd70001c, 0x00000001)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+/* PEEK(0xfd700000) (used target peek value 0x00181400) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+POKE32(0xfd700000, 0x00180f01)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfd70001c) (used target peek value 0x00000001) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+POKE32(0xfd70001c, 0x00000000)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+/* PEEK(0xfd700000) (used target peek value 0x80100f01) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+WHILE_NE32(0xfd700000, 0x80000000, 0x80000000)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+/* PEEK(0xfd700000) (used target peek value 0x80100f01) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+POKE32(0xfd700000, 0x80000f01)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+/* PEEK(0xfd700004) (used target peek value 0x80100a00) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+POKE32(0xfd700004, 0x80100a00)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfd70001c) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+POKE32(0xfd70001c, 0x00000002)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+/* PEEK(0xfd700004) (used target peek value 0x00180a00) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+POKE32(0xfd700004, 0x00180f01)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfd70001c) (used target peek value 0x00000002) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+POKE32(0xfd70001c, 0x00000000)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+/* PEEK(0xfd700004) (used target peek value 0x80100f01) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+WHILE_NE32(0xfd700004, 0x80000000, 0x80000000)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+/* PEEK(0xfd700004) (used target peek value 0x80100f01) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+POKE32(0xfd700004, 0x80000f01)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+/* PEEK(0xfd700008) (used target peek value 0x80102803) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+POKE32(0xfd700008, 0x80102803)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfd70001c) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+POKE32(0xfd70001c, 0x00000004)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+/* PEEK(0xfd700008) (used target peek value 0x00182803) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+POKE32(0xfd700008, 0x00182803)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+/* PEEK(0xfd70001c) (used target peek value 0x00000004) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_POWER_CFG
+*/
+POKE32(0xfd70001c, 0x00000000)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+/* PEEK(0xfd700008) (used target peek value 0x80102803) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+WHILE_NE32(0xfd700008, 0x80000000, 0x80000000)
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+/* PEEK(0xfd700008) (used target peek value 0x80102803) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+POKE32(0xfd700008, 0x80002803)
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+/* PEEK(0xfd70103c) (used target peek value 0x80102803) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+POKE32(0xfd70103c, 0x80102803)
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_POWER_CFG
+*/
+/* PEEK(0xfd701058) (used target peek value 0x00007ff8) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_POWER_CFG
+*/
+POKE32(0xfd701058, 0x0000fff8)
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+/* PEEK(0xfd70103c) (used target peek value 0x00182803) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+POKE32(0xfd70103c, 0x00182803)
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_POWER_CFG
+*/
+/* PEEK(0xfd701058) (used target peek value 0x0000fff8) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_POWER_CFG
+*/
+POKE32(0xfd701058, 0x00007ff8)
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+/* PEEK(0xfd70103c) (used target peek value 0x80102803) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+WHILE_NE32(0xfd70103c, 0x80000000, 0x80000000)
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+/* PEEK(0xfd70103c) (used target peek value 0x80102803) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+POKE32(0xfd70103c, 0x80002803)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+/* PEEK(0xfd70412c) (used target peek value 0x00000d28) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+POKE32(0xfd70412c, 0x00001d28)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+/* PEEK(0xfd70412c) (used target peek value 0x00001d28) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+POKE32(0xfd70412c, 0x000016a0)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+/* PEEK(0xfd70412c) (used target peek value 0x000016a0) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+POKE32(0xfd70412c, 0x000006a0)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfd704000) (used target peek value 0x1d437041) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA03
+*/
+/* PEEK(0xfd704014) (used target peek value 0x1f10e795) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA03
+*/
+WHILE_NE32(0xfd704014, 0x00000001, 0x00000001)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfd704000) (used target peek value 0x1d437041) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfd704000) (used target peek value 0x1d437041) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA01
+*/
+/* PEEK(0xfd70400c) (used target peek value 0x00000040) */
+/* PEEK(0xa5000000) (used target peek value 0x00110011) */
+/* PEEK(0xa5020000) (used target peek value 0x000b000b) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfd704000) (used target peek value 0x1d437041) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL0_CFG
+*/
+/* PEEK(0xfd700000) (used target peek value 0x80000f01) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL1_CFG
+*/
+/* PEEK(0xfd700004) (used target peek value 0x80000f01) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_PLL2_CFG
+*/
+/* PEEK(0xfd700008) (used target peek value 0x80002803) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_PLL0_CFG
+*/
+/* PEEK(0xfd70103c) (used target peek value 0x80002803) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+/* PEEK(0xfd70412c) (used target peek value 0x000006a0) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_MUX_CFG
+*/
+/* PEEK(0xfd70000c) (used target peek value 0x00000071) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV_CFG
+*/
+/* PEEK(0xfd700010) (used target peek value 0x002ffd93) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
+*/
+/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_DIV2_CFG
+*/
+/* PEEK(0xfd701050) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
+*/
+/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
+*/
+/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_DIV2_CFG
+*/
+/* PEEK(0xfd701050) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
+*/
+/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_MUX_CFG
+*/
+/* PEEK(0xfd70000c) (used target peek value 0x00000071) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
+*/
+/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_DIV2_CFG
+*/
+/* PEEK(0xfd701050) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_DIV2_CFG
+*/
+/* PEEK(0xfd701050) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgenb_regs.CLOCKGENB_DIV2_CFG
+*/
+/* PEEK(0xfd701050) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_clockgena_regs.CLOCKGENA_DIV2_CFG
+*/
+/* PEEK(0xfd700014) (used target peek value 0x00ffffe4) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG58
+*/
+/* PEEK(0xfd7041e8) (used target peek value 0x00000001) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG58
+*/
+POKE32(0xfd7041e8, 0x00000000)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+/* PEEK(0xfd70412c) (used target peek value 0x000006a0) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG11
+*/
+POKE32(0xfd70412c, 0x080006a1)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG15
+*/
+/* PEEK(0xfd70413c) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG15
+*/
+POKE32(0xfd70413c, 0x08000001)
+DELAY(200)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG58
+*/
+/* PEEK(0xfd7041e8) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG58
+*/
+POKE32(0xfd7041e8, 0x00000001)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA03
+*/
+/* PEEK(0xfd704014) (used target peek value 0x1f13ef95) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA03
+*/
+WHILE_NE32(0xfd704014, 0x00100400, 0x00100400)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA05
+*/
+/* PEEK(0xfd70401c) (used target peek value 0x1f1bd47a) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_STA05
+*/
+WHILE_NE32(0xfd70401c, 0x00100400, 0x00100400)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG12
+*/
+POKE32(0xfd704130, 0xa200780f)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG16
+*/
+POKE32(0xfd704140, 0xa200780f)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG38
+*/
+POKE32(0xfd704198, 0x000ffd08)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG39
+*/
+POKE32(0xfd70419c, 0x000ffd18)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG13
+*/
+POKE32(0xfd704134, 0x00000002)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG14
+*/
+POKE32(0xfd704138, 0x00000002)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG17
+*/
+POKE32(0xfd704144, 0x00000002)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG18
+*/
+POKE32(0xfd704148, 0x00000002)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG55
+*/
+POKE32(0xfd7041dc, 0x03fc2380)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG56
+*/
+POKE32(0xfd7041e0, 0x03fc2380)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG42
+*/
+POKE32(0xfd7041a8, 0x07b7dbed)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG43
+*/
+POKE32(0xfd7041ac, 0x000001ed)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG44
+*/
+POKE32(0xfd7041b0, 0x07b7dbed)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG45
+*/
+POKE32(0xfd7041b4, 0x000001ed)
+
+
+/*
+st40_emi_regs.EMI_BANK_ENABLE
+*/
+POKE32(0xfdf00860, 0x00000005)
+
+
+/*
+st40_emi_regs.EMI_BANK0_BASEADDRESS
+*/
+POKE32(0xfdf00800, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_BASEADDRESS
+*/
+POKE32(0xfdf00810, 0x00000008)
+
+
+/*
+st40_emi_regs.EMI_BANK2_BASEADDRESS
+*/
+POKE32(0xfdf00820, 0x0000000c)
+
+
+/*
+st40_emi_regs.EMI_BANK3_BASEADDRESS
+*/
+POKE32(0xfdf00830, 0x00000010)
+
+
+/*
+st40_emi_regs.EMI_BANK4_BASEADDRESS
+*/
+POKE32(0xfdf00840, 0x00000014)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA0
+*/
+POKE32(0xfdf00100, 0x001016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA1
+*/
+POKE32(0xfdf00108, 0x9d200000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA2
+*/
+POKE32(0xfdf00110, 0x9d220000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA3
+*/
+POKE32(0xfdf00118, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA0
+*/
+POKE32(0xfdf00180, 0x002046f9)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA1
+*/
+POKE32(0xfdf00188, 0xa5a00000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA2
+*/
+POKE32(0xfdf00190, 0xa5a20000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA3
+*/
+POKE32(0xfdf00198, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA0
+*/
+POKE32(0xfdf00200, 0x042086f1)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA1
+*/
+POKE32(0xfdf00208, 0x8a002200)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA2
+*/
+POKE32(0xfdf00210, 0x8a004200)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA3
+*/
+POKE32(0xfdf00218, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_GENCFG
+*/
+POKE32(0xfdf00028, 0x00000050)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfdd18008, 0x07f6015b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_1
+*/
+POKE32(0xfdd1800c, 0x000000b0)
+
+
+/*
+st40_lmigp_regs.LMI_STR_0
+*/
+POKE32(0xfdd18018, 0xcd2db41b)
+
+
+/*
+st40_lmigp_regs.LMI_STR_1
+*/
+POKE32(0xfdd1801c, 0x002202d6)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA0_0
+*/
+POKE32(0xfdd18030, 0x18001a20)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA1_0
+*/
+POKE32(0xfdd18038, 0x18001a20)
+DELAY(200000)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020023)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd18048, 0x00010000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd18048, 0x00018000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd18048, 0x00008004)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd18048, 0x00000b53)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd18048, 0x00000a53)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfdd18008, 0x07f6035b)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd18010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_GCC_0
+*/
+POKE32(0xfdd18028, 0x00000000)
+POKE32(0xa8000000, 0x00000000)
+POKE32(0xa8000000, 0xaaaaaaaa)
+/* PEEK(0xa8000000) (used target peek value 0xaaaaaaaa) */
+POKE32(0xa8001000, 0x00000000)
+POKE32(0xa8001000, 0x55555555)
+/* PEEK(0xa8001000) (used target peek value 0x55555555) */
+POKE32(0xa8002000, 0x00000000)
+POKE32(0xa8002000, 0x12345678)
+/* PEEK(0xa8002000) (used target peek value 0x12345678) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfdd19008, 0x07f6015b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_1
+*/
+POKE32(0xfdd1900c, 0x000000b0)
+
+
+/*
+st40_lmigp_regs.LMI_STR_0
+*/
+POKE32(0xfdd19018, 0xcd2db41b)
+
+
+/*
+st40_lmigp_regs.LMI_STR_1
+*/
+POKE32(0xfdd1901c, 0x002202d6)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA0_0
+*/
+POKE32(0xfdd19030, 0x1c001a20)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA1_0
+*/
+POKE32(0xfdd19038, 0x1c001a20)
+DELAY(200000)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020023)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd19048, 0x00010000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd19048, 0x00018000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd19048, 0x00008004)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd19048, 0x00000b53)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfdd19048, 0x00000a53)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfdd19008, 0x07f6035b)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfdd19010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_GCC_0
+*/
+POKE32(0xfdd19028, 0x00000000)
+POKE32(0xb8000000, 0x00000000)
+POKE32(0xb8000000, 0xaaaaaaaa)
+/* PEEK(0xb8000000) (used target peek value 0xaaaaaaaa) */
+POKE32(0xb8001000, 0x00000000)
+POKE32(0xb8001000, 0x55555555)
+/* PEEK(0xb8001000) (used target peek value 0x55555555) */
+POKE32(0xb8002000, 0x00000000)
+POKE32(0xb8002000, 0x12345678)
+/* PEEK(0xb8002000) (used target peek value 0x12345678) */
+
+
+/*
+st40_ccn_regs.CCN_CCR
+*/
+POKE32(0xff00001c, 0x8000090d)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG05
+*/
+/* PEEK(0xfd704114) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG05
+*/
+POKE32(0xfd704114, 0x00000000)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG09
+*/
+/* PEEK(0xfd704124) (used target peek value 0x00000a8c) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG09
+*/
+POKE32(0xfd704124, 0x08000a8c)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG29
+*/
+/* PEEK(0xfd704174) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG28
+*/
+POKE32(0xfd704170, 0x00004001)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG29
+*/
+/* PEEK(0xfd704174) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG29
+*/
+POKE32(0xfd704174, 0x00000001)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG29
+*/
+/* PEEK(0xfd704174) (used target peek value 0x00000001) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG29
+*/
+POKE32(0xfd704174, 0x00000000)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG05
+*/
+/* PEEK(0xfd704114) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG05
+*/
+POKE32(0xfd704114, 0x00000000)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG09
+*/
+/* PEEK(0xfd704124) (used target peek value 0x08000a8c) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG09
+*/
+POKE32(0xfd704124, 0x08000a8c)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG27
+*/
+/* PEEK(0xfd70416c) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG26
+*/
+POKE32(0xfd704168, 0x00004001)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG27
+*/
+/* PEEK(0xfd70416c) (used target peek value 0x00000000) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG27
+*/
+POKE32(0xfd70416c, 0x00000001)
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG27
+*/
+/* PEEK(0xfd70416c) (used target peek value 0x00000001) */
+
+
+/*
+sti7200_sysconf_regs.SYSCONF_SYS_CFG27
+*/
+POKE32(0xfd70416c, 0x00000000)
diff --git a/board/st/mb680/Makefile b/board/st/mb680/Makefile
new file mode 100644
index 0000000000..e71bce43bb
--- /dev/null
+++ b/board/st/mb680/Makefile
@@ -0,0 +1,54 @@
+#
+# (C) Copyright 2007 STMicroelectronics.
+# Stuart Menefy <stuart.menefy@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+SOBJS-y	= init-$(BOARD).o
+
+COBJS-y	+= $(BOARD).o
+COBJS-$(CONFIG_CMD_NAND) += nand.o
+
+
+SRCS	:= $(SOBJS-y:.o=.S) $(COBJS-y:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS-y))
+SOBJS	:= $(addprefix $(obj),$(SOBJS-y))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/st/mb680/config.mk b/board/st/mb680/config.mk
new file mode 100644
index 0000000000..e79b8e0e9f
--- /dev/null
+++ b/board/st/mb680/config.mk
@@ -0,0 +1,43 @@
+#
+# (C) Copyright 2008 STMicroelectronics.
+# Sean McGoogan <Sean.McGoogan@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# MB680 board:
+#
+#	Valid values for TEXT_BASE are:
+#
+#	0x9BF00000	29-bit mode (Traditional Mode)
+#	0x8FF00000	32-bit mode (Space-Enhancement Mode)
+#
+# Note:	Alternative definitions of TEXT_BASE are put into
+#	'config.tmp' from the top-level 'Makefile'.
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+# Installs at LMI0 BASE + 255MB in P1 (cachable)
+TEXT_BASE = 0x9BF00000
+endif
+
+PLATFORM_LDFLAGS +=
diff --git a/board/st/mb680/init-mb680.S b/board/st/mb680/init-mb680.S
new file mode 100644
index 0000000000..dd070ee358
--- /dev/null
+++ b/board/st/mb680/init-mb680.S
@@ -0,0 +1,81 @@
+#include "asm/stx7105reg.h"
+#include "../../../cpu/sh/init_ram.S"
+
+/*
+ * This is derived from STMicroelectronics gnu toolchain example:
+ *   sh-superh-elf/examples/os21/romdynamic/memory_mb680.S
+ */
+
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *	opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+/*
+ * For compatibility with old poke table code, we define some of the
+ * new names, to map onto the old names. Ultimately, the old poke table
+ * code will be updated to the "new order", and we can just delete
+ * the following mappings.
+ */
+#define POKE8(A, VAL)				POKE_CHAR(A, VAL)
+#define POKE16(A, VAL)				POKE_SHORT(A, VAL)
+#define POKE32(A, VAL)				POKE_LONG(A, VAL)
+#define OR32(A, VAL)				OR_LONG(A, VAL)
+#define UPDATE32(A, AND, OR)			UPDATE_LONG(A, AND, OR)
+#define POKE_UPDATE32(A1, A2, AND, SHIFT, OR)	POKE_UPDATE_LONG(A1, A2, AND, SHIFT, OR)
+#define WHILE_NE32(A, AND, VAL)			WHILE_NE(A, AND, VAL)
+#define DELAY(VAL)				/* do nothing */
+
+
+	.section .data.init, "a"
+
+	.balign 32
+
+__memory_setup_table:
+
+	/*
+	 * include the appropriate set of "GDB pokes", (usually) generated
+	 * using the "romgen" utility, from a known good target-pack.
+	 *
+	 * This file may be regenerated by connecting your specific board
+	 * to an STMC2 (note: currently it must be version 2) and then
+	 * executing the following command (redirecting the output):
+	 *
+	 * host% romgen --target-connect --show-comment <stmc2>:mb680:st40
+	 *
+	 * Where "<stmc2>" should be replaced with the IP address
+	 * (or the DNS name) of the STMC2 box.  Also the "mb680" should
+	 * substituted if you have a custom target-pack connect command.
+	 *
+	 * Note: The connect command used with "romgen", should connect
+	 * only in 29-bit mode - even if U-Boot will be built for 32-bit mode.
+	 * That is, do not use the "seuc=1" (or similar) option with "romgen".
+	 */
+#if 1
+#include "mb680-stx7105c2.romgen"	/* for STx7105 cut 2.x */
+#else
+#include "mb680-stx7105c1.romgen"	/* for STx7105 cut 1.x */
+#endif
+
+#ifdef CONFIG_SH_SE_MODE
+	/*
+	 * Note that we also manually need to move the LMI base addresses to
+	 * their 32-bit SE mode locations as defined in the datasheet and change the
+	 * 'upper bound addresses' (in row attribute registers) for the LMIs.
+	 */
+	UPDATE32(STX7105_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
+	/* Change LMI upper bound addresses
+	 # Upper LMI addr=0x40000000 + 256MiB=0x50000000
+	 */
+	UPDATE32(ST40_LMI_SDRA0_0(), 0x001FFFFF, 0x50000000)
+	UPDATE32(ST40_LMI_SDRA1_0(), 0x001FFFFF, 0x50000000)
+#endif	/* CONFIG_SH_SE_MODE */
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/st/mb680/mb680-stx7105c1.romgen b/board/st/mb680/mb680-stx7105c1.romgen
new file mode 100644
index 0000000000..e93eb56ac7
--- /dev/null
+++ b/board/st/mb680/mb680-stx7105c1.romgen
@@ -0,0 +1,1653 @@
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x0d43e041) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+/* PEEK(0xfe0011a0) (used target peek value 0x00000004) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+POKE32(0xfe0011a0, 0x00000004)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x0d43e041) */
+POKE32(0xfe000010, 0x0000c0de)
+POKE32(0xfe0000b8, 0x00000001)
+POKE32(0xfe000010, 0x0000c1a0)
+/* PEEK(0xfe210000) (used target peek value 0x00000000) */
+POKE32(0xfe210000, 0x00800000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+/* PEEK(0xfe0011a0) (used target peek value 0x00000004) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+POKE32(0xfe0011a0, 0x00000005)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x0d43e041) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+POKE32(0xfe213014, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+POKE32(0xfe213024, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_ENABLE_FB
+*/
+/* PEEK(0xfe21301c) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_ENABLE_FB
+*/
+WHILE_NE32(0xfe21301c, 0xffffffff, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_ENABLE_FB
+*/
+/* PEEK(0xfe213020) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_ENABLE_FB
+*/
+WHILE_NE32(0xfe213020, 0xffffffff, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80001e02) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x80101e02)
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000001)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x00181e02) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x00180f01)
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000001) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80100f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+WHILE_NE32(0xfe213000, 0x80000000, 0x80000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80100f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x80000f01)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x80102803)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV0_CFG
+*/
+POKE32(0xfe213b00, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV1_CFG
+*/
+POKE32(0xfe213b04, 0x00000001)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV2_CFG
+*/
+POKE32(0xfe213b08, 0x00000001)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV3_CFG
+*/
+POKE32(0xfe213b0c, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0LS_DIV4_CFG
+*/
+POKE32(0xfe213a10, 0x00010100)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV5_CFG
+*/
+POKE32(0xfe213b14, 0x00000307)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0LS_DIV6_CFG
+*/
+POKE32(0xfe213a18, 0x00010100)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0LS_DIV7_CFG
+*/
+POKE32(0xfe213a1c, 0x00010100)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV8_CFG
+*/
+POKE32(0xfe213b20, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV9_CFG
+*/
+POKE32(0xfe213b24, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV10_CFG
+*/
+POKE32(0xfe213b28, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV11_CFG
+*/
+POKE32(0xfe213b2c, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV12_CFG
+*/
+POKE32(0xfe213b30, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0LS_DIV13_CFG
+*/
+POKE32(0xfe213a34, 0x00000811)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV14_CFG
+*/
+POKE32(0xfe213b38, 0x0000050b)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV15_CFG
+*/
+POKE32(0xfe213b3c, 0x00000307)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV16_CFG
+*/
+POKE32(0xfe213b40, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV17_CFG
+*/
+POKE32(0xfe213b44, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000002)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x00182803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x00182803)
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000002) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80102803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+WHILE_NE32(0xfe213004, 0x80000000, 0x80000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80102803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x80002803)
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+POKE32(0xfe213014, 0xa6aa59aa)
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+POKE32(0xfe213024, 0x0000000a)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x00000d28) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x00001d28)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x00001d28) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x000016a0)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000016a0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x000006a0)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA3
+*/
+/* PEEK(0xfe001014) (used target peek value 0x1f032c9c) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA3
+*/
+WHILE_NE32(0xfe001014, 0x00000001, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a10) (used target peek value 0x00010100) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a18) (used target peek value 0x00010100) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a1c) (used target peek value 0x00010100) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b04) (used target peek value 0x00000001) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b08) (used target peek value 0x00000001) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b00) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b20) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b24) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b28) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+/* PEEK(0xfe213024) (used target peek value 0x0000000a) */
+/* PEEK(0xfe213b40) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+/* PEEK(0xfe213024) (used target peek value 0x0000000a) */
+/* PEEK(0xfe213b44) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b14) (used target peek value 0x00000307) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b2c) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b30) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a34) (used target peek value 0x00000811) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b38) (used target peek value 0x0000050b) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b3c) (used target peek value 0x00000307) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000006a0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x00000126) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+POKE32(0xfe001110, 0x00000122)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000006a0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x080246a1)
+DELAY(200)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x00000122) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+POKE32(0xfe001110, 0x00000126)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA3
+*/
+/* PEEK(0xfe001014) (used target peek value 0x1f13ac9c) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA3
+*/
+WHILE_NE32(0xfe001014, 0x00100400, 0x00100400)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa000787f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+POKE32(0xfe001198, 0x002f000c)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x00400002)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+POKE32(0xfe001138, 0x00000002)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x07fc23dc)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+POKE32(0xfe0011a8, 0x07afd7eb)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+POKE32(0xfe0011ac, 0x00b001eb)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG51
+*/
+POKE32(0xfe0011cc, 0x01eb01eb)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG52
+*/
+POKE32(0xfe0011d0, 0x01eb01eb)
+
+
+/*
+st40_emi_regs.EMI_BANK_ENABLE
+*/
+POKE32(0xfe700860, 0x00000005)
+
+
+/*
+st40_emi_regs.EMI_BANK0_BASEADDRESS
+*/
+POKE32(0xfe700800, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_BASEADDRESS
+*/
+POKE32(0xfe700810, 0x00000010)
+
+
+/*
+st40_emi_regs.EMI_BANK2_BASEADDRESS
+*/
+POKE32(0xfe700820, 0x00000012)
+
+
+/*
+st40_emi_regs.EMI_BANK3_BASEADDRESS
+*/
+POKE32(0xfe700830, 0x00000014)
+
+
+/*
+st40_emi_regs.EMI_BANK4_BASEADDRESS
+*/
+POKE32(0xfe700840, 0x0000001c)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA0
+*/
+POKE32(0xfe700100, 0x001016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA1
+*/
+POKE32(0xfe700108, 0x9d200000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA2
+*/
+POKE32(0xfe700110, 0x9d220000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA3
+*/
+POKE32(0xfe700118, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA0
+*/
+POKE32(0xfe700140, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA1
+*/
+POKE32(0xfe700148, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA2
+*/
+POKE32(0xfe700150, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA3
+*/
+POKE32(0xfe700158, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA0
+*/
+POKE32(0xfe700180, 0x002046f9)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA1
+*/
+POKE32(0xfe700188, 0xa5a00000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA2
+*/
+POKE32(0xfe700190, 0xa5a20000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA3
+*/
+POKE32(0xfe700198, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA0
+*/
+POKE32(0xfe7001c0, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA1
+*/
+POKE32(0xfe7001c8, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA2
+*/
+POKE32(0xfe7001d0, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA3
+*/
+POKE32(0xfe7001d8, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA0
+*/
+POKE32(0xfe700200, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA1
+*/
+POKE32(0xfe700208, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA2
+*/
+POKE32(0xfe700210, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA3
+*/
+POKE32(0xfe700218, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_GENCFG
+*/
+POKE32(0xfe700028, 0x00000010)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x080246a1) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30017b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_1
+*/
+POKE32(0xfe90100c, 0x000000b0)
+
+
+/*
+st40_lmigp_regs.LMI_STR_0
+*/
+POKE32(0xfe901018, 0xcd2db41b)
+
+
+/*
+st40_lmigp_regs.LMI_STR_1
+*/
+POKE32(0xfe90101c, 0x00222ed6)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA0_0
+*/
+POKE32(0xfe901030, 0x1c001a20)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA1_0
+*/
+POKE32(0xfe901038, 0x1c001a20)
+DELAY(200000)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020023)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00010000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00018000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00008004)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00000b53)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00000a53)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+/* PEEK(0xfe901008) (used target peek value 0x0b30017b) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30037b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+/* PEEK(0xfe901008) (used target peek value 0x0b30037b) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30037b)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_GCC_0
+*/
+POKE32(0xfe901028, 0x00000000)
+POKE32(0xfe20d200, 0x00000005)
+POKE32(0xfe20d204, 0x00000004)
+POKE32(0xfe20d208, 0x00000003)
+POKE32(0xfe20d20c, 0x00000002)
+POKE32(0xfe20d210, 0x00000001)
+POKE32(0xfe20d214, 0x00000001)
+POKE32(0xfe20d218, 0x00000001)
+POKE32(0xfe20d21c, 0x00000001)
+POKE32(0xfe20d220, 0x00000001)
+POKE32(0xfe2410fc, 0x00000005)
+POKE32(0xfe20a0ec, 0x00000002)
+POKE32(0xfe20a0f0, 0x00000005)
+POKE32(0xfe20a0f4, 0x00000003)
+POKE32(0xfe20a0f8, 0x00000003)
+POKE32(0xfe20a1ec, 0x00000002)
+POKE32(0xfe20a1f0, 0x00000005)
+POKE32(0xfe20a1f4, 0x00000003)
+POKE32(0xfe20a1f8, 0x00000003)
+POKE32(0xfe20a1fc, 0x00000000)
+POKE32(0xfe20a2ec, 0x00000002)
+POKE32(0xfe20a2f0, 0x00000005)
+POKE32(0xfe20a2f4, 0x00000003)
+POKE32(0xfe20a2f8, 0x00000003)
+POKE32(0xfe20a2fc, 0x00000000)
+POKE32(0xfe20a3ec, 0x00000002)
+POKE32(0xfe20a3f0, 0x00000005)
+POKE32(0xfe20a3f4, 0x00000003)
+POKE32(0xfe20a3f8, 0x00000003)
+POKE32(0xfe20a3fc, 0x00000000)
+POKE32(0xfe20aefc, 0x00000005)
+POKE32(0xfe540034, 0x00000003)
+POKE32(0xfe540038, 0x00000000)
+POKE32(0xfe540110, 0x00010303)
+POKE32(0xfe540114, 0x00000000)
+POKE32(0xfe540030, 0x00000005)
+POKE32(0xfe54010c, 0x00000005)
+POKE32(0xfe540600, 0x00000006)
+POKE32(0xfe540604, 0x00000005)
+POKE32(0xfe540608, 0x00000004)
+POKE32(0xfe54060c, 0x00000003)
+POKE32(0xfe540610, 0x00000002)
+POKE32(0xfe540614, 0x00000001)
+POKE32(0xfe540618, 0x00000000)
+POKE32(0xfe540680, 0x00000001)
+POKE32(0xfe540684, 0x00000000)
+POKE32(0xfe20bb04, 0x00000005)
+POKE32(0xfe20bb08, 0x00000003)
+POKE32(0xfe20bb10, 0x00000002)
+POKE32(0xfe20bb24, 0x00000005)
+POKE32(0xfe20bb28, 0x00000003)
+POKE32(0xfe20bb2c, 0x00000000)
+POKE32(0xfe20bb30, 0x00000002)
+POKE32(0xfe20bb44, 0x00000005)
+POKE32(0xfe20bb48, 0x00000003)
+POKE32(0xfe20bb4c, 0x00000000)
+POKE32(0xfe20bb50, 0x00000002)
+POKE32(0xfe20bb84, 0x00000005)
+POKE32(0xfe20bb88, 0x00000003)
+POKE32(0xfe20bb8c, 0x00000000)
+POKE32(0xfe20bb90, 0x00000002)
+POKE32(0xfe20a0fc, 0x00000000)
+POKE32(0xfe20bb0c, 0x00000000)
+POKE32(0xfe231010, 0x00000008)
+POKE32(0xfe231080, 0x00000221)
+POKE32(0xfe261010, 0x00000008)
+POKE32(0xfe261080, 0x00000221)
+POKE32(0xfd101024, 0x0003c000)
+POKE32(0xfd101824, 0x0003c000)
+POKE32(0xfd104d24, 0x0003c000)
+POKE32(0xfd102024, 0x0003c000)
+/* PEEK(0xfe001180) (used target peek value 0x00000b35) */
+POKE32(0xfe001180, 0x00000b05)
+POKE32(0xfe1fff04, 0x00254608)
+POKE32(0xfeafff04, 0x00254608)
+/* PEEK(0xfe00111c) (used target peek value 0x08081000) */
+POKE32(0xfe00111c, 0x08091000)
+POKE32(0xfd117000, 0x0025c608)
+POKE32(0xfd111000, 0x00201004)
+/* PEEK(0xfe001180) (used target peek value 0x00000b05) */
+POKE32(0xfe001180, 0x00000b01)
+POKE32(0xfe401744, 0x0025c005)
+
+
+/*
+st40_ccn_regs.CCN_CCR
+*/
+POKE32(0xff00001c, 0x8000090d)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG09
+*/
+/* PEEK(0xfe001124) (used target peek value 0x00000a8c) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG09
+*/
+POKE32(0xfe001124, 0x08000a8c)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG05
+*/
+/* PEEK(0xfe001114) (used target peek value 0x00000040) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG05
+*/
+POKE32(0xfe001114, 0x00000040)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG26
+*/
+POKE32(0xfe001168, 0xfe804001)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+POKE32(0xfe00116c, 0x00001fd1)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd1) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+POKE32(0xfe00116c, 0x00001fd0)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG09
+*/
+/* PEEK(0xfe001124) (used target peek value 0x08000a8c) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG09
+*/
+POKE32(0xfe001124, 0x08000a8c)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG05
+*/
+/* PEEK(0xfe001114) (used target peek value 0x00000040) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG05
+*/
+POKE32(0xfe001114, 0x00000040)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcc) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG28
+*/
+POKE32(0xfe001170, 0xfe604001)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcc) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+POKE32(0xfe001174, 0x00001fcd)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcd) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+POKE32(0xfe001174, 0x00001fcc)
diff --git a/board/st/mb680/mb680-stx7105c2.romgen b/board/st/mb680/mb680-stx7105c2.romgen
new file mode 100644
index 0000000000..fc886795d9
--- /dev/null
+++ b/board/st/mb680/mb680-stx7105c2.romgen
@@ -0,0 +1,1665 @@
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x1d43e041) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+/* PEEK(0xfe0011a0) (used target peek value 0x00000004) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+POKE32(0xfe0011a0, 0x00000004)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x1d43e041) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x00000126) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+POKE32(0xfe001110, 0x000001a6)
+POKE32(0xfe000010, 0x0000c0de)
+POKE32(0xfe0000b8, 0x00000001)
+POKE32(0xfe000010, 0x0000c1a0)
+/* PEEK(0xfe210000) (used target peek value 0x00000000) */
+POKE32(0xfe210000, 0x00800000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+/* PEEK(0xfe0011a0) (used target peek value 0x00000004) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+POKE32(0xfe0011a0, 0x00000005)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x1d43e041) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+POKE32(0xfe213014, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+POKE32(0xfe213024, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_ENABLE_FB
+*/
+/* PEEK(0xfe21301c) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_ENABLE_FB
+*/
+WHILE_NE32(0xfe21301c, 0xffffffff, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_ENABLE_FB
+*/
+/* PEEK(0xfe213020) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_ENABLE_FB
+*/
+WHILE_NE32(0xfe213020, 0xffffffff, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80001e02) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x80101e02)
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000001)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x00181e02) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x00180f01)
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000001) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80100f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+WHILE_NE32(0xfe213000, 0x80000000, 0x80000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80100f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x80000f01)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x80102803)
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000002)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x00182803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x00182803)
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000002) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80102803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+WHILE_NE32(0xfe213004, 0x80000000, 0x80000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80102803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x80002803)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV0_CFG
+*/
+POKE32(0xfe213b00, 0x00000001)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV1_CFG
+*/
+POKE32(0xfe213b04, 0x00000001)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV2_CFG
+*/
+POKE32(0xfe213b08, 0x00000001)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV3_CFG
+*/
+POKE32(0xfe213b0c, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0LS_DIV4_CFG
+*/
+POKE32(0xfe213a10, 0x00010100)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV5_CFG
+*/
+POKE32(0xfe213b14, 0x00000307)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0LS_DIV6_CFG
+*/
+POKE32(0xfe213a18, 0x00010100)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0LS_DIV7_CFG
+*/
+POKE32(0xfe213a1c, 0x00010100)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV8_CFG
+*/
+POKE32(0xfe213b20, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV9_CFG
+*/
+POKE32(0xfe213b24, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV10_CFG
+*/
+POKE32(0xfe213b28, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV11_CFG
+*/
+POKE32(0xfe213b2c, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV12_CFG
+*/
+POKE32(0xfe213b30, 0x00000102)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0LS_DIV13_CFG
+*/
+POKE32(0xfe213a34, 0x00000811)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV14_CFG
+*/
+POKE32(0xfe213b38, 0x0000050b)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV15_CFG
+*/
+POKE32(0xfe213b3c, 0x00000307)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV16_CFG
+*/
+POKE32(0xfe213b40, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV17_CFG
+*/
+POKE32(0xfe213b44, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+POKE32(0xfe213014, 0xa6aa59aa)
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+POKE32(0xfe213024, 0x0000000a)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x00000d28) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x00001d28)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x00001d28) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x000016a0)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000016a0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x000006a0)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA3
+*/
+/* PEEK(0xfe001014) (used target peek value 0x1e020380) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA3
+*/
+WHILE_NE32(0xfe001014, 0x00000001, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a10) (used target peek value 0x00010100) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a18) (used target peek value 0x00010100) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a1c) (used target peek value 0x00010100) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b04) (used target peek value 0x00000001) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b08) (used target peek value 0x00000001) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b00) (used target peek value 0x00000001) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b20) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b24) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b28) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+/* PEEK(0xfe213024) (used target peek value 0x0000000a) */
+/* PEEK(0xfe213b40) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+/* PEEK(0xfe213024) (used target peek value 0x0000000a) */
+/* PEEK(0xfe213b44) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b14) (used target peek value 0x00000307) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b2c) (used target peek value 0x00000103) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b30) (used target peek value 0x00000102) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a34) (used target peek value 0x00000811) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b38) (used target peek value 0x0000050b) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b3c) (used target peek value 0x00000307) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000006a0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x000001a6) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+POKE32(0xfe001110, 0x000001a2)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000006a0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x080246a1)
+DELAY(200)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x000001a2) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+POKE32(0xfe001110, 0x000001a6)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA3
+*/
+/* PEEK(0xfe001014) (used target peek value 0x1e161fca) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA3
+*/
+WHILE_NE32(0xfe001014, 0x00100400, 0x00100400)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa000787f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+POKE32(0xfe001198, 0x002f000c)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x00400002)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+POKE32(0xfe001138, 0x00000002)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x07fc23dc)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+POKE32(0xfe0011a8, 0x07afd7eb)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+POKE32(0xfe0011ac, 0x00b001eb)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG51
+*/
+POKE32(0xfe0011cc, 0x01eb01eb)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG52
+*/
+POKE32(0xfe0011d0, 0x01eb01eb)
+
+
+/*
+st40_emi_regs.EMI_BANK_ENABLE
+*/
+POKE32(0xfe700860, 0x00000005)
+
+
+/*
+st40_emi_regs.EMI_BANK0_BASEADDRESS
+*/
+POKE32(0xfe700800, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_BASEADDRESS
+*/
+POKE32(0xfe700810, 0x00000010)
+
+
+/*
+st40_emi_regs.EMI_BANK2_BASEADDRESS
+*/
+POKE32(0xfe700820, 0x00000012)
+
+
+/*
+st40_emi_regs.EMI_BANK3_BASEADDRESS
+*/
+POKE32(0xfe700830, 0x00000014)
+
+
+/*
+st40_emi_regs.EMI_BANK4_BASEADDRESS
+*/
+POKE32(0xfe700840, 0x0000001c)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA0
+*/
+POKE32(0xfe700100, 0x001016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA1
+*/
+POKE32(0xfe700108, 0x9d200000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA2
+*/
+POKE32(0xfe700110, 0x9d220000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA3
+*/
+POKE32(0xfe700118, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA0
+*/
+POKE32(0xfe700140, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA1
+*/
+POKE32(0xfe700148, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA2
+*/
+POKE32(0xfe700150, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA3
+*/
+POKE32(0xfe700158, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA0
+*/
+POKE32(0xfe700180, 0x002046f9)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA1
+*/
+POKE32(0xfe700188, 0xa5a00000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA2
+*/
+POKE32(0xfe700190, 0xa5a20000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA3
+*/
+POKE32(0xfe700198, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA0
+*/
+POKE32(0xfe7001c0, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA1
+*/
+POKE32(0xfe7001c8, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA2
+*/
+POKE32(0xfe7001d0, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA3
+*/
+POKE32(0xfe7001d8, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA0
+*/
+POKE32(0xfe700200, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA1
+*/
+POKE32(0xfe700208, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA2
+*/
+POKE32(0xfe700210, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA3
+*/
+POKE32(0xfe700218, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_GENCFG
+*/
+POKE32(0xfe700028, 0x00000010)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x080246a1) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30017b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_1
+*/
+POKE32(0xfe90100c, 0x000000b0)
+
+
+/*
+st40_lmigp_regs.LMI_STR_0
+*/
+POKE32(0xfe901018, 0xcd2db41b)
+
+
+/*
+st40_lmigp_regs.LMI_STR_1
+*/
+POKE32(0xfe90101c, 0x00222ed6)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA0_0
+*/
+POKE32(0xfe901030, 0x1c001a20)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA1_0
+*/
+POKE32(0xfe901038, 0x1c001a20)
+DELAY(200000)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020023)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00010000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00018000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00008004)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00000b53)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00000a53)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+/* PEEK(0xfe901008) (used target peek value 0x0b30017b) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30037b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+/* PEEK(0xfe901008) (used target peek value 0x0b30037b) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30037b)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_GCC_0
+*/
+POKE32(0xfe901028, 0x00000000)
+POKE32(0xfe20d200, 0x00000005)
+POKE32(0xfe20d204, 0x00000004)
+POKE32(0xfe20d208, 0x00000003)
+POKE32(0xfe20d20c, 0x00000002)
+POKE32(0xfe20d210, 0x00000001)
+POKE32(0xfe20d214, 0x00000001)
+POKE32(0xfe20d218, 0x00000001)
+POKE32(0xfe20d21c, 0x00000001)
+POKE32(0xfe20d220, 0x00000001)
+POKE32(0xfe2410fc, 0x00000005)
+POKE32(0xfe20a0ec, 0x00000002)
+POKE32(0xfe20a0f0, 0x00000005)
+POKE32(0xfe20a0f4, 0x00000003)
+POKE32(0xfe20a0f8, 0x00000003)
+POKE32(0xfe20a1ec, 0x00000002)
+POKE32(0xfe20a1f0, 0x00000005)
+POKE32(0xfe20a1f4, 0x00000003)
+POKE32(0xfe20a1f8, 0x00000003)
+POKE32(0xfe20a1fc, 0x00000000)
+POKE32(0xfe20a2ec, 0x00000002)
+POKE32(0xfe20a2f0, 0x00000005)
+POKE32(0xfe20a2f4, 0x00000003)
+POKE32(0xfe20a2f8, 0x00000003)
+POKE32(0xfe20a2fc, 0x00000000)
+POKE32(0xfe20a3ec, 0x00000002)
+POKE32(0xfe20a3f0, 0x00000005)
+POKE32(0xfe20a3f4, 0x00000003)
+POKE32(0xfe20a3f8, 0x00000003)
+POKE32(0xfe20a3fc, 0x00000000)
+POKE32(0xfe20aefc, 0x00000005)
+POKE32(0xfe540034, 0x00000003)
+POKE32(0xfe540038, 0x00000000)
+POKE32(0xfe540110, 0x00010303)
+POKE32(0xfe540114, 0x00000000)
+POKE32(0xfe540030, 0x00000005)
+POKE32(0xfe54010c, 0x00000005)
+POKE32(0xfe540600, 0x00000006)
+POKE32(0xfe540604, 0x00000005)
+POKE32(0xfe540608, 0x00000004)
+POKE32(0xfe54060c, 0x00000003)
+POKE32(0xfe540610, 0x00000002)
+POKE32(0xfe540614, 0x00000001)
+POKE32(0xfe540618, 0x00000000)
+POKE32(0xfe540680, 0x00000001)
+POKE32(0xfe540684, 0x00000000)
+POKE32(0xfe20bb04, 0x00000005)
+POKE32(0xfe20bb08, 0x00000003)
+POKE32(0xfe20bb10, 0x00000002)
+POKE32(0xfe20bb24, 0x00000005)
+POKE32(0xfe20bb28, 0x00000003)
+POKE32(0xfe20bb2c, 0x00000000)
+POKE32(0xfe20bb30, 0x00000002)
+POKE32(0xfe20bb44, 0x00000005)
+POKE32(0xfe20bb48, 0x00000003)
+POKE32(0xfe20bb4c, 0x00000000)
+POKE32(0xfe20bb50, 0x00000002)
+POKE32(0xfe20bb84, 0x00000005)
+POKE32(0xfe20bb88, 0x00000003)
+POKE32(0xfe20bb8c, 0x00000000)
+POKE32(0xfe20bb90, 0x00000002)
+POKE32(0xfe20a0fc, 0x00000000)
+POKE32(0xfe20bb0c, 0x00000000)
+POKE32(0xfe231010, 0x00000008)
+POKE32(0xfe231080, 0x00000221)
+POKE32(0xfe261010, 0x00000008)
+POKE32(0xfe261080, 0x00000221)
+POKE32(0xfd101024, 0x0003c000)
+POKE32(0xfd101824, 0x0003c000)
+POKE32(0xfd104d24, 0x0003c000)
+POKE32(0xfd102024, 0x0003c000)
+/* PEEK(0xfe001180) (used target peek value 0x00000b35) */
+POKE32(0xfe001180, 0x00000b05)
+POKE32(0xfe1fff04, 0x00254608)
+POKE32(0xfeafff04, 0x00254608)
+/* PEEK(0xfe00111c) (used target peek value 0x08081508) */
+POKE32(0xfe00111c, 0x08091508)
+POKE32(0xfd117000, 0x0025c608)
+POKE32(0xfd111000, 0x00201004)
+/* PEEK(0xfe001180) (used target peek value 0x00000b05) */
+POKE32(0xfe001180, 0x00000b01)
+POKE32(0xfe401744, 0x0025c005)
+
+
+/*
+st40_ccn_regs.CCN_CCR
+*/
+POKE32(0xff00001c, 0x8000090d)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG09
+*/
+/* PEEK(0xfe001124) (used target peek value 0x00000a8c) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG09
+*/
+POKE32(0xfe001124, 0x08000a8c)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG05
+*/
+/* PEEK(0xfe001114) (used target peek value 0x04000040) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG05
+*/
+POKE32(0xfe001114, 0x04000040)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG26
+*/
+POKE32(0xfe001168, 0xfe804001)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+POKE32(0xfe00116c, 0x00001fd1)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd1) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+POKE32(0xfe00116c, 0x00001fd0)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG09
+*/
+/* PEEK(0xfe001124) (used target peek value 0x08000a8c) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG09
+*/
+POKE32(0xfe001124, 0x08000a8c)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG05
+*/
+/* PEEK(0xfe001114) (used target peek value 0x04000040) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG05
+*/
+POKE32(0xfe001114, 0x04000040)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcc) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG28
+*/
+POKE32(0xfe001170, 0xfe604001)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcc) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+POKE32(0xfe001174, 0x00001fcd)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcd) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+POKE32(0xfe001174, 0x00001fcc)
diff --git a/board/st/mb680/mb680.c b/board/st/mb680/mb680.c
new file mode 100644
index 0000000000..4d2da9f902
--- /dev/null
+++ b/board/st/mb680/mb680.c
@@ -0,0 +1,217 @@
+/*
+ * (C) Copyright 2008-2009 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/soc.h>
+#include <asm/stx7105reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+
+#define PIO_BASE  0xfd020000	/* Base of PIO block in COMMs block */
+
+
+/* following are the offsets in the EMI functions EPLD (IC21),
+ * in the STB Peripheral board (MB705)*/
+#define EPLD_IDENT		0x00	/* EPLD Identifier Register */
+#define EPLD_TEST		0x02	/* EPLD Test Register */
+#define EPLD_SWITCH		0x04	/* EPLD Switch Register */
+#define EPLD_MISC		0x0a	/* Miscellaneous Control Register */
+
+#ifdef CONFIG_SH_SE_MODE
+#define EPLD_BASE		0xb7000000	/* Phys 0x07000000 */
+#else
+#define EPLD_BASE		0xa7000000	/* EMI Bank E */
+#endif	/* CONFIG_SH_SE_MODE */
+
+
+static inline void epld_write(unsigned long value, unsigned long offset)
+{
+	/* 16-bit write to EPLD registers */
+	writew(value, EPLD_BASE + offset);
+}
+
+static inline unsigned long epld_read(unsigned long offset)
+{
+	/* 16-bit read from EPLD registers */
+	return readw(EPLD_BASE + offset);
+}
+
+void flashWriteEnable(void)
+{
+	unsigned short epld_reg;
+
+	/* Enable Vpp for writing to flash */
+	epld_reg = epld_read(EPLD_MISC);
+	epld_reg |= 1u << 3;	/* NandFlashWP = MISC[3] = 1 */
+	epld_reg |= 1u << 2;	/* NorFlashVpp = MISC[2] = 1 */
+	epld_write(epld_reg, EPLD_MISC);
+}
+
+void flashWriteDisable(void)
+{
+	unsigned short epld_reg;
+
+	/* Disable Vpp for writing to flash */
+	epld_reg = epld_read(EPLD_MISC);
+	epld_reg &= ~(1u << 3);	/* NandFlashWP = MISC[3] = 0 */
+	epld_reg &= ~(1u << 2);	/* NorFlashVpp = MISC[2] = 0 */
+	epld_write(epld_reg, EPLD_MISC);
+}
+
+static int mb680_init_epld(void)
+{
+	const unsigned short test_value = 0x1234u;
+	unsigned short epld_reg;
+	unsigned short epld_version, board_version;
+
+	/* write (anything) to the test register */
+	epld_write(test_value, EPLD_TEST);
+	/* verify we got back an inverted result */
+	epld_reg = epld_read(EPLD_TEST);
+	if (epld_reg != (test_value ^ 0xffffu)) {
+		printf("Failed EPLD test (offset=%02x, result=%04x)\n",
+			EPLD_TEST, epld_reg);
+		return 1;
+		}
+
+	/* Assume we can trust the version register */
+	epld_reg = epld_read(EPLD_IDENT);
+	board_version = epld_reg >> 4 & 0xfu;
+	epld_version = epld_reg & 0xfu;
+
+	/* display the board revision, and EPLD version */
+	printf("MB705: revision %c, EPLD version %02d\n",
+		board_version + 'A' - 1,
+		epld_version);
+
+	/* return a "success" result */
+	return 0;
+}
+
+#ifdef CONFIG_STMAC_LAN8700
+static void phy_reset(void)
+{
+	/* Reset the SMSC LAN8700 PHY */
+	STPIO_SET_PIN(PIO_PORT(5), 5, 1);
+	STPIO_SET_PIN(PIO_PORT(11), 2, 1);
+	udelay(1);
+	STPIO_SET_PIN(PIO_PORT(5), 5, 0);
+	udelay(100);
+	STPIO_SET_PIN(PIO_PORT(5), 5, 1);
+	udelay(1);
+	STPIO_SET_PIN(PIO_PORT(11), 2, 0);
+}
+#endif	/* CONFIG_STMAC_LAN8700 */
+
+static void configPIO(void)
+{
+	unsigned long sysconf;
+
+	/* Setup PIO of ASC device */
+	SET_PIO_ASC(PIO_PORT(4), 0, 1, 2, 3);  /* UART2 - AS0 */
+	SET_PIO_ASC(PIO_PORT(5), 0, 1, 3, 2);  /* UART3 - AS1 */
+
+	/* Select UART2 via PIO4 */
+	sysconf = *STX7105_SYSCONF_SYS_CFG07;
+	/* CFG07[1] = UART2_RXD_SRC_SELECT = 0 */
+	/* CFG07[2] = UART2_CTS_SRC_SELECT = 0 */
+	sysconf &= ~(1ul<<2 | 1ul<<1);
+	*STX7105_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* Route UART2 via PIO4 for TX, RX, CTS & RTS */
+	sysconf = *STX7105_SYSCONF_SYS_CFG34;
+	/* PIO4[0] CFG34[8,0]   AltFunction = 3 */
+	/* PIO4[1] CFG34[9,1]   AltFunction = 3 */
+	/* PIO4[2] CFG34[10,2]  AltFunction = 3 */
+	/* PIO4[3] CFG34[11,3]  AltFunction = 3 */
+	sysconf &= ~0x0f0ful;	/* 3,3,3,3 */
+	sysconf |=  0x0f00ul;	/* 2,2,2,2 */
+	*STX7105_SYSCONF_SYS_CFG34 = sysconf;
+
+	/* Route UART3 via PIO5 for TX, RX, CTS & RTS */
+	sysconf = *STX7105_SYSCONF_SYS_CFG35;
+	/* PIO5[0] CFG35[8,0]   AltFunction = 3 */
+	/* PIO5[1] CFG35[9,1]   AltFunction = 3 */
+	/* PIO5[2] CFG35[10,2]  AltFunction = 3 */
+	/* PIO5[3] CFG35[11,3]  AltFunction = 3 */
+	sysconf &= ~0x0f0ful;	/* 3,3,3,3 */
+	sysconf |=  0x000ful;	/* 1,1,1,1 */
+	*STX7105_SYSCONF_SYS_CFG35 = sysconf;
+
+#ifdef CONFIG_STMAC_LAN8700
+	/* Configure SMSC LAN8700 PHY Reset signals */
+	SET_PIO_PIN(PIO_PORT(5), 5, STPIO_OUT);
+	SET_PIO_PIN(PIO_PORT(11), 2, STPIO_OUT);
+#endif	/* CONFIG_STMAC_LAN8700 */
+}
+
+extern int board_init(void)
+{
+	configPIO();
+
+	/* Reset the PHY */
+#ifdef CONFIG_STMAC_LAN8700
+	phy_reset();
+#endif	/* CONFIG_STMAC_LAN8700 */
+
+#if defined(CONFIG_SH_STM_SATA)
+	stx7105_configure_sata ();
+#endif	/* CONFIG_SH_STM_SATA */
+
+	return 0;
+}
+
+int checkboard (void)
+{
+	printf ("\n\nBoard: STx7105-Mboard (MB680)"
+#ifdef CONFIG_SH_SE_MODE
+		"  [32-bit mode]"
+#else
+		"  [29-bit mode]"
+#endif
+		"\n");
+
+	/*
+	 * initialize the EPLD.
+	 */
+	mb680_init_epld();
+
+#if 0	/* QQQ - DELETE */
+{
+const unsigned long nand_reg = *ST40_EMI_NAND_VERSION_REG;
+const unsigned long epld_reg = epld_read(EPLD_SWITCH);
+	printf ("*ST40_EMI_NAND_VERSION_REG = %u.%u.%u\n",
+		(nand_reg>>8)&0x0ful,
+		(nand_reg>>4)&0x0ful,
+		(nand_reg>>0)&0x0ful);
+	printf("*EPLD_SWITCH = 0x%08x  -->  boot-from-%s\n",
+		epld_reg,
+		(epld_reg & (1ul<<8)) ? "NAND" : "NOR");
+}
+#endif	/* QQQ - DELETE */
+
+	return 0;
+}
diff --git a/board/st/mb680/nand.c b/board/st/mb680/nand.c
new file mode 100644
index 0000000000..19391cc87a
--- /dev/null
+++ b/board/st/mb680/nand.c
@@ -0,0 +1,121 @@
+/*
+ * (C) Copyright 2006 DENX Software Engineering
+ * (C) Copyright 2008-2009 STMicroelectronics, Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <nand.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+#include <asm/stx7105reg.h>
+#include <asm/stm-nand.h>
+
+
+/*
+ * hardware specific access to control-lines for "bit-banging".
+ *	CL -> Emi_Addr(17)
+ *	AL -> Emi_Addr(18)
+ *	nCE is handled by EMI (not s/w controlable)
+ */
+#ifndef CFG_NAND_FLEX_MODE	/* for "bit-banging" (c.f. STM "flex-mode")  */
+static void mb680_hwcontrol(struct mtd_info *mtdinfo, int cmd)
+{
+	struct nand_chip* this = (struct nand_chip *)(mtdinfo->priv);
+
+	switch(cmd) {
+
+	case NAND_CTL_SETCLE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (1u << 17));
+		break;
+
+	case NAND_CTL_CLRCLE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(1u << 17));
+		break;
+
+	case NAND_CTL_SETALE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (1u << 18));
+		break;
+
+	case NAND_CTL_CLRALE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(1u << 18));
+		break;
+	}
+}
+#endif /* CFG_NAND_FLEX_MODE */
+
+
+/*
+ * hardware specific access to the Ready/not_Busy signal.
+ * Signal is routed through the EMI NAND Controller block.
+ */
+#ifndef CFG_NAND_FLEX_MODE	/* for "bit-banging" (c.f. STM "flex-mode")  */
+static int mb680_device_ready(struct mtd_info *mtd)
+{
+	/* extract bit 1: status of RBn pin on boot bank */
+	return ((*ST40_EMI_NAND_RBN_STA) & (1ul<<1)) ? 1 : 0;
+}
+#endif /* CFG_NAND_FLEX_MODE */
+
+
+/*
+ * Board-specific NAND initialization. The following members of the
+ * argument are board-specific (per include/linux/mtd/nand.h):
+ * - IO_ADDR_R?: address to read the 8 I/O lines of the flash device
+ * - IO_ADDR_W?: address to write the 8 I/O lines of the flash device
+ * - hwcontrol: hardwarespecific function for accesing control-lines
+ * - dev_ready: hardwarespecific function for  accesing device ready/busy line
+ * - enable_hwecc?: function to enable (reset)  hardware ecc generator. Must
+ *   only be provided if a hardware ECC is available
+ * - eccmode: mode of ecc, see defines
+ * - chip_delay: chip dependent delay for transfering data from array to
+ *   read regs (tR)
+ * - options: various chip options. They can partly be set to inform
+ *   nand_scan about special functionality. See the defines for further
+ *   explanation
+ * Members with a "?" were not set in the merged testing-NAND branch,
+ * so they are not set here either.
+ */
+extern int board_nand_init(struct nand_chip *nand)
+{
+	nand->eccmode       = NAND_ECC_SOFT;
+	nand->options       = NAND_NO_AUTOINCR;
+
+#ifdef CFG_NAND_FLEX_MODE	/* for STM "flex-mode" (c.f. "bit-banging") */
+	nand->select_chip   = stm_flex_select_chip;
+	nand->dev_ready     = stm_flex_device_ready;
+	nand->hwcontrol     = stm_flex_hwcontrol;
+	nand->read_byte     = stm_flex_read_byte;
+	nand->write_byte    = stm_flex_write_byte;
+	nand->read_buf      = stm_flex_read_buf;
+	nand->write_buf     = stm_flex_write_buf;
+#else				/* for "bit-banging" (c.f. STM "flex-mode")  */
+	nand->dev_ready     = mb680_device_ready;
+	nand->hwcontrol     = mb680_hwcontrol;
+#endif /* CFG_NAND_FLEX_MODE */
+
+#if 1
+	/* Enable the following to use a Bad Block Table (BBT) */
+	nand->options      |= NAND_USE_FLASH_BBT;
+	nand->scan_bbt      = stm_nand_default_bbt;
+#endif
+
+	return 0;
+}
diff --git a/board/st/mb704/Makefile b/board/st/mb704/Makefile
new file mode 100644
index 0000000000..c99b16c9c9
--- /dev/null
+++ b/board/st/mb704/Makefile
@@ -0,0 +1,52 @@
+#
+# (C) Copyright 2007 STMicroelectronics.
+# Stuart Menefy <stuart.menefy@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+SOBJS	= init-$(BOARD).o
+
+COBJS	= $(BOARD).o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/st/mb704/config.mk b/board/st/mb704/config.mk
new file mode 100644
index 0000000000..ca02cd39d5
--- /dev/null
+++ b/board/st/mb704/config.mk
@@ -0,0 +1,43 @@
+#
+# (C) Copyright 2009 STMicroelectronics.
+# Sean McGoogan <Sean.McGoogan@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# MB704 board:
+#
+#	Valid values for TEXT_BASE are:
+#
+#	0x8FF00000	29-bit mode (Traditional Mode)
+#	0x83F00000	32-bit mode (Space-Enhancement Mode)
+#
+# Note:	Alternative definitions of TEXT_BASE are put into
+#	'config.tmp' from the top-level 'Makefile'.
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+# Installs at LMI0 BASE + 63MB in P1 (cachable)
+TEXT_BASE = 0x8FF00000
+endif
+
+PLATFORM_LDFLAGS +=
diff --git a/board/st/mb704/init-mb704.S b/board/st/mb704/init-mb704.S
new file mode 100644
index 0000000000..a837882fc1
--- /dev/null
+++ b/board/st/mb704/init-mb704.S
@@ -0,0 +1,82 @@
+#include "asm/stx5197reg.h"
+#include "../../../cpu/sh/init_ram.S"
+
+/*
+ * This is derived from STMicroelectronics gnu toolchain example:
+ *   sh-superh-elf/examples/os21/romdynamic/memory_mb704.S
+ */
+
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *	opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+/*
+ * For compatibility with old poke table code, we define some of the
+ * new names, to map onto the old names. Ultimately, the old poke table
+ * code will be updated to the "new order", and we can just delete
+ * the following mappings.
+ */
+#define POKE8(A, VAL)				POKE_CHAR(A, VAL)
+#define POKE16(A, VAL)				POKE_SHORT(A, VAL)
+#define POKE32(A, VAL)				POKE_LONG(A, VAL)
+#define OR32(A, VAL)				OR_LONG(A, VAL)
+#define UPDATE32(A, AND, OR)			UPDATE_LONG(A, AND, OR)
+#define POKE_UPDATE32(A1, A2, AND, SHIFT, OR)	POKE_UPDATE_LONG(A1, A2, AND, SHIFT, OR)
+#define WHILE_NE32(A, AND, VAL)			WHILE_NE(A, AND, VAL)
+#define DELAY(VAL)				/* do nothing */
+
+
+	.section .data.init, "a"
+
+	.balign 32
+
+__memory_setup_table:
+
+
+	/*
+	 * include the appropriate set of "GDB pokes", (usually) generated
+	 * using the "romgen" utility, from a known good target-pack.
+	 *
+	 * This file may be regenerated by connecting your specific board
+	 * to an STMC2 (note: currently it must be version 2) and then
+	 * executing the following command (redirecting the output):
+	 *
+	 * host% romgen --target-connect --show-comment <stmc2>:mb704:st40
+	 *
+	 * Where "<stmc2>" should be replaced with the IP address
+	 * (or the DNS name) of the STMC2 box.  Also the "mb704" should
+	 * substituted if you have a custom target-pack connect command.
+	 *
+	 * Note: The connect command used with "romgen", should connect
+	 * only in 29-bit mode - even if U-Boot will be built for 32-bit mode.
+	 * That is, do not use the "seuc=1" (or similar) option with "romgen".
+	 */
+#include "mb704.romgen"
+
+
+#ifdef CONFIG_SH_SE_MODE
+	/*
+	 * Note that we also manually need to move the LMI base addresses to
+	 * their 32-bit SE mode locations as defined in the datasheet and change the
+	 * 'upper bound addresses' (in row attribute registers) for the LMIs.
+	 * CTRL_M.LMI_MEM_BASE_ADDR_SIG = 0x40 [11:4]
+	 */
+	UPDATE32(STX5197_HD_CONF_MON_CONFIG_CONTROL_M, 0xfffff00f, (0x40 << 4))
+
+	/*
+	 * Change LMI upper bound addresses
+	 * Upper LMI addr = 0x40000000 + 64MiB = 0x44000000
+	 */
+	UPDATE32(ST40_LMI_SDRA0_0(), 0x001fffff, 0x44000000)
+	UPDATE32(ST40_LMI_SDRA1_0(), 0x001fffff, 0x44000000)
+#endif	/* CONFIG_SH_SE_MODE */
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/st/mb704/mb704.c b/board/st/mb704/mb704.c
new file mode 100644
index 0000000000..cf40a9a461
--- /dev/null
+++ b/board/st/mb704/mb704.c
@@ -0,0 +1,110 @@
+/*
+ * (C) Copyright 2009 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/stx5197reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+
+#define PIO_BASE  0xfd120000	/* Base of PIO block in COMMs block */
+
+
+	/* Alternate Function Output Selection accessors */
+#define ALT_SELn(n,alt)		( (((alt)>>(n))&1)<<(8*(n)) )
+#define ALT_SEL(alt)		( ALT_SELn(1,(alt)) | ALT_SELn(0,(alt)) )
+#define ALT_MASK(port,pin,alt)	( ALT_SEL(alt) << ((((port)&1)?16:0)+((pin)&7)) )
+#define ALTFOP(reg,port,pin,alt)			\
+	do {						\
+		reg &= ~ALT_MASK((port),(pin), 0x3);	\
+		reg |=  ALT_MASK((port),(pin),(alt));	\
+	} while(0)
+
+
+extern void flashWriteEnable (void)
+{
+	/* Enable Vpp for writing to flash */
+}
+
+extern void flashWriteDisable (void)
+{
+	/* Disable Vpp for writing to flash */
+}
+
+
+#ifdef CONFIG_STM_ASC_SERIAL
+static void configSerial (void)
+{
+	unsigned long sysconf;
+
+#if (CFG_STM_ASC_BASE == CFG_STM_ASC2_BASE)
+	/* Setup PIO of ASC device */
+	SET_PIO_ASC(PIO_PORT(1), 2, 3, 5, 4);  /* UART2 - AS0 */
+	/* Route UART2 via PIO1 for TX, RX, CTS & RTS */
+	sysconf = *STX5197_HD_CONF_MON_CONFIG_CONTROL_F;
+	ALTFOP(sysconf,1,2,1);		/* PIO1[2] AltFunction = 1 */
+	ALTFOP(sysconf,1,3,1);		/* PIO1[3] AltFunction = 1 */
+	ALTFOP(sysconf,1,4,1);		/* PIO1[4] AltFunction = 1 */
+	ALTFOP(sysconf,1,5,1);		/* PIO1[5] AltFunction = 1 */
+	*STX5197_HD_CONF_MON_CONFIG_CONTROL_F = sysconf;
+#elif (CFG_STM_ASC_BASE == CFG_STM_ASC3_BASE)
+	/* Setup PIO of ASC device */
+	SET_PIO_ASC(PIO_PORT(2), 0, 1, 2, 5);  /* UART3 - AS1 */
+	/* Route UART3 via PIO2 for TX, RX, CTS & RTS */
+	sysconf = *STX5197_HD_CONF_MON_CONFIG_CONTROL_G;
+	ALTFOP(sysconf,2,0,1);		/* PIO2[0] AltFunction = 1 */
+	ALTFOP(sysconf,2,1,1);		/* PIO2[1] AltFunction = 1 */
+	ALTFOP(sysconf,2,2,1);		/* PIO2[2] AltFunction = 1 */
+	ALTFOP(sysconf,2,5,1);		/* PIO2[5] AltFunction = 1 */
+	*STX5197_HD_CONF_MON_CONFIG_CONTROL_G = sysconf;
+#else
+#error Unknown serial port configuration!
+#endif
+}
+#endif /* CONFIG_STM_ASC_SERIAL */
+
+
+extern int board_init (void)
+{
+#ifdef CONFIG_STM_ASC_SERIAL
+	configSerial ();
+#endif /* CONFIG_STM_ASC_SERIAL */
+
+	return 0;
+}
+
+
+extern int checkboard (void)
+{
+	printf ("\n\nBoard: STx5197-Mboard (MB704)"
+#ifdef CONFIG_SH_SE_MODE
+		"  [32-bit mode]"
+#else
+		"  [29-bit mode]"
+#endif
+		"\n");
+
+	return 0;
+}
diff --git a/board/st/mb704/mb704.romgen b/board/st/mb704/mb704.romgen
new file mode 100644
index 0000000000..08fa12fe20
--- /dev/null
+++ b/board/st/mb704/mb704.romgen
@@ -0,0 +1,781 @@
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+/* PEEK(0xfdc00300) (used target peek value 0x00000100) */
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+POKE32(0xfdc00300, 0x000000f0)
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+POKE32(0xfdc00300, 0x0000000f)
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+/* PEEK(0xfdc00300) (used target peek value 0x00000000) */
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+WHILE_NE32(0xfdc00300, 0x00000100, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.MODE_CONTROL
+*/
+POKE32(0xfdc00110, 0x00000001)
+
+
+/*
+sti5197_system_services_regs.MODE_CONTROL
+*/
+/* PEEK(0xfdc00110) (used target peek value 0x00000001) */
+
+
+/*
+sti5197_system_services_regs.MODE_CONTROL
+*/
+WHILE_NE32(0xfdc00110, 0x00000001, 0x00000001)
+
+
+/*
+sti5197_system_services_regs.PLLA_CONFIG1
+*/
+POKE32(0xfdc00004, 0x00002000)
+
+
+/*
+sti5197_system_services_regs.PLLB_CONFIG1
+*/
+POKE32(0xfdc0000c, 0x00002000)
+
+
+/*
+sti5197_system_services_regs.PLLA_CONFIG1
+*/
+POKE32(0xfdc00004, 0x00002000)
+
+
+/*
+sti5197_system_services_regs.PLLA_CONFIG0
+*/
+POKE32(0xfdc00000, 0x00002303)
+
+
+/*
+sti5197_system_services_regs.PLLB_CONFIG1
+*/
+POKE32(0xfdc0000c, 0x00002000)
+
+
+/*
+sti5197_system_services_regs.PLLB_CONFIG0
+*/
+POKE32(0xfdc00008, 0x00002803)
+
+
+/*
+sti5197_system_services_regs.CPU_CLK_CONFIG0
+*/
+POKE32(0xfdc00090, 0x0000366c)
+
+
+/*
+sti5197_system_services_regs.CPU_CLK_CONFIG1
+*/
+POKE32(0xfdc00094, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.CPU_CLK_CONFIG2
+*/
+POKE32(0xfdc00098, 0x00000053)
+
+
+/*
+sti5197_system_services_regs.LMI_CLK_CONFIG0
+*/
+POKE32(0xfdc000a0, 0x0000cccc)
+
+
+/*
+sti5197_system_services_regs.LMI_CLK_CONFIG1
+*/
+POKE32(0xfdc000a4, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.LMI_CLK_CONFIG2
+*/
+POKE32(0xfdc000a8, 0x00000075)
+
+
+/*
+sti5197_system_services_regs.BLLITER_CLK_CONFIG0
+*/
+POKE32(0xfdc000ac, 0x0000366c)
+
+
+/*
+sti5197_system_services_regs.BLLITER_CLK_CONFIG1
+*/
+POKE32(0xfdc000b0, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.BLLITER_CLK_CONFIG2
+*/
+POKE32(0xfdc000b4, 0x00000053)
+
+
+/*
+sti5197_system_services_regs.SYSTEM_CLK_CONFIG0
+*/
+POKE32(0xfdc000b8, 0x0000739c)
+
+
+/*
+sti5197_system_services_regs.SYSTEM_CLK_CONFIG1
+*/
+POKE32(0xfdc000bc, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.SYSTEM_CLK_CONFIG2
+*/
+POKE32(0xfdc000c0, 0x00000014)
+
+
+/*
+sti5197_system_services_regs.FDMA_PLL_CLK_CONFIG0
+*/
+POKE32(0xfdc000c4, 0x00000aaa)
+
+
+/*
+sti5197_system_services_regs.FDMA_PLL_CLK_CONFIG1
+*/
+POKE32(0xfdc000c8, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.FDMA_PLL_CLK_CONFIG2
+*/
+POKE32(0xfdc000cc, 0x00000071)
+
+
+/*
+sti5197_system_services_regs.AV_CLK_CONFIG0
+*/
+POKE32(0xfdc000d0, 0x00003c78)
+
+
+/*
+sti5197_system_services_regs.AV_CLK_CONFIG1
+*/
+POKE32(0xfdc000d4, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.AV_CLK_CONFIG2
+*/
+POKE32(0xfdc000d8, 0x00000013)
+
+
+/*
+sti5197_system_services_regs.SPARE_PLL_CLK_CONFIG0
+*/
+POKE32(0xfdc000dc, 0x00003c78)
+
+
+/*
+sti5197_system_services_regs.SPARE_PLL_CLK_CONFIG1
+*/
+POKE32(0xfdc000e0, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.SPARE_PLL_CLK_CONFIG2
+*/
+POKE32(0xfdc000e4, 0x00000013)
+
+
+/*
+sti5197_system_services_regs.ETHERNET_CLK_CONFIG0
+*/
+POKE32(0xfdc000e8, 0x00003c78)
+
+
+/*
+sti5197_system_services_regs.ETHERNET_CLK_CONFIG1
+*/
+POKE32(0xfdc000ec, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.ETHERNET_CLK_CONFIG2
+*/
+POKE32(0xfdc000f0, 0x00000013)
+
+
+/*
+sti5197_system_services_regs.ST40_ICK_CLK_CONFIG0
+*/
+POKE32(0xfdc000f4, 0x00000aaa)
+
+
+/*
+sti5197_system_services_regs.ST40_ICK_CLK_CONFIG1
+*/
+POKE32(0xfdc000f8, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.ST40_ICK_CLK_CONFIG2
+*/
+POKE32(0xfdc000fc, 0x00000071)
+
+
+/*
+sti5197_system_services_regs.ST40_PCK_CLK_CONFIG0
+*/
+POKE32(0xfdc00100, 0x0000cccc)
+
+
+/*
+sti5197_system_services_regs.ST40_PCK_CLK_CONFIG1
+*/
+POKE32(0xfdc00104, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.ST40_PCK_CLK_CONFIG2
+*/
+POKE32(0xfdc00108, 0x00000075)
+
+
+/*
+sti5197_system_services_regs.PLL_SELECT_CFG
+*/
+POKE32(0xfdc00180, 0x00000844)
+
+
+/*
+sti5197_system_services_regs.PLL_SELECT_CFG .ALT_TRANSPORT_SELECT [offset 12, size 1]
+*/
+/* PEEK(0xfdc00180) (used target peek value 0x00000844) */
+
+
+/*
+sti5197_system_services_regs.PLL_SELECT_CFG .ALT_TRANSPORT_SELECT [offset 12, size 1]
+*/
+POKE32(0xfdc00180, 0x00001844)
+
+
+/*
+sti5197_system_services_regs.PLL_SELECT_CFG .ALT_TRANSPORT_SELECT [offset 12, size 1]
+*/
+UPDATE32(0xfdc00180, 0xffffefff, 0x00001000)
+
+
+/*
+sti5197_system_services_regs.PLLA_CONFIG1
+*/
+/* PEEK(0xfdc00004) (used target peek value 0x00002000) */
+
+
+/*
+sti5197_system_services_regs.PLLA_CONFIG1
+*/
+POKE32(0xfdc00004, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.PLLB_CONFIG1
+*/
+/* PEEK(0xfdc0000c) (used target peek value 0x00002000) */
+
+
+/*
+sti5197_system_services_regs.PLLB_CONFIG1
+*/
+POKE32(0xfdc0000c, 0x00000000)
+DELAY(200)
+DELAY(20)
+
+
+/*
+sti5197_system_services_regs.PLLA_CONFIG1
+*/
+/* PEEK(0xfdc00004) (used target peek value 0x00008000) */
+DELAY(20)
+
+
+/*
+sti5197_system_services_regs.PLLB_CONFIG1
+*/
+/* PEEK(0xfdc0000c) (used target peek value 0x00008000) */
+
+
+/*
+sti5197_system_services_regs.SPARE1_CLK_SETUP0
+*/
+POKE32(0xfdc00014, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.PCM_CLK_SETUP0
+*/
+POKE32(0xfdc00020, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.SPDIF_CLK_SETUP0
+*/
+POKE32(0xfdc00030, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.SC_CLK_SETUP0
+*/
+POKE32(0xfdc00040, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.PIX_CLK_SETUP0
+*/
+POKE32(0xfdc00054, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.FDMA_FS_CLK_SETUP0
+*/
+POKE32(0xfdc00060, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.AUX_CLK_SETUP0
+*/
+POKE32(0xfdc00070, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.USB_CLK_SETUP0
+*/
+POKE32(0xfdc00080, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.FSA_SETUP
+*/
+POKE32(0xfdc00010, 0x00000f08)
+
+
+/*
+sti5197_system_services_regs.FSB_SETUP
+*/
+POKE32(0xfdc00050, 0x00000f08)
+
+
+/*
+sti5197_system_services_regs.FSA_SETUP
+*/
+POKE32(0xfdc00010, 0x00000f18)
+
+
+/*
+sti5197_system_services_regs.FSB_SETUP
+*/
+POKE32(0xfdc00050, 0x00000f18)
+
+
+/*
+sti5197_system_services_regs.SPARE1_CLK_SETUP0
+*/
+POKE32(0xfdc00014, 0x00000af1)
+
+
+/*
+sti5197_system_services_regs.SPARE1_CLK_SETUP1
+*/
+POKE32(0xfdc00018, 0x00001c72)
+
+
+/*
+sti5197_system_services_regs.DCO_MODE_CFG
+*/
+POKE32(0xfdc00170, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.PCM_CLK_SETUP0
+*/
+POKE32(0xfdc00020, 0x00000af3)
+
+
+/*
+sti5197_system_services_regs.PCM_CLK_SETUP1
+*/
+POKE32(0xfdc00024, 0x00003c00)
+
+
+/*
+sti5197_system_services_regs.DCO_MODE_CFG
+*/
+POKE32(0xfdc00170, 0x00000001)
+
+
+/*
+sti5197_system_services_regs.DCO_MODE_CFG
+*/
+POKE32(0xfdc00170, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.SPDIF_CLK_SETUP0
+*/
+POKE32(0xfdc00030, 0x00000b31)
+
+
+/*
+sti5197_system_services_regs.SPDIF_CLK_SETUP1
+*/
+POKE32(0xfdc00034, 0x00004dea)
+
+
+/*
+sti5197_system_services_regs.DCO_MODE_CFG
+*/
+POKE32(0xfdc00170, 0x00000001)
+
+
+/*
+sti5197_system_services_regs.SC_CLK_SETUP0
+*/
+POKE32(0xfdc00040, 0x00000af1)
+
+
+/*
+sti5197_system_services_regs.SC_CLK_SETUP1
+*/
+POKE32(0xfdc00044, 0x00001c72)
+
+
+/*
+sti5197_system_services_regs.DCO_MODE_CFG
+*/
+POKE32(0xfdc00170, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.PIX_CLK_SETUP0
+*/
+POKE32(0xfdc00054, 0x00000af1)
+
+
+/*
+sti5197_system_services_regs.PIX_CLK_SETUP1
+*/
+POKE32(0xfdc00058, 0x00001c72)
+
+
+/*
+sti5197_system_services_regs.DCO_MODE_CFG
+*/
+POKE32(0xfdc00170, 0x00000001)
+
+
+/*
+sti5197_system_services_regs.FDMA_FS_CLK_SETUP0
+*/
+POKE32(0xfdc00060, 0x00000a39)
+
+
+/*
+sti5197_system_services_regs.FDMA_FS_CLK_SETUP1
+*/
+POKE32(0xfdc00064, 0x00003334)
+
+
+/*
+sti5197_system_services_regs.AUX_CLK_SETUP0
+*/
+POKE32(0xfdc00070, 0x00000af1)
+
+
+/*
+sti5197_system_services_regs.AUX_CLK_SETUP1
+*/
+POKE32(0xfdc00074, 0x00001c72)
+
+
+/*
+sti5197_system_services_regs.USB_CLK_SETUP0
+*/
+POKE32(0xfdc00080, 0x00000ab3)
+
+
+/*
+sti5197_system_services_regs.USB_CLK_SETUP1
+*/
+POKE32(0xfdc00084, 0x00000000)
+
+
+/*
+sti5197_system_services_regs.FSA_SETUP
+*/
+POKE32(0xfdc00010, 0x00000f10)
+
+
+/*
+sti5197_system_services_regs.FSB_SETUP
+*/
+POKE32(0xfdc00050, 0x00000f10)
+DELAY(200)
+
+
+/*
+sti5197_system_services_regs.MODE_CONTROL
+*/
+POKE32(0xfdc00110, 0x00000002)
+
+
+/*
+sti5197_system_services_regs.MODE_CONTROL
+*/
+/* PEEK(0xfdc00110) (used target peek value 0x00000002) */
+
+
+/*
+sti5197_system_services_regs.MODE_CONTROL
+*/
+WHILE_NE32(0xfdc00110, 0x00000002, 0x00000002)
+
+
+/*
+LMI.LMI_MIM0
+*/
+POKE32(0xfe000008, 0x061c0203)
+
+
+/*
+LMI.LMI_STR
+*/
+POKE32(0xfe000018, 0x3ff27e7a)
+
+
+/*
+LMI.LMI_SDRA0
+*/
+POKE32(0xfe000030, 0x10001a00)
+
+
+/*
+LMI.LMI_SDRA1
+*/
+POKE32(0xfe000038, 0x10001a00)
+DELAY(200)
+
+
+/*
+LMI.LMI_SCR
+*/
+POKE32(0xfe000010, 0x00000003)
+
+
+/*
+LMI.LMI_SCR
+*/
+POKE32(0xfe000010, 0x00000001)
+
+
+/*
+LMI.LMI_SCR
+*/
+POKE32(0xfe000010, 0x00000002)
+
+
+/*
+LMI.LMI_SDMR0
+*/
+POKE32(0xfe000048, 0x00000400)
+
+
+/*
+LMI.LMI_SDMR1
+*/
+POKE32(0xfe000050, 0x00000400)
+DELAY(200)
+
+
+/*
+LMI.LMI_SDMR0
+*/
+POKE32(0xfe000048, 0x00000133)
+
+
+/*
+LMI.LMI_SDMR1
+*/
+POKE32(0xfe000050, 0x00000133)
+DELAY(200)
+
+
+/*
+LMI.LMI_SCR
+*/
+POKE32(0xfe000010, 0x00000002)
+
+
+/*
+LMI.LMI_SCR
+*/
+POKE32(0xfe000010, 0x00000004)
+
+
+/*
+LMI.LMI_SCR
+*/
+POKE32(0xfe000010, 0x00000004)
+
+
+/*
+LMI.LMI_SCR
+*/
+POKE32(0xfe000010, 0x00000004)
+
+
+/*
+LMI.LMI_SDMR0
+*/
+POKE32(0xfe000048, 0x00000033)
+
+
+/*
+LMI.LMI_SDMR1
+*/
+POKE32(0xfe000050, 0x00000033)
+
+
+/*
+LMI.LMI_SCR
+*/
+POKE32(0xfe000010, 0x00000000)
+
+
+/*
+LMI.LMI_COC_UPPER
+*/
+POKE32(0xfe00002c, 0x00330000)
+
+
+/*
+LMI.LMI_COC_LOWER
+*/
+POKE32(0xfe000028, 0x0003e000)
+
+
+/*
+sti5197_hd_config_monitor_regs.CONFIG_CONTROL_H
+*/
+/* PEEK(0xfd901014) (used target peek value 0x00000000) */
+
+
+/*
+sti5197_hd_config_monitor_regs.CONFIG_CONTROL_H
+*/
+POKE32(0xfd901014, 0x00000000)
+
+
+/*
+sti5197_hd_config_monitor_regs.CONFIG_CONTROL_M
+*/
+/* PEEK(0xfd901048) (used target peek value 0x000000c0) */
+
+
+/*
+sti5197_hd_config_monitor_regs.CONFIG_CONTROL_M
+*/
+POKE32(0xfd901048, 0x400000c0)
+
+
+/*
+LMI.LMI_MIM1
+*/
+POKE32(0xfe00000c, 0x00000075)
+
+
+/*
+sti5197_hd_config_monitor_regs.CONFIG_CONTROL_C
+*/
+/* PEEK(0xfd901000) (used target peek value 0x00000000) */
+
+
+/*
+sti5197_hd_config_monitor_regs.CONFIG_CONTROL_C
+*/
+POKE32(0xfd901000, 0x00800000)
+
+
+/*
+sti5197_system_services_regs.CLOCK_OBSERVATION_CFG
+*/
+POKE32(0xfdc00188, 0x0000002a)
+
+
+/*
+sti5197_hs_config_monitor_regs.CONFIG_MONITOR_A
+*/
+/* PEEK(0xfd002008) (used target peek value 0x38472000) */
+
+
+/*
+sti5197_hd_config_monitor_regs.CONFIG_MONITOR_G
+*/
+/* PEEK(0xfd901030) (used target peek value 0x00001279) */
+
+
+/*
+sti5197_hd_config_monitor_regs.CONFIG_MONITOR_J
+*/
+/* PEEK(0xfd90103c) (used target peek value 0x8ac30000) */
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+/* PEEK(0xfdc00300) (used target peek value 0x00000000) */
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+POKE32(0xfdc00300, 0x00000100)
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+/* PEEK(0xfdc00300) (used target peek value 0x00000100) */
+
+
+/*
+sti5197_system_services_regs.REGISTER_LOCK
+*/
+WHILE_NE32(0xfdc00300, 0x00000100, 0x00000100)
+
+
+/*
+st40_ccn_regs.CCN_CCR
+*/
+POKE32(0xff00001c, 0x8000090d)
diff --git a/board/st/pdk7105/Makefile b/board/st/pdk7105/Makefile
new file mode 100644
index 0000000000..55b775617d
--- /dev/null
+++ b/board/st/pdk7105/Makefile
@@ -0,0 +1,54 @@
+#
+# (C) Copyright 2007 STMicroelectronics.
+# Stuart Menefy <stuart.menefy@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+SOBJS-y	= init-$(BOARD).o
+
+COBJS-y	+= $(BOARD).o
+COBJS-$(CONFIG_CMD_NAND) += nand.o  swUpdate.o
+
+
+SRCS	:= $(SOBJS-y:.o=.S) $(COBJS-y:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS-y))
+SOBJS	:= $(addprefix $(obj),$(SOBJS-y))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/st/pdk7105/algorithm_error.h b/board/st/pdk7105/algorithm_error.h
new file mode 100644
index 0000000000..3e1bd34c28
--- /dev/null
+++ b/board/st/pdk7105/algorithm_error.h
@@ -0,0 +1,112 @@
+/*---------------------------------------------------------------------------
+//
+//	Copyright(C) SMIT Corporation, 2000-2010.
+//
+//  File	:	algorithm_error.h
+//	Purpose	:
+//	History :
+//				2008-03-06 created by X.J.MENG.
+//
+---------------------------------------------------------------------------*/
+#ifndef XYSSL_ERROR_H
+#define XYSSL_ERROR_H
+
+#ifdef __cplusplus
+extern "C"{
+#endif
+
+//the issue rang is from 0x00a01000  to 0x00a01033
+#define ISSUE_ERROR_BASE 0x00a01000
+enum{
+//asn1 issue list
+ XYSSL_ERR_ASN1_OUT_OF_DATA = ISSUE_ERROR_BASE,
+ XYSSL_ERR_ASN1_UNEXPECTED_TAG,
+ XYSSL_ERR_ASN1_NO_CRITICAL_TAG,
+ XYSSL_ERR_ASN1_INVALID_LENGTH,
+ XYSSL_ERR_ASN1_LENGTH_MISMATCH,
+ XYSSL_ERR_ASN1_INVALID_DATA,
+//x509 issue list
+ XYSSL_ERR_X509_FEATURE_UNAVAILABLE,
+ XYSSL_ERR_X509_CERT_INVALID_PEM,
+ XYSSL_ERR_X509_CERT_INVALID_CERT,
+ XYSSL_ERR_X509_CERT_INVALID_FORMAT,
+ XYSSL_ERR_X509_CERT_INVALID_VERSION,
+ XYSSL_ERR_X509_CERT_INVALID_SERIAL,
+ XYSSL_ERR_X509_CERT_INVALID_ALG,
+ XYSSL_ERR_X509_CERT_INVALID_NAME,
+ XYSSL_ERR_X509_CERT_INVALID_DATE,
+ XYSSL_ERR_X509_CERT_INVALID_PUBKEY,
+ XYSSL_ERR_X509_CERT_INVALID_SIGNATURE,
+ XYSSL_ERR_X509_CERT_INVALID_EXTENSIONS,
+ XYSSL_ERR_X509_CERT_UNKNOWN_VERSION,
+ XYSSL_ERR_X509_CERT_UNKNOWN_SIG_ALG,
+ XYSSL_ERR_X509_CERT_UNKNOWN_PK_ALG,
+ XYSSL_ERR_X509_CERT_SIG_MISMATCH,
+ XYSSL_ERR_X509_CERT_VERIFY_FAILED,
+ XYSSL_ERR_X509_KEY_INVALID_PEM,
+ XYSSL_ERR_X509_KEY_INVALID_VERSION,
+ XYSSL_ERR_X509_KEY_INVALID_FORMAT,
+ XYSSL_ERR_X509_KEY_INVALID_ENC_IV,
+ XYSSL_ERR_X509_KEY_UNKNOWN_ENC_ALG,
+ XYSSL_ERR_X509_KEY_PASSWORD_REQUIRED,
+ XYSSL_ERR_X509_KEY_PASSWORD_MISMATCH,
+ XYSSL_ERR_X509_POINT_ERROR,
+ XYSSL_ERR_X509_VALUE_TO_LENGTH,
+ XYSSL_ERR_X509_ISSUER_AND_SUBJECT_VERIFY,
+ XYSSL_ERR_X509_EXT_BASIC_NO_VALID,
+ XYSSL_ERR_X509_ISSUE_SUBJECT,
+ XYSSL_ERR_X509_EXT_NO_VALID,
+//rsa issue list
+ XYSSL_ERR_RSA_BAD_INPUT_DATA,
+ XYSSL_ERR_RSA_INVALID_PUBLIC_KEY,
+ XYSSL_ERR_RSA_INVALID_PADDING,
+ XYSSL_ERR_RSA_KEY_GEN_FAILED,
+ XYSSL_ERR_RSA_KEY_CHECK_FAILED,
+ XYSSL_ERR_RSA_PUBLIC_FAILED,
+ XYSSL_ERR_RSA_PRIVATE_FAILED,
+ XYSSL_ERR_RSA_VERIFY_FAILED,
+//dh issue list
+ XYSSL_ERR_DHM_BAD_INPUT_DATA,
+ XYSSL_ERR_DHM_READ_PARAMS_FAILED,
+ XYSSL_ERR_DHM_MAKE_PARAMS_FAILED,
+ XYSSL_ERR_DHM_READ_PUBLIC_FAILED,
+ XYSSL_ERR_DHM_MAKE_PUBLIC_FAILED,
+ XYSSL_ERR_DHM_CALC_SECRET_FAILED,
+//mpi issue list
+ XYSSL_ERR_MPI_FILE_IO_ERROR,
+ XYSSL_ERR_MPI_BAD_INPUT_DATA,
+ XYSSL_ERR_MPI_INVALID_CHARACTER,
+ XYSSL_ERR_MPI_BUFFER_TOO_SMALL,
+ XYSSL_ERR_MPI_NEGATIVE_VALUE,
+ XYSSL_ERR_MPI_DIVISION_BY_ZERO,
+ XYSSL_ERR_MPI_NOT_ACCEPTABLE,
+//base64 issue list
+ XYSSL_ERR_BASE64_BUFFER_TOO_SMALL,
+ XYSSL_ERR_BASE64_INVALID_CHARACTER,
+//SHA-1 and SHA-256 issue list
+XYSSL_ERR_SHA1_SIGN_LEN_INPUT_CHECK_FAILED ,
+XYSSL_ERR_SHA1_SIGN_LEN_OUT_CHECK_FAILED,
+XYSSL_ERR_SHA256_SIGN_LEN_INPUT_CHECK_FAILED,
+XYSSL_ERR_SHA256_SIGN_LEN_OUT_CHECK_FAILED,
+//DES issue list
+XYSSL_ERR_DES_KEY_LEN_INPUT_CHECK_FAILED,
+XYSSL_ERR_DES_DATE_LEN_OUT_CHECK_FAILED,
+//AES issue list
+XYSSL_ERR_AES_KEY_LEN_INPUT_CHECK_FAILED,
+XYSSL_ERR_AES_VECTOR_LEN_INPUT_CHECK_FAILED,
+XYSSL_ERR_AES_DATES_LEN_INPUT_CHECK_FAILED,
+XYSSL_ERR_AES_DATES_LEN_OUT_PUT_CHECK_FAILED,
+//RAND ISSUE LIST
+XYSSL_ERR_RAND_DATES_GEN_OUT_FAILED,
+//MGF
+RE_MGF,               // Mask generation function not defined or not supported.
+RE_MGF_LEN,           // Invalid mask generation function input or output length.
+XYSSL_ERR_NO_VALID_MEMORY_SPACE
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff --git a/board/st/pdk7105/config.mk b/board/st/pdk7105/config.mk
new file mode 100644
index 0000000000..86ff620953
--- /dev/null
+++ b/board/st/pdk7105/config.mk
@@ -0,0 +1,43 @@
+#
+# (C) Copyright 2008 STMicroelectronics.
+# Sean McGoogan <Sean.McGoogan@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# PDK-7105 board:
+#
+#	Valid values for TEXT_BASE are:
+#
+#	0x9BF00000	29-bit mode (Traditional Mode)
+#	0x8FF00000	32-bit mode (Space-Enhancement Mode)
+#
+# Note:	Alternative definitions of TEXT_BASE are put into
+#	'config.tmp' from the top-level 'Makefile'.
+#
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef TEXT_BASE
+# Installs at LMI0 BASE + 255MB in P1 (cachable)
+TEXT_BASE = 0x9BF00000
+endif
+
+PLATFORM_LDFLAGS +=
diff --git a/board/st/pdk7105/init-pdk7105.S b/board/st/pdk7105/init-pdk7105.S
new file mode 100644
index 0000000000..19b3c32d2b
--- /dev/null
+++ b/board/st/pdk7105/init-pdk7105.S
@@ -0,0 +1,77 @@
+#include "asm/stx7105reg.h"
+#include "../../../cpu/sh/init_ram.S"
+
+/*
+ * This is derived from STMicroelectronics gnu toolchain example:
+ *   sh-superh-elf/examples/os21/romdynamic/memory_mb680.S
+ */
+
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *	opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+/*
+ * For compatibility with old poke table code, we define some of the
+ * new names, to map onto the old names. Ultimately, the old poke table
+ * code will be updated to the "new order", and we can just delete
+ * the following mappings.
+ */
+#define POKE8(A, VAL)				POKE_CHAR(A, VAL)
+#define POKE16(A, VAL)				POKE_SHORT(A, VAL)
+#define POKE32(A, VAL)				POKE_LONG(A, VAL)
+#define OR32(A, VAL)				OR_LONG(A, VAL)
+#define UPDATE32(A, AND, OR)			UPDATE_LONG(A, AND, OR)
+#define POKE_UPDATE32(A1, A2, AND, SHIFT, OR)	POKE_UPDATE_LONG(A1, A2, AND, SHIFT, OR)
+#define WHILE_NE32(A, AND, VAL)			WHILE_NE(A, AND, VAL)
+#define DELAY(VAL)				/* do nothing */
+
+
+	.section .data.init, "a"
+
+	.balign 32
+
+__memory_setup_table:
+
+	/*
+	 * include the appropriate set of "GDB pokes", (usually) generated
+	 * using the "romgen" utility, from a known good target-pack.
+	 *
+	 * This file may be regenerated by connecting your specific board
+	 * to an STMC2 (note: currently it must be version 2) and then
+	 * executing the following command (redirecting the output):
+	 *
+	 * host% romgen --target-connect --show-comment <stmc2>:sdk7105:st40
+	 *
+	 * Where "<stmc2>" should be replaced with the IP address
+	 * (or the DNS name) of the STMC2 box.  Also the "sdk7105" should
+	 * substituted if you have a custom target-pack connect command.
+	 *
+	 * Note: The connect command used with "romgen", should connect
+	 * only in 29-bit mode - even if U-Boot will be built for 32-bit mode.
+	 * That is, do not use the "seuc=1" (or similar) option with "romgen".
+	 */
+#include "pdk7105.romgen"
+
+#ifdef CONFIG_SH_SE_MODE
+	/*
+	 * Note that we also manually need to move the LMI base addresses to
+	 * their 32-bit SE mode locations as defined in the datasheet and change the
+	 * 'upper bound addresses' (in row attribute registers) for the LMIs.
+	 */
+	UPDATE32(STX7105_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
+	/* Change LMI upper bound addresses
+	 * Upper LMI addr=0x40000000 + 512MiB=0x60000000
+	 */
+	UPDATE32(ST40_LMI_SDRA0_0(), 0x001FFFFF, 0x60000000)
+	UPDATE32(ST40_LMI_SDRA1_0(), 0x001FFFFF, 0x60000000)
+#endif	/* CONFIG_SH_SE_MODE */
+
+	END_MARKER
+
+__memory_setup_table_end:
+
+	.end
diff --git a/board/st/pdk7105/nand.c b/board/st/pdk7105/nand.c
new file mode 100644
index 0000000000..78e1e2622b
--- /dev/null
+++ b/board/st/pdk7105/nand.c
@@ -0,0 +1,120 @@
+/*
+ * (C) Copyright 2006 DENX Software Engineering
+ * (C) Copyright 2008-2009 STMicroelectronics, Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <nand.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+#include <asm/stx7105reg.h>
+#include <asm/stm-nand.h>
+
+/*
+ * hardware specific access to control-lines for "bit-banging".
+ *	CL -> Emi_Addr(17)
+ *	AL -> Emi_Addr(18)
+ *	nCE is handled by EMI (not s/w controlable)
+ */
+#ifndef CFG_NAND_FLEX_MODE	/* for "bit-banging" (c.f. STM "flex-mode")  */
+static void pdk7105_hwcontrol(struct mtd_info *mtdinfo, int cmd)
+{
+	struct nand_chip* this = (struct nand_chip *)(mtdinfo->priv);
+
+	switch(cmd) {
+
+	case NAND_CTL_SETCLE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (1u << 17));
+		break;
+
+	case NAND_CTL_CLRCLE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(1u << 17));
+		break;
+
+	case NAND_CTL_SETALE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (1u << 18));
+		break;
+
+	case NAND_CTL_CLRALE:
+		this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(1u << 18));
+		break;
+	}
+}
+#endif /* CFG_NAND_FLEX_MODE */
+
+
+/*
+ * hardware specific access to the Ready/not_Busy signal.
+ * Signal is routed through the EMI NAND Controller block.
+ */
+#ifndef CFG_NAND_FLEX_MODE	/* for "bit-banging" (c.f. STM "flex-mode")  */
+static int pdk7105_device_ready(struct mtd_info *mtd)
+{
+	/* extract bit 1: status of RBn pin on boot bank */
+	return ((*ST40_EMI_NAND_RBN_STA) & (1ul<<1)) ? 1 : 0;
+}
+#endif /* CFG_NAND_FLEX_MODE */
+
+
+/*
+ * Board-specific NAND initialization. The following members of the
+ * argument are board-specific (per include/linux/mtd/nand.h):
+ * - IO_ADDR_R?: address to read the 8 I/O lines of the flash device
+ * - IO_ADDR_W?: address to write the 8 I/O lines of the flash device
+ * - hwcontrol: hardwarespecific function for accesing control-lines
+ * - dev_ready: hardwarespecific function for  accesing device ready/busy line
+ * - enable_hwecc?: function to enable (reset)  hardware ecc generator. Must
+ *   only be provided if a hardware ECC is available
+ * - eccmode: mode of ecc, see defines
+ * - chip_delay: chip dependent delay for transfering data from array to
+ *   read regs (tR)
+ * - options: various chip options. They can partly be set to inform
+ *   nand_scan about special functionality. See the defines for further
+ *   explanation
+ * Members with a "?" were not set in the merged testing-NAND branch,
+ * so they are not set here either.
+ */
+extern int board_nand_init(struct nand_chip *nand)
+{
+	nand->eccmode       = NAND_ECC_SOFT;
+	nand->options       = NAND_NO_AUTOINCR;
+
+#ifdef CFG_NAND_FLEX_MODE	/* for STM "flex-mode" (c.f. "bit-banging") */
+	nand->select_chip   = stm_flex_select_chip;
+	nand->dev_ready     = stm_flex_device_ready;
+	nand->hwcontrol     = stm_flex_hwcontrol;
+	nand->read_byte     = stm_flex_read_byte;
+	nand->write_byte    = stm_flex_write_byte;
+	nand->read_buf      = stm_flex_read_buf;
+	nand->write_buf     = stm_flex_write_buf;
+#else				/* for "bit-banging" (c.f. STM "flex-mode")  */
+	nand->dev_ready     = pdk7105_device_ready;
+	nand->hwcontrol     = pdk7105_hwcontrol;
+#endif /* CFG_NAND_FLEX_MODE */
+
+#if 1
+	/* Enable the following to use a Bad Block Table (BBT) */
+	nand->options      |= NAND_USE_FLASH_BBT;
+	nand->scan_bbt      = stm_nand_default_bbt;
+#endif
+
+	return 0;
+}
diff --git a/board/st/pdk7105/pdk7105.c b/board/st/pdk7105/pdk7105.c
new file mode 100644
index 0000000000..c975f65439
--- /dev/null
+++ b/board/st/pdk7105/pdk7105.c
@@ -0,0 +1,248 @@
+/*
+ * (C) Copyright 2008-2009 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/soc.h>
+#include <asm/stx7105reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+
+
+void flashWriteEnable(void)
+{
+	/* Enable Vpp for writing to flash */
+	/* FLASH_WP# = PIO6[4] = 1 */
+	STPIO_SET_PIN(PIO_PORT(6), 4, 1);
+}
+
+void flashWriteDisable(void)
+{
+	/* Disable Vpp for writing to flash */
+	/* FLASH_WP# = PIO6[4] = 0 */
+	STPIO_SET_PIN(PIO_PORT(6), 4, 0);
+}
+
+static void configEthernet(void)
+{
+	unsigned long sysconf;
+
+	/* Configure & Reset the Ethernet PHY */
+
+	/* Set the GMAC in MII mode */
+	sysconf = *STX7105_SYSCONF_SYS_CFG07;
+	sysconf &= ~0x060f0000ul;
+	sysconf |=  0x08010000ul;
+	*STX7105_SYSCONF_SYS_CFG07 = sysconf;
+
+	sysconf = *STX7105_SYSCONF_SYS_CFG37;
+	/* PIO7[4] CFG37[12,4]  AltFunction = 1 */
+	/* PIO7[5] CFG37[13,5]  AltFunction = 1 */
+	/* PIO7[6] CFG37[14,6]  AltFunction = 1 */
+	/* PIO7[7] CFG37[15,7]  AltFunction = 1 */
+	sysconf &= ~0xf0f0ul;	/* 3,3,3,3,0,0,0,0 */
+	*STX7105_SYSCONF_SYS_CFG37 = sysconf;
+
+	sysconf = *STX7105_SYSCONF_SYS_CFG46;
+	/* PIO8[0] CFG46[8,0]   AltFunction = 1 */
+	/* PIO8[1] CFG46[9,1]   AltFunction = 1 */
+	/* PIO8[2] CFG46[10,2]  AltFunction = 1 */
+	/* PIO8[3] CFG46[11,3]  AltFunction = 1 */
+	/* PIO8[4] CFG46[12,4]  AltFunction = 1 */
+	/* PIO8[5] CFG46[13,5]  AltFunction = 1 */
+	/* PIO8[6] CFG46[14,6]  AltFunction = 1 */
+	/* PIO8[7] CFG46[15,7]  AltFunction = 1 */
+	sysconf &= ~0xfffful;	/* 3,3,3,3,3,3,3,3 */
+	*STX7105_SYSCONF_SYS_CFG46 = sysconf;
+
+	sysconf = *STX7105_SYSCONF_SYS_CFG47;
+	/* PIO9[0] CFG47[8,0]   AltFunction = 1 */
+	/* PIO9[1] CFG47[9,1]   AltFunction = 1 */
+	/* PIO9[2] CFG47[10,2]  AltFunction = 1 */
+	/* PIO9[3] CFG47[11,3]  AltFunction = 1 */
+	/* PIO9[4] CFG47[12,4]  AltFunction = 1 */
+	/* PIO9[5] CFG47[13,5]  AltFunction = 1 */
+	/* PIO9[6] CFG47[14,6]  AltFunction = 1 */
+	sysconf &= ~0x7f7ful;	/* 0,3,3,3,3,3,3,3 */
+	*STX7105_SYSCONF_SYS_CFG47 = sysconf;
+
+	/* Setup PIO for the Ethernet's MII bus */
+	SET_PIO_PIN(PIO_PORT(7),4,STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(7),5,STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(7),6,STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(7),7,STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(8),0,STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(8),1,STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(8),2,STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(8),3,STPIO_ALT_BIDIR);
+	SET_PIO_PIN(PIO_PORT(8),4,STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(8),5,STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(8),6,STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(8),7,STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(9),0,STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(9),1,STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(9),2,STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(9),3,STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(9),4,STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(9),5,STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(9),6,STPIO_IN);
+
+	/* Setup PIO for the PHY's reset */
+	SET_PIO_PIN(PIO_PORT(15), 5, STPIO_OUT);
+
+	/* Finally, toggle the PHY Reset pin ("RST#") */
+	STPIO_SET_PIN(PIO_PORT(15), 5, 0);
+	udelay(100);	/* small delay */
+	STPIO_SET_PIN(PIO_PORT(15), 5, 1);
+}
+
+#if defined(CONFIG_SPI)
+static void configSpi(void)
+{
+#if defined(CONFIG_SOFT_SPI)
+	/* Configure SPI Serial Flash for PIO "bit-banging" */
+
+#if 1
+	/*
+	 * On the PDK-7105 board, the following 4 pairs of PIO
+	 * pins are connected together with a 3K3 resistor.
+	 *
+	 *	SPI_CLK  PIO15[0] <-> PIO2[5] COM_CLK
+	 *	SPI_DOUT PIO15[1] <-> PIO2[6] COM_DOUT
+	 *	SPI_NOCS PIO15[2] <-> PIO2[4] COM_NOTCS
+	 *	SPI_DIN  PIO15[3] <-> PIO2[7] COM_DIN
+	 *
+	 * To minimise drive "contention", we may set
+	 * associated pins on PIO2 to be simple inputs.
+	 */
+	SET_PIO_PIN(PIO_PORT(2),4,STPIO_IN);	/* COM_NOTCS */
+	SET_PIO_PIN(PIO_PORT(2),5,STPIO_IN);	/* COM_CLK */
+	SET_PIO_PIN(PIO_PORT(2),6,STPIO_IN);	/* COM_DOUT */
+	SET_PIO_PIN(PIO_PORT(2),7,STPIO_IN);	/* COM_DIN */
+#endif
+
+	/* SPI is on PIO15:[3:0] */
+	SET_PIO_PIN(PIO_PORT(15),3,STPIO_IN);	/* SPI_DIN */
+	SET_PIO_PIN(PIO_PORT(15),0,STPIO_OUT);	/* SPI_CLK */
+	SET_PIO_PIN(PIO_PORT(15),1,STPIO_OUT);	/* SPI_DOUT */
+	SET_PIO_PIN(PIO_PORT(15),2,STPIO_OUT);	/* SPI_NOCS */
+
+	/* drive outputs with sensible initial values */
+	STPIO_SET_PIN(PIO_PORT(15), 2, 1);	/* deassert SPI_NOCS */
+	STPIO_SET_PIN(PIO_PORT(15), 0, 1);	/* assert SPI_CLK */
+	STPIO_SET_PIN(PIO_PORT(15), 1, 0);	/* deassert SPI_DOUT */
+#endif	/* CONFIG_SOFT_SPI */
+}
+#endif	/* CONFIG_SPI */
+
+static void configPIO(void)
+{
+	unsigned long sysconf;
+
+	/* Setup PIO of ASC device */
+#if CFG_STM_ASC_BASE == ST40_ASC0_REGS_BASE	/* UART #0 */
+	SET_PIO_ASC(PIO_PORT(0), 0, 1, 4, 3);  /* UART0 */
+#elif CFG_STM_ASC_BASE == ST40_ASC2_REGS_BASE	/* UART #2 */
+	SET_PIO_ASC(PIO_PORT(4), 0, 1, 2, 3);  /* UART2 */
+////#elif CFG_STM_ASC_BASE == ST40_ASC3_REGS_BASE	/* UART #3 */
+	SET_PIO_ASC(PIO_PORT(5), 0, 1, 3, 2);  /* UART3 */
+#else
+#error Unsure which UART to configure!
+#endif	/* CFG_STM_ASC_BASE == ST40_ASCx_REGS_BASE */
+
+#if CFG_STM_ASC_BASE == ST40_ASC0_REGS_BASE	/* UART #0 */
+	/* Route UART0 via PIO0 for TX, RX, CTS & RTS */
+	sysconf = *STX7105_SYSCONF_SYS_CFG19;
+	/* PIO0[0] CFG19[16,8,0]   AltFunction = 4 */
+	/* PIO0[1] CFG19[17,9,1]   AltFunction = 4 */
+	/* PIO0[3] CFG19[19,11,3]  AltFunction = 4 */
+	/* PIO0[4] CFG19[20,12,4]  AltFunction = 4 */
+	sysconf &= ~0x1b1b1bul;	/* 7,7,0,7,7 */
+	sysconf |=  0x001b1bul;	/* 3,3,0,3,3 */
+	*STX7105_SYSCONF_SYS_CFG19 = sysconf;
+#elif CFG_STM_ASC_BASE == ST40_ASC2_REGS_BASE	/* UART #2 */
+	/* Select UART2 via PIO4 */
+	sysconf = *STX7105_SYSCONF_SYS_CFG07;
+	/* CFG07[1] = UART2_RXD_SRC_SELECT = 0 */
+	/* CFG07[2] = UART2_CTS_SRC_SELECT = 0 */
+	sysconf &= ~(1ul<<2 | 1ul<<1);
+	*STX7105_SYSCONF_SYS_CFG07 = sysconf;
+	/* Route UART2 via PIO4 for TX, RX, CTS & RTS */
+	sysconf = *STX7105_SYSCONF_SYS_CFG34;
+	/* PIO4[0] CFG34[8,0]   AltFunction = 3 */
+	/* PIO4[1] CFG34[9,1]   AltFunction = 3 */
+	/* PIO4[2] CFG34[10,2]  AltFunction = 3 */
+	/* PIO4[3] CFG34[11,3]  AltFunction = 3 */
+	sysconf &= ~0x0f0ful;	/* 3,3,3,3 */
+	sysconf |=  0x0f00ul;	/* 2,2,2,2 */
+	*STX7105_SYSCONF_SYS_CFG34 = sysconf;
+//////#elif CFG_STM_ASC_BASE == ST40_ASC3_REGS_BASE	/* UART #3 */
+	/* Route UART3 via PIO5 for TX, RX, CTS & RTS */
+	sysconf = *STX7105_SYSCONF_SYS_CFG35;
+	/* PIO5[0] CFG35[8,0]   AltFunction = 3 */
+	/* PIO5[1] CFG35[9,1]   AltFunction = 3 */
+	/* PIO5[2] CFG35[10,2]  AltFunction = 3 */
+	/* PIO5[3] CFG35[11,3]  AltFunction = 3 */
+	sysconf &= ~0x0f0ful;	/* 3,3,3,3 */
+	sysconf |=  0x000ful;	/* 1,1,1,1 */
+	*STX7105_SYSCONF_SYS_CFG35 = sysconf;
+#else
+#error Unsure which UART to configure!
+#endif	/* CFG_STM_ASC_BASE == ST40_ASCx_REGS_BASE */
+
+	/* Setup PIO for FLASH_WP# (Active-Low WriteProtect) */
+	SET_PIO_PIN(PIO_PORT(6), 4, STPIO_OUT);
+
+	/* Configure & Reset the Ethernet PHY */
+	configEthernet();
+
+#if defined(CONFIG_SPI)
+	/* Configure for SPI Serial Flash */
+	configSpi();
+#endif	/* CONFIG_SPI */
+}
+
+extern int board_init(void)
+{
+	configPIO();
+
+#if defined(CONFIG_SH_STM_SATA)
+	stx7105_configure_sata ();
+#endif	/* CONFIG_SH_STM_SATA */
+
+	return 0;
+}
+
+int checkboard (void)
+{
+	printf ("\n\nBoard: STx7105-PDK"
+#ifdef CONFIG_SH_SE_MODE
+		"  [32-bit mode]"
+#else
+		"  [29-bit mode]"
+#endif
+		"\n");
+
+	return 0;
+}
diff --git a/board/st/pdk7105/pdk7105.romgen b/board/st/pdk7105/pdk7105.romgen
new file mode 100644
index 0000000000..19f933e5fe
--- /dev/null
+++ b/board/st/pdk7105/pdk7105.romgen
@@ -0,0 +1,549 @@
+
+/*
+sdk7105 connect start - parameters {'no_devid_validate': '1', 'no_convertor_abort': '1', 'no_devid_abort': '1'}
+Initialization TCK frequency set to 1562500 Hz
+Device id  0x1d43e041
+tapmux connect(): boot mode single core setup
+tapmux setup to bypass to core st40, channel 1
+sdk7105 initialization start ...
+sdk7105_setup - parameters {'tapmux_bypass_init': u'st40', 'no_devid_validate': '1', 'no_convertor_abort': '1', 'reset_low_period': 360000, 'no_devid_abort': '1'}
+Chip infos
+*/
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_DEVICEID0
+PEEK(0xfe001000) (used target peek value 0x1d43e041)
+Device ID = 0x1D43E041 ==> STi7105 cut 2
+*/
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+PEEK(0xfe00100c) (used target peek value 0x00001015)
+Mode pins = 0x00001015 ==> ClockgenA ref : SYSCLKIN/OSC
+                           Boot mode ... : ST40 first
+                           Boot port size: 16-bits
+                           Boot device . : NOR flash
+*/
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG40*/
+POKE32(0xfe0011a0, 0x00000005)
+POKE32(0xfe0011a0, 0x00000005)
+
+/*stx7105_sysconf_regs.SYSCONF_CFG04*/
+POKE32(0xfe001110, 0x000001a6)
+
+/* Magic sequence to  configure the ClockGenA switch control to reset values*/
+/* These do not appear to be correctly reset on WDT reset so do it here     */
+/* CLOCKGEN A CKGA_CLKOPSRC_SWITCH_CFG  reset=0 */
+POKE32(0xfe213014, 0x00000000)
+/* CLOCKGEN A CKGA_CLKOPSRC_SWITCH_CFG2 reset=0 */
+POKE32(0xfe213024, 0x00000000)
+
+/*stx7105_clockgena_regs.CKGA_PLL0_ENABLE_FB*/
+WHILE_NE32(0xfe21301c, 0xffffffff, 0x00000000)
+
+/*stx7105_clockgena_regs.CKGA_PLL1_ENABLE_FB*/
+WHILE_NE32(0xfe213020, 0xffffffff, 0x00000000)
+
+/*stx7105_clockgena_regs.CKGA_PLL0_CFG*/
+POKE32(0xfe213000, 0x80101e02)
+
+/*stx7105_clockgena_regs.CKGA_POWER_CFG*/
+POKE32(0xfe213010, 0x00000001)
+
+
+/*stx7105_clockgena_regs.CKGA_PLL0_CFG*/
+POKE32(0xfe213000, 0x00180f01)
+
+/*stx7105_clockgena_regs.CKGA_POWER_CFG*/
+POKE32(0xfe213010, 0x00000000)
+
+
+/*stx7105_clockgena_regs.CKGA_PLL0_CFG*/
+WHILE_NE32(0xfe213000, 0x80000000, 0x80000000)
+
+
+/*stx7105_clockgena_regs.CKGA_PLL0_CFG*/
+POKE32(0xfe213000, 0x80000f01)
+
+
+/*stx7105_clockgena_regs.CKGA_PLL1_CFG*/
+POKE32(0xfe213004, 0x80102803)
+
+
+POKE32(0xfe213b00, 0x00000001)      /*stx7105_clockgena_regs.CKGA_PLL1_DIV0_CFG*/
+POKE32(0xfe213b04, 0x00000001)      /*stx7105_clockgena_regs.CKGA_PLL1_DIV1_CFG*/
+POKE32(0xfe213b08, 0x00000001)      /*stx7105_clockgena_regs.CKGA_PLL1_DIV2_CFG*/
+POKE32(0xfe213b0c, 0x00000103)      /*stx7105_clockgena_regs.CKGA_PLL1_DIV3_CFG*/
+POKE32(0xfe213a10, 0x00010100)      /*stx7105_clockgena_regs.CKGA_PLL0LS_DIV4_CFG*/
+POKE32(0xfe213b14, 0x00000307)      /*stx7105_clockgena_regs.CKGA_PLL1_DIV5_CFG*/
+POKE32(0xfe213a18, 0x00010100)      /*stx7105_clockgena_regs.CKGA_PLL0LS_DIV6_CFG*/
+POKE32(0xfe213a1c, 0x00010100)      /*stx7105_clockgena_regs.CKGA_PLL0LS_DIV7_CFG*/
+POKE32(0xfe213b20, 0x00000103)      /*stx7105_clockgena_regs.CKGA_PLL1_DIV8_CFG*/
+POKE32(0xfe213b24, 0x00000103)      /*stx7105_clockgena_regs.CKGA_PLL1_DIV9_CFG*/
+POKE32(0xfe213b28, 0x00000103)      /*stx7105_clockgena_regs.CKGA_PLL1_DIV10_CFG*/
+POKE32(0xfe213b2c, 0x00000103)      /*stx7105_clockgena_regs.CKGA_PLL1_DIV11_CFG*/
+POKE32(0xfe213b30, 0x00000102)      /*stx7105_clockgena_regs.CKGA_PLL1_DIV12_CFG*/
+POKE32(0xfe213a34, 0x00000811)      /*stx7105_clockgena_regs.CKGA_PLL0LS_DIV13_CFG*/
+POKE32(0xfe213b38, 0x0000050b)      /*stx7105_clockgena_regs.CKGA_PLL1_DIV14_CFG*/
+POKE32(0xfe213b3c, 0x00000307)      /*stx7105_clockgena_regs.CKGA_PLL1_DIV15_CFG*/
+POKE32(0xfe213b40, 0x00000103)      /*stx7105_clockgena_regs.CKGA_PLL1_DIV16_CFG*/
+POKE32(0xfe213b44, 0x00000103)      /*stx7105_clockgena_regs.CKGA_PLL1_DIV17_CFG*/
+
+
+POKE32(0xfe213010, 0x00000002)      /*stx7105_clockgena_regs.CKGA_POWER_CFG*/
+POKE32(0xfe213004, 0x00182803)      /*stx7105_clockgena_regs.CKGA_PLL1_CFG*/
+POKE32(0xfe213010, 0x00000000)      /*stx7105_clockgena_regs.CKGA_POWER_CFG*/
+WHILE_NE32(0xfe213004, 0x80000000, 0x80000000)    /*stx7105_clockgena_regs.CKGA_PLL1_CFG*/
+POKE32(0xfe213004, 0x80002803)      /*stx7105_clockgena_regs.CKGA_PLL1_CFG*/
+POKE32(0xfe213014, 0xa6aa59aa)      /*stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG*/
+POKE32(0xfe213024, 0x0000000a)      /*stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2*/
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG11*/
+POKE32(0xfe00112c, 0x00001d28)
+POKE32(0xfe00112c, 0x00001af4)
+POKE32(0xfe00112c, 0x00000af4)
+
+/*stx7105_sysconf_regs.SYSCONF_STA3*/
+WHILE_NE32(0xfe001014, 0x00000001, 0x00000000)
+
+
+/*set_lmi2x_freq: freq=800.000 rdiv=0x3, ddiv=0x50 Clock frequencies*/
+/*stx7105_sysconf_regs.SYSCONF_CFG04*/
+POKE32(0xfe001110, 0x000001a2)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG11*/
+POKE32(0xfe00112c, 0x08000af5)
+
+/*stx7105_sysconf_regs.SYSCONF_CFG12*/
+POKE32(0xfe001130, 0xa000380f)
+POKE32(0xfe001130, 0xa000380f)
+POKE32(0xfe001130, 0xa000380f)
+POKE32(0xfe001130, 0xa000380f)
+POKE32(0xfe001130, 0xa000380f)
+POKE32(0xfe001130, 0xa000380f)
+POKE32(0xfe001130, 0xa200380f)
+POKE32(0xfe001130, 0xa200380f)
+POKE32(0xfe001130, 0xa200380f)
+POKE32(0xfe001130, 0xa200380f)
+POKE32(0xfe001130, 0xa200380f)
+POKE32(0xfe001130, 0xa200780f)
+POKE32(0xfe001130, 0xa200780f)
+POKE32(0xfe001130, 0xa200680f)
+POKE32(0xfe001130, 0xa200680f)
+POKE32(0xfe001130, 0xa200680f)
+POKE32(0xfe001130, 0xa200680f)
+POKE32(0xfe001130, 0xa200680f)
+POKE32(0xfe001130, 0xa200684f)
+POKE32(0xfe001130, 0xa200686f)
+/*
+POKE32(0xfe001130, 0xa200687f)
+POKE32(0xfe001130, 0xa200687f)
+POKE32(0xfe001130, 0xa200687f)
+POKE32(0xfe001130, 0xa200687f)
+POKE32(0xfe001130, 0xa200687f)
+*/
+
+POKE32(0xfe001130, 0xa200687f)
+POKE32(0xfe001130, 0xa200687f)
+POKE32(0xfe001130, 0xa200687f)
+POKE32(0xfe001130, 0xa200687f)
+POKE32(0xfe001130, 0xa200687f)
+
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG13*/
+POKE32(0xfe001134, 0x00400000)
+POKE32(0xfe001134, 0x00600000)
+POKE32(0xfe001134, 0x00600000)
+POKE32(0xfe001134, 0x00600000)
+POKE32(0xfe001134, 0x00600000)
+POKE32(0xfe001134, 0x00600000)
+POKE32(0xfe001134, 0x00600000)
+POKE32(0xfe001134, 0x00600000)
+POKE32(0xfe001134, 0x00600000)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG14*/
+POKE32(0xfe001138, 0x00000000)
+POKE32(0xfe001138, 0x00000000)
+POKE32(0xfe001138, 0x00000000)
+POKE32(0xfe001138, 0x00000000)
+POKE32(0xfe001138, 0x00000000)
+POKE32(0xfe001138, 0x00000000)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG38*/
+POKE32(0xfe001198, 0x0000fe00)
+POKE32(0xfe001198, 0x0000fe00)
+POKE32(0xfe001198, 0x0000fe00)
+POKE32(0xfe001198, 0x0020fe00)
+POKE32(0xfe001198, 0x0020fe00)
+POKE32(0xfe001198, 0x002cfe00)
+POKE32(0xfe001198, 0x002ffe00)
+POKE32(0xfe001198, 0x002ffe0c)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG40*/
+POKE32(0xfe0011a0, 0x00000005)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG42*/
+POKE32(0xfe0011a8, 0x20000000)
+POKE32(0xfe0011a8, 0x28000000)
+POKE32(0xfe0011a8, 0x2fb80000)
+POKE32(0xfe0011a8, 0x2fbbdc00)
+POKE32(0xfe0011a8, 0x2fbbddee)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG43*/
+POKE32(0xfe0011ac, 0x00000000)
+POKE32(0xfe0011ac, 0x18000000)
+POKE32(0xfe0011ac, 0x18a00000)
+POKE32(0xfe0011ac, 0x18a001ee)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG51*/
+POKE32(0xfe0011cc, 0x00000000)
+POKE32(0xfe0011cc, 0x00000000)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG52*/
+POKE32(0xfe0011d0, 0x00000000)
+POKE32(0xfe0011d0, 0x00000000)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG55*/
+POKE32(0xfe0011dc, 0x00002000)
+POKE32(0xfe0011dc, 0x00002000)
+POKE32(0xfe0011dc, 0x00002000)
+POKE32(0xfe0011dc, 0x07fc2000)
+POKE32(0xfe0011dc, 0x07fc2000)
+POKE32(0xfe0011dc, 0x07fc2000)
+POKE32(0xfe0011dc, 0x07fc2000)
+POKE32(0xfe0011dc, 0x07fc2280)
+POKE32(0xfe0011dc, 0x07fc22c0)
+POKE32(0xfe0011dc, 0x07fc22c0)
+POKE32(0xfe0011dc, 0x07fc22c4)
+
+/*stx7105_sysconf_regs.SYSCONF_CFG04*/
+POKE32(0xfe001110, 0x000001a6)
+DELAY(10)
+
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG13*/
+POKE32(0xfe001134, 0x00600000)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG14*/
+POKE32(0xfe001138, 0x00000000)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG42*/
+POKE32(0xfe0011a8, 0x2fbbddee)
+POKE32(0xfe0011a8, 0x2fbbddee)
+POKE32(0xfe0011a8, 0x2fbbddee)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG43*/
+POKE32(0xfe0011ac, 0x18a001ee)
+POKE32(0xfe0011ac, 0x18a001ee)
+
+/*stx7105_sysconf_regs.SYSCONF_CFG51*/
+POKE32(0xfe0011cc, 0x00000000)
+POKE32(0xfe0011cc, 0x00000000)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG52*/
+POKE32(0xfe0011d0, 0x00000000)
+POKE32(0xfe0011d0, 0x00000000)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG55*/
+POKE32(0xfe0011dc, 0x07fc22c4)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG04*/
+POKE32(0xfe001110, 0x000001a2)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG11*/
+POKE32(0xfe00112c, 0x00000af5)
+POKE32(0xfe00112c, 0x00000af4)
+DELAY(10)
+POKE32(0xfe00112c, 0x08000af4)
+POKE32(0xfe00112c, 0x08000af5)
+DELAY(10)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG04*/
+POKE32(0xfe001110, 0x000001a6)
+DELAY(10)
+
+
+/*st40_emi_regs.EMI_BANK_ENABLE*/
+POKE32(0xfe700860, 0x00000005)
+
+POKE32(0xfe700800, 0x00000000)   /*st40_emi_regs.EMI_BANK0_BASEADDRESS*/
+POKE32(0xfe700810, 0x00000010)   /*st40_emi_regs.EMI_BANK1_BASEADDRESS*/
+POKE32(0xfe700820, 0x00000018)   /*st40_emi_regs.EMI_BANK2_BASEADDRESS*/
+POKE32(0xfe700830, 0x0000001a)   /*st40_emi_regs.EMI_BANK3_BASEADDRESS*/
+POKE32(0xfe700840, 0x0000001c)   /*st40_emi_regs.EMI_BANK4_BASEADDRESS*/
+
+
+
+/*st40_emi_regs.EMI_BANK0_EMICONFIGDATA0-3*/
+POKE32(0xfe700100, 0x001016d1)
+POKE32(0xfe700108, 0x9d200000)
+POKE32(0xfe700110, 0x9d220000)
+POKE32(0xfe700118, 0x00000000)
+
+
+/*st40_emi_regs.EMI_BANK1_EMICONFIGDATA0-3*/
+POKE32(0xfe700140, 0x002016d1)
+POKE32(0xfe700148, 0x9d222200)
+POKE32(0xfe700150, 0x9d220044)
+POKE32(0xfe700158, 0x00000000)
+
+
+/*st40_emi_regs.EMI_BANK2_EMICONFIGDATA0-3*/
+POKE32(0xfe700180, 0x002046f9)
+POKE32(0xfe700188, 0xa5a00000)
+POKE32(0xfe700190, 0xa5a20000)
+POKE32(0xfe700198, 0x00000000)
+
+
+/*st40_emi_regs.EMI_BANK3_EMICONFIGDATA0-3*/
+POKE32(0xfe7001c0, 0x002016d1)
+POKE32(0xfe7001c8, 0x9d222200)
+POKE32(0xfe7001d0, 0x9d220044)
+POKE32(0xfe7001d8, 0x00000000)
+
+
+/*st40_emi_regs.EMI_BANK4_EMICONFIGDATA0-3*/
+POKE32(0xfe700200, 0x002016d1)
+POKE32(0xfe700208, 0x9d222200)
+POKE32(0xfe700210, 0x9d220044)
+POKE32(0xfe700218, 0x00000000)
+
+
+/*st40_emi_regs.EMI_GENCFG*/
+POKE32(0xfe700028, 0x00000010)
+
+
+/*st40_lmigp_regs.LMI_MIM_0-1*/
+POKE32(0xfe901008, 0x0b30017b)
+POKE32(0xfe90100c, 0x000000b0)
+
+
+/*st40_lmigp_regs.LMI_STR_0-1*/
+POKE32(0xfe901018, 0xcf35b424)
+POKE32(0xfe90101c, 0x00242ed8)
+
+/*st40_lmigp_regs.LMI_SDRA0_0-1*/
+POKE32(0xfe901030, 0x1c001a20)
+POKE32(0xfe901038, 0x1c001a20)
+DELAY(200000)
+
+
+/*st40_lmigp_regs.LMI_SCR_0*/
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020023)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020022)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+
+
+/*st40_lmigp_regs.LMI_SDMR0_0*/
+POKE32(0xfe901048, 0x00010000)
+
+/*st40_lmigp_regs.LMI_SDMR0_0*/
+POKE32(0xfe901048, 0x00018000)
+
+/*st40_lmigp_regs.LMI_SDMR0_0*/
+POKE32(0xfe901048, 0x00008006)
+
+/*st40_lmigp_regs.LMI_SDMR0_0*/
+POKE32(0xfe901048, 0x00004363)
+
+/*st40_lmigp_regs.LMI_SCR_0*/
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020022)
+POKE32(0xfe901010, 0x00020024)
+POKE32(0xfe901010, 0x00020024)
+
+
+/*st40_lmigp_regs.LMI_SDMR0_0*/
+POKE32(0xfe901048, 0x00004263)
+
+/*st40_lmigp_regs.LMI_MIM_0*/
+POKE32(0xfe901008, 0x0b30037b)
+POKE32(0xfe901008, 0x0b30037b)
+
+
+/*st40_lmigp_regs.LMI_SCR_0*/
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+
+
+/*st40_lmigp_regs.LMI_GCC_0*/
+POKE32(0xfe901028, 0x00000000)
+
+/*Info: correcting interco reset setup*/
+POKE32(0xfe20d200, 0x00000005)
+POKE32(0xfe20d204, 0x00000004)
+POKE32(0xfe20d208, 0x00000003)
+POKE32(0xfe20d20c, 0x00000002)
+POKE32(0xfe20d210, 0x00000001)
+POKE32(0xfe20d214, 0x00000001)
+POKE32(0xfe20d218, 0x00000001)
+POKE32(0xfe20d21c, 0x00000001)
+POKE32(0xfe20d220, 0x00000001)
+POKE32(0xfe2410fc, 0x00000005)
+POKE32(0xfe20a0ec, 0x00000002)
+POKE32(0xfe20a0f0, 0x00000005)
+POKE32(0xfe20a0f4, 0x00000003)
+POKE32(0xfe20a0f8, 0x00000003)
+POKE32(0xfe20a1ec, 0x00000002)
+POKE32(0xfe20a1f0, 0x00000005)
+POKE32(0xfe20a1f4, 0x00000003)
+POKE32(0xfe20a1f8, 0x00000003)
+POKE32(0xfe20a1fc, 0x00000000)
+POKE32(0xfe20a2ec, 0x00000002)
+POKE32(0xfe20a2f0, 0x00000005)
+POKE32(0xfe20a2f4, 0x00000003)
+POKE32(0xfe20a2f8, 0x00000003)
+POKE32(0xfe20a2fc, 0x00000000)
+POKE32(0xfe20a3ec, 0x00000002)
+POKE32(0xfe20a3f0, 0x00000005)
+POKE32(0xfe20a3f4, 0x00000003)
+POKE32(0xfe20a3f8, 0x00000003)
+POKE32(0xfe20a3fc, 0x00000000)
+POKE32(0xfe20aefc, 0x00000005)
+POKE32(0xfe540034, 0x00000003)
+POKE32(0xfe540038, 0x00000000)
+POKE32(0xfe540110, 0x00010303)
+POKE32(0xfe540114, 0x00000000)
+POKE32(0xfe540030, 0x00000005)
+POKE32(0xfe54010c, 0x00000005)
+POKE32(0xfe540600, 0x00000006)
+POKE32(0xfe540604, 0x00000005)
+POKE32(0xfe540608, 0x00000004)
+POKE32(0xfe54060c, 0x00000003)
+POKE32(0xfe540610, 0x00000002)
+POKE32(0xfe540614, 0x00000001)
+POKE32(0xfe540618, 0x00000000)
+POKE32(0xfe540680, 0x00000001)
+POKE32(0xfe540684, 0x00000000)
+POKE32(0xfe20bb04, 0x00000005)
+POKE32(0xfe20bb08, 0x00000003)
+POKE32(0xfe20bb10, 0x00000002)
+POKE32(0xfe20bb24, 0x00000005)
+POKE32(0xfe20bb28, 0x00000003)
+POKE32(0xfe20bb2c, 0x00000000)
+POKE32(0xfe20bb30, 0x00000002)
+POKE32(0xfe20bb44, 0x00000005)
+POKE32(0xfe20bb48, 0x00000003)
+POKE32(0xfe20bb4c, 0x00000000)
+POKE32(0xfe20bb50, 0x00000002)
+POKE32(0xfe20bb84, 0x00000005)
+POKE32(0xfe20bb88, 0x00000003)
+POKE32(0xfe20bb8c, 0x00000000)
+POKE32(0xfe20bb90, 0x00000002)
+POKE32(0xfe20a0fc, 0x00000000)
+POKE32(0xfe20bb0c, 0x00000000)
+POKE32(0xfe231010, 0x00000008)
+POKE32(0xfe231080, 0x00000221)
+POKE32(0xfe261010, 0x00000008)
+POKE32(0xfe261080, 0x00000221)
+POKE32(0xfd101024, 0x0003c000)
+POKE32(0xfd101824, 0x0003c000)
+POKE32(0xfd104d24, 0x0003c000)
+POKE32(0xfd102024, 0x0003c000)
+/* PEEK(0xfe001180) (used target peek value 0x00000b35) */
+POKE32(0xfe001180, 0x00000b05)
+POKE32(0xfe1fff04, 0x00254608)
+POKE32(0xfeafff04, 0x00254608)
+/* PEEK(0xfe00111c) (used target peek value 0x08081508) */
+POKE32(0xfe00111c, 0x08091508)
+POKE32(0xfd117000, 0x0025c608)
+POKE32(0xfd111000, 0x00201004)
+/* PEEK(0xfe001180) (used target peek value 0x00000b05) */
+POKE32(0xfe001180, 0x00000b01)
+POKE32(0xfe401744, 0x0025c005)
+
+
+/*st40_ccn_regs.CCN_CCR*/
+POKE32(0xff00001c, 0x8000090d)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG09*/
+POKE32(0xfe001124, 0x08000a8c)
+
+/*stx7105_sysconf_regs.SYSCONF_CFG05*/
+POKE32(0xfe001114, 0x04000040)
+
+/*stx7105_sysconf_regs.SYSCONF_CFG26*/
+POKE32(0xfe001168, 0xfe804001)
+
+/*stx7105_sysconf_regs.SYSCONF_CFG27*/
+POKE32(0xfe00116c, 0x00001fd1)
+POKE32(0xfe00116c, 0x00001fd0)
+
+/*stx7105: booted audio companion*/
+/*stx7105_sysconf_regs.SYSCONF_CFG09*/
+POKE32(0xfe001124, 0x08000a8c)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG05*/
+POKE32(0xfe001114, 0x04000040)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG28*/
+POKE32(0xfe001170, 0xfe604001)
+
+/*stx7105_sysconf_regs.SYSCONF_CFG29*/
+POKE32(0xfe001174, 0x00001fcd)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG29*/
+POKE32(0xfe001174, 0x00001fcc)
+
+/* stx7105: booted video companion*/
+/* TCK frequency set to 12500000 Hz*/
+/* tapmux complete_connect(): single core setup*/
+/* sdk7105 initialization complete*/
diff --git a/board/st/pdk7105/pdk7105.romgen-733MHZ b/board/st/pdk7105/pdk7105.romgen-733MHZ
new file mode 100644
index 0000000000..19f933e5fe
--- /dev/null
+++ b/board/st/pdk7105/pdk7105.romgen-733MHZ
@@ -0,0 +1,549 @@
+
+/*
+sdk7105 connect start - parameters {'no_devid_validate': '1', 'no_convertor_abort': '1', 'no_devid_abort': '1'}
+Initialization TCK frequency set to 1562500 Hz
+Device id  0x1d43e041
+tapmux connect(): boot mode single core setup
+tapmux setup to bypass to core st40, channel 1
+sdk7105 initialization start ...
+sdk7105_setup - parameters {'tapmux_bypass_init': u'st40', 'no_devid_validate': '1', 'no_convertor_abort': '1', 'reset_low_period': 360000, 'no_devid_abort': '1'}
+Chip infos
+*/
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_DEVICEID0
+PEEK(0xfe001000) (used target peek value 0x1d43e041)
+Device ID = 0x1D43E041 ==> STi7105 cut 2
+*/
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+PEEK(0xfe00100c) (used target peek value 0x00001015)
+Mode pins = 0x00001015 ==> ClockgenA ref : SYSCLKIN/OSC
+                           Boot mode ... : ST40 first
+                           Boot port size: 16-bits
+                           Boot device . : NOR flash
+*/
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG40*/
+POKE32(0xfe0011a0, 0x00000005)
+POKE32(0xfe0011a0, 0x00000005)
+
+/*stx7105_sysconf_regs.SYSCONF_CFG04*/
+POKE32(0xfe001110, 0x000001a6)
+
+/* Magic sequence to  configure the ClockGenA switch control to reset values*/
+/* These do not appear to be correctly reset on WDT reset so do it here     */
+/* CLOCKGEN A CKGA_CLKOPSRC_SWITCH_CFG  reset=0 */
+POKE32(0xfe213014, 0x00000000)
+/* CLOCKGEN A CKGA_CLKOPSRC_SWITCH_CFG2 reset=0 */
+POKE32(0xfe213024, 0x00000000)
+
+/*stx7105_clockgena_regs.CKGA_PLL0_ENABLE_FB*/
+WHILE_NE32(0xfe21301c, 0xffffffff, 0x00000000)
+
+/*stx7105_clockgena_regs.CKGA_PLL1_ENABLE_FB*/
+WHILE_NE32(0xfe213020, 0xffffffff, 0x00000000)
+
+/*stx7105_clockgena_regs.CKGA_PLL0_CFG*/
+POKE32(0xfe213000, 0x80101e02)
+
+/*stx7105_clockgena_regs.CKGA_POWER_CFG*/
+POKE32(0xfe213010, 0x00000001)
+
+
+/*stx7105_clockgena_regs.CKGA_PLL0_CFG*/
+POKE32(0xfe213000, 0x00180f01)
+
+/*stx7105_clockgena_regs.CKGA_POWER_CFG*/
+POKE32(0xfe213010, 0x00000000)
+
+
+/*stx7105_clockgena_regs.CKGA_PLL0_CFG*/
+WHILE_NE32(0xfe213000, 0x80000000, 0x80000000)
+
+
+/*stx7105_clockgena_regs.CKGA_PLL0_CFG*/
+POKE32(0xfe213000, 0x80000f01)
+
+
+/*stx7105_clockgena_regs.CKGA_PLL1_CFG*/
+POKE32(0xfe213004, 0x80102803)
+
+
+POKE32(0xfe213b00, 0x00000001)      /*stx7105_clockgena_regs.CKGA_PLL1_DIV0_CFG*/
+POKE32(0xfe213b04, 0x00000001)      /*stx7105_clockgena_regs.CKGA_PLL1_DIV1_CFG*/
+POKE32(0xfe213b08, 0x00000001)      /*stx7105_clockgena_regs.CKGA_PLL1_DIV2_CFG*/
+POKE32(0xfe213b0c, 0x00000103)      /*stx7105_clockgena_regs.CKGA_PLL1_DIV3_CFG*/
+POKE32(0xfe213a10, 0x00010100)      /*stx7105_clockgena_regs.CKGA_PLL0LS_DIV4_CFG*/
+POKE32(0xfe213b14, 0x00000307)      /*stx7105_clockgena_regs.CKGA_PLL1_DIV5_CFG*/
+POKE32(0xfe213a18, 0x00010100)      /*stx7105_clockgena_regs.CKGA_PLL0LS_DIV6_CFG*/
+POKE32(0xfe213a1c, 0x00010100)      /*stx7105_clockgena_regs.CKGA_PLL0LS_DIV7_CFG*/
+POKE32(0xfe213b20, 0x00000103)      /*stx7105_clockgena_regs.CKGA_PLL1_DIV8_CFG*/
+POKE32(0xfe213b24, 0x00000103)      /*stx7105_clockgena_regs.CKGA_PLL1_DIV9_CFG*/
+POKE32(0xfe213b28, 0x00000103)      /*stx7105_clockgena_regs.CKGA_PLL1_DIV10_CFG*/
+POKE32(0xfe213b2c, 0x00000103)      /*stx7105_clockgena_regs.CKGA_PLL1_DIV11_CFG*/
+POKE32(0xfe213b30, 0x00000102)      /*stx7105_clockgena_regs.CKGA_PLL1_DIV12_CFG*/
+POKE32(0xfe213a34, 0x00000811)      /*stx7105_clockgena_regs.CKGA_PLL0LS_DIV13_CFG*/
+POKE32(0xfe213b38, 0x0000050b)      /*stx7105_clockgena_regs.CKGA_PLL1_DIV14_CFG*/
+POKE32(0xfe213b3c, 0x00000307)      /*stx7105_clockgena_regs.CKGA_PLL1_DIV15_CFG*/
+POKE32(0xfe213b40, 0x00000103)      /*stx7105_clockgena_regs.CKGA_PLL1_DIV16_CFG*/
+POKE32(0xfe213b44, 0x00000103)      /*stx7105_clockgena_regs.CKGA_PLL1_DIV17_CFG*/
+
+
+POKE32(0xfe213010, 0x00000002)      /*stx7105_clockgena_regs.CKGA_POWER_CFG*/
+POKE32(0xfe213004, 0x00182803)      /*stx7105_clockgena_regs.CKGA_PLL1_CFG*/
+POKE32(0xfe213010, 0x00000000)      /*stx7105_clockgena_regs.CKGA_POWER_CFG*/
+WHILE_NE32(0xfe213004, 0x80000000, 0x80000000)    /*stx7105_clockgena_regs.CKGA_PLL1_CFG*/
+POKE32(0xfe213004, 0x80002803)      /*stx7105_clockgena_regs.CKGA_PLL1_CFG*/
+POKE32(0xfe213014, 0xa6aa59aa)      /*stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG*/
+POKE32(0xfe213024, 0x0000000a)      /*stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2*/
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG11*/
+POKE32(0xfe00112c, 0x00001d28)
+POKE32(0xfe00112c, 0x00001af4)
+POKE32(0xfe00112c, 0x00000af4)
+
+/*stx7105_sysconf_regs.SYSCONF_STA3*/
+WHILE_NE32(0xfe001014, 0x00000001, 0x00000000)
+
+
+/*set_lmi2x_freq: freq=800.000 rdiv=0x3, ddiv=0x50 Clock frequencies*/
+/*stx7105_sysconf_regs.SYSCONF_CFG04*/
+POKE32(0xfe001110, 0x000001a2)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG11*/
+POKE32(0xfe00112c, 0x08000af5)
+
+/*stx7105_sysconf_regs.SYSCONF_CFG12*/
+POKE32(0xfe001130, 0xa000380f)
+POKE32(0xfe001130, 0xa000380f)
+POKE32(0xfe001130, 0xa000380f)
+POKE32(0xfe001130, 0xa000380f)
+POKE32(0xfe001130, 0xa000380f)
+POKE32(0xfe001130, 0xa000380f)
+POKE32(0xfe001130, 0xa200380f)
+POKE32(0xfe001130, 0xa200380f)
+POKE32(0xfe001130, 0xa200380f)
+POKE32(0xfe001130, 0xa200380f)
+POKE32(0xfe001130, 0xa200380f)
+POKE32(0xfe001130, 0xa200780f)
+POKE32(0xfe001130, 0xa200780f)
+POKE32(0xfe001130, 0xa200680f)
+POKE32(0xfe001130, 0xa200680f)
+POKE32(0xfe001130, 0xa200680f)
+POKE32(0xfe001130, 0xa200680f)
+POKE32(0xfe001130, 0xa200680f)
+POKE32(0xfe001130, 0xa200684f)
+POKE32(0xfe001130, 0xa200686f)
+/*
+POKE32(0xfe001130, 0xa200687f)
+POKE32(0xfe001130, 0xa200687f)
+POKE32(0xfe001130, 0xa200687f)
+POKE32(0xfe001130, 0xa200687f)
+POKE32(0xfe001130, 0xa200687f)
+*/
+
+POKE32(0xfe001130, 0xa200687f)
+POKE32(0xfe001130, 0xa200687f)
+POKE32(0xfe001130, 0xa200687f)
+POKE32(0xfe001130, 0xa200687f)
+POKE32(0xfe001130, 0xa200687f)
+
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG13*/
+POKE32(0xfe001134, 0x00400000)
+POKE32(0xfe001134, 0x00600000)
+POKE32(0xfe001134, 0x00600000)
+POKE32(0xfe001134, 0x00600000)
+POKE32(0xfe001134, 0x00600000)
+POKE32(0xfe001134, 0x00600000)
+POKE32(0xfe001134, 0x00600000)
+POKE32(0xfe001134, 0x00600000)
+POKE32(0xfe001134, 0x00600000)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG14*/
+POKE32(0xfe001138, 0x00000000)
+POKE32(0xfe001138, 0x00000000)
+POKE32(0xfe001138, 0x00000000)
+POKE32(0xfe001138, 0x00000000)
+POKE32(0xfe001138, 0x00000000)
+POKE32(0xfe001138, 0x00000000)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG38*/
+POKE32(0xfe001198, 0x0000fe00)
+POKE32(0xfe001198, 0x0000fe00)
+POKE32(0xfe001198, 0x0000fe00)
+POKE32(0xfe001198, 0x0020fe00)
+POKE32(0xfe001198, 0x0020fe00)
+POKE32(0xfe001198, 0x002cfe00)
+POKE32(0xfe001198, 0x002ffe00)
+POKE32(0xfe001198, 0x002ffe0c)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG40*/
+POKE32(0xfe0011a0, 0x00000005)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG42*/
+POKE32(0xfe0011a8, 0x20000000)
+POKE32(0xfe0011a8, 0x28000000)
+POKE32(0xfe0011a8, 0x2fb80000)
+POKE32(0xfe0011a8, 0x2fbbdc00)
+POKE32(0xfe0011a8, 0x2fbbddee)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG43*/
+POKE32(0xfe0011ac, 0x00000000)
+POKE32(0xfe0011ac, 0x18000000)
+POKE32(0xfe0011ac, 0x18a00000)
+POKE32(0xfe0011ac, 0x18a001ee)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG51*/
+POKE32(0xfe0011cc, 0x00000000)
+POKE32(0xfe0011cc, 0x00000000)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG52*/
+POKE32(0xfe0011d0, 0x00000000)
+POKE32(0xfe0011d0, 0x00000000)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG55*/
+POKE32(0xfe0011dc, 0x00002000)
+POKE32(0xfe0011dc, 0x00002000)
+POKE32(0xfe0011dc, 0x00002000)
+POKE32(0xfe0011dc, 0x07fc2000)
+POKE32(0xfe0011dc, 0x07fc2000)
+POKE32(0xfe0011dc, 0x07fc2000)
+POKE32(0xfe0011dc, 0x07fc2000)
+POKE32(0xfe0011dc, 0x07fc2280)
+POKE32(0xfe0011dc, 0x07fc22c0)
+POKE32(0xfe0011dc, 0x07fc22c0)
+POKE32(0xfe0011dc, 0x07fc22c4)
+
+/*stx7105_sysconf_regs.SYSCONF_CFG04*/
+POKE32(0xfe001110, 0x000001a6)
+DELAY(10)
+
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG13*/
+POKE32(0xfe001134, 0x00600000)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG14*/
+POKE32(0xfe001138, 0x00000000)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG42*/
+POKE32(0xfe0011a8, 0x2fbbddee)
+POKE32(0xfe0011a8, 0x2fbbddee)
+POKE32(0xfe0011a8, 0x2fbbddee)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG43*/
+POKE32(0xfe0011ac, 0x18a001ee)
+POKE32(0xfe0011ac, 0x18a001ee)
+
+/*stx7105_sysconf_regs.SYSCONF_CFG51*/
+POKE32(0xfe0011cc, 0x00000000)
+POKE32(0xfe0011cc, 0x00000000)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG52*/
+POKE32(0xfe0011d0, 0x00000000)
+POKE32(0xfe0011d0, 0x00000000)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG55*/
+POKE32(0xfe0011dc, 0x07fc22c4)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG04*/
+POKE32(0xfe001110, 0x000001a2)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG11*/
+POKE32(0xfe00112c, 0x00000af5)
+POKE32(0xfe00112c, 0x00000af4)
+DELAY(10)
+POKE32(0xfe00112c, 0x08000af4)
+POKE32(0xfe00112c, 0x08000af5)
+DELAY(10)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG04*/
+POKE32(0xfe001110, 0x000001a6)
+DELAY(10)
+
+
+/*st40_emi_regs.EMI_BANK_ENABLE*/
+POKE32(0xfe700860, 0x00000005)
+
+POKE32(0xfe700800, 0x00000000)   /*st40_emi_regs.EMI_BANK0_BASEADDRESS*/
+POKE32(0xfe700810, 0x00000010)   /*st40_emi_regs.EMI_BANK1_BASEADDRESS*/
+POKE32(0xfe700820, 0x00000018)   /*st40_emi_regs.EMI_BANK2_BASEADDRESS*/
+POKE32(0xfe700830, 0x0000001a)   /*st40_emi_regs.EMI_BANK3_BASEADDRESS*/
+POKE32(0xfe700840, 0x0000001c)   /*st40_emi_regs.EMI_BANK4_BASEADDRESS*/
+
+
+
+/*st40_emi_regs.EMI_BANK0_EMICONFIGDATA0-3*/
+POKE32(0xfe700100, 0x001016d1)
+POKE32(0xfe700108, 0x9d200000)
+POKE32(0xfe700110, 0x9d220000)
+POKE32(0xfe700118, 0x00000000)
+
+
+/*st40_emi_regs.EMI_BANK1_EMICONFIGDATA0-3*/
+POKE32(0xfe700140, 0x002016d1)
+POKE32(0xfe700148, 0x9d222200)
+POKE32(0xfe700150, 0x9d220044)
+POKE32(0xfe700158, 0x00000000)
+
+
+/*st40_emi_regs.EMI_BANK2_EMICONFIGDATA0-3*/
+POKE32(0xfe700180, 0x002046f9)
+POKE32(0xfe700188, 0xa5a00000)
+POKE32(0xfe700190, 0xa5a20000)
+POKE32(0xfe700198, 0x00000000)
+
+
+/*st40_emi_regs.EMI_BANK3_EMICONFIGDATA0-3*/
+POKE32(0xfe7001c0, 0x002016d1)
+POKE32(0xfe7001c8, 0x9d222200)
+POKE32(0xfe7001d0, 0x9d220044)
+POKE32(0xfe7001d8, 0x00000000)
+
+
+/*st40_emi_regs.EMI_BANK4_EMICONFIGDATA0-3*/
+POKE32(0xfe700200, 0x002016d1)
+POKE32(0xfe700208, 0x9d222200)
+POKE32(0xfe700210, 0x9d220044)
+POKE32(0xfe700218, 0x00000000)
+
+
+/*st40_emi_regs.EMI_GENCFG*/
+POKE32(0xfe700028, 0x00000010)
+
+
+/*st40_lmigp_regs.LMI_MIM_0-1*/
+POKE32(0xfe901008, 0x0b30017b)
+POKE32(0xfe90100c, 0x000000b0)
+
+
+/*st40_lmigp_regs.LMI_STR_0-1*/
+POKE32(0xfe901018, 0xcf35b424)
+POKE32(0xfe90101c, 0x00242ed8)
+
+/*st40_lmigp_regs.LMI_SDRA0_0-1*/
+POKE32(0xfe901030, 0x1c001a20)
+POKE32(0xfe901038, 0x1c001a20)
+DELAY(200000)
+
+
+/*st40_lmigp_regs.LMI_SCR_0*/
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020023)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020022)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+
+
+/*st40_lmigp_regs.LMI_SDMR0_0*/
+POKE32(0xfe901048, 0x00010000)
+
+/*st40_lmigp_regs.LMI_SDMR0_0*/
+POKE32(0xfe901048, 0x00018000)
+
+/*st40_lmigp_regs.LMI_SDMR0_0*/
+POKE32(0xfe901048, 0x00008006)
+
+/*st40_lmigp_regs.LMI_SDMR0_0*/
+POKE32(0xfe901048, 0x00004363)
+
+/*st40_lmigp_regs.LMI_SCR_0*/
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020022)
+POKE32(0xfe901010, 0x00020024)
+POKE32(0xfe901010, 0x00020024)
+
+
+/*st40_lmigp_regs.LMI_SDMR0_0*/
+POKE32(0xfe901048, 0x00004263)
+
+/*st40_lmigp_regs.LMI_MIM_0*/
+POKE32(0xfe901008, 0x0b30037b)
+POKE32(0xfe901008, 0x0b30037b)
+
+
+/*st40_lmigp_regs.LMI_SCR_0*/
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+
+
+/*st40_lmigp_regs.LMI_GCC_0*/
+POKE32(0xfe901028, 0x00000000)
+
+/*Info: correcting interco reset setup*/
+POKE32(0xfe20d200, 0x00000005)
+POKE32(0xfe20d204, 0x00000004)
+POKE32(0xfe20d208, 0x00000003)
+POKE32(0xfe20d20c, 0x00000002)
+POKE32(0xfe20d210, 0x00000001)
+POKE32(0xfe20d214, 0x00000001)
+POKE32(0xfe20d218, 0x00000001)
+POKE32(0xfe20d21c, 0x00000001)
+POKE32(0xfe20d220, 0x00000001)
+POKE32(0xfe2410fc, 0x00000005)
+POKE32(0xfe20a0ec, 0x00000002)
+POKE32(0xfe20a0f0, 0x00000005)
+POKE32(0xfe20a0f4, 0x00000003)
+POKE32(0xfe20a0f8, 0x00000003)
+POKE32(0xfe20a1ec, 0x00000002)
+POKE32(0xfe20a1f0, 0x00000005)
+POKE32(0xfe20a1f4, 0x00000003)
+POKE32(0xfe20a1f8, 0x00000003)
+POKE32(0xfe20a1fc, 0x00000000)
+POKE32(0xfe20a2ec, 0x00000002)
+POKE32(0xfe20a2f0, 0x00000005)
+POKE32(0xfe20a2f4, 0x00000003)
+POKE32(0xfe20a2f8, 0x00000003)
+POKE32(0xfe20a2fc, 0x00000000)
+POKE32(0xfe20a3ec, 0x00000002)
+POKE32(0xfe20a3f0, 0x00000005)
+POKE32(0xfe20a3f4, 0x00000003)
+POKE32(0xfe20a3f8, 0x00000003)
+POKE32(0xfe20a3fc, 0x00000000)
+POKE32(0xfe20aefc, 0x00000005)
+POKE32(0xfe540034, 0x00000003)
+POKE32(0xfe540038, 0x00000000)
+POKE32(0xfe540110, 0x00010303)
+POKE32(0xfe540114, 0x00000000)
+POKE32(0xfe540030, 0x00000005)
+POKE32(0xfe54010c, 0x00000005)
+POKE32(0xfe540600, 0x00000006)
+POKE32(0xfe540604, 0x00000005)
+POKE32(0xfe540608, 0x00000004)
+POKE32(0xfe54060c, 0x00000003)
+POKE32(0xfe540610, 0x00000002)
+POKE32(0xfe540614, 0x00000001)
+POKE32(0xfe540618, 0x00000000)
+POKE32(0xfe540680, 0x00000001)
+POKE32(0xfe540684, 0x00000000)
+POKE32(0xfe20bb04, 0x00000005)
+POKE32(0xfe20bb08, 0x00000003)
+POKE32(0xfe20bb10, 0x00000002)
+POKE32(0xfe20bb24, 0x00000005)
+POKE32(0xfe20bb28, 0x00000003)
+POKE32(0xfe20bb2c, 0x00000000)
+POKE32(0xfe20bb30, 0x00000002)
+POKE32(0xfe20bb44, 0x00000005)
+POKE32(0xfe20bb48, 0x00000003)
+POKE32(0xfe20bb4c, 0x00000000)
+POKE32(0xfe20bb50, 0x00000002)
+POKE32(0xfe20bb84, 0x00000005)
+POKE32(0xfe20bb88, 0x00000003)
+POKE32(0xfe20bb8c, 0x00000000)
+POKE32(0xfe20bb90, 0x00000002)
+POKE32(0xfe20a0fc, 0x00000000)
+POKE32(0xfe20bb0c, 0x00000000)
+POKE32(0xfe231010, 0x00000008)
+POKE32(0xfe231080, 0x00000221)
+POKE32(0xfe261010, 0x00000008)
+POKE32(0xfe261080, 0x00000221)
+POKE32(0xfd101024, 0x0003c000)
+POKE32(0xfd101824, 0x0003c000)
+POKE32(0xfd104d24, 0x0003c000)
+POKE32(0xfd102024, 0x0003c000)
+/* PEEK(0xfe001180) (used target peek value 0x00000b35) */
+POKE32(0xfe001180, 0x00000b05)
+POKE32(0xfe1fff04, 0x00254608)
+POKE32(0xfeafff04, 0x00254608)
+/* PEEK(0xfe00111c) (used target peek value 0x08081508) */
+POKE32(0xfe00111c, 0x08091508)
+POKE32(0xfd117000, 0x0025c608)
+POKE32(0xfd111000, 0x00201004)
+/* PEEK(0xfe001180) (used target peek value 0x00000b05) */
+POKE32(0xfe001180, 0x00000b01)
+POKE32(0xfe401744, 0x0025c005)
+
+
+/*st40_ccn_regs.CCN_CCR*/
+POKE32(0xff00001c, 0x8000090d)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG09*/
+POKE32(0xfe001124, 0x08000a8c)
+
+/*stx7105_sysconf_regs.SYSCONF_CFG05*/
+POKE32(0xfe001114, 0x04000040)
+
+/*stx7105_sysconf_regs.SYSCONF_CFG26*/
+POKE32(0xfe001168, 0xfe804001)
+
+/*stx7105_sysconf_regs.SYSCONF_CFG27*/
+POKE32(0xfe00116c, 0x00001fd1)
+POKE32(0xfe00116c, 0x00001fd0)
+
+/*stx7105: booted audio companion*/
+/*stx7105_sysconf_regs.SYSCONF_CFG09*/
+POKE32(0xfe001124, 0x08000a8c)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG05*/
+POKE32(0xfe001114, 0x04000040)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG28*/
+POKE32(0xfe001170, 0xfe604001)
+
+/*stx7105_sysconf_regs.SYSCONF_CFG29*/
+POKE32(0xfe001174, 0x00001fcd)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG29*/
+POKE32(0xfe001174, 0x00001fcc)
+
+/* stx7105: booted video companion*/
+/* TCK frequency set to 12500000 Hz*/
+/* tapmux complete_connect(): single core setup*/
+/* sdk7105 initialization complete*/
diff --git a/board/st/pdk7105/pdk7105_600_loader_elbida.romgen b/board/st/pdk7105/pdk7105_600_loader_elbida.romgen
new file mode 100644
index 0000000000..15f50ca393
--- /dev/null
+++ b/board/st/pdk7105/pdk7105_600_loader_elbida.romgen
@@ -0,0 +1,546 @@
+
+/*
+sdk7105 connect start - parameters {'no_devid_validate': '1', 'no_convertor_abort': '1', 'no_devid_abort': '1'}
+Initialization TCK frequency set to 1562500 Hz
+Device id  0x1d43e041
+tapmux connect(): boot mode single core setup
+tapmux setup to bypass to core st40, channel 1
+sdk7105 initialization start ...
+sdk7105_setup - parameters {'tapmux_bypass_init': u'st40', 'no_devid_validate': '1', 'no_convertor_abort': '1', 'reset_low_period': 360000, 'no_devid_abort': '1'}
+Chip infos
+*/
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_DEVICEID0
+PEEK(0xfe001000) (used target peek value 0x1d43e041)
+Device ID = 0x1D43E041 ==> STi7105 cut 2
+*/
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+PEEK(0xfe00100c) (used target peek value 0x00001015)
+Mode pins = 0x00001015 ==> ClockgenA ref : SYSCLKIN/OSC
+                           Boot mode ... : ST40 first
+                           Boot port size: 16-bits
+                           Boot device . : NOR flash
+*/
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG40*/
+POKE32(0xfe0011a0, 0x00000005)
+POKE32(0xfe0011a0, 0x00000005)
+
+/*stx7105_sysconf_regs.SYSCONF_CFG04*/
+POKE32(0xfe001110, 0x000001a6)
+
+/* Magic sequence to  configure the ClockGenA switch control to reset values*/
+/* These do not appear to be correctly reset on WDT reset so do it here     */
+/* CLOCKGEN A CKGA_CLKOPSRC_SWITCH_CFG  reset=0 */
+POKE32(0xfe213014, 0x00000000)
+/* CLOCKGEN A CKGA_CLKOPSRC_SWITCH_CFG2 reset=0 */
+POKE32(0xfe213024, 0x00000000)
+
+/*stx7105_clockgena_regs.CKGA_PLL0_ENABLE_FB*/
+WHILE_NE32(0xfe21301c, 0xffffffff, 0x00000000)
+
+/*stx7105_clockgena_regs.CKGA_PLL1_ENABLE_FB*/
+WHILE_NE32(0xfe213020, 0xffffffff, 0x00000000)
+
+/*stx7105_clockgena_regs.CKGA_PLL0_CFG*/
+POKE32(0xfe213000, 0x80101e02)
+
+/*stx7105_clockgena_regs.CKGA_POWER_CFG*/
+POKE32(0xfe213010, 0x00000001)
+
+
+/*stx7105_clockgena_regs.CKGA_PLL0_CFG*/
+POKE32(0xfe213000, 0x00180f01)
+
+/*stx7105_clockgena_regs.CKGA_POWER_CFG*/
+POKE32(0xfe213010, 0x00000000)
+
+
+/*stx7105_clockgena_regs.CKGA_PLL0_CFG*/
+WHILE_NE32(0xfe213000, 0x80000000, 0x80000000)
+
+
+/*stx7105_clockgena_regs.CKGA_PLL0_CFG*/
+POKE32(0xfe213000, 0x80000f01)
+
+
+/*stx7105_clockgena_regs.CKGA_PLL1_CFG*/
+POKE32(0xfe213004, 0x80102803)
+
+
+POKE32(0xfe213b00, 0x00000001)      /*stx7105_clockgena_regs.CKGA_PLL1_DIV0_CFG*/
+POKE32(0xfe213b04, 0x00000001)      /*stx7105_clockgena_regs.CKGA_PLL1_DIV1_CFG*/
+POKE32(0xfe213b08, 0x00000001)      /*stx7105_clockgena_regs.CKGA_PLL1_DIV2_CFG*/
+POKE32(0xfe213b0c, 0x00000103)      /*stx7105_clockgena_regs.CKGA_PLL1_DIV3_CFG*/
+POKE32(0xfe213a10, 0x00010100)      /*stx7105_clockgena_regs.CKGA_PLL0LS_DIV4_CFG*/
+POKE32(0xfe213b14, 0x00000307)      /*stx7105_clockgena_regs.CKGA_PLL1_DIV5_CFG*/
+POKE32(0xfe213a18, 0x00010100)      /*stx7105_clockgena_regs.CKGA_PLL0LS_DIV6_CFG*/
+POKE32(0xfe213a1c, 0x00010100)      /*stx7105_clockgena_regs.CKGA_PLL0LS_DIV7_CFG*/
+POKE32(0xfe213b20, 0x00000103)      /*stx7105_clockgena_regs.CKGA_PLL1_DIV8_CFG*/
+POKE32(0xfe213b24, 0x00000103)      /*stx7105_clockgena_regs.CKGA_PLL1_DIV9_CFG*/
+POKE32(0xfe213b28, 0x00000103)      /*stx7105_clockgena_regs.CKGA_PLL1_DIV10_CFG*/
+POKE32(0xfe213b2c, 0x00000103)      /*stx7105_clockgena_regs.CKGA_PLL1_DIV11_CFG*/
+POKE32(0xfe213b30, 0x00000102)      /*stx7105_clockgena_regs.CKGA_PLL1_DIV12_CFG*/
+POKE32(0xfe213a34, 0x00000811)      /*stx7105_clockgena_regs.CKGA_PLL0LS_DIV13_CFG*/
+POKE32(0xfe213b38, 0x0000050b)      /*stx7105_clockgena_regs.CKGA_PLL1_DIV14_CFG*/
+POKE32(0xfe213b3c, 0x00000307)      /*stx7105_clockgena_regs.CKGA_PLL1_DIV15_CFG*/
+POKE32(0xfe213b40, 0x00000103)      /*stx7105_clockgena_regs.CKGA_PLL1_DIV16_CFG*/
+POKE32(0xfe213b44, 0x00000103)      /*stx7105_clockgena_regs.CKGA_PLL1_DIV17_CFG*/
+
+
+POKE32(0xfe213010, 0x00000002)      /*stx7105_clockgena_regs.CKGA_POWER_CFG*/
+POKE32(0xfe213004, 0x00182803)      /*stx7105_clockgena_regs.CKGA_PLL1_CFG*/
+POKE32(0xfe213010, 0x00000000)      /*stx7105_clockgena_regs.CKGA_POWER_CFG*/
+WHILE_NE32(0xfe213004, 0x80000000, 0x80000000)    /*stx7105_clockgena_regs.CKGA_PLL1_CFG*/
+POKE32(0xfe213004, 0x80002803)      /*stx7105_clockgena_regs.CKGA_PLL1_CFG*/
+POKE32(0xfe213014, 0xa6aa59aa)      /*stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG*/
+POKE32(0xfe213024, 0x0000000a)      /*stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2*/
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG11*/
+POKE32(0xfe00112c, 0x00001d28)
+POKE32(0xfe00112c, 0x00001228)
+POKE32(0xfe00112c, 0x00000228)
+
+/*stx7105_sysconf_regs.SYSCONF_STA3*/
+WHILE_NE32(0xfe001014, 0x00000001, 0x00000000)
+
+
+/*set_lmi2x_freq: freq=800.000 rdiv=0x3, ddiv=0x50 Clock frequencies*/
+/*stx7105_sysconf_regs.SYSCONF_CFG04*/
+POKE32(0xfe001110, 0x000001a2)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG11*/
+POKE32(0xfe00112c, 0x08000229)
+
+/*stx7105_sysconf_regs.SYSCONF_CFG12*/
+POKE32(0xfe001130, 0xa000380f)
+POKE32(0xfe001130, 0xa000380f)
+POKE32(0xfe001130, 0xa000380f)
+POKE32(0xfe001130, 0xa000380f)
+POKE32(0xfe001130, 0xa000380f)
+POKE32(0xfe001130, 0xa000380f)
+POKE32(0xfe001130, 0xa200380f)
+POKE32(0xfe001130, 0xa200380f)
+POKE32(0xfe001130, 0xa200380f)
+POKE32(0xfe001130, 0xa200380f)
+POKE32(0xfe001130, 0xa200380f)
+POKE32(0xfe001130, 0xa200780f)
+POKE32(0xfe001130, 0xa200780f)
+POKE32(0xfe001130, 0xa200680f)
+POKE32(0xfe001130, 0xa200680f)
+POKE32(0xfe001130, 0xa200680f)
+POKE32(0xfe001130, 0xa200680f)
+POKE32(0xfe001130, 0xa200680f)
+POKE32(0xfe001130, 0xa200684f)
+POKE32(0xfe001130, 0xa200686f)
+/*
+POKE32(0xfe001130, 0xa200687f)
+POKE32(0xfe001130, 0xa200687f)
+POKE32(0xfe001130, 0xa200687f)
+POKE32(0xfe001130, 0xa200687f)
+POKE32(0xfe001130, 0xa200687f)
+*/
+POKE32(0xfe001130, 0xa200787f)
+POKE32(0xfe001130, 0xa200787f)
+POKE32(0xfe001130, 0xa200787f)
+POKE32(0xfe001130, 0xa200787f)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG13*/
+POKE32(0xfe001134, 0x00400000)
+POKE32(0xfe001134, 0x00600000)
+POKE32(0xfe001134, 0x00600000)
+POKE32(0xfe001134, 0x00600000)
+POKE32(0xfe001134, 0x00600000)
+POKE32(0xfe001134, 0x00600000)
+POKE32(0xfe001134, 0x00600000)
+POKE32(0xfe001134, 0x00600000)
+POKE32(0xfe001134, 0x00600000)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG14*/
+POKE32(0xfe001138, 0x00000000)
+POKE32(0xfe001138, 0x00000000)
+POKE32(0xfe001138, 0x00000000)
+POKE32(0xfe001138, 0x00000000)
+POKE32(0xfe001138, 0x00000000)
+POKE32(0xfe001138, 0x00000000)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG38*/
+POKE32(0xfe001198, 0x0000fe00)
+POKE32(0xfe001198, 0x0000fe00)
+POKE32(0xfe001198, 0x0000fe00)
+POKE32(0xfe001198, 0x0020fe00)
+POKE32(0xfe001198, 0x0020fe00)
+POKE32(0xfe001198, 0x002cfe00)
+POKE32(0xfe001198, 0x002ffe00)
+POKE32(0xfe001198, 0x002ffe0c)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG40*/
+POKE32(0xfe0011a0, 0x00000005)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG42*/
+POKE32(0xfe0011a8, 0x20000000)
+POKE32(0xfe0011a8, 0x28000000)
+POKE32(0xfe0011a8, 0x2fb40000)
+POKE32(0xfe0011a8, 0x2fb7fc00)
+POKE32(0xfe0011a8, 0x2fb7fdfa)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG43*/
+POKE32(0xfe0011ac, 0x00000000)
+POKE32(0xfe0011ac, 0x18000000)
+POKE32(0xfe0011ac, 0x18a00000)
+POKE32(0xfe0011ac, 0x18a001fa)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG51*/
+POKE32(0xfe0011cc, 0x00000000)
+POKE32(0xfe0011cc, 0x00000000)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG52*/
+POKE32(0xfe0011d0, 0x00000000)
+POKE32(0xfe0011d0, 0x00000000)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG55*/
+POKE32(0xfe0011dc, 0x00002000)
+POKE32(0xfe0011dc, 0x00002000)
+POKE32(0xfe0011dc, 0x00002000)
+POKE32(0xfe0011dc, 0x07fc2000)
+POKE32(0xfe0011dc, 0x07fc2000)
+POKE32(0xfe0011dc, 0x07fc2000)
+POKE32(0xfe0011dc, 0x07fc2000)
+POKE32(0xfe0011dc, 0x07fc2280)
+POKE32(0xfe0011dc, 0x07fc22c0)
+POKE32(0xfe0011dc, 0x07fc22c0)
+POKE32(0xfe0011dc, 0x07fc22c4)
+
+/*stx7105_sysconf_regs.SYSCONF_CFG04*/
+POKE32(0xfe001110, 0x000001a6)
+DELAY(10)
+
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG13*/
+POKE32(0xfe001134, 0x00600000)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG14*/
+POKE32(0xfe001138, 0x00000000)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG42*/
+POKE32(0xfe0011a8, 0x2fb7fdfa)
+POKE32(0xfe0011a8, 0x2fb7fdfa)
+POKE32(0xfe0011a8, 0x2fb7fdfa)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG43*/
+POKE32(0xfe0011ac, 0x18a001fa)
+POKE32(0xfe0011ac, 0x18a001fa)
+
+/*stx7105_sysconf_regs.SYSCONF_CFG51*/
+POKE32(0xfe0011cc, 0x00000000)
+POKE32(0xfe0011cc, 0x00000000)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG52*/
+POKE32(0xfe0011d0, 0x00000000)
+POKE32(0xfe0011d0, 0x00000000)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG55*/
+POKE32(0xfe0011dc, 0x07fc22c4)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG04*/
+POKE32(0xfe001110, 0x000001a2)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG11*/
+POKE32(0xfe00112c, 0x00000229)
+POKE32(0xfe00112c, 0x00000228)
+DELAY(10)
+POKE32(0xfe00112c, 0x08000228)
+POKE32(0xfe00112c, 0x08000229)
+DELAY(10)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG04*/
+POKE32(0xfe001110, 0x000001a6)
+DELAY(10)
+
+
+/*st40_emi_regs.EMI_BANK_ENABLE*/
+POKE32(0xfe700860, 0x00000005)
+
+POKE32(0xfe700800, 0x00000000)   /*st40_emi_regs.EMI_BANK0_BASEADDRESS*/
+POKE32(0xfe700810, 0x00000010)   /*st40_emi_regs.EMI_BANK1_BASEADDRESS*/
+POKE32(0xfe700820, 0x00000018)   /*st40_emi_regs.EMI_BANK2_BASEADDRESS*/
+POKE32(0xfe700830, 0x0000001a)   /*st40_emi_regs.EMI_BANK3_BASEADDRESS*/
+POKE32(0xfe700840, 0x0000001c)   /*st40_emi_regs.EMI_BANK4_BASEADDRESS*/
+
+
+
+/*st40_emi_regs.EMI_BANK0_EMICONFIGDATA0-3*/
+POKE32(0xfe700100, 0x001016d1)
+POKE32(0xfe700108, 0x9d200000)
+POKE32(0xfe700110, 0x9d220000)
+POKE32(0xfe700118, 0x00000000)
+
+
+/*st40_emi_regs.EMI_BANK1_EMICONFIGDATA0-3*/
+POKE32(0xfe700140, 0x002016d1)
+POKE32(0xfe700148, 0x9d222200)
+POKE32(0xfe700150, 0x9d220044)
+POKE32(0xfe700158, 0x00000000)
+
+
+/*st40_emi_regs.EMI_BANK2_EMICONFIGDATA0-3*/
+POKE32(0xfe700180, 0x002046f9)
+POKE32(0xfe700188, 0xa5a00000)
+POKE32(0xfe700190, 0xa5a20000)
+POKE32(0xfe700198, 0x00000000)
+
+
+/*st40_emi_regs.EMI_BANK3_EMICONFIGDATA0-3*/
+POKE32(0xfe7001c0, 0x002016d1)
+POKE32(0xfe7001c8, 0x9d222200)
+POKE32(0xfe7001d0, 0x9d220044)
+POKE32(0xfe7001d8, 0x00000000)
+
+
+/*st40_emi_regs.EMI_BANK4_EMICONFIGDATA0-3*/
+POKE32(0xfe700200, 0x002016d1)
+POKE32(0xfe700208, 0x9d222200)
+POKE32(0xfe700210, 0x9d220044)
+POKE32(0xfe700218, 0x00000000)
+
+
+/*st40_emi_regs.EMI_GENCFG*/
+POKE32(0xfe700028, 0x00000010)
+
+
+/*st40_lmigp_regs.LMI_MIM_0-1*/
+POKE32(0xfe901008, 0x0b30017b)
+POKE32(0xfe90100c, 0x000000b0)
+
+
+/*st40_lmigp_regs.LMI_STR_0-1*/
+POKE32(0xfe901018, 0xcf35b424)
+POKE32(0xfe90101c, 0x00242ed8)
+
+/*st40_lmigp_regs.LMI_SDRA0_0-1*/
+POKE32(0xfe901030, 0x2c001e20)
+POKE32(0xfe901038, 0x2c001e20)
+DELAY(200000)
+
+
+/*st40_lmigp_regs.LMI_SCR_0*/
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020023)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020022)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+
+
+/*st40_lmigp_regs.LMI_SDMR0_0*/
+POKE32(0xfe901048, 0x00010000)
+
+/*st40_lmigp_regs.LMI_SDMR0_0*/
+POKE32(0xfe901048, 0x00018000)
+
+/*st40_lmigp_regs.LMI_SDMR0_0*/
+POKE32(0xfe901048, 0x00008046)
+
+/*st40_lmigp_regs.LMI_SDMR0_0*/
+POKE32(0xfe901048, 0x00004363)
+
+/*st40_lmigp_regs.LMI_SCR_0*/
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020022)
+POKE32(0xfe901010, 0x00020024)
+POKE32(0xfe901010, 0x00020024)
+
+
+/*st40_lmigp_regs.LMI_SDMR0_0*/
+POKE32(0xfe901048, 0x00004263)
+
+/*st40_lmigp_regs.LMI_MIM_0*/
+POKE32(0xfe901008, 0x0b30037b)
+POKE32(0xfe901008, 0x0b30037b)
+
+
+/*st40_lmigp_regs.LMI_SCR_0*/
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+POKE32(0xfe901010, 0x00020021)
+
+
+/*st40_lmigp_regs.LMI_GCC_0*/
+POKE32(0xfe901028, 0x00000000)
+
+/*Info: correcting interco reset setup*/
+POKE32(0xfe20d200, 0x00000005)
+POKE32(0xfe20d204, 0x00000004)
+POKE32(0xfe20d208, 0x00000003)
+POKE32(0xfe20d20c, 0x00000002)
+POKE32(0xfe20d210, 0x00000001)
+POKE32(0xfe20d214, 0x00000001)
+POKE32(0xfe20d218, 0x00000001)
+POKE32(0xfe20d21c, 0x00000001)
+POKE32(0xfe20d220, 0x00000001)
+POKE32(0xfe2410fc, 0x00000005)
+POKE32(0xfe20a0ec, 0x00000002)
+POKE32(0xfe20a0f0, 0x00000005)
+POKE32(0xfe20a0f4, 0x00000003)
+POKE32(0xfe20a0f8, 0x00000003)
+POKE32(0xfe20a1ec, 0x00000002)
+POKE32(0xfe20a1f0, 0x00000005)
+POKE32(0xfe20a1f4, 0x00000003)
+POKE32(0xfe20a1f8, 0x00000003)
+POKE32(0xfe20a1fc, 0x00000000)
+POKE32(0xfe20a2ec, 0x00000002)
+POKE32(0xfe20a2f0, 0x00000005)
+POKE32(0xfe20a2f4, 0x00000003)
+POKE32(0xfe20a2f8, 0x00000003)
+POKE32(0xfe20a2fc, 0x00000000)
+POKE32(0xfe20a3ec, 0x00000002)
+POKE32(0xfe20a3f0, 0x00000005)
+POKE32(0xfe20a3f4, 0x00000003)
+POKE32(0xfe20a3f8, 0x00000003)
+POKE32(0xfe20a3fc, 0x00000000)
+POKE32(0xfe20aefc, 0x00000005)
+POKE32(0xfe540034, 0x00000003)
+POKE32(0xfe540038, 0x00000000)
+POKE32(0xfe540110, 0x00010303)
+POKE32(0xfe540114, 0x00000000)
+POKE32(0xfe540030, 0x00000005)
+POKE32(0xfe54010c, 0x00000005)
+POKE32(0xfe540600, 0x00000006)
+POKE32(0xfe540604, 0x00000005)
+POKE32(0xfe540608, 0x00000004)
+POKE32(0xfe54060c, 0x00000003)
+POKE32(0xfe540610, 0x00000002)
+POKE32(0xfe540614, 0x00000001)
+POKE32(0xfe540618, 0x00000000)
+POKE32(0xfe540680, 0x00000001)
+POKE32(0xfe540684, 0x00000000)
+POKE32(0xfe20bb04, 0x00000005)
+POKE32(0xfe20bb08, 0x00000003)
+POKE32(0xfe20bb10, 0x00000002)
+POKE32(0xfe20bb24, 0x00000005)
+POKE32(0xfe20bb28, 0x00000003)
+POKE32(0xfe20bb2c, 0x00000000)
+POKE32(0xfe20bb30, 0x00000002)
+POKE32(0xfe20bb44, 0x00000005)
+POKE32(0xfe20bb48, 0x00000003)
+POKE32(0xfe20bb4c, 0x00000000)
+POKE32(0xfe20bb50, 0x00000002)
+POKE32(0xfe20bb84, 0x00000005)
+POKE32(0xfe20bb88, 0x00000003)
+POKE32(0xfe20bb8c, 0x00000000)
+POKE32(0xfe20bb90, 0x00000002)
+POKE32(0xfe20a0fc, 0x00000000)
+POKE32(0xfe20bb0c, 0x00000000)
+POKE32(0xfe231010, 0x00000008)
+POKE32(0xfe231080, 0x00000221)
+POKE32(0xfe261010, 0x00000008)
+POKE32(0xfe261080, 0x00000221)
+POKE32(0xfd101024, 0x0003c000)
+POKE32(0xfd101824, 0x0003c000)
+POKE32(0xfd104d24, 0x0003c000)
+POKE32(0xfd102024, 0x0003c000)
+/* PEEK(0xfe001180) (used target peek value 0x00000b35) */
+POKE32(0xfe001180, 0x00000b05)
+POKE32(0xfe1fff04, 0x00254608)
+POKE32(0xfeafff04, 0x00254608)
+/* PEEK(0xfe00111c) (used target peek value 0x08081508) */
+POKE32(0xfe00111c, 0x08091508)
+POKE32(0xfd117000, 0x0025c608)
+POKE32(0xfd111000, 0x00201004)
+/* PEEK(0xfe001180) (used target peek value 0x00000b05) */
+POKE32(0xfe001180, 0x00000b01)
+POKE32(0xfe401744, 0x0025c005)
+
+
+/*st40_ccn_regs.CCN_CCR*/
+POKE32(0xff00001c, 0x8000090d)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG09*/
+POKE32(0xfe001124, 0x08000a8c)
+
+/*stx7105_sysconf_regs.SYSCONF_CFG05*/
+POKE32(0xfe001114, 0x04000040)
+
+/*stx7105_sysconf_regs.SYSCONF_CFG26*/
+POKE32(0xfe001168, 0xfe804001)
+
+/*stx7105_sysconf_regs.SYSCONF_CFG27*/
+POKE32(0xfe00116c, 0x00001fd1)
+POKE32(0xfe00116c, 0x00001fd0)
+
+/*stx7105: booted audio companion*/
+/*stx7105_sysconf_regs.SYSCONF_CFG09*/
+POKE32(0xfe001124, 0x08000a8c)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG05*/
+POKE32(0xfe001114, 0x04000040)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG28*/
+POKE32(0xfe001170, 0xfe604001)
+
+/*stx7105_sysconf_regs.SYSCONF_CFG29*/
+POKE32(0xfe001174, 0x00001fcd)
+
+
+/*stx7105_sysconf_regs.SYSCONF_CFG29*/
+POKE32(0xfe001174, 0x00001fcc)
+
+/* stx7105: booted video companion*/
+/* TCK frequency set to 12500000 Hz*/
+/* tapmux complete_connect(): single core setup*/
+/* sdk7105 initialization complete*/
diff --git a/board/st/pdk7105/pdk7105_800_elbida.romgen b/board/st/pdk7105/pdk7105_800_elbida.romgen
new file mode 100644
index 0000000000..630dada70f
--- /dev/null
+++ b/board/st/pdk7105/pdk7105_800_elbida.romgen
@@ -0,0 +1,2794 @@
+/* sdk7105 connect start - parameters {'no_devid_validate': '1', 'no_convertor_abort': '1', 'no_devid_abort': '1'}
+ */
+/* Initialization TCK frequency set to 1562500 Hz
+ */
+/* Device id  0x1d43e041
+ */
+/* tapmux connect(): boot mode single core setup
+ */
+/* tapmux setup to bypass to core st40, channel 1
+ */
+/* sdk7105 initialization start ...
+ */
+/* sdk7105_setup - parameters {'tapmux_bypass_init': u'st40', 'no_devid_validate': '1', 'no_convertor_abort': '1', 'reset_low_period': 360000, 'no_devid_abort': '1'}
+ */
+/* Chip infos
+ */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x1d43e041) */
+/*   Device ID = 0x1D43E041 ==> STi7105 cut 2
+ */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+/*   Mode pins = 0x00001015 ==> ClockgenA ref : SYSCLKIN/OSC
+ */
+/*                              Boot mode ... : ST40 first
+ */
+/*                              Boot port size: 16-bits
+ */
+/*                              Boot device . : NOR flash
+ */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+/* PEEK(0xfe0011a0) (used target peek value 0x00000004) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+POKE32(0xfe0011a0, 0x00000005)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+/* PEEK(0xfe0011a0) (used target peek value 0x00000005) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+POKE32(0xfe0011a0, 0x00000005)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x1d43e041) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x00000126) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+POKE32(0xfe001110, 0x000001a6)
+
+
+/* Magic sequence to  configure the ClockGenA switch control to reset values*/
+/* These do not appear to be correctly reset on WDT reset so do it here     */
+/* CLOCKGEN A CKGA_CLKOPSRC_SWITCH_CFG  reset=0 */
+POKE32(0xfe213014, 0x00000000)
+/* CLOCKGEN A CKGA_CLKOPSRC_SWITCH_CFG2 reset=0 */
+POKE32(0xfe213024, 0x00000000)
+
+/*
+stx7105_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x1d43e041) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_ENABLE_FB
+*/
+/* PEEK(0xfe21301c) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_ENABLE_FB
+*/
+WHILE_NE32(0xfe21301c, 0xffffffff, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_ENABLE_FB
+*/
+/* PEEK(0xfe213020) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_ENABLE_FB
+*/
+WHILE_NE32(0xfe213020, 0xffffffff, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80001e02) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x80101e02)
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000001)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x00181e02) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x00180f01)
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000001) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80100f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+WHILE_NE32(0xfe213000, 0x80000000, 0x80000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80100f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+POKE32(0xfe213000, 0x80000f01)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x80102803)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV0_CFG
+*/
+POKE32(0xfe213b00, 0x00000001)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV1_CFG
+*/
+POKE32(0xfe213b04, 0x00000001)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV2_CFG
+*/
+POKE32(0xfe213b08, 0x00000001)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV3_CFG
+*/
+POKE32(0xfe213b0c, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0LS_DIV4_CFG
+*/
+POKE32(0xfe213a10, 0x00010100)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV5_CFG
+*/
+POKE32(0xfe213b14, 0x00000307)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0LS_DIV6_CFG
+*/
+POKE32(0xfe213a18, 0x00010100)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0LS_DIV7_CFG
+*/
+POKE32(0xfe213a1c, 0x00010100)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV8_CFG
+*/
+POKE32(0xfe213b20, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV9_CFG
+*/
+POKE32(0xfe213b24, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV10_CFG
+*/
+POKE32(0xfe213b28, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV11_CFG
+*/
+POKE32(0xfe213b2c, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV12_CFG
+*/
+POKE32(0xfe213b30, 0x00000102)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0LS_DIV13_CFG
+*/
+POKE32(0xfe213a34, 0x00000811)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV14_CFG
+*/
+POKE32(0xfe213b38, 0x0000050b)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV15_CFG
+*/
+POKE32(0xfe213b3c, 0x00000307)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV16_CFG
+*/
+POKE32(0xfe213b40, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_DIV17_CFG
+*/
+POKE32(0xfe213b44, 0x00000103)
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000002)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x00182803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x00182803)
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+/* PEEK(0xfe213010) (used target peek value 0x00000002) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_POWER_CFG
+*/
+POKE32(0xfe213010, 0x00000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80102803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+WHILE_NE32(0xfe213004, 0x80000000, 0x80000000)
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80102803) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+POKE32(0xfe213004, 0x80002803)
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+POKE32(0xfe213014, 0xa6aa59aa)
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+POKE32(0xfe213024, 0x0000000a)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_DEVICEID0
+*/
+/* PEEK(0xfe001000) (used target peek value 0x1d43e041) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x00000d28) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x00001d28)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x00001d28) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x000016a0)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000016a0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x000006a0)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA3
+*/
+/* PEEK(0xfe001014) (used target peek value 0x1f1016a4) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA3
+*/
+WHILE_NE32(0xfe001014, 0x00000001, 0x00000000)
+/* set_lmi2x_freq: freq=800.000 rdiv=0x3, ddiv=0x50
+ */
+/* Clock frequencies
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+/*   CKGA_PLL0HS     = 900.0 MHz
+ */
+/*   CKGA_PLL0LS     = 450.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+/*   CKGA_PLL1       = 800.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a10) (used target peek value 0x00010100) */
+/*   ST40 ICK        = 450.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a18) (used target peek value 0x00010100) */
+/*   LX DMU          = 450.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a1c) (used target peek value 0x00010100) */
+/*   LX AUD          = 450.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b04) (used target peek value 0x00000001) */
+/*   FDMA0           = 400.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b08) (used target peek value 0x00000001) */
+/*   FDMA1           = 400.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b00) (used target peek value 0x00000001) */
+/*   STNOC           = 400.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b20) (used target peek value 0x00000103) */
+/*   IC_BDISP_200    = 200.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b24) (used target peek value 0x00000103) */
+/*   IC_DISP_200     = 200.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b28) (used target peek value 0x00000103) */
+/*   IC_TS_200       = 200.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+/* PEEK(0xfe213024) (used target peek value 0x0000000a) */
+/* PEEK(0xfe213b40) (used target peek value 0x00000103) */
+/*   IC_COMPO_200    = 200.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG2
+*/
+/* PEEK(0xfe213024) (used target peek value 0x0000000a) */
+/* PEEK(0xfe213b44) (used target peek value 0x00000103) */
+/*   IC_IF_200       = 200.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b14) (used target peek value 0x00000307) */
+/*   IC_IF_100       = 100.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b2c) (used target peek value 0x00000103) */
+/*   DISP_PIPE_200   = 200.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b30) (used target peek value 0x00000102) */
+/*   BLIT_PROC       = 266.7 MHz
+ */
+/*   IC_DELTA_200    = 266.7 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213a34) (used target peek value 0x00000811) */
+/*   ETHERNET        = 25.0 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b38) (used target peek value 0x0000050b) */
+/*   PCI             = 66.7 MHz
+ */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL0_CFG
+*/
+/* PEEK(0xfe213000) (used target peek value 0x80000f01) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_PLL1_CFG
+*/
+/* PEEK(0xfe213004) (used target peek value 0x80002803) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA1
+*/
+/* PEEK(0xfe00100c) (used target peek value 0x00001015) */
+
+
+/*
+stx7105_clockgena_regs.CKGA_CLKOPSRC_SWITCH_CFG
+*/
+/* PEEK(0xfe213014) (used target peek value 0xa6aa59aa) */
+/* PEEK(0xfe213b3c) (used target peek value 0x00000307) */
+/*   EMI MASTER      = 100.0 MHz
+ */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000006a0) */
+/*   LMI2X           = 800.0 MHz
+ */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x000001a6) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+POKE32(0xfe001110, 0x000001a2)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000006a0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x080006a1)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa000380f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa000380f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa000380f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa000380f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa000380f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa000380f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa000380f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa000380f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa000380f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa000380f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa000380f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa000380f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa000380f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200380f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200380f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200380f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200380f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200380f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200380f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200380f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200380f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200380f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200380f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200780f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200780f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200780f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200780f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200680f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200680f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200680f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200680f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200680f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200680f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200680f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200680f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200680f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200680f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200684f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200684f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200686f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200686f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200687f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200687f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200687f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200687f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200687f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200687f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200687f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+/* PEEK(0xfe001130) (used target peek value 0xa200687f) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG12
+*/
+POKE32(0xfe001130, 0xa200687f)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+/* PEEK(0xfe001134) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x00400000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+/* PEEK(0xfe001134) (used target peek value 0x00400000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x00600000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+/* PEEK(0xfe001134) (used target peek value 0x00600000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x00600000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+/* PEEK(0xfe001134) (used target peek value 0x00600000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x00600000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+/* PEEK(0xfe001134) (used target peek value 0x00600000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x00600000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+/* PEEK(0xfe001134) (used target peek value 0x00600000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x00600000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+/* PEEK(0xfe001134) (used target peek value 0x00600000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x00600000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+/* PEEK(0xfe001134) (used target peek value 0x00600000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x00600000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+/* PEEK(0xfe001134) (used target peek value 0x00600000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x00600000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+/* PEEK(0xfe001138) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+POKE32(0xfe001138, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+/* PEEK(0xfe001138) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+POKE32(0xfe001138, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+/* PEEK(0xfe001138) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+POKE32(0xfe001138, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+/* PEEK(0xfe001138) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+POKE32(0xfe001138, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+/* PEEK(0xfe001138) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+POKE32(0xfe001138, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+/* PEEK(0xfe001138) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+POKE32(0xfe001138, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+POKE32(0xfe001198, 0x0000fe00)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+/* PEEK(0xfe001198) (used target peek value 0x0000fe00) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+POKE32(0xfe001198, 0x0000fe00)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+/* PEEK(0xfe001198) (used target peek value 0x0000fe00) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+POKE32(0xfe001198, 0x0000fe00)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+/* PEEK(0xfe001198) (used target peek value 0x0000fe00) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+POKE32(0xfe001198, 0x0020fe00)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+/* PEEK(0xfe001198) (used target peek value 0x0020fe00) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+POKE32(0xfe001198, 0x0020fe00)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+/* PEEK(0xfe001198) (used target peek value 0x0020fe00) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+POKE32(0xfe001198, 0x002cfe00)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+/* PEEK(0xfe001198) (used target peek value 0x002cfe00) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+POKE32(0xfe001198, 0x002ffe00)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+/* PEEK(0xfe001198) (used target peek value 0x002ffe00) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG38
+*/
+POKE32(0xfe001198, 0x002ffe0c)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+/* PEEK(0xfe0011a0) (used target peek value 0x00000005) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG40
+*/
+POKE32(0xfe0011a0, 0x00000005)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+/* PEEK(0xfe0011a8) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+POKE32(0xfe0011a8, 0x20000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+/* PEEK(0xfe0011a8) (used target peek value 0x20000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+POKE32(0xfe0011a8, 0x28000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+/* PEEK(0xfe0011a8) (used target peek value 0x28000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+POKE32(0xfe0011a8, 0x2fb80000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+/* PEEK(0xfe0011a8) (used target peek value 0x2fb80000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+POKE32(0xfe0011a8, 0x2fbbdc00)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+/* PEEK(0xfe0011a8) (used target peek value 0x2fbbdc00) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+POKE32(0xfe0011a8, 0x2fbbddee)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+/* PEEK(0xfe0011ac) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+POKE32(0xfe0011ac, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+/* PEEK(0xfe0011ac) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+POKE32(0xfe0011ac, 0x18000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+/* PEEK(0xfe0011ac) (used target peek value 0x18000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+POKE32(0xfe0011ac, 0x18a00000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+/* PEEK(0xfe0011ac) (used target peek value 0x18a00000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+POKE32(0xfe0011ac, 0x18a001ee)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG51
+*/
+/* PEEK(0xfe0011cc) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG51
+*/
+POKE32(0xfe0011cc, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG51
+*/
+/* PEEK(0xfe0011cc) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG51
+*/
+POKE32(0xfe0011cc, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG52
+*/
+/* PEEK(0xfe0011d0) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG52
+*/
+POKE32(0xfe0011d0, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG52
+*/
+/* PEEK(0xfe0011d0) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG52
+*/
+POKE32(0xfe0011d0, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+/* PEEK(0xfe0011dc) (used target peek value 0x00002000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x00002000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+/* PEEK(0xfe0011dc) (used target peek value 0x00002000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x00002000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+/* PEEK(0xfe0011dc) (used target peek value 0x00002000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x00002000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+/* PEEK(0xfe0011dc) (used target peek value 0x00002000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x07fc2000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+/* PEEK(0xfe0011dc) (used target peek value 0x07fc2000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x07fc2000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+/* PEEK(0xfe0011dc) (used target peek value 0x07fc2000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x07fc2000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+/* PEEK(0xfe0011dc) (used target peek value 0x07fc2000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x07fc2000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+/* PEEK(0xfe0011dc) (used target peek value 0x07fc2000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x07fc2280)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+/* PEEK(0xfe0011dc) (used target peek value 0x07fc2280) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x07fc22c0)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+/* PEEK(0xfe0011dc) (used target peek value 0x07fc22c0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x07fc22c0)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+/* PEEK(0xfe0011dc) (used target peek value 0x07fc22c0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x07fc22c4)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x000001a2) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+POKE32(0xfe001110, 0x000001a6)
+DELAY(10)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA3
+*/
+/* PEEK(0xfe001014) (used target peek value 0x1e166c50) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_STA3
+*/
+/* PEEK(0xfe001014) (used target peek value 0x1e166450) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x080006a1) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x080006a1) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+/* PEEK(0xfe001134) (used target peek value 0x00600000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG13
+*/
+POKE32(0xfe001134, 0x00600000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+/* PEEK(0xfe001138) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG14
+*/
+POKE32(0xfe001138, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+/* PEEK(0xfe0011a8) (used target peek value 0x2fbbddee) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+POKE32(0xfe0011a8, 0x2fbbddee)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+/* PEEK(0xfe0011a8) (used target peek value 0x2fbbddee) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+POKE32(0xfe0011a8, 0x2fbbddee)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+/* PEEK(0xfe0011a8) (used target peek value 0x2fbbddee) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG42
+*/
+POKE32(0xfe0011a8, 0x2fbbddee)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+/* PEEK(0xfe0011ac) (used target peek value 0x18a001ee) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+POKE32(0xfe0011ac, 0x18a001ee)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+/* PEEK(0xfe0011ac) (used target peek value 0x18a001ee) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG43
+*/
+POKE32(0xfe0011ac, 0x18a001ee)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG51
+*/
+/* PEEK(0xfe0011cc) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG51
+*/
+POKE32(0xfe0011cc, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG51
+*/
+/* PEEK(0xfe0011cc) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG51
+*/
+POKE32(0xfe0011cc, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG52
+*/
+/* PEEK(0xfe0011d0) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG52
+*/
+POKE32(0xfe0011d0, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG52
+*/
+/* PEEK(0xfe0011d0) (used target peek value 0x00000000) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG52
+*/
+POKE32(0xfe0011d0, 0x00000000)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+/* PEEK(0xfe0011dc) (used target peek value 0x07fc22c4) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG55
+*/
+POKE32(0xfe0011dc, 0x07fc22c4)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x000001a6) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+POKE32(0xfe001110, 0x000001a2)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x080006a1) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x000006a1)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000006a1) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x000006a0)
+DELAY(10)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x000006a0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x080006a0)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x080006a0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+POKE32(0xfe00112c, 0x080006a1)
+DELAY(10)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+/* PEEK(0xfe001110) (used target peek value 0x000001a2) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG04
+*/
+POKE32(0xfe001110, 0x000001a6)
+DELAY(10)
+
+
+/*
+st40_emi_regs.EMI_BANK_ENABLE
+*/
+POKE32(0xfe700860, 0x00000005)
+
+
+/*
+st40_emi_regs.EMI_BANK0_BASEADDRESS
+*/
+POKE32(0xfe700800, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_BASEADDRESS
+*/
+POKE32(0xfe700810, 0x00000010)
+
+
+/*
+st40_emi_regs.EMI_BANK2_BASEADDRESS
+*/
+POKE32(0xfe700820, 0x00000018)
+
+
+/*
+st40_emi_regs.EMI_BANK3_BASEADDRESS
+*/
+POKE32(0xfe700830, 0x0000001a)
+
+
+/*
+st40_emi_regs.EMI_BANK4_BASEADDRESS
+*/
+POKE32(0xfe700840, 0x0000001c)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA0
+*/
+POKE32(0xfe700100, 0x001016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA1
+*/
+POKE32(0xfe700108, 0x9d200000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA2
+*/
+POKE32(0xfe700110, 0x9d220000)
+
+
+/*
+st40_emi_regs.EMI_BANK0_EMICONFIGDATA3
+*/
+POKE32(0xfe700118, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA0
+*/
+POKE32(0xfe700140, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA1
+*/
+POKE32(0xfe700148, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA2
+*/
+POKE32(0xfe700150, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK1_EMICONFIGDATA3
+*/
+POKE32(0xfe700158, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA0
+*/
+POKE32(0xfe700180, 0x002046f9)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA1
+*/
+POKE32(0xfe700188, 0xa5a00000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA2
+*/
+POKE32(0xfe700190, 0xa5a20000)
+
+
+/*
+st40_emi_regs.EMI_BANK2_EMICONFIGDATA3
+*/
+POKE32(0xfe700198, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA0
+*/
+POKE32(0xfe7001c0, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA1
+*/
+POKE32(0xfe7001c8, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA2
+*/
+POKE32(0xfe7001d0, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK3_EMICONFIGDATA3
+*/
+POKE32(0xfe7001d8, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA0
+*/
+POKE32(0xfe700200, 0x002016d1)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA1
+*/
+POKE32(0xfe700208, 0x9d222200)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA2
+*/
+POKE32(0xfe700210, 0x9d220044)
+
+
+/*
+st40_emi_regs.EMI_BANK4_EMICONFIGDATA3
+*/
+POKE32(0xfe700218, 0x00000000)
+
+
+/*
+st40_emi_regs.EMI_GENCFG
+*/
+POKE32(0xfe700028, 0x00000010)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG11
+*/
+/* PEEK(0xfe00112c) (used target peek value 0x080006a1) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30017b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_1
+*/
+POKE32(0xfe90100c, 0x000000b0)
+
+
+/*
+st40_lmigp_regs.LMI_STR_0
+*/
+POKE32(0xfe901018, 0xcf35b424)
+
+
+/*
+st40_lmigp_regs.LMI_STR_1
+*/
+POKE32(0xfe90101c, 0x00242ed8)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA0_0
+*/
+POKE32(0xfe901030, 0x1c001a20)
+
+
+/*
+st40_lmigp_regs.LMI_SDRA1_0
+*/
+POKE32(0xfe901038, 0x1c001a20)
+DELAY(200000)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020023)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00010000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00018000)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00008006)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00004363)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020022)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020024)
+
+
+/*
+st40_lmigp_regs.LMI_SDMR0_0
+*/
+POKE32(0xfe901048, 0x00004263)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+/* PEEK(0xfe901008) (used target peek value 0x0b30017b) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30037b)
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+/* PEEK(0xfe901008) (used target peek value 0x0b30037b) */
+
+
+/*
+st40_lmigp_regs.LMI_MIM_0
+*/
+POKE32(0xfe901008, 0x0b30037b)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_SCR_0
+*/
+POKE32(0xfe901010, 0x00020021)
+
+
+/*
+st40_lmigp_regs.LMI_GCC_0
+*/
+POKE32(0xfe901028, 0x00000000)
+/* Info: correcting interco reset setup
+ */
+POKE32(0xfe20d200, 0x00000005)
+POKE32(0xfe20d204, 0x00000004)
+POKE32(0xfe20d208, 0x00000003)
+POKE32(0xfe20d20c, 0x00000002)
+POKE32(0xfe20d210, 0x00000001)
+POKE32(0xfe20d214, 0x00000001)
+POKE32(0xfe20d218, 0x00000001)
+POKE32(0xfe20d21c, 0x00000001)
+POKE32(0xfe20d220, 0x00000001)
+POKE32(0xfe2410fc, 0x00000005)
+POKE32(0xfe20a0ec, 0x00000002)
+POKE32(0xfe20a0f0, 0x00000005)
+POKE32(0xfe20a0f4, 0x00000003)
+POKE32(0xfe20a0f8, 0x00000003)
+POKE32(0xfe20a1ec, 0x00000002)
+POKE32(0xfe20a1f0, 0x00000005)
+POKE32(0xfe20a1f4, 0x00000003)
+POKE32(0xfe20a1f8, 0x00000003)
+POKE32(0xfe20a1fc, 0x00000000)
+POKE32(0xfe20a2ec, 0x00000002)
+POKE32(0xfe20a2f0, 0x00000005)
+POKE32(0xfe20a2f4, 0x00000003)
+POKE32(0xfe20a2f8, 0x00000003)
+POKE32(0xfe20a2fc, 0x00000000)
+POKE32(0xfe20a3ec, 0x00000002)
+POKE32(0xfe20a3f0, 0x00000005)
+POKE32(0xfe20a3f4, 0x00000003)
+POKE32(0xfe20a3f8, 0x00000003)
+POKE32(0xfe20a3fc, 0x00000000)
+POKE32(0xfe20aefc, 0x00000005)
+POKE32(0xfe540034, 0x00000003)
+POKE32(0xfe540038, 0x00000000)
+POKE32(0xfe540110, 0x00010303)
+POKE32(0xfe540114, 0x00000000)
+POKE32(0xfe540030, 0x00000005)
+POKE32(0xfe54010c, 0x00000005)
+POKE32(0xfe540600, 0x00000006)
+POKE32(0xfe540604, 0x00000005)
+POKE32(0xfe540608, 0x00000004)
+POKE32(0xfe54060c, 0x00000003)
+POKE32(0xfe540610, 0x00000002)
+POKE32(0xfe540614, 0x00000001)
+POKE32(0xfe540618, 0x00000000)
+POKE32(0xfe540680, 0x00000001)
+POKE32(0xfe540684, 0x00000000)
+POKE32(0xfe20bb04, 0x00000005)
+POKE32(0xfe20bb08, 0x00000003)
+POKE32(0xfe20bb10, 0x00000002)
+POKE32(0xfe20bb24, 0x00000005)
+POKE32(0xfe20bb28, 0x00000003)
+POKE32(0xfe20bb2c, 0x00000000)
+POKE32(0xfe20bb30, 0x00000002)
+POKE32(0xfe20bb44, 0x00000005)
+POKE32(0xfe20bb48, 0x00000003)
+POKE32(0xfe20bb4c, 0x00000000)
+POKE32(0xfe20bb50, 0x00000002)
+POKE32(0xfe20bb84, 0x00000005)
+POKE32(0xfe20bb88, 0x00000003)
+POKE32(0xfe20bb8c, 0x00000000)
+POKE32(0xfe20bb90, 0x00000002)
+POKE32(0xfe20a0fc, 0x00000000)
+POKE32(0xfe20bb0c, 0x00000000)
+POKE32(0xfe231010, 0x00000008)
+POKE32(0xfe231080, 0x00000221)
+POKE32(0xfe261010, 0x00000008)
+POKE32(0xfe261080, 0x00000221)
+POKE32(0xfd101024, 0x0003c000)
+POKE32(0xfd101824, 0x0003c000)
+POKE32(0xfd104d24, 0x0003c000)
+POKE32(0xfd102024, 0x0003c000)
+/* PEEK(0xfe001180) (used target peek value 0x00000b35) */
+POKE32(0xfe001180, 0x00000b05)
+POKE32(0xfe1fff04, 0x00254608)
+POKE32(0xfeafff04, 0x00254608)
+/* PEEK(0xfe00111c) (used target peek value 0x08081508) */
+POKE32(0xfe00111c, 0x08091508)
+POKE32(0xfd117000, 0x0025c608)
+POKE32(0xfd111000, 0x00201004)
+/* PEEK(0xfe001180) (used target peek value 0x00000b05) */
+POKE32(0xfe001180, 0x00000b01)
+POKE32(0xfe401744, 0x0025c005)
+
+
+/*
+st40_ccn_regs.CCN_CCR
+*/
+POKE32(0xff00001c, 0x8000090d)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG09
+*/
+/* PEEK(0xfe001124) (used target peek value 0x00000a8c) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG09
+*/
+POKE32(0xfe001124, 0x08000a8c)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG05
+*/
+/* PEEK(0xfe001114) (used target peek value 0x04000040) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG05
+*/
+POKE32(0xfe001114, 0x04000040)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG26
+*/
+POKE32(0xfe001168, 0xfe804001)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd0) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+POKE32(0xfe00116c, 0x00001fd1)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+/* PEEK(0xfe00116c) (used target peek value 0x00001fd1) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG27
+*/
+POKE32(0xfe00116c, 0x00001fd0)
+/* stx7105: booted audio companion
+ */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG09
+*/
+/* PEEK(0xfe001124) (used target peek value 0x08000a8c) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG09
+*/
+POKE32(0xfe001124, 0x08000a8c)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG05
+*/
+/* PEEK(0xfe001114) (used target peek value 0x04000040) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG05
+*/
+POKE32(0xfe001114, 0x04000040)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcc) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG28
+*/
+POKE32(0xfe001170, 0xfe604001)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcc) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+POKE32(0xfe001174, 0x00001fcd)
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+/* PEEK(0xfe001174) (used target peek value 0x00001fcd) */
+
+
+/*
+stx7105_sysconf_regs.SYSCONF_CFG29
+*/
+POKE32(0xfe001174, 0x00001fcc)
+/* stx7105: booted video companion
+ */
+/* TCK frequency set to 12500000 Hz
+ */
+/* tapmux complete_connect(): single core setup
+ */
+/* sdk7105 initialization complete
+ */
diff --git a/board/st/pdk7105/sha.h b/board/st/pdk7105/sha.h
new file mode 100644
index 0000000000..90275efb69
--- /dev/null
+++ b/board/st/pdk7105/sha.h
@@ -0,0 +1,44 @@
+/*---------------------------------------------------------------------------
+//
+//	Copyright(C) SMIT Corporation, 2000-2010.
+//
+//  File	:	sha.h
+//	Purpose	:	SHA ALGORITHM
+//	History :
+//				2008-03-06 created by X.J.MENG.
+//
+---------------------------------------------------------------------------*/
+#ifndef XYSSL_SHA_H
+#define XYSSL_SHA_H
+
+#ifdef __cplusplus
+extern "C"{
+#endif
+
+#define SHA1_KEY_LENGTH          20
+#define SHA256_KEY_LENGTH        32
+extern unsigned char sha256_key[SHA256_KEY_LENGTH];
+
+/////////////////////////////////////////////////////////////////////////
+///////                     Api for CIPLUS                     //////////
+/////////////////////////////////////////////////////////////////////////
+
+
+//sha1 algorithm
+unsigned long soft_sha_1(unsigned char *i_pdata,
+			  unsigned long  i_udatalen,
+			  unsigned char *o_pdata);
+
+
+//sha256 algorithm
+unsigned long soft_sha_256(unsigned char *i_pdata,
+			    unsigned long  i_udatalen,
+			    unsigned char *o_pdata);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff --git a/board/st/pdk7105/swUpdate.c b/board/st/pdk7105/swUpdate.c
new file mode 100644
index 0000000000..1741965db5
--- /dev/null
+++ b/board/st/pdk7105/swUpdate.c
@@ -0,0 +1,8981 @@
+/*******************************************************************************
+Copyright (c) 2010 Shenzhen State Micro Technology Co., Ltd.
+All right reserved.
+
+Author: jiagong
+Date  : 2010-06-14
+
+*********************************************************************************/
+
+/*
+* Description:
+* internal usb mass storage  partitions:
+*  ________________________________________...............
+* |          |           |                 |             :
+* | 1:Backup | 2:Running |     3: User     |   4: Game   :
+* |__________|___________|_________________|..............
+*
+*/
+
+#include <common.h>
+#include <command.h>
+#include <malloc.h>
+#include <asm/stx7105reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+#include <asm/st40reg.h>
+
+#include "swUpdate.h"
+#include "sha.h"
+#include "algorithm_error.h"
+
+
+unsigned long cfg_7105_usb_ohci_regs;
+extern int dev_index;
+
+// 32-bit integer manipulation macros (big endian)
+#ifndef GET_ULONG_BE
+#define GET_ULONG_BE(n,b,i)                             \
+{                                                                          \
+	(n) = ( (unsigned long) (b)[(i) + 3]       )          \
+	| ( (unsigned long) (b)[(i) + 2] <<  8 )             \
+	| ( (unsigned long) (b)[(i) + 1] << 16 )            \
+	| ( (unsigned long) (b)[(i) + 0] << 24 );           \
+}
+#endif
+
+#ifndef PUT_ULONG_BE
+#define PUT_ULONG_BE(n,b,i)                              \
+{                                                                          \
+	(b)[(i) + 3] = (unsigned char) ( (n)       );         \
+	(b)[(i) + 2] = (unsigned char) ( (n) >>  8 );      \
+	(b)[(i) + 1] = (unsigned char) ( (n) >> 16 );     \
+	(b)[(i) + 0] = (unsigned char) ( (n) >> 24 );     \
+}
+#endif
+// 32-bit integer manipulation macros (little endian)
+#ifndef GET_ULONG_LE
+#define GET_ULONG_LE(n,b,i)                              \
+{                                                                          \
+	(n) = ( (unsigned long) (b)[(i) + 0]       )          \
+	| ( (unsigned long) (b)[(i) + 1] <<  8 )             \
+	| ( (unsigned long) (b)[(i) + 2] << 16 )            \
+	| ( (unsigned long) (b)[(i) + 3] << 24 );           \
+}
+#endif
+
+#ifndef PUT_ULONG_LE
+#define PUT_ULONG_LE(n,b,i)                             \
+{                                                                         \
+	(b)[(i) + 0] = (unsigned char) ( (n)       );        \
+	(b)[(i) + 1] = (unsigned char) ( (n) >>  8 );     \
+	(b)[(i) + 2] = (unsigned char) ( (n) >> 16 );    \
+	(b)[(i) + 3] = (unsigned char) ( (n) >> 24 );    \
+}
+#endif
+
+
+#ifndef XYSSL_SHA1_H
+#define XYSSL_SHA1_H
+/////////////////////////////////////////////////////
+//////////////////////inner//////////////////////////
+/////////////////////////////////////////////////////
+// sha1 context structure
+
+
+typedef struct
+{
+	unsigned long total[2];     /*!< number of bytes processed  */
+	unsigned long state[5];     /*!< intermediate digest state  */
+	unsigned char buffer[64];   /*!< data block being processed */
+}sha1_context;
+static	sha1_context sha1_ctx;
+
+// SHA-1 context setup
+static void sha1_starts( sha1_context *ctx )
+{
+	ctx->total[0] = 0;
+	ctx->total[1] = 0;
+
+	ctx->state[0] = 0x67452301;
+	ctx->state[1] = 0xEFCDAB89;
+	ctx->state[2] = 0x98BADCFE;
+	ctx->state[3] = 0x10325476;
+	ctx->state[4] = 0xC3D2E1F0;
+}
+
+//sha1
+static void sha1_process( sha1_context *ctx, unsigned char data[64] )
+{
+	unsigned long temp, W[16], A, B, C, D, E;
+
+	GET_ULONG_BE( W[ 0], data,  0 );
+	GET_ULONG_BE( W[ 1], data,  4 );
+	GET_ULONG_BE( W[ 2], data,  8 );
+	GET_ULONG_BE( W[ 3], data, 12 );
+	GET_ULONG_BE( W[ 4], data, 16 );
+	GET_ULONG_BE( W[ 5], data, 20 );
+	GET_ULONG_BE( W[ 6], data, 24 );
+	GET_ULONG_BE( W[ 7], data, 28 );
+	GET_ULONG_BE( W[ 8], data, 32 );
+	GET_ULONG_BE( W[ 9], data, 36 );
+	GET_ULONG_BE( W[10], data, 40 );
+	GET_ULONG_BE( W[11], data, 44 );
+	GET_ULONG_BE( W[12], data, 48 );
+	GET_ULONG_BE( W[13], data, 52 );
+	GET_ULONG_BE( W[14], data, 56 );
+	GET_ULONG_BE( W[15], data, 60 );
+
+#define S(x,n) ((x << n) | ((x & 0xFFFFFFFF) >> (32 - n)))
+
+#define R(t)                                                                    \
+	(                                                                             \
+	temp = W[(t -  3) & 0x0F] ^ W[(t - 8) & 0x0F] ^        \
+	W[(t - 14) & 0x0F] ^ W[ t      & 0x0F],                       \
+	( W[t & 0x0F] = S(temp,1) )                                      \
+	)
+
+#define P(a,b,c,d,e,x)                                                      \
+	{                                                                             \
+	e += S(a,5) + F(b,c,d) + K + x; b = S(b,30);             \
+	}
+
+	A = ctx->state[0];
+	B = ctx->state[1];
+	C = ctx->state[2];
+	D = ctx->state[3];
+	E = ctx->state[4];
+
+#define F(x,y,z) (z ^ (x & (y ^ z)))
+#define K 0x5A827999
+
+	P( A, B, C, D, E, W[0]  );
+	P( E, A, B, C, D, W[1]  );
+	P( D, E, A, B, C, W[2]  );
+	P( C, D, E, A, B, W[3]  );
+	P( B, C, D, E, A, W[4]  );
+	P( A, B, C, D, E, W[5]  );
+	P( E, A, B, C, D, W[6]  );
+	P( D, E, A, B, C, W[7]  );
+	P( C, D, E, A, B, W[8]  );
+	P( B, C, D, E, A, W[9]  );
+	P( A, B, C, D, E, W[10] );
+	P( E, A, B, C, D, W[11] );
+	P( D, E, A, B, C, W[12] );
+	P( C, D, E, A, B, W[13] );
+	P( B, C, D, E, A, W[14] );
+	P( A, B, C, D, E, W[15] );
+	P( E, A, B, C, D, R(16) );
+	P( D, E, A, B, C, R(17) );
+	P( C, D, E, A, B, R(18) );
+	P( B, C, D, E, A, R(19) );
+
+#undef K
+#undef F
+
+#define F(x,y,z) (x ^ y ^ z)
+#define K 0x6ED9EBA1
+
+	P( A, B, C, D, E, R(20) );
+	P( E, A, B, C, D, R(21) );
+	P( D, E, A, B, C, R(22) );
+	P( C, D, E, A, B, R(23) );
+	P( B, C, D, E, A, R(24) );
+	P( A, B, C, D, E, R(25) );
+	P( E, A, B, C, D, R(26) );
+	P( D, E, A, B, C, R(27) );
+	P( C, D, E, A, B, R(28) );
+	P( B, C, D, E, A, R(29) );
+	P( A, B, C, D, E, R(30) );
+	P( E, A, B, C, D, R(31) );
+	P( D, E, A, B, C, R(32) );
+	P( C, D, E, A, B, R(33) );
+	P( B, C, D, E, A, R(34) );
+	P( A, B, C, D, E, R(35) );
+	P( E, A, B, C, D, R(36) );
+	P( D, E, A, B, C, R(37) );
+	P( C, D, E, A, B, R(38) );
+	P( B, C, D, E, A, R(39) );
+
+#undef K
+#undef F
+
+#define F(x,y,z) ((x & y) | (z & (x | y)))
+#define K 0x8F1BBCDC
+
+	P( A, B, C, D, E, R(40) );
+	P( E, A, B, C, D, R(41) );
+	P( D, E, A, B, C, R(42) );
+	P( C, D, E, A, B, R(43) );
+	P( B, C, D, E, A, R(44) );
+	P( A, B, C, D, E, R(45) );
+	P( E, A, B, C, D, R(46) );
+	P( D, E, A, B, C, R(47) );
+	P( C, D, E, A, B, R(48) );
+	P( B, C, D, E, A, R(49) );
+	P( A, B, C, D, E, R(50) );
+	P( E, A, B, C, D, R(51) );
+	P( D, E, A, B, C, R(52) );
+	P( C, D, E, A, B, R(53) );
+	P( B, C, D, E, A, R(54) );
+	P( A, B, C, D, E, R(55) );
+	P( E, A, B, C, D, R(56) );
+	P( D, E, A, B, C, R(57) );
+	P( C, D, E, A, B, R(58) );
+	P( B, C, D, E, A, R(59) );
+
+#undef K
+#undef F
+
+#define F(x,y,z) (x ^ y ^ z)
+#define K 0xCA62C1D6
+
+	P( A, B, C, D, E, R(60) );
+	P( E, A, B, C, D, R(61) );
+	P( D, E, A, B, C, R(62) );
+	P( C, D, E, A, B, R(63) );
+	P( B, C, D, E, A, R(64) );
+	P( A, B, C, D, E, R(65) );
+	P( E, A, B, C, D, R(66) );
+	P( D, E, A, B, C, R(67) );
+	P( C, D, E, A, B, R(68) );
+	P( B, C, D, E, A, R(69) );
+	P( A, B, C, D, E, R(70) );
+	P( E, A, B, C, D, R(71) );
+	P( D, E, A, B, C, R(72) );
+	P( C, D, E, A, B, R(73) );
+	P( B, C, D, E, A, R(74) );
+	P( A, B, C, D, E, R(75) );
+	P( E, A, B, C, D, R(76) );
+	P( D, E, A, B, C, R(77) );
+	P( C, D, E, A, B, R(78) );
+	P( B, C, D, E, A, R(79) );
+
+#undef K
+#undef F
+
+#undef P
+#undef R
+#undef S
+
+	ctx->state[0] += A;
+	ctx->state[1] += B;
+	ctx->state[2] += C;
+	ctx->state[3] += D;
+	ctx->state[4] += E;
+}
+
+/*
+* SHA-1 process buffer
+*/
+static void sha1_update( sha1_context *ctx, unsigned char *input,  unsigned long ilen )
+{
+	unsigned long fill;
+	unsigned long left;
+
+	if( ilen <= 0 )
+		return;
+
+	left = ctx->total[0] & 0x3F;
+	fill = 64 - left;
+
+	ctx->total[0] += ilen;
+	ctx->total[0] &= 0xFFFFFFFF;
+
+	if( ctx->total[0] < (unsigned long) ilen )
+		ctx->total[1]++;
+
+	if( left && (ilen >= fill) )
+	{
+		memcpy( (void *) (ctx->buffer + left),
+			(void *) input, fill );
+		sha1_process( ctx, ctx->buffer );
+		input += fill;
+		ilen  -= fill;
+		left = 0;
+	}
+
+	while( ilen >= 64 )
+	{
+		sha1_process( ctx, input );
+		input += 64;
+		ilen  -= 64;
+	}
+
+	if( ilen > 0 )
+	{
+		memcpy( (void *) (ctx->buffer + left),
+			(void *) input, ilen );
+	}
+}
+
+
+// SHA-1 final digest
+static unsigned long sha1_finish( sha1_context *ctx,unsigned char *output )
+{
+	unsigned long last, padn;
+	unsigned long high, low;
+	unsigned char msglen[8];
+	unsigned char sha_padding[64] = {0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+	};
+	high = ( ctx->total[0] >> 29 )
+		| ( ctx->total[1] <<  3 );
+	low  = ( ctx->total[0] <<  3 );
+
+	PUT_ULONG_BE( high, msglen, 0 );
+	PUT_ULONG_BE( low,  msglen, 4 );
+
+	last = ctx->total[0] & 0x3F;
+	padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );
+
+	sha1_update( ctx, (unsigned char *) sha_padding, padn );
+	sha1_update( ctx, msglen, 8 );
+
+	PUT_ULONG_BE( ctx->state[0], output,  0 );
+	PUT_ULONG_BE( ctx->state[1], output,  4 );
+	PUT_ULONG_BE( ctx->state[2], output,  8 );
+	PUT_ULONG_BE( ctx->state[3], output, 12 );
+	PUT_ULONG_BE( ctx->state[4], output, 16 );
+
+	memset(&sha1_ctx, 0, sizeof( sha1_ctx ) );
+	return 0;
+}
+
+// output = SHA-1( input buffer )
+static void sha1( unsigned char *input, unsigned long  ilen, unsigned char output[20] )
+{
+	sha1_context ctx;
+
+	sha1_starts( &ctx );
+	sha1_update( &ctx, input, ilen );
+	sha1_finish( &ctx, output);
+
+	memset( &ctx, 0, sizeof( sha1_context ) );
+}
+
+/////////////////////////////////////////////////////
+//////////////////////external///////////////////////
+/////////////////////////////////////////////////////
+unsigned long soft_sha_1(unsigned char *i_pdata, unsigned long  i_udatalen,
+						 unsigned char *o_pdata)
+{
+	sha1(i_pdata, i_udatalen, o_pdata);
+
+	return 0;
+}
+
+#endif
+
+
+#define COMMAND_SIZE	64
+#define MAX_NAME_LEN	256
+#define MAX_IMAGE_SECTION  0x100000
+#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
+
+#define IPTV_FLAG_ADDR              0x90000
+#define SPI_UBOOT_UPDATE_INFO       0x91000
+#define SPI_LOADER_INFO             0x95000
+#define SWLOADADDR                  0x80000000
+
+#define UPDATEUBOOTFLAG   0xabcd6789
+
+#define PIO3_BASSADDRESS  0xFD023000
+#define PIO3_CLEAR_C0  *(volatile unsigned char *)(PIO3_BASSADDRESS+0x28)
+#define PIO3_CLEAR_C1 *(volatile unsigned char *)(PIO3_BASSADDRESS+0x38)
+#define PIO3_CLEAR_C2   *(volatile unsigned char *)(PIO3_BASSADDRESS+0x48)
+#define PIO3_SET_C0  *(volatile unsigned char *)(PIO3_BASSADDRESS+0x24)
+#define PIO3_SET_C1 *(volatile unsigned char *)(PIO3_BASSADDRESS+0x34)
+#define PIO3_SET_C2   *(volatile unsigned char *)(PIO3_BASSADDRESS+0x44)
+
+/*********************** ST ***** HDMI&CVBS ******************************/
+#define D_NTSC 1
+#define D_PAL 0
+#define DISPLAY_SD D_NTSC
+
+#define ARGB8888 1
+#define COLORTYPE ARGB8888
+/* DEVICE */
+
+unsigned long STSYS_ReadRegDev32BE(void *Address_p) {
+	unsigned long RetVal = ((unsigned long) (((*(((volatile unsigned char *) (Address_p))    )) << 24) |
+		((*(((volatile unsigned char *) (Address_p)) + 1)) << 16) |
+		((*(((volatile unsigned char *) (Address_p)) + 2)) <<  8) |
+		((*(((volatile unsigned char *) (Address_p)) + 3))     )));
+	return RetVal;
+}
+
+
+unsigned long STSYS_ReadRegDev32LE(void *Address_p)
+{
+	unsigned long RetVal =  (*((volatile unsigned long *) (Address_p)));
+	return RetVal;
+}
+
+void STSYS_WriteRegDev32BE(void *Address_p, unsigned long Value)
+{
+	*((volatile unsigned long *) (Address_p)) = (unsigned long) ((((Value) & 0xFF000000) >> 24) |
+		(((Value) & 0x00FF0000) >> 8 ) |
+		(((Value) & 0x0000FF00) << 8 ) |
+		(((Value) & 0x000000FF) << 24));
+}
+
+
+
+void STSYS_WriteRegDev32LE(void *Address_p, unsigned long Value)
+{
+	*((volatile unsigned long *) (Address_p)) = (unsigned long) (Value);
+}
+
+#ifdef ULONG
+#undef ULONG
+#endif
+#define ULONG unsigned long
+
+#ifdef UCHAR
+#undef UCHAR
+#endif
+#define UCHAR unsigned char
+
+void WriteRegister(volatile ULONG *reg,ULONG val)
+{
+	*((volatile ULONG *) (reg)) = (ULONG) (val);
+}
+
+void WriteByteRegister(volatile UCHAR *reg,UCHAR val)
+{
+	*((volatile UCHAR *) (reg)) = (UCHAR) (val);
+}
+
+typedef struct PIXER_COLOR
+{
+	unsigned char uR;
+	unsigned char uG;
+	unsigned char uB;
+}PIXER_COLOR_t;
+
+
+#define  stsys_WRITEREGDEV32LE(a,v) STSYS_WriteRegDev32LE((void*)a,v)
+#define  stsys_READREGDEV32LE(a,v) STSYS_ReadRegDev32LE((void*)a)
+#define  stsys_WRITEREGMEM32LE(a,v) STSYS_WriteRegDev32LE((void*)a,v) //was mem
+#define  stsys_READREGMEM32LE(a,v) STSYS_ReadRegDev32LE((void*)a) //was mem
+
+
+#define ST7105_CKG_BASE_ADDRESS           0xfe000000
+#define ST7105_CKG_B_BASE_ADDRESS         0xfe000000
+#define ST7105_DENC_BASE_ADDRESS          0xfe030000
+#define ST7105_HD_TVOUT_BASE_ADDRESS      0xfe030000
+#define ST7105_HDMI_BASE_ADDRESS          0xfd104000
+#define ST7105_HD_TVOUT_VTGB_BASE_ADDRESS 0xfe030200
+#define ST7105_HD_TVOUT_VTGA_BASE_ADDRESS 0xfe030300
+#define ST7105_HD_TVOUT_HDF_BASE_ADDRESS  0xfe030800
+#define ST7105_AWG_BASE_ADDRESS           0xfe030b00 //sure?
+
+#define ST7105_GDP1_LAYER_BASE_ADDRESS    0xfe20a100
+#define ST7105_GDP3_LAYER_BASE_ADDRESS    0xfe20a300
+
+#define ST7105_VMIX1_BASE_ADDRESS         0xfe20ac00
+#define ST7105_VMIX2_BASE_ADDRESS         0xfe20ad00
+
+#define ST7105_CFG_BASE_ADDRESS           0xfe001000
+
+#define ST7105_HD_TVOUT_MAIN_GLUE_BASE_ADDRESS 0xfe030400
+
+/*Added by LQ */
+#define GDP1_NODE_TOP_ADDRESS           0x98200100
+#define GDP1_NODE_TOP_PHY_ADDRESS       0x48200100
+
+#define SD_PIC_LAOD_ADDRESS		        0x980012a0
+#define SD_PIC_LAOD_PHY_ADDRESS		    0x480012a0
+
+#define HD_PIC_LAOD_ADDRESS		        0x986012a0
+#define HD_PIC_LAOD_PHY_ADDRESS		    0x486012a0
+
+#define GDP3_NODE_TOP_ADDRESS		    0x98300100
+#define GDP3_NODE_TOP_PHY_ADDRESS	    0x48300100
+
+#define GDP3_NODE_BOTTOM_ADDRESS	    0x98310100
+#define GDP3_NODE_BOTTOM_PHY_ADDRESS	0x48310100
+
+typedef unsigned char   BYTE;
+typedef unsigned short  WORD;
+typedef unsigned int    DWORD;
+typedef unsigned int    LONG;
+
+
+typedef struct tagBITMAPFILEHEADER {
+	WORD    bfType;
+	DWORD   bfSize;
+	WORD    bfReserved1;
+	WORD    bfReserved2;
+	DWORD   bfOffBits;
+} BITMAPFILEHEADER, *PBITMAPFILEHEADER;
+
+typedef struct tagBITMAPINFOHEADER{
+	DWORD  biSize;
+	LONG   biwidth;
+	LONG   biheight;
+	WORD   biPlanes;
+	WORD   biBitCount;
+	DWORD  biCompression;
+	DWORD  biSizeImage;
+	LONG   biXPelsPerMeter;
+	LONG   biYPelsPerMeter;
+	DWORD  biClrUsed;
+	DWORD  biClrImportant;
+} BITMAPINFOHEADER, *PBITMAPINFOHEADER;
+
+typedef struct tagRGBQUAD {
+	BYTE    rgbBlue;
+	BYTE    rgbGreen;
+	BYTE    rgbRed;
+	BYTE    rgbReserved;
+} RGBQUAD;
+
+static unsigned int image_data[]=
+{
+	0x801e1e1e,0x801c1c1c,0x801c1c1c,0x801c1c1c,0x80161616,0x800c0c0c,
+0x80060606,0x800f0f0f,0x80181818,0x801c1c1c,0x801d1d1d,0x801d1d1d,
+0x801e1e1e,0x801e1e1e,0x801c1c1c,0x801b1b1b,0x80191919,0x80171717,
+0x80171717,0x80191919,0x801b1b1b,0x801d1d1d,0x801f1f1f,0x80202020,
+0x801f1f1f,0x801d1d1d,0x801a1a1a,0x80181818,0x80171717,0x80171717,
+0x80191919,0x80191919,0x80070707,0x80070707,0x80111111,0x800a0a0a,
+0x800c0c0c,0x801d1d1d,0x80171717,0x80191919,0x80191919,0x80171717,
+0x80191919,0x801d1d1d,0x801f1f1f,0x801e1e1e,0x80202020,0x801d1d1d,
+0x801d1d1d,0x80191919,0x80191919,0x80171717,0x800c0c0c,0x80080808,
+0x80131313,0x801d1d1d,0x80202020,0x801b1b1b,0x800d0d0d,0x80090909,
+0x80151515,0x80191919,0x80191919,0x80171717,0x80171717,0x801b1b1b,
+0x801e1e1e,0x801f1f1f,0x801f1f1f,0x80202020,0x801f1f1f,0x801b1b1b,
+0x80191919,0x80171717,0x80161616,0x80181818,0x80161616,0x800e0e0e,
+0x80111111,0x80101010,0x80101010,0x80171717,0x80161616,0x800f0f0f,
+0x800d0d0d,0x800d0d0d,0x800d0d0d,0x80181818,0x801b1b1b,0x801e1e1e,
+0x801f1f1f,0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801a1a1a,0x80181818,
+0x80181818,0x80171717,0x80171717,0x80191919,0x801d1d1d,0x801f1f1f,
+0x801e1e1e,0x801c1c1c,0x80202020,0x80171717,0x80050505,0x800a0a0a,
+0x80181818,0x80181818,0x801a1a1a,0x801b1b1b,0x80202020,0x801f1f1f,
+0x801f1f1f,0x801e1e1e,0x801e1e1e,0x80181818,0x80181818,0x80181818,
+0x80181818,0x80181818,0x801b1b1b,0x801f1f1f,0x80202020,0x801e1e1e,
+0x801f1f1f,0x80101010,0x800c0c0c,0x800b0b0b,0x800a0a0a,0x800c0c0c,
+0x800a0a0a,0x800b0b0b,0x800d0d0d,0x800d0d0d,0x800d0d0d,0x80101010,
+0x80161616,0x80191919,0x80181818,0x80181818,0x80181818,0x80181818,
+0x80191919,0x801d1d1d,0x80202020,0x801f1f1f,0x801e1e1e,0x801f1f1f,
+0x801b1b1b,0x80191919,0x80171717,0x80191919,0x801a1a1a,0x80161616,
+0x80181818,0x80212121,0x801c1c1c,0x800e0e0e,0x80121212,0x801e1e1e,
+0x801a1a1a,0x80171717,0x80191919,0x80181818,0x80171717,0x801b1b1b,
+0x801e1e1e,0x801d1d1d,0x801f1f1f,0x80212121,0x801f1f1f,0x801a1a1a,
+0x80171717,0x80191919,0x80181818,0x800d0d0d,0x80070707,0x80090909,
+0x80090909,0x800a0a0a,0x80090909,0x80080808,0x800a0a0a,0x80070707,
+0x80070707,0x80080808,0x80070707,0x80101010,0x80191919,0x800f0f0f,0x800e0e0e,0x800f0f0f,0x800b0b0b,0x80040404,
+0x80000000,0x80040404,0x800d0d0d,0x80121212,0x80111111,0x800f0f0f,
+0x80151515,0x801c1c1c,0x80191919,0x80191919,0x80181818,0x80181818,
+0x80191919,0x801b1b1b,0x801d1d1d,0x801e1e1e,0x801e1e1e,0x801f1f1f,
+0x801d1d1d,0x80191919,0x80121212,0x800d0d0d,0x800c0c0c,0x800d0d0d,
+0x800a0a0a,0x800f0f0f,0x80020202,0x80020202,0x800a0a0a,0x80020202,
+0x80000000,0x800a0a0a,0x80151515,0x80181818,0x801a1a1a,0x801a1a1a,
+0x801b1b1b,0x801f1f1f,0x80202020,0x801e1e1e,0x80212121,0x801c1c1c,
+0x801b1b1b,0x80171717,0x80191919,0x80161616,0x80060606,0x80000000,
+0x80161616,0x801b1b1b,0x80191919,0x80121212,0x80030303,0x80000000,
+0x800e0e0e,0x80141414,0x80101010,0x80151515,0x801a1a1a,0x801e1e1e,
+0x80202020,0x80202020,0x801f1f1f,0x801f1f1f,0x801a1a1a,0x80171717,
+0x80181818,0x80191919,0x80171717,0x80191919,0x80131313,0x80020202,
+0x80000000,0x80000000,0x80000000,0x800c0c0c,0x800c0c0c,0x80000000,
+0x80000000,0x80000000,0x80060606,0x801a1a1a,0x801f1f1f,0x801f1f1f,
+0x801f1f1f,0x801d1d1d,0x801e1e1e,0x801b1b1b,0x80181818,0x80181818,
+0x80181818,0x80181818,0x80191919,0x801d1d1d,0x801d1d1d,0x80171717,
+0x80131313,0x80111111,0x80131313,0x80090909,0x80000000,0x80010101,
+0x800e0e0e,0x800d0d0d,0x80101010,0x80131313,0x80141414,0x80121212,
+0x801c1c1c,0x801d1d1d,0x801a1a1a,0x80161616,0x80181818,0x80181818,
+0x80191919,0x801b1b1b,0x801e1e1e,0x80202020,0x801f1f1f,0x801e1e1e,
+0x801b1b1b,0x80030303,0x80000000,0x80000000,0x80000000,0x80010101,
+0x80000000,0x80010101,0x80000000,0x80010101,0x80000000,0x80000000,
+0x800c0c0c,0x80151515,0x80181818,0x801b1b1b,0x80191919,0x80191919,
+0x801c1c1c,0x801f1f1f,0x80202020,0x801e1e1e,0x801d1d1d,0x801d1d1d,
+0x80191919,0x80191919,0x80171717,0x80181818,0x80161616,0x80090909,
+0x80090909,0x80191919,0x80171717,0x80000000,0x80050505,0x80181818,
+0x80191919,0x80171717,0x801a1a1a,0x80171717,0x801a1a1a,0x801e1e1e,
+0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801f1f1f,0x801c1c1c,0x80181818,
+0x80161616,0x80191919,0x80171717,0x80090909,0x80000000,0x80010101,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80010101,0x80000000,
+0x80000000,0x80000000,0x80000000,0x800c0c0c,0x80141414,0x80030303,0x80000000,0x80010101,0x80010101,0x80000000,
+0x80020202,0x80000000,0x80000000,0x80010101,0x80000000,0x80000000,
+0x800a0a0a,0x80181818,0x80171717,0x80171717,0x80171717,0x80181818,
+0x801b1b1b,0x801d1d1d,0x801e1e1e,0x801f1f1f,0x801d1d1d,0x801e1e1e,
+0x801c1c1c,0x80161616,0x800a0a0a,0x80010101,0x80000000,0x80010101,
+0x80000000,0x80020202,0x80000000,0x80000000,0x80010101,0x80000000,
+0x80020202,0x80000000,0x80151515,0x80151515,0x80191919,0x801d1d1d,
+0x801f1f1f,0x801e1e1e,0x801e1e1e,0x80202020,0x801c1c1c,0x80191919,
+0x801a1a1a,0x80161616,0x80181818,0x80161616,0x80060606,0x80010101,
+0x80131313,0x800a0a0a,0x80000000,0x80010101,0x80000000,0x80000000,
+0x80040404,0x80000000,0x80000000,0x80101010,0x801d1d1d,0x801e1e1e,
+0x801d1d1d,0x801f1f1f,0x801f1f1f,0x801b1b1b,0x801b1b1b,0x80161616,
+0x80181818,0x801a1a1a,0x80181818,0x801c1c1c,0x80151515,0x80000000,
+0x80050505,0x80070707,0x80010101,0x800b0b0b,0x800b0b0b,0x80010101,
+0x80050505,0x80000000,0x80040404,0x801d1d1d,0x80202020,0x801d1d1d,
+0x801f1f1f,0x801e1e1e,0x801c1c1c,0x80151515,0x80181818,0x80191919,
+0x80181818,0x80181818,0x801c1c1c,0x80222222,0x801b1b1b,0x800c0c0c,
+0x80000000,0x80020202,0x80000000,0x80000000,0x80020202,0x80010101,
+0x80000000,0x80020202,0x80010101,0x80010101,0x80000000,0x80020202,
+0x80181818,0x80191919,0x80161616,0x801b1b1b,0x80181818,0x80191919,
+0x801c1c1c,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x80202020,
+0x80171717,0x80020202,0x80010101,0x80030303,0x80010101,0x80050505,
+0x80030303,0x80000000,0x800e0e0e,0x80121212,0x80080808,0x80000000,
+0x800b0b0b,0x80181818,0x801a1a1a,0x80181818,0x80191919,0x801e1e1e,
+0x80202020,0x801e1e1e,0x801d1d1d,0x801f1f1f,0x801d1d1d,0x80181818,
+0x80161616,0x80191919,0x80181818,0x80191919,0x80151515,0x80020202,
+0x80000000,0x80161616,0x801b1b1b,0x80020202,0x80000000,0x80101010,
+0x80181818,0x80171717,0x80191919,0x801a1a1a,0x801f1f1f,0x801e1e1e,
+0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801a1a1a,0x80181818,0x80171717,
+0x80181818,0x80191919,0x80191919,0x80101010,0x800a0a0a,0x800b0b0b,
+0x800a0a0a,0x800c0c0c,0x800b0b0b,0x80080808,0x800b0b0b,0x80090909,
+0x80080808,0x80040404,0x80020202,0x800f0f0f,0x80141414,0x80000000,0x80060606,0x80090909,0x80070707,0x80090909,
+0x80090909,0x800a0a0a,0x800d0d0d,0x800a0a0a,0x80060606,0x80030303,
+0x80090909,0x80171717,0x801a1a1a,0x80171717,0x80171717,0x801a1a1a,
+0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801f1f1f,0x801d1d1d,0x80191919,
+0x80181818,0x801a1a1a,0x80090909,0x80000000,0x80030303,0x800a0a0a,
+0x800a0a0a,0x80080808,0x80080808,0x80000000,0x80050505,0x800a0a0a,
+0x80010101,0x800c0c0c,0x80141414,0x80191919,0x801e1e1e,0x801f1f1f,
+0x801d1d1d,0x801e1e1e,0x801f1f1f,0x801d1d1d,0x80181818,0x801a1a1a,
+0x80181818,0x80191919,0x80141414,0x80010101,0x80000000,0x80000000,
+0x80050505,0x80010101,0x80000000,0x80000000,0x80010101,0x80010101,
+0x80000000,0x80010101,0x80000000,0x80131313,0x801e1e1e,0x801d1d1d,
+0x801f1f1f,0x80212121,0x801c1c1c,0x80181818,0x80181818,0x80191919,
+0x80181818,0x80191919,0x801c1c1c,0x801f1f1f,0x80151515,0x80000000,
+0x800f0f0f,0x80131313,0x80050505,0x80090909,0x80080808,0x80010101,
+0x800c0c0c,0x80070707,0x80040404,0x800c0c0c,0x80090909,0x80191919,
+0x80202020,0x801a1a1a,0x80171717,0x80181818,0x801a1a1a,0x80161616,
+0x801b1b1b,0x801f1f1f,0x801e1e1e,0x80202020,0x801e1e1e,0x80121212,
+0x80050505,0x80050505,0x80030303,0x80000000,0x80000000,0x80030303,
+0x80070707,0x80070707,0x80080808,0x80060606,0x80070707,0x80080808,
+0x80141414,0x80191718,0x801b191a,0x80191718,0x80171717,0x801c1c1c,
+0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801e1e1e,0x801d1d1d,0x801a1a1a,
+0x80161616,0x80010101,0x80040404,0x80090909,0x80010101,0x800f0f0f,
+0x80050505,0x80000000,0x80050505,0x80060606,0x80010101,0x80000000,
+0x800d0d0d,0x80191919,0x80191919,0x80181818,0x80202020,0x801e1e1e,
+0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801c1c1c,0x80191919,0x80191919,
+0x801a1a1a,0x80161616,0x80191919,0x80181818,0x800e0e0e,0x80000000,
+0x80020202,0x801c1c1c,0x801d1d1d,0x80090909,0x80000000,0x80060606,
+0x80141414,0x801a1a1a,0x80181818,0x801f1f1f,0x801f1f1f,0x801e1e1e,
+0x801e1e1e,0x801e1e1e,0x801b1b1b,0x80171717,0x80171717,0x80191919,
+0x801b191a,0x80181617,0x801d1b1c,0x80222222,0x800c0c0c,0x80050505,
+0x800a0a0a,0x800a0a0a,0x80070707,0x80080808,0x80080808,0x80050505,
+0x800b0b0b,0x800f0f0f,0x80000000,0x800e0e0e,0x80101010,0x80000000,0x80020202,0x80020202,0x80010101,0x80020202,
+0x80020202,0x80000000,0x80010101,0x80010101,0x80000000,0x80000000,
+0x80080808,0x801a1a1a,0x80171717,0x80191919,0x801b1b1b,0x801c1c1c,
+0x801d1d1d,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801a1a1a,0x80191919,
+0x80171717,0x80171717,0x800a0a0a,0x80040404,0x80030303,0x80010101,
+0x80050505,0x80090909,0x80141414,0x80030303,0x80030303,0x80070707,
+0x80030303,0x80101010,0x801a1a1a,0x801c1c1c,0x801e1e1e,0x801f1f1f,
+0x80202020,0x801f1f1f,0x801d1d1d,0x801b1b1b,0x80191919,0x80161616,
+0x80171717,0x80181818,0x80171717,0x80080808,0x80010101,0x80000000,
+0x80000000,0x80010101,0x80020202,0x80000000,0x80020202,0x80030303,
+0x80010101,0x80090909,0x80010101,0x80111111,0x801c1c1c,0x801e1e1e,
+0x801d1d1d,0x801b1b1b,0x80181818,0x801a1a1a,0x80171717,0x80191919,
+0x801a1a1a,0x801b1b1b,0x801d1d1d,0x801f1f1f,0x80161616,0x80000000,
+0x80040404,0x80050505,0x80000000,0x80080808,0x80040404,0x80020202,
+0x80141414,0x80030303,0x80000000,0x80000000,0x80040404,0x801c1c1c,
+0x801c1c1c,0x80161616,0x80171717,0x80191919,0x80151515,0x80191919,
+0x801e1e1e,0x801e1e1e,0x801d1d1d,0x801f1f1f,0x801f1f1f,0x80181818,
+0x80161616,0x80171717,0x800e0e0e,0x80020202,0x80020202,0x80090909,
+0x800c0c0c,0x800a0a0a,0x80090909,0x800a0a0a,0x80121212,0x80171717,
+0x801b1b1b,0x80181617,0x80191718,0x80191718,0x801c1c1c,0x801d1d1d,
+0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801d1d1d,0x801b1b1b,0x80181818,
+0x80171717,0x80010101,0x80020202,0x80040404,0x80010101,0x80181818,
+0x80060606,0x80000000,0x80030303,0x80050505,0x80020202,0x80000000,
+0x800a0a0a,0x80161616,0x80191919,0x801c1c1c,0x801e1e1e,0x80202020,
+0x80202020,0x801e1e1e,0x801c1c1c,0x801a1a1a,0x80191919,0x80181818,
+0x80171717,0x80191919,0x801e1e1e,0x80171717,0x80020202,0x80000000,
+0x80131313,0x80202020,0x801b1b1b,0x800c0c0c,0x80020202,0x80010101,
+0x80080808,0x80171717,0x80212121,0x801e1e1e,0x801e1e1e,0x801f1f1f,
+0x801f1f1f,0x801a1a1a,0x80181818,0x80191919,0x80191919,0x80181818,
+0x80191718,0x801e1c1d,0x80211f20,0x801b1b1b,0x80050505,0x80010101,
+0x80030303,0x80000000,0x80000000,0x80000000,0x80010101,0x80010101,
+0x80090909,0x800d0d0d,0x80000000,0x800f0f0f,0x80121212,0x800a0a0a,0x800a0a0a,0x80050505,0x80050505,0x80050505,
+0x80080808,0x80050505,0x80060606,0x80060606,0x80070707,0x800a0a0a,
+0x800e0e0e,0x80181818,0x80171717,0x801b1b1b,0x801e1e1e,0x801e1e1e,
+0x801e1e1e,0x801e1e1e,0x801d1d1d,0x801b1b1b,0x801a1a1a,0x80161616,
+0x80181818,0x801a1a1a,0x80080808,0x80000000,0x80030303,0x80060606,
+0x80000000,0x80060606,0x80181818,0x80030303,0x80000000,0x80010101,
+0x80050505,0x800f0f0f,0x801c1c1c,0x801f1f1f,0x801f1f1f,0x801f1f1f,
+0x80202020,0x801d1d1d,0x80191919,0x80181818,0x80191919,0x80161616,
+0x80191919,0x80191919,0x801e1e1e,0x80171717,0x80080808,0x80000000,
+0x80151515,0x80141414,0x800c0c0c,0x80000000,0x80000000,0x80030303,
+0x80020202,0x80101010,0x80040404,0x80151515,0x80202020,0x80202020,
+0x801c1c1c,0x80181818,0x80171717,0x80191919,0x80171717,0x801b1b1b,
+0x801c1c1c,0x801e1e1e,0x801f1f1f,0x80202020,0x80161616,0x80000000,
+0x80000000,0x80030303,0x80000000,0x80040404,0x80000000,0x80020202,
+0x80191919,0x80090909,0x80000000,0x80000000,0x800b0b0b,0x80191919,
+0x80171717,0x80181818,0x80191919,0x80171717,0x801a1a1a,0x801d1d1d,
+0x801d1d1d,0x801d1d1d,0x801f1f1f,0x801f1f1f,0x801c1c1c,0x80191919,
+0x80191919,0x80151515,0x80070707,0x80000000,0x80000000,0x80020202,
+0x80010101,0x80000000,0x80020202,0x80000000,0x800a0a0a,0x80151515,
+0x80191919,0x80161415,0x80191718,0x801b191a,0x801f1f1f,0x801e1e1e,
+0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801a1a1a,0x80181818,0x80171717,
+0x80171717,0x80020202,0x80000000,0x80010101,0x80000000,0x801d1d1d,
+0x80050505,0x80000000,0x800e0e0e,0x800c0c0c,0x80070707,0x80020202,
+0x800b0b0b,0x80181818,0x801d1d1d,0x80202020,0x801e1e1e,0x80202020,
+0x80202020,0x801c1c1c,0x80181818,0x80181818,0x80181818,0x80171717,
+0x80181818,0x801a1a1a,0x80171717,0x800b0b0b,0x80000000,0x80070707,
+0x801b1b1b,0x80111111,0x80151515,0x801a1a1a,0x800a0a0a,0x80000000,
+0x80000000,0x800a0a0a,0x80191919,0x801f1f1f,0x801e1e1e,0x801f1f1f,
+0x801d1d1d,0x80181818,0x80161616,0x80181818,0x80191919,0x80191919,
+0x801d1b1c,0x801f1d1e,0x80201e1f,0x801f1f1f,0x800f0f0f,0x80080808,
+0x80090909,0x80090909,0x800a0a0a,0x80080808,0x80090909,0x800a0a0a,
+0x80111111,0x800f0f0f,0x80010101,0x800e0e0e,0x80181818,0x80161616,0x800d0d0d,0x80030303,0x80020202,0x80030303,
+0x80010101,0x80030303,0x80040404,0x80020202,0x80080808,0x80171717,
+0x80171717,0x80171717,0x801a1a1a,0x801c1c1c,0x801e1e1e,0x801f1f1f,
+0x801f1f1f,0x801e1e1e,0x801b1b1b,0x80171717,0x80191919,0x80151515,
+0x801a1a1a,0x801a1a1a,0x80050505,0x80000000,0x80101010,0x80111111,
+0x80010101,0x80030303,0x800f0f0f,0x80000000,0x80000000,0x80000000,
+0x80080808,0x800a0a0a,0x80171717,0x801f1f1f,0x80202020,0x801d1d1d,
+0x801d1d1d,0x801a1a1a,0x80161616,0x80181818,0x80171717,0x80191919,
+0x801c1c1c,0x801c1c1c,0x80232323,0x801d1d1d,0x800e0e0e,0x80000000,
+0x800c0c0c,0x80101010,0x800a0a0a,0x80000000,0x80090909,0x800a0a0a,
+0x80000000,0x80050505,0x80000000,0x80131313,0x801d1d1d,0x801b1b1b,
+0x80181818,0x80191919,0x80191919,0x80171717,0x80191919,0x801d1d1d,
+0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801f1f1f,0x80151515,0x80010101,
+0x80060606,0x800b0b0b,0x80020202,0x80040404,0x80040404,0x800a0a0a,
+0x801b1b1b,0x80151515,0x800a0a0a,0x800f0f0f,0x80181818,0x80191919,
+0x80181818,0x801a1a1a,0x80171717,0x80191919,0x80202020,0x801d1d1d,
+0x801d1d1d,0x801f1f1f,0x801f1f1f,0x801b1b1b,0x80181818,0x80171717,
+0x80171717,0x800b0b0b,0x80000000,0x80010101,0x80080808,0x800c0c0c,
+0x800d0d0d,0x800e0e0e,0x80060606,0x80000000,0x80080808,0x80161616,
+0x801a1a1a,0x801a1819,0x801f1d1e,0x80201e1f,0x801e1e1e,0x801e1e1e,
+0x801f1f1f,0x801d1d1d,0x801a1a1a,0x80171717,0x80171717,0x80191919,
+0x80161616,0x80020202,0x80000000,0x80080808,0x80000000,0x80161616,
+0x80030303,0x80010101,0x80010101,0x80000000,0x80000000,0x80000000,
+0x800a0a0a,0x801d1d1d,0x80202020,0x801f1f1f,0x801f1f1f,0x801e1e1e,
+0x801c1c1c,0x80191919,0x80171717,0x80181818,0x80191919,0x80181818,
+0x801d1d1d,0x801c1c1c,0x800c0c0c,0x80000000,0x80030303,0x80151515,
+0x80141414,0x80010101,0x80000000,0x80171717,0x80141414,0x800a0a0a,
+0x80030303,0x80000000,0x80101010,0x801d1d1d,0x801e1e1e,0x801a1a1a,
+0x80181818,0x80181818,0x80181818,0x80171717,0x80191919,0x801d1d1d,
+0x80211f20,0x801f1d1e,0x801e1c1d,0x80202020,0x80171717,0x80080808,
+0x80050505,0x80080808,0x80050505,0x80070707,0x80070707,0x800d0d0d,
+0x801a1a1a,0x80121212,0x80000000,0x800e0e0e,0x80191919,0x801a1a1a,0x800b0b0b,0x80000000,0x80010101,0x80030303,
+0x80000000,0x80020202,0x80010101,0x80000000,0x80020202,0x80171717,
+0x80191919,0x80191919,0x801e1e1e,0x801d1d1d,0x801e1e1e,0x801f1f1f,
+0x801e1e1e,0x801b1b1b,0x80181818,0x80171717,0x80191919,0x80181818,
+0x801a1a1a,0x80121212,0x80000000,0x80040404,0x80131313,0x80010101,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80050505,0x80000000,
+0x80050505,0x80000000,0x80121212,0x801c1c1c,0x801f1f1f,0x801b1b1b,
+0x801a1a1a,0x80191919,0x80181818,0x801a1a1a,0x80161616,0x801b1b1b,
+0x801c1c1c,0x801f1f1f,0x801e1e1e,0x800f0f0f,0x80080808,0x80000000,
+0x80000000,0x80070707,0x80030303,0x80010101,0x80111111,0x80101010,
+0x80000000,0x80000000,0x80010101,0x80151515,0x801b1b1b,0x80181818,
+0x80171717,0x80191919,0x801b1b1b,0x80181818,0x801c1c1c,0x801f1f1f,
+0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801c1c1c,0x80131313,0x80000000,
+0x800b0b0b,0x800b0b0b,0x80030303,0x80000000,0x80000000,0x80000000,
+0x80020202,0x80000000,0x80010101,0x80020202,0x800f0f0f,0x80161616,
+0x80181818,0x80171717,0x80171717,0x80202020,0x801d1d1d,0x801d1d1d,
+0x80202020,0x80202020,0x801a1a1a,0x80171717,0x80181818,0x80161616,
+0x800e0e0e,0x80000000,0x80000000,0x80000000,0x80030303,0x80040404,
+0x80060606,0x80060606,0x80020202,0x80000000,0x800a0a0a,0x80181818,
+0x80181818,0x80191718,0x801e1c1d,0x80201e1f,0x801d1d1d,0x801e1e1e,
+0x801e1e1e,0x801a1a1a,0x80171717,0x80161616,0x80181818,0x80191919,
+0x80171717,0x80040404,0x80030303,0x80131313,0x80000000,0x80090909,
+0x80020202,0x80020202,0x80000000,0x80020202,0x80080808,0x80070707,
+0x80101010,0x80212121,0x80202020,0x801c1c1c,0x801f1f1f,0x801c1c1c,
+0x80181818,0x80171717,0x80181818,0x80181818,0x80191919,0x801b1b1b,
+0x801f1f1f,0x801d1d1d,0x80111111,0x80020202,0x800e0e0e,0x801b1b1b,
+0x800c0c0c,0x80010101,0x80040404,0x80141414,0x801b1b1b,0x80191919,
+0x80080808,0x80050505,0x801d1d1d,0x80222222,0x801b1b1b,0x80181818,
+0x80161616,0x80181818,0x80191919,0x80191919,0x801c1c1c,0x801f1f1f,
+0x801f1d1e,0x80211f20,0x80201e1f,0x801c1c1c,0x80131313,0x80020202,
+0x80000000,0x80000000,0x80000000,0x80010101,0x80000000,0x80060606,
+0x801e1e1e,0x80131313,0x80000000,0x800d0d0d,0x80181818,0x801b1b1b,0x800c0c0c,0x80010101,0x80040404,0x80050505,
+0x80070707,0x80060606,0x80050505,0x80010101,0x80020202,0x80161616,
+0x80181818,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801e1e1e,
+0x801b1b1b,0x80171717,0x80171717,0x80191919,0x80191919,0x80191919,
+0x801c1c1c,0x801a1a1a,0x800e0e0e,0x800d0d0d,0x80161616,0x80030303,
+0x80070707,0x80060606,0x80030303,0x800b0b0b,0x800e0e0e,0x80020202,
+0x80030303,0x80000000,0x80171717,0x801d1d1d,0x801e1e1e,0x801a1a1a,
+0x80191919,0x80191919,0x80171717,0x80171717,0x801b1b1b,0x801d1d1d,
+0x801c1c1c,0x80212121,0x80191919,0x80000000,0x80000000,0x80000000,
+0x80020202,0x800d0d0d,0x80090909,0x800c0c0c,0x801b1b1b,0x80181818,
+0x800c0c0c,0x80090909,0x800d0d0d,0x80191919,0x801b1b1b,0x801a1a1a,
+0x80191919,0x80171717,0x801b1b1b,0x801c1c1c,0x801e1e1e,0x801f1f1f,
+0x801f1f1f,0x801e1e1e,0x801b1b1b,0x801a1a1a,0x80121212,0x80000000,
+0x80010101,0x80000000,0x80000000,0x80030303,0x80010101,0x80000000,
+0x80020202,0x80030303,0x80000000,0x80020202,0x80151515,0x801a1a1a,
+0x80181818,0x801a1a1a,0x801e1e1e,0x801d1d1d,0x801d1d1d,0x801e1e1e,
+0x80202020,0x801c1c1c,0x80161616,0x80191919,0x80191919,0x80111111,
+0x80010101,0x80000000,0x80010101,0x80000000,0x80000000,0x80020202,
+0x80030303,0x80000000,0x80020202,0x80000000,0x80090909,0x80191919,
+0x801b1b1b,0x801f1d1e,0x80211f20,0x80211f20,0x801e1e1e,0x801d1d1d,
+0x801a1a1a,0x80171717,0x80161616,0x80181818,0x80191919,0x80191919,
+0x801b1b1b,0x80050505,0x80050505,0x80161616,0x80020202,0x80000000,
+0x80030303,0x80030303,0x80040404,0x80030303,0x80080808,0x80040404,
+0x80080808,0x80191919,0x801e1e1e,0x80202020,0x801c1c1c,0x801a1a1a,
+0x80181818,0x80181818,0x80181818,0x80181818,0x801b1b1b,0x801f1f1f,
+0x80202020,0x801c1c1c,0x801d1d1d,0x80141414,0x80171717,0x80191919,
+0x80050505,0x80010101,0x800b0b0b,0x801a1a1a,0x801c1c1c,0x80202020,
+0x801d1d1d,0x801a1a1a,0x80202020,0x80181818,0x80171717,0x80191919,
+0x80181818,0x80171717,0x80191919,0x801e1e1e,0x80202020,0x801e1e1e,
+0x80201e1f,0x801e1c1d,0x801c1a1b,0x801b1b1b,0x80131313,0x80000000,
+0x80020202,0x800f0f0f,0x80151515,0x80111111,0x80000000,0x80040404,
+0x801e1e1e,0x80111111,0x80000000,0x800b0b0b,0x801a1a1a,0x801e1e1e,0x800c0c0c,0x80000000,0x80020202,0x80030303,
+0x80000000,0x80000000,0x80020202,0x80010101,0x80020202,0x80191919,
+0x801c1c1c,0x80212121,0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801b1b1b,
+0x80181818,0x80171717,0x80181818,0x801a1a1a,0x801c1c1c,0x801c1c1c,
+0x801d1d1d,0x80222222,0x801a1a1a,0x80060606,0x80080808,0x80040404,
+0x80060606,0x80060606,0x80040404,0x800a0a0a,0x80090909,0x80020202,
+0x80000000,0x800d0d0d,0x801e1e1e,0x801d1d1d,0x801b1b1b,0x80191919,
+0x80191919,0x80181818,0x80171717,0x80181818,0x801f1f1f,0x801f1f1f,
+0x801f1f1f,0x80202020,0x801a1a1a,0x80050505,0x80010101,0x80010101,
+0x80101010,0x80141414,0x80030303,0x80000000,0x80050505,0x80020202,
+0x80030303,0x80030303,0x80080808,0x80151515,0x80171717,0x80181818,
+0x80191919,0x80181818,0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801f1f1f,
+0x801d1d1d,0x801c1c1c,0x80191919,0x80181818,0x80101010,0x80000000,
+0x80000000,0x80050505,0x80000000,0x800a0a0a,0x800f0f0f,0x80030303,
+0x80080808,0x800f0f0f,0x80000000,0x80090909,0x80191919,0x80191919,
+0x80191919,0x801e1e1e,0x80222222,0x801b1b1b,0x80202020,0x801e1e1e,
+0x801b1b1b,0x80171717,0x80181818,0x801a1a1a,0x80181818,0x80131313,
+0x80000000,0x800b0b0b,0x800a0a0a,0x80040404,0x80080808,0x80101010,
+0x80101010,0x800e0e0e,0x80050505,0x80010101,0x80070707,0x80191919,
+0x801d1d1d,0x80211f20,0x801f1d1e,0x801e1c1d,0x801d1d1d,0x801b1b1b,
+0x80181818,0x80171717,0x80181818,0x80191919,0x801b1b1b,0x801c1c1c,
+0x801d1d1d,0x80040404,0x80030303,0x800d0d0d,0x80010101,0x80010101,
+0x80030303,0x80030303,0x800b0b0b,0x80000000,0x80000000,0x80000000,
+0x80060606,0x80161616,0x801b1b1b,0x801e1e1e,0x80191919,0x80191919,
+0x80181818,0x80191919,0x80191919,0x801b1b1b,0x801d1d1d,0x801f1f1f,
+0x801f1f1f,0x801d1d1d,0x801e1e1e,0x801b1b1b,0x801b1b1b,0x80131313,
+0x80010101,0x80000000,0x80141414,0x801b1b1b,0x800a0a0a,0x800b0b0b,
+0x801f1f1f,0x80202020,0x80191919,0x80181818,0x80171717,0x80191919,
+0x80191919,0x80191919,0x801c1c1c,0x80202020,0x80202020,0x801e1e1e,
+0x80222021,0x801a1819,0x80181617,0x801a1a1a,0x80141414,0x80000000,
+0x80030303,0x80131313,0x80181818,0x80131313,0x80030303,0x80050505,
+0x801b1b1b,0x800e0e0e,0x80000000,0x800b0b0b,0x801e1e1e,0x80202020,0x800c0c0c,0x80010101,0x80040404,0x80060606,
+0x80060606,0x80070707,0x80060606,0x80000000,0x80020202,0x801e1e1e,
+0x801e1e1e,0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801b1b1b,0x80171717,
+0x80171717,0x80191919,0x801a1a1a,0x80181818,0x801b1b1b,0x80212121,
+0x801c1c1c,0x801d1d1d,0x801c1c1c,0x80030303,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80010101,0x80000000,0x80020202,
+0x80010101,0x801e1e1e,0x801e1e1e,0x80191919,0x80171717,0x80191919,
+0x80181818,0x80171717,0x801a1a1a,0x801e1e1e,0x801e1e1e,0x801e1e1e,
+0x80212121,0x801c1c1c,0x801c1c1c,0x80141414,0x80080808,0x80000000,
+0x80121212,0x80151515,0x80020202,0x80000000,0x80020202,0x80000000,
+0x80030303,0x80000000,0x80030303,0x80161616,0x80191919,0x80181818,
+0x80191919,0x801b1b1b,0x80212121,0x801e1e1e,0x801e1e1e,0x801e1e1e,
+0x801c1c1c,0x801b1b1b,0x80181818,0x80171717,0x80101010,0x80000000,
+0x800f0f0f,0x80171717,0x80000000,0x800d0d0d,0x801d1d1d,0x80040404,
+0x80000000,0x80020202,0x80030303,0x800f0f0f,0x80181818,0x80191919,
+0x80202020,0x801c1c1c,0x801d1d1d,0x80202020,0x801e1e1e,0x801c1c1c,
+0x80171717,0x80181818,0x801b1b1b,0x80171717,0x80171717,0x801e1e1e,
+0x80161616,0x801d1d1d,0x800f0f0f,0x80000000,0x80000000,0x80030303,
+0x80000000,0x80000000,0x80010101,0x80010101,0x800b0b0b,0x801f1f1f,
+0x80202020,0x801f1d1e,0x801d1b1c,0x80211f20,0x801a1a1a,0x80181818,
+0x80171717,0x80191919,0x80191919,0x80191919,0x801c1c1c,0x80212121,
+0x801f1f1f,0x80010101,0x80000000,0x80010101,0x80000000,0x80050505,
+0x80030303,0x80010101,0x80101010,0x80000000,0x80000000,0x800a0a0a,
+0x80181818,0x80242424,0x801d1d1d,0x80181818,0x80191919,0x80181818,
+0x80171717,0x80181818,0x801b1b1b,0x801f1f1f,0x801f1f1f,0x801d1d1d,
+0x801e1e1e,0x80212121,0x80191919,0x80151515,0x801a1a1a,0x800e0e0e,
+0x80000000,0x80070707,0x801f1f1f,0x80151515,0x80000000,0x80010101,
+0x80161616,0x801b1b1b,0x80171717,0x80181818,0x80191919,0x80181818,
+0x80191919,0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801e1e1e,
+0x801d1b1c,0x801b191a,0x801b191a,0x80181818,0x80141414,0x80010101,
+0x80000000,0x80010101,0x80000000,0x80010101,0x80000000,0x80070707,
+0x801a1a1a,0x800b0b0b,0x80020202,0x800a0a0a,0x801f1f1f,0x801e1e1e,0x800e0e0e,0x80000000,0x80020202,0x80000000,
+0x80010101,0x80000000,0x80000000,0x80000000,0x80030303,0x801d1d1d,
+0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801b1b1b,0x80181818,0x80181818,
+0x80181818,0x80191919,0x801a1a1a,0x801d1d1d,0x801e1e1e,0x801d1d1d,
+0x801f1f1f,0x80212121,0x80171717,0x80050505,0x80020202,0x800f0f0f,
+0x80000000,0x80090909,0x80070707,0x80020202,0x80111111,0x80030303,
+0x80040404,0x801b1b1b,0x80181818,0x801a1a1a,0x80191919,0x80161616,
+0x80171717,0x801b1b1b,0x801e1e1e,0x801e1e1e,0x801c1c1c,0x801f1f1f,
+0x801e1e1e,0x80181818,0x80181818,0x80181818,0x800b0b0b,0x80000000,
+0x80121212,0x801c1c1c,0x801c1c1c,0x801b1b1b,0x80090909,0x80000000,
+0x80111111,0x80161616,0x80191919,0x80161616,0x80181818,0x801a1a1a,
+0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801e1e1e,
+0x801a1a1a,0x80181818,0x80191919,0x80171717,0x800d0d0d,0x80000000,
+0x80151515,0x80191919,0x80000000,0x800b0b0b,0x801f1f1f,0x800c0c0c,
+0x80000000,0x80010101,0x80060606,0x80171717,0x801a1a1a,0x801c1c1c,
+0x80212121,0x801e1e1e,0x801e1e1e,0x80202020,0x801a1a1a,0x80181818,
+0x80171717,0x80181818,0x80191919,0x80191919,0x801c1c1c,0x80202020,
+0x801d1d1d,0x80202020,0x80101010,0x80000000,0x80030303,0x80070707,
+0x80050505,0x80080808,0x80030303,0x80000000,0x800e0e0e,0x801f1f1f,
+0x801f1f1f,0x801f1f1f,0x80212121,0x80191919,0x80181818,0x80191919,
+0x80181818,0x80171717,0x801b1b1b,0x801f1f1f,0x801f1f1f,0x801d1d1d,
+0x801d1d1d,0x80020202,0x80020202,0x80000000,0x80040404,0x800f0f0f,
+0x80050505,0x80000000,0x80121212,0x80010101,0x80000000,0x800f0f0f,
+0x801e1e1e,0x801e1e1e,0x80171717,0x80181818,0x80191919,0x80171717,
+0x80181818,0x801c1c1c,0x80202020,0x80202020,0x801f1f1f,0x801f1f1f,
+0x80202020,0x80181818,0x80171717,0x80141414,0x800f0f0f,0x80070707,
+0x80010101,0x800c0c0c,0x80151515,0x800c0c0c,0x80030303,0x80010101,
+0x80080808,0x80151515,0x801a1a1a,0x80171717,0x80171717,0x801a1a1a,
+0x801d1d1d,0x801e1e1e,0x801f1f1f,0x80202020,0x801e1e1e,0x801c1c1c,
+0x80191919,0x80161616,0x80181818,0x801a1a1a,0x80111111,0x80020202,
+0x80000000,0x80030303,0x80030303,0x80020202,0x80020202,0x80080808,
+0x80161616,0x800f0f0f,0x80000000,0x800c0c0c,0x80161616,0x800f0f0f,0x80080808,0x80010101,0x80040404,0x80040404,
+0x80020202,0x80030303,0x80030303,0x80050505,0x80040404,0x80111111,
+0x80121212,0x801d1d1d,0x801b1b1b,0x80191919,0x80171717,0x80181818,
+0x80191919,0x801a1a1a,0x801c1c1c,0x801e1e1e,0x801f1f1f,0x80212121,
+0x801e1e1e,0x80161616,0x800a0a0a,0x80000000,0x80000000,0x80050505,
+0x80010101,0x80050505,0x80040404,0x80000000,0x800a0a0a,0x80000000,
+0x80000000,0x800b0b0b,0x80141414,0x80171717,0x80191919,0x80191919,
+0x801b1b1b,0x801d1d1d,0x801e1e1e,0x801e1e1e,0x80212121,0x801d1d1d,
+0x801b1b1b,0x80181818,0x80171717,0x800f0f0f,0x80040404,0x80020202,
+0x80141414,0x80141414,0x80101010,0x80111111,0x80080808,0x80010101,
+0x800c0c0c,0x800c0c0c,0x800c0c0c,0x80101010,0x80181818,0x801b1b1b,
+0x801e1e1e,0x80212121,0x801f1f1f,0x801f1f1f,0x801c1c1c,0x80181818,
+0x80161616,0x80191919,0x801b1b1b,0x80161616,0x80090909,0x80000000,
+0x80141414,0x80141414,0x80020202,0x80050505,0x800c0c0c,0x80010101,
+0x80000000,0x80000000,0x80010101,0x800c0c0c,0x80171717,0x801f1f1f,
+0x801f1f1f,0x801d1d1d,0x801d1d1d,0x801b1b1b,0x80181818,0x80191919,
+0x80191919,0x80171717,0x80181818,0x801c1c1c,0x801f1f1f,0x801e1e1e,
+0x801f1f1f,0x801e1e1e,0x800d0d0d,0x80010101,0x800c0c0c,0x80191919,
+0x80161616,0x80121212,0x800b0b0b,0x80000000,0x800a0a0a,0x801d1d1d,
+0x80202020,0x801c1c1c,0x801a1a1a,0x80171717,0x80191919,0x80171717,
+0x80181818,0x801b1b1b,0x801e1e1e,0x801d1d1d,0x801e1e1e,0x801f1f1f,
+0x801d1d1d,0x80020202,0x80020202,0x80111111,0x80121212,0x80090909,
+0x80020202,0x80020202,0x80000000,0x80000000,0x80000000,0x80010101,
+0x80080808,0x80131313,0x80171717,0x80191919,0x80171717,0x80191919,
+0x801c1c1c,0x801d1d1d,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801e1e1e,
+0x80181818,0x80161616,0x80141414,0x80080808,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80010101,0x80000000,0x80000000,
+0x80010101,0x80111111,0x801b1b1b,0x80181818,0x801a1a1a,0x801d1d1d,
+0x801f1f1f,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801c1c1c,0x801a1a1a,
+0x80171717,0x80191919,0x80181818,0x80191919,0x80131313,0x80020202,
+0x80020202,0x80181818,0x801b1b1b,0x801b1b1b,0x80191919,0x80121212,
+0x800e0e0e,0x80070707,0x80000000,0x800a0a0a,0x800b0b0b,0x80000000,0x80010101,0x80000000,0x80000000,0x80020202,
+0x80010101,0x80010101,0x80000000,0x80010101,0x80000000,0x80000000,
+0x80000000,0x80161616,0x80181818,0x80171717,0x80171717,0x80191919,
+0x801b1b1b,0x801c1c1c,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801f1f1f,
+0x801b1b1b,0x800e0e0e,0x80020202,0x80000000,0x80010101,0x80010101,
+0x80010101,0x80000000,0x80010101,0x80000000,0x80040404,0x80000000,
+0x80000000,0x80000000,0x80111111,0x80151515,0x80191919,0x801c1c1c,
+0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801d1d1d,0x80181818,
+0x80171717,0x80181818,0x80171717,0x800a0a0a,0x80000000,0x80020202,
+0x800f0f0f,0x80060606,0x80000000,0x80010101,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x800a0a0a,0x801b1b1b,0x801f1f1f,
+0x801f1f1f,0x80202020,0x801e1e1e,0x801e1e1e,0x80191919,0x801a1a1a,
+0x80181818,0x80161616,0x80191919,0x80191919,0x800d0d0d,0x80000000,
+0x800b0b0b,0x80020202,0x80000000,0x80020202,0x80000000,0x80000000,
+0x80090909,0x80090909,0x80000000,0x80000000,0x800a0a0a,0x801b1b1b,
+0x801e1e1e,0x801e1e1e,0x801c1c1c,0x80171717,0x80171717,0x80191919,
+0x80191919,0x80191919,0x801a1a1a,0x801f1f1f,0x80202020,0x801f1f1f,
+0x80222222,0x801d1d1d,0x800b0b0b,0x80000000,0x800a0a0a,0x80181818,
+0x80141414,0x80080808,0x80000000,0x80000000,0x800c0c0c,0x801e1e1e,
+0x801f1f1f,0x80181818,0x80181818,0x801b1b1b,0x80181818,0x80181818,
+0x801a1a1a,0x801e1e1e,0x801f1f1f,0x801d1d1d,0x801d1d1d,0x801f1f1f,
+0x80191919,0x80030303,0x80010101,0x80191919,0x80171717,0x80000000,
+0x80000000,0x80010101,0x80020202,0x800b0b0b,0x800d0d0d,0x80000000,
+0x80000000,0x80101010,0x80191919,0x80181818,0x80181818,0x801c1c1c,
+0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801d1d1d,0x801b1b1b,
+0x801a1a1a,0x801a1a1a,0x80191919,0x800a0a0a,0x80000000,0x80020202,
+0x80020202,0x80030303,0x80070707,0x800e0e0e,0x800d0d0d,0x80020202,
+0x80000000,0x800d0d0d,0x80181818,0x80171717,0x801d1d1d,0x801f1f1f,
+0x80202020,0x801f1f1f,0x801d1d1d,0x801c1c1c,0x801a1a1a,0x80181818,
+0x80181818,0x80191919,0x80191919,0x801d1d1d,0x801c1c1c,0x80101010,
+0x80101010,0x80212121,0x801e1e1e,0x80181818,0x801a1a1a,0x80151515,
+0x80070707,0x80000000,0x80010101,0x80131313,0x800e0e0e,0x80050505,0x80070707,0x80040404,0x80020202,0x80030303,
+0x80060606,0x80050505,0x80030303,0x80070707,0x80070707,0x80050505,
+0x80050505,0x80181818,0x80181818,0x80181818,0x80191919,0x801b1b1b,
+0x801d1d1d,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x80202020,0x801d1d1d,
+0x80191919,0x80121212,0x80080808,0x80060606,0x80090909,0x80090909,
+0x800a0a0a,0x80090909,0x800d0d0d,0x800a0a0a,0x80090909,0x80080808,
+0x800b0b0b,0x80070707,0x80131313,0x80171717,0x801b1b1b,0x801d1d1d,
+0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801a1a1a,0x801a1a1a,
+0x80191919,0x80181818,0x80171717,0x800e0e0e,0x80020202,0x80040404,
+0x80151515,0x800a0a0a,0x80060606,0x80060606,0x80060606,0x80050505,
+0x80050505,0x80050505,0x80050505,0x80101010,0x801d1d1d,0x80202020,
+0x801f1f1f,0x801e1e1e,0x801b1b1b,0x801b1b1b,0x80161616,0x801a1a1a,
+0x80191919,0x80161616,0x801a1a1a,0x801f1f1f,0x801a1a1a,0x800e0e0e,
+0x80161616,0x80030303,0x80060606,0x800f0f0f,0x80090909,0x800a0a0a,
+0x80151515,0x80181818,0x80131313,0x80030303,0x800f0f0f,0x801e1e1e,
+0x801e1e1e,0x801c1c1c,0x80181818,0x80171717,0x80181818,0x80171717,
+0x80191919,0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801f1f1f,0x80202020,
+0x801b1b1b,0x80171717,0x800c0c0c,0x80050505,0x800c0c0c,0x801a1a1a,
+0x801a1a1a,0x80101010,0x80020202,0x800b0b0b,0x80181818,0x801e1e1e,
+0x801a1a1a,0x80171717,0x80171717,0x80181818,0x80171717,0x801b1b1b,
+0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801b1b1b,
+0x80121212,0x80060606,0x80040404,0x80171717,0x80161616,0x80080808,
+0x800b0b0b,0x800e0e0e,0x80161616,0x801d1d1d,0x801a1a1a,0x800c0c0c,
+0x800a0a0a,0x80161616,0x801a1a1a,0x80171717,0x801c1c1c,0x801d1d1d,
+0x801f1f1f,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801b1b1b,0x80171717,
+0x80171717,0x80151515,0x80191919,0x80161616,0x80121212,0x80151515,
+0x80191919,0x801d1d1d,0x801d1d1d,0x801c1c1c,0x80171717,0x80101010,
+0x800c0c0c,0x80111111,0x801a1a1a,0x801d1d1d,0x801e1e1e,0x801f1f1f,
+0x801f1f1f,0x801e1e1e,0x801c1c1c,0x801a1a1a,0x80191919,0x80181818,
+0x80191919,0x80191919,0x801c1c1c,0x80202020,0x801f1f1f,0x801f1f1f,
+0x801e1e1e,0x801b1b1b,0x801c1c1c,0x80151515,0x80191919,0x80181818,
+0x800b0b0b,0x80030303,0x80090909,0x801a1a1a,0x80181818,0x80171717,0x80181818,0x80171717,0x80191919,0x801b1b1b,
+0x801e1e1e,0x801e1e1e,0x801d1d1d,0x801f1f1f,0x801c1c1c,0x80191919,
+0x80151515,0x801a1a1a,0x80181818,0x80191919,0x801b1b1b,0x801d1d1d,
+0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801c1c1c,0x80191919,
+0x80191919,0x80191919,0x80171717,0x80191919,0x801e1e1e,0x80202020,
+0x801f1f1f,0x801f1f1f,0x80212121,0x801c1c1c,0x80191919,0x80181818,
+0x80191919,0x80171717,0x80181818,0x801a1a1a,0x801d1d1d,0x801e1e1e,
+0x801e1e1e,0x801e1e1e,0x801d1d1d,0x801c1c1c,0x80171717,0x80171717,
+0x80171717,0x80161616,0x801a1a1a,0x801b1b1b,0x80171717,0x801a1a1a,
+0x80232323,0x801c1c1c,0x801a1a1a,0x80191919,0x80181818,0x80171717,
+0x80171717,0x801a1a1a,0x801e1e1e,0x801c1c1c,0x801e1e1e,0x801e1e1e,
+0x801f1f1f,0x801e1e1e,0x80191919,0x80171717,0x80191919,0x80171717,
+0x80171717,0x801c1c1c,0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801f1f1f,
+0x80212121,0x80111111,0x80151515,0x801b1b1b,0x80151515,0x80161616,
+0x801b1b1b,0x801e1e1e,0x80202020,0x80181818,0x801f1f1f,0x80212121,
+0x801b1b1b,0x80171717,0x80161616,0x80191919,0x80191919,0x80181818,
+0x801a1a1a,0x801f1f1f,0x80212121,0x801f1f1f,0x801d1d1d,0x801e1e1e,
+0x801b1b1b,0x80181818,0x80151515,0x80131313,0x80151515,0x801d1d1d,
+0x80202020,0x801c1c1c,0x80191919,0x801d1d1d,0x801d1d1d,0x80191919,
+0x80171717,0x80181818,0x80181818,0x80161616,0x801b1b1b,0x801e1e1e,
+0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801b1b1b,0x80171717,
+0x80191919,0x80141414,0x80141414,0x801b1b1b,0x801e1e1e,0x801d1d1d,
+0x80202020,0x80212121,0x801f1f1f,0x801d1d1d,0x801b1b1b,0x80161616,
+0x80151515,0x80181818,0x80191919,0x801a1a1a,0x80202020,0x801e1e1e,
+0x801e1e1e,0x801f1f1f,0x801d1d1d,0x801a1a1a,0x80181818,0x80171717,
+0x80191919,0x80171717,0x801c1c1c,0x801f1f1f,0x801d1d1d,0x801d1d1d,
+0x801e1e1e,0x80202020,0x801d1d1d,0x80181818,0x80171717,0x80171717,
+0x80171717,0x80191919,0x801e1e1e,0x80212121,0x801f1f1f,0x801f1f1f,
+0x801d1d1d,0x801c1c1c,0x80191919,0x80181818,0x80181818,0x80191919,
+0x80191919,0x801c1c1c,0x801f1f1f,0x801e1e1e,0x801c1c1c,0x801f1f1f,
+0x801f1f1f,0x80191919,0x80161616,0x80181818,0x801a1a1a,0x80171717,
+0x80171717,0x801b1b1b,0x801e1e1e,0x80212121,0x80181818,0x80191919,0x80171717,0x80171717,0x801b1b1b,0x801e1e1e,
+0x801e1e1e,0x801f1f1f,0x80202020,0x801e1e1e,0x801b1b1b,0x801b1b1b,
+0x80191919,0x80171717,0x80191919,0x801a1a1a,0x801c1c1c,0x801e1e1e,
+0x801f1f1f,0x80202020,0x801e1e1e,0x801c1c1c,0x80181818,0x80181818,
+0x80181818,0x80161616,0x80171717,0x801b1b1b,0x801e1e1e,0x801e1e1e,
+0x80202020,0x80202020,0x801d1d1d,0x80191919,0x80191919,0x80181818,
+0x80171717,0x80181818,0x801b1b1b,0x801d1d1d,0x801f1f1f,0x80202020,
+0x801f1f1f,0x801c1c1c,0x801a1a1a,0x80181818,0x801c1c1c,0x80181818,
+0x80181818,0x80191919,0x801d1d1d,0x801e1e1e,0x801d1d1d,0x80212121,
+0x801e1e1e,0x801a1a1a,0x80191919,0x80181818,0x80181818,0x80181818,
+0x80181818,0x801b1b1b,0x80212121,0x801f1f1f,0x801f1f1f,0x801e1e1e,
+0x801c1c1c,0x801b1b1b,0x80171717,0x80181818,0x80191919,0x80191919,
+0x801b1b1b,0x801e1e1e,0x801e1e1e,0x801d1d1d,0x801d1d1d,0x801e1e1e,
+0x801b1b1b,0x80171717,0x80191919,0x80181818,0x80171717,0x801b1b1b,
+0x801d1d1d,0x801e1e1e,0x801d1d1d,0x80202020,0x80202020,0x801a1a1a,
+0x80171717,0x80191919,0x80181818,0x80181818,0x80191919,0x801c1c1c,
+0x801f1f1f,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801d1d1d,0x80191919,
+0x80181818,0x80161616,0x80171717,0x80191919,0x801a1a1a,0x801d1d1d,
+0x80202020,0x801f1f1f,0x80212121,0x801e1e1e,0x801a1a1a,0x80171717,
+0x80171717,0x80181818,0x80191919,0x801b1b1b,0x801f1f1f,0x801d1d1d,
+0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801a1a1a,0x80181818,0x80181818,
+0x80191919,0x80171717,0x80191919,0x801c1c1c,0x801e1e1e,0x801f1f1f,
+0x801d1d1d,0x801e1e1e,0x801c1c1c,0x80171717,0x80181818,0x801a1a1a,
+0x80181818,0x80171717,0x80191919,0x80212121,0x80202020,0x801f1f1f,
+0x801e1e1e,0x801e1e1e,0x801a1a1a,0x80171717,0x80171717,0x80191919,
+0x80181818,0x801a1a1a,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x80202020,
+0x801e1e1e,0x801a1a1a,0x80171717,0x80171717,0x80181818,0x80191919,
+0x80191919,0x801c1c1c,0x801e1e1e,0x801d1d1d,0x80202020,0x801e1e1e,
+0x801c1c1c,0x801a1a1a,0x80181818,0x80171717,0x80181818,0x801a1a1a,
+0x801c1c1c,0x80202020,0x801f1f1f,0x801d1d1d,0x801f1f1f,0x801c1c1c,
+0x80181818,0x80191919,0x80181818,0x80191919,0x80181818,0x80181818,
+0x801d1d1d,0x80212121,0x801f1f1f,0x801e1e1e,0x80181818,0x80171717,0x80181818,0x801a1a1a,0x801d1d1d,0x80202020,
+0x801f1f1f,0x801f1f1f,0x801d1d1d,0x80191919,0x80161616,0x80161616,
+0x80181818,0x80171717,0x801a1a1a,0x801c1c1c,0x801e1e1e,0x801f1f1f,
+0x801f1f1f,0x801e1e1e,0x801c1c1c,0x80191919,0x80181818,0x801a1a1a,
+0x801a1a1a,0x80191919,0x801c1c1c,0x80202020,0x80212121,0x80202020,
+0x801f1f1f,0x801b1b1b,0x80181818,0x80181818,0x80181818,0x80181818,
+0x80181818,0x801b1b1b,0x801d1d1d,0x801e1e1e,0x801f1f1f,0x801f1f1f,
+0x801d1d1d,0x801a1a1a,0x80181818,0x80171717,0x80181818,0x80161616,
+0x801a1a1a,0x801d1d1d,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801f1f1f,
+0x801b1b1b,0x801b1b1b,0x80181818,0x80181818,0x80191919,0x801a1a1a,
+0x801d1d1d,0x801d1d1d,0x801b1b1b,0x801d1d1d,0x80202020,0x801d1d1d,
+0x80191919,0x80181818,0x80171717,0x80191919,0x80161616,0x801c1c1c,
+0x801f1f1f,0x801d1d1d,0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801a1a1a,
+0x80171717,0x80191919,0x801a1a1a,0x80171717,0x801a1a1a,0x801e1e1e,
+0x801e1e1e,0x801e1e1e,0x801e1e1e,0x80202020,0x801b1b1b,0x80171717,
+0x80181818,0x801a1a1a,0x801a1a1a,0x80171717,0x801c1c1c,0x801f1f1f,
+0x80202020,0x801f1f1f,0x801d1d1d,0x801d1d1d,0x801b1b1b,0x80171717,
+0x80191919,0x80181818,0x80191919,0x801c1c1c,0x801d1d1d,0x801d1d1d,
+0x801d1d1d,0x801d1d1d,0x801c1c1c,0x80191919,0x80181818,0x80181818,
+0x80171717,0x80161616,0x801a1a1a,0x801e1e1e,0x801f1f1f,0x801e1e1e,
+0x801d1d1d,0x801e1e1e,0x801b1b1b,0x80181818,0x80171717,0x80191919,
+0x80171717,0x801a1a1a,0x801c1c1c,0x801f1f1f,0x80212121,0x80202020,
+0x801e1e1e,0x801d1d1d,0x80191919,0x80171717,0x80191919,0x80191919,
+0x80191919,0x801b1b1b,0x801d1d1d,0x80222222,0x801f1f1f,0x801e1e1e,
+0x801d1d1d,0x801b1b1b,0x80181818,0x80171717,0x80181818,0x801a1a1a,
+0x801a1a1a,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801f1f1f,0x801f1f1f,
+0x801c1c1c,0x80181818,0x80181818,0x80181818,0x80191919,0x801a1a1a,
+0x801b1b1b,0x801e1e1e,0x80202020,0x801e1e1e,0x801e1e1e,0x801c1c1c,
+0x801a1a1a,0x80191919,0x80181818,0x80181818,0x801a1a1a,0x801c1c1c,
+0x801f1f1f,0x801f1f1f,0x801d1d1d,0x801e1e1e,0x80202020,0x801a1a1a,
+0x80161616,0x80191919,0x801a1a1a,0x80171717,0x80181818,0x801e1e1e,
+0x80202020,0x801e1e1e,0x801c1c1c,0x801d1d1d,0x80181818,0x80161616,0x801b1b1b,0x801e1e1e,0x801e1e1e,0x801f1f1f,
+0x801d1d1d,0x801e1e1e,0x801b1b1b,0x80181818,0x80191919,0x80181818,
+0x80191919,0x801a1a1a,0x801d1d1d,0x801e1e1e,0x801f1f1f,0x801f1f1f,
+0x801e1e1e,0x801c1c1c,0x80191919,0x80161616,0x80181818,0x80181818,
+0x80181818,0x801c1c1c,0x80202020,0x801f1f1f,0x801d1d1d,0x80202020,
+0x801f1f1f,0x801a1a1a,0x80181818,0x801a1a1a,0x80171717,0x80171717,
+0x801a1a1a,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801d1d1d,
+0x801b1b1b,0x80191919,0x80181818,0x80181818,0x80181818,0x80191919,
+0x801f1f1f,0x801f1f1f,0x801c1c1c,0x80202020,0x801f1f1f,0x801b1b1b,
+0x80181818,0x801a1a1a,0x80171717,0x80171717,0x80191919,0x801a1a1a,
+0x801f1f1f,0x801f1f1f,0x80202020,0x801f1f1f,0x801e1e1e,0x80191919,
+0x80181818,0x801b1b1b,0x80191919,0x80171717,0x801c1c1c,0x801d1d1d,
+0x801f1f1f,0x80202020,0x801f1f1f,0x801d1d1d,0x801a1a1a,0x80181818,
+0x80181818,0x80181818,0x80161616,0x80191919,0x801f1f1f,0x80202020,
+0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801b1b1b,0x80161616,0x801a1a1a,
+0x80191919,0x80141414,0x80191919,0x801c1c1c,0x80202020,0x801e1e1e,
+0x801f1f1f,0x80202020,0x801e1e1e,0x80191919,0x80171717,0x80181818,
+0x80181818,0x80181818,0x801b1b1b,0x801d1d1d,0x801f1f1f,0x801f1f1f,
+0x801f1f1f,0x801e1e1e,0x80191919,0x80181818,0x80181818,0x80181818,
+0x80181818,0x801b1b1b,0x801e1e1e,0x801f1f1f,0x801d1d1d,0x801f1f1f,
+0x801f1f1f,0x801b1b1b,0x80171717,0x80181818,0x80191919,0x80181818,
+0x80181818,0x801f1f1f,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801d1d1d,
+0x801d1d1d,0x80191919,0x80181818,0x80181818,0x80181818,0x80151515,
+0x80191919,0x80212121,0x80202020,0x801d1d1d,0x801f1f1f,0x801e1e1e,
+0x801b1b1b,0x80171717,0x80171717,0x80191919,0x801a1a1a,0x80181818,
+0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801a1a1a,
+0x80171717,0x80181818,0x801a1a1a,0x80171717,0x80181818,0x801c1c1c,
+0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801c1c1c,0x801a1a1a,
+0x80181818,0x80181818,0x80191919,0x801a1a1a,0x801c1c1c,0x801f1f1f,
+0x801f1f1f,0x801c1c1c,0x801f1f1f,0x801e1e1e,0x80171717,0x80161616,
+0x80191919,0x80191919,0x80171717,0x80191919,0x801e1e1e,0x80212121,
+0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801b1b1b,0x80171717,0x801a1a1a,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801f1f1f,
+0x801e1e1e,0x801b1b1b,0x80181818,0x80181818,0x80181818,0x80191919,
+0x801a1a1a,0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801f1f1f,
+0x801c1c1c,0x80181818,0x80181818,0x801a1a1a,0x80161616,0x801a1a1a,
+0x801d1d1d,0x801e1e1e,0x801f1f1f,0x80202020,0x801e1e1e,0x801d1d1d,
+0x80181818,0x801a1a1a,0x80191919,0x80171717,0x80171717,0x801b1b1b,
+0x801e1e1e,0x801f1f1f,0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801a1a1a,
+0x80171717,0x80181818,0x80181818,0x80171717,0x801b1b1b,0x801e1e1e,
+0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801b1b1b,0x80171717,
+0x80181818,0x80191919,0x80191919,0x80191919,0x801b1b1b,0x801f1f1f,
+0x80202020,0x801d1d1d,0x80202020,0x801b1b1b,0x80181818,0x80191919,
+0x80191919,0x80181818,0x80181818,0x801b1b1b,0x80202020,0x801e1e1e,
+0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801b1b1b,0x80181818,0x80171717,
+0x80171717,0x80171717,0x801a1a1a,0x801e1e1e,0x801f1f1f,0x801e1e1e,
+0x801e1e1e,0x80202020,0x801a1a1a,0x80181818,0x80171717,0x80181818,
+0x80191919,0x80191919,0x801c1c1c,0x80202020,0x801e1e1e,0x80202020,
+0x80202020,0x801c1c1c,0x80181818,0x80181818,0x80181818,0x80181818,
+0x80171717,0x801c1c1c,0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801e1e1e,
+0x801d1d1d,0x801a1a1a,0x80181818,0x80191919,0x80181818,0x80171717,
+0x801b1b1b,0x801f1f1f,0x801f1f1f,0x801d1d1d,0x801f1f1f,0x801f1f1f,
+0x801c1c1c,0x80181818,0x80171717,0x80181818,0x80191919,0x80191919,
+0x80202020,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801c1c1c,
+0x80191919,0x80191919,0x80191919,0x80171717,0x80181818,0x801c1c1c,
+0x80202020,0x80202020,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801a1a1a,
+0x80171717,0x80191919,0x80191919,0x80171717,0x801a1a1a,0x801f1f1f,
+0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801b1b1b,0x80171717,
+0x80171717,0x80191919,0x80171717,0x801a1a1a,0x801d1d1d,0x801e1e1e,
+0x801f1f1f,0x80202020,0x801e1e1e,0x801c1c1c,0x80181818,0x80191919,
+0x80191919,0x80181818,0x80191919,0x801c1c1c,0x801f1f1f,0x801f1f1f,
+0x801e1e1e,0x801f1f1f,0x801c1c1c,0x80181818,0x80171717,0x80191919,
+0x80181818,0x80161616,0x801c1c1c,0x801e1e1e,0x801e1e1e,0x801e1e1e,
+0x801f1f1f,0x801f1f1f,0x801b1b1b,0x80161616,0x801b1b1b,0x801c1c1c,0x801d1d1d,0x801e1e1e,0x801e1e1e,0x801e1e1e,
+0x801b1b1b,0x80191919,0x80171717,0x80181818,0x80191919,0x801a1a1a,
+0x801c1c1c,0x801e1e1e,0x801e1e1e,0x80202020,0x801f1f1f,0x801b1b1b,
+0x80191919,0x80191919,0x80191919,0x80181818,0x801a1a1a,0x801c1c1c,
+0x801f1f1f,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801c1c1c,0x801a1a1a,
+0x801a1a1a,0x80181818,0x80171717,0x80181818,0x801b1b1b,0x801d1d1d,
+0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801c1c1c,0x801b1b1b,0x801a1a1a,
+0x80191919,0x80161616,0x80171717,0x801b1b1b,0x801e1e1e,0x801d1d1d,
+0x801e1e1e,0x80202020,0x801f1f1f,0x801a1a1a,0x80181818,0x80191919,
+0x80191919,0x80171717,0x80181818,0x801c1c1c,0x801f1f1f,0x801e1e1e,
+0x801e1e1e,0x801f1f1f,0x801b1b1b,0x801a1a1a,0x80191919,0x80181818,
+0x80181818,0x80181818,0x801b1b1b,0x801e1e1e,0x801e1e1e,0x801f1f1f,
+0x80202020,0x801e1e1e,0x801b1b1b,0x80191919,0x80181818,0x80181818,
+0x80171717,0x801b1b1b,0x801d1d1d,0x801d1d1d,0x801e1e1e,0x80202020,
+0x801e1e1e,0x801b1b1b,0x80181818,0x80191919,0x80191919,0x80171717,
+0x80181818,0x801c1c1c,0x801f1f1f,0x801e1e1e,0x80202020,0x801e1e1e,
+0x801c1c1c,0x801a1a1a,0x80191919,0x80181818,0x80181818,0x80191919,
+0x801c1c1c,0x801d1d1d,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801d1d1d,
+0x801b1b1b,0x80181818,0x80191919,0x80171717,0x80181818,0x801b1b1b,
+0x801e1e1e,0x801d1d1d,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801a1a1a,
+0x80181818,0x80191919,0x80191919,0x80181818,0x80191919,0x801e1e1e,
+0x801e1e1e,0x80202020,0x80202020,0x801e1e1e,0x801c1c1c,0x801a1a1a,
+0x80191919,0x80181818,0x80171717,0x80191919,0x801c1c1c,0x801d1d1d,
+0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801a1a1a,0x801a1a1a,
+0x80181818,0x80171717,0x80181818,0x801b1b1b,0x801e1e1e,0x801e1e1e,
+0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801a1a1a,0x80181818,0x80191919,
+0x80191919,0x80181818,0x801a1a1a,0x801d1d1d,0x801f1f1f,0x801f1f1f,
+0x801f1f1f,0x801e1e1e,0x801c1c1c,0x801a1a1a,0x80191919,0x80181818,
+0x80171717,0x80191919,0x801c1c1c,0x801e1e1e,0x801f1f1f,0x801e1e1e,
+0x801f1f1f,0x801b1b1b,0x80191919,0x80191919,0x80181818,0x80161616,
+0x80181818,0x801b1b1b,0x801e1e1e,0x801d1d1d,0x801d1d1d,0x80202020,
+0x801f1f1f,0x801a1a1a,0x80181818,0x80191919,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801d1d1d,0x801b1b1b,
+0x80181818,0x80171717,0x80171717,0x80191919,0x801b1b1b,0x801c1c1c,
+0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801f1f1f,0x801d1d1d,0x80191919,
+0x80171717,0x80181818,0x80191919,0x80181818,0x801d1d1d,0x801f1f1f,
+0x80202020,0x801f1f1f,0x801e1e1e,0x801c1c1c,0x801a1a1a,0x80181818,
+0x80191919,0x80171717,0x80171717,0x801b1b1b,0x801e1e1e,0x801e1e1e,
+0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801b1b1b,0x80181818,0x80181818,
+0x80181818,0x80171717,0x80191919,0x801d1d1d,0x801e1e1e,0x801e1e1e,
+0x801f1f1f,0x80202020,0x801c1c1c,0x80181818,0x80171717,0x801a1a1a,
+0x80191919,0x80181818,0x801a1a1a,0x801f1f1f,0x80202020,0x801f1f1f,
+0x801d1d1d,0x801e1e1e,0x80181818,0x80191919,0x80181818,0x80171717,
+0x80181818,0x801b1b1b,0x801e1e1e,0x801f1f1f,0x801d1d1d,0x80202020,
+0x801f1f1f,0x801b1b1b,0x80181818,0x80181818,0x80181818,0x80181818,
+0x801a1a1a,0x801d1d1d,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801f1f1f,
+0x801c1c1c,0x80171717,0x80171717,0x80191919,0x80191919,0x80191919,
+0x801a1a1a,0x801f1f1f,0x80202020,0x801f1f1f,0x80202020,0x801c1c1c,
+0x80181818,0x80181818,0x80181818,0x80181818,0x80191919,0x801c1c1c,
+0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801a1a1a,
+0x80181818,0x80171717,0x80181818,0x80181818,0x801a1a1a,0x801e1e1e,
+0x801f1f1f,0x801d1d1d,0x801d1d1d,0x801f1f1f,0x801c1c1c,0x80181818,
+0x80161616,0x80181818,0x801a1a1a,0x80191919,0x801c1c1c,0x80202020,
+0x801e1e1e,0x80202020,0x80202020,0x801c1c1c,0x80181818,0x80181818,
+0x80181818,0x80171717,0x80181818,0x801c1c1c,0x801f1f1f,0x801f1f1f,
+0x801e1e1e,0x801e1e1e,0x801d1d1d,0x801b1b1b,0x80171717,0x80181818,
+0x80181818,0x80171717,0x801a1a1a,0x801e1e1e,0x801f1f1f,0x801f1f1f,
+0x801e1e1e,0x801f1f1f,0x801d1d1d,0x80181818,0x80161616,0x80181818,
+0x80191919,0x80191919,0x801d1d1d,0x801f1f1f,0x80202020,0x801f1f1f,
+0x801d1d1d,0x801c1c1c,0x801a1a1a,0x80181818,0x80191919,0x80171717,
+0x80181818,0x801d1d1d,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801e1e1e,
+0x801c1c1c,0x80191919,0x80181818,0x80181818,0x80171717,0x80171717,
+0x801a1a1a,0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801e1e1e,0x801e1e1e,
+0x801c1c1c,0x80171717,0x80171717,0x80191919,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801b1b1b,0x80171717,
+0x80181818,0x80181818,0x80191919,0x801b1b1b,0x801d1d1d,0x801e1e1e,
+0x801f1f1f,0x801f1f1f,0x801f1f1f,0x801b1b1b,0x80191919,0x80191919,
+0x80181818,0x80171717,0x80191919,0x801c1c1c,0x801e1e1e,0x801f1f1f,
+0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801b1b1b,0x80191919,0x80181818,
+0x80171717,0x80181818,0x801b1b1b,0x801e1e1e,0x801f1f1f,0x801e1e1e,
+0x801d1d1d,0x801e1e1e,0x801a1a1a,0x801a1a1a,0x80181818,0x80161616,
+0x80171717,0x801b1b1b,0x801e1e1e,0x801d1d1d,0x801e1e1e,0x80202020,
+0x80202020,0x801b1b1b,0x80181818,0x80181818,0x80191919,0x80181818,
+0x80191919,0x801c1c1c,0x801f1f1f,0x801f1f1f,0x801f1f1f,0x80202020,
+0x801d1d1d,0x801a1a1a,0x80191919,0x80181818,0x80171717,0x80181818,
+0x801b1b1b,0x801f1f1f,0x801f1f1f,0x801d1d1d,0x801f1f1f,0x801e1e1e,
+0x801b1b1b,0x80181818,0x80171717,0x80181818,0x80191919,0x80191919,
+0x801e1e1e,0x801d1d1d,0x801e1e1e,0x80202020,0x801f1f1f,0x801b1b1b,
+0x80181818,0x80181818,0x80181818,0x80171717,0x80191919,0x801d1d1d,
+0x801f1f1f,0x801e1e1e,0x801f1f1f,0x80202020,0x801c1c1c,0x801a1a1a,
+0x80181818,0x80171717,0x80171717,0x80181818,0x801b1b1b,0x801f1f1f,
+0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801d1d1d,0x801a1a1a,0x80171717,
+0x80171717,0x80191919,0x80171717,0x801b1b1b,0x801e1e1e,0x801e1e1e,
+0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801b1b1b,0x80181818,0x80191919,
+0x80181818,0x80171717,0x80191919,0x801d1d1d,0x801f1f1f,0x801e1e1e,
+0x801f1f1f,0x801e1e1e,0x801c1c1c,0x80191919,0x80171717,0x80181818,
+0x80191919,0x80181818,0x801c1c1c,0x801d1d1d,0x801f1f1f,0x801f1f1f,
+0x801f1f1f,0x801e1e1e,0x801b1b1b,0x80171717,0x80191919,0x80171717,
+0x80171717,0x801c1c1c,0x801e1e1e,0x801d1d1d,0x801e1e1e,0x801f1f1f,
+0x801e1e1e,0x801a1a1a,0x80181818,0x80181818,0x80181818,0x80171717,
+0x80191919,0x801d1d1d,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801e1e1e,
+0x801c1c1c,0x801a1a1a,0x80191919,0x80181818,0x80181818,0x80191919,
+0x801d1d1d,0x80202020,0x80202020,0x801e1e1e,0x801d1d1d,0x801e1e1e,
+0x80181818,0x80191919,0x80181818,0x80161616,0x80171717,0x801b1b1b,
+0x801f1f1f,0x801f1f1f,0x801e1e1e,0x80202020,0x801e1e1e,0x801a1a1a,
+0x80171717,0x80181818,0x80191919,0x80181818,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801b1b1b,0x80181818,0x80171717,
+0x80181818,0x80191919,0x801b1b1b,0x801d1d1d,0x801e1e1e,0x801f1f1f,
+0x801f1f1f,0x801e1e1e,0x801c1c1c,0x80191919,0x80171717,0x80181818,
+0x80191919,0x80191919,0x801b1b1b,0x801f1f1f,0x801f1f1f,0x801f1f1f,
+0x801e1e1e,0x801d1d1d,0x801b1b1b,0x80191919,0x80171717,0x80171717,
+0x80171717,0x801b1b1b,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801e1e1e,
+0x801c1c1c,0x801a1a1a,0x80171717,0x80191919,0x80181818,0x80171717,
+0x80191919,0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801f1f1f,
+0x801c1c1c,0x80181818,0x80171717,0x80181818,0x80191919,0x80181818,
+0x801b1b1b,0x801f1f1f,0x80202020,0x801f1f1f,0x801e1e1e,0x801e1e1e,
+0x801b1b1b,0x80171717,0x80191919,0x80181818,0x80181818,0x801b1b1b,
+0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801e1e1e,0x801b1b1b,
+0x80181818,0x80171717,0x80171717,0x80181818,0x801a1a1a,0x801c1c1c,
+0x801f1f1f,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801c1c1c,0x80181818,
+0x80171717,0x80191919,0x80191919,0x80181818,0x801a1a1a,0x801f1f1f,
+0x80212121,0x801f1f1f,0x801d1d1d,0x801e1e1e,0x80181818,0x80191919,
+0x80181818,0x80171717,0x80181818,0x801b1b1b,0x801e1e1e,0x801f1f1f,
+0x801d1d1d,0x801e1e1e,0x801e1e1e,0x801a1a1a,0x80171717,0x80161616,
+0x80181818,0x80191919,0x801b1b1b,0x801e1e1e,0x801f1f1f,0x801e1e1e,
+0x801e1e1e,0x801e1e1e,0x801b1b1b,0x80171717,0x80171717,0x80191919,
+0x801a1a1a,0x80191919,0x801c1c1c,0x80202020,0x80202020,0x801d1d1d,
+0x801f1f1f,0x801c1c1c,0x80181818,0x80171717,0x80181818,0x80181818,
+0x80191919,0x801b1b1b,0x80202020,0x801e1e1e,0x801e1e1e,0x801f1f1f,
+0x801d1d1d,0x801a1a1a,0x80181818,0x80171717,0x80191919,0x80181818,
+0x801a1a1a,0x801e1e1e,0x80202020,0x801f1f1f,0x801d1d1d,0x801e1e1e,
+0x801b1b1b,0x80181818,0x80161616,0x80181818,0x80191919,0x80191919,
+0x801c1c1c,0x801f1f1f,0x801f1f1f,0x801f1f1f,0x801d1d1d,0x801c1c1c,
+0x80191919,0x80181818,0x80181818,0x80191919,0x80191919,0x801c1c1c,
+0x801f1f1f,0x80202020,0x801f1f1f,0x801e1e1e,0x801c1c1c,0x801a1a1a,
+0x80171717,0x80181818,0x80171717,0x80171717,0x801a1a1a,0x801e1e1e,
+0x80202020,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801c1c1c,0x80171717,
+0x80161616,0x80191919,0x801a1a1a,0x80191919,0x801e1e1e,0x801e1e1e,0x801b1b1b,0x80171717,0x80171717,0x80191919,
+0x80191919,0x801a1a1a,0x801c1c1c,0x801e1e1e,0x801f1f1f,0x80202020,
+0x801e1e1e,0x801c1c1c,0x80181818,0x80191919,0x80181818,0x80171717,
+0x80191919,0x801d1d1d,0x801f1f1f,0x801e1e1e,0x80202020,0x801e1e1e,
+0x801c1c1c,0x801b1b1b,0x80191919,0x80171717,0x80171717,0x80181818,
+0x801b1b1b,0x801d1d1d,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801e1e1e,
+0x801b1b1b,0x80171717,0x80181818,0x80161616,0x80171717,0x801b1b1b,
+0x801d1d1d,0x801d1d1d,0x801e1e1e,0x80202020,0x801e1e1e,0x801a1a1a,
+0x80181818,0x80181818,0x80181818,0x80181818,0x80191919,0x801c1c1c,
+0x801f1f1f,0x801e1e1e,0x801f1f1f,0x80202020,0x801e1e1e,0x80191919,
+0x80171717,0x80181818,0x80181818,0x80181818,0x801b1b1b,0x801f1f1f,
+0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801e1e1e,0x801b1b1b,0x80191919,
+0x80181818,0x80181818,0x80181818,0x80181818,0x801c1c1c,0x80202020,
+0x801e1e1e,0x80202020,0x801f1f1f,0x801b1b1b,0x80181818,0x80181818,
+0x80191919,0x80181818,0x80191919,0x801c1c1c,0x801f1f1f,0x801e1e1e,
+0x801f1f1f,0x801f1f1f,0x801d1d1d,0x80191919,0x80181818,0x80181818,
+0x80181818,0x80181818,0x801b1b1b,0x801f1f1f,0x80202020,0x801e1e1e,
+0x801e1e1e,0x801d1d1d,0x801a1a1a,0x80171717,0x80161616,0x80181818,
+0x80191919,0x80191919,0x801f1f1f,0x801d1d1d,0x801d1d1d,0x801f1f1f,
+0x801e1e1e,0x801a1a1a,0x80181818,0x80181818,0x80181818,0x80181818,
+0x80191919,0x801d1d1d,0x80202020,0x801f1f1f,0x801e1e1e,0x801f1f1f,
+0x801c1c1c,0x801a1a1a,0x80181818,0x80181818,0x80181818,0x80181818,
+0x801b1b1b,0x801f1f1f,0x80202020,0x801f1f1f,0x801e1e1e,0x801e1e1e,
+0x801a1a1a,0x80171717,0x80171717,0x80191919,0x80171717,0x801b1b1b,
+0x801e1e1e,0x801d1d1d,0x801f1f1f,0x80212121,0x801f1f1f,0x801a1a1a,
+0x80171717,0x80191919,0x80181818,0x80171717,0x80191919,0x801e1e1e,
+0x80202020,0x801e1e1e,0x80202020,0x801e1e1e,0x801c1c1c,0x801a1a1a,
+0x80181818,0x80171717,0x80181818,0x801a1a1a,0x801c1c1c,0x801e1e1e,
+0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801d1d1d,0x801b1b1b,0x80171717,
+0x80191919,0x80161616,0x80171717,0x801b1b1b,0x801e1e1e,0x801e1e1e,
+0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801a1a1a,0x80171717,0x80181818,
+0x80191919,0x80191919,0x801a1a1a,0x801d1d1d,0x801d1d1d,0x801b1b1b,0x80181818,0x80171717,0x80181818,0x801a1a1a,
+0x801a1a1a,0x801c1c1c,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801e1e1e,
+0x801c1c1c,0x80191919,0x80181818,0x80191919,0x80191919,0x80191919,
+0x801b1b1b,0x801f1f1f,0x80202020,0x801e1e1e,0x801e1e1e,0x801c1c1c,
+0x801a1a1a,0x80191919,0x80171717,0x80171717,0x80181818,0x801a1a1a,
+0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801d1d1d,0x801c1c1c,0x801b1b1b,
+0x80191919,0x80171717,0x80181818,0x80171717,0x80191919,0x801e1e1e,
+0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801e1e1e,0x801b1b1b,0x80181818,
+0x80171717,0x80191919,0x80191919,0x80191919,0x801b1b1b,0x801e1e1e,
+0x80202020,0x801e1e1e,0x801d1d1d,0x801d1d1d,0x801b1b1b,0x80171717,
+0x80171717,0x80191919,0x80181818,0x801b1b1b,0x801e1e1e,0x801f1f1f,
+0x801e1e1e,0x801d1d1d,0x801c1c1c,0x801b1b1b,0x80181818,0x80181818,
+0x80181818,0x80191919,0x801a1a1a,0x801c1c1c,0x801e1e1e,0x80202020,
+0x801e1e1e,0x801e1e1e,0x801c1c1c,0x80181818,0x80171717,0x80191919,
+0x80191919,0x80181818,0x801c1c1c,0x801f1f1f,0x80202020,0x801f1f1f,
+0x801d1d1d,0x801d1d1d,0x801b1b1b,0x80171717,0x80181818,0x80181818,
+0x80191919,0x801b1b1b,0x801e1e1e,0x80202020,0x801f1f1f,0x801e1e1e,
+0x801d1d1d,0x801b1b1b,0x80181818,0x80171717,0x80181818,0x80191919,
+0x801b1b1b,0x801c1c1c,0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801e1e1e,
+0x801b1b1b,0x80181818,0x80171717,0x80191919,0x80191919,0x80191919,
+0x801c1c1c,0x801f1f1f,0x80202020,0x801e1e1e,0x801d1d1d,0x801d1d1d,
+0x80191919,0x80191919,0x80181818,0x80191919,0x80191919,0x801b1b1b,
+0x801d1d1d,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801b1b1b,
+0x80181818,0x80171717,0x80181818,0x801a1a1a,0x801a1a1a,0x801e1e1e,
+0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801f1f1f,0x801c1c1c,0x80181818,
+0x80171717,0x80191919,0x80191919,0x80191919,0x801c1c1c,0x80202020,
+0x80202020,0x801e1e1e,0x801e1e1e,0x801c1c1c,0x801a1a1a,0x80191919,
+0x80181818,0x80181818,0x801a1a1a,0x801c1c1c,0x801f1f1f,0x801f1f1f,
+0x801e1e1e,0x801d1d1d,0x801c1c1c,0x801b1b1b,0x80181818,0x80161616,
+0x80181818,0x80181818,0x801a1a1a,0x801f1f1f,0x80202020,0x801e1e1e,
+0x801d1d1d,0x801e1e1e,0x801b1b1b,0x80181818,0x80171717,0x80191919,
+0x801a1a1a,0x801a1a1a,0x801c1c1c,0x80202020,0x801b1b1b,0x80171717,0x80171717,0x80191919,0x801a1a1a,0x80181818,
+0x801d1d1d,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801c1c1c,
+0x80191919,0x80161616,0x801a1a1a,0x80181818,0x80181818,0x801c1c1c,
+0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801d1d1d,0x801a1a1a,
+0x80181818,0x80181818,0x80171717,0x80181818,0x801a1a1a,0x801d1d1d,
+0x801f1f1f,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801a1a1a,0x80171717,
+0x80171717,0x801a1a1a,0x80171717,0x801b1b1b,0x801d1d1d,0x801d1d1d,
+0x801e1e1e,0x80202020,0x801e1e1e,0x801c1c1c,0x80171717,0x80191919,
+0x801a1a1a,0x80181818,0x80181818,0x801c1c1c,0x801e1e1e,0x801e1e1e,
+0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801a1a1a,0x80171717,0x80181818,
+0x80191919,0x80181818,0x801b1b1b,0x801e1e1e,0x801f1f1f,0x801d1d1d,
+0x801d1d1d,0x801e1e1e,0x801b1b1b,0x80161616,0x80171717,0x80181818,
+0x80181818,0x80191919,0x801c1c1c,0x80202020,0x80202020,0x801d1d1d,
+0x80202020,0x801b1b1b,0x80171717,0x80181818,0x80191919,0x80181818,
+0x80181818,0x80191919,0x80202020,0x801e1e1e,0x801f1f1f,0x80202020,
+0x801e1e1e,0x80191919,0x80171717,0x80181818,0x80181818,0x80191919,
+0x801c1c1c,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x80202020,
+0x801a1a1a,0x80181818,0x80171717,0x80191919,0x80191919,0x80191919,
+0x801c1c1c,0x80212121,0x801d1d1d,0x801f1f1f,0x801f1f1f,0x801b1b1b,
+0x80171717,0x80181818,0x80191919,0x80181818,0x80191919,0x801e1e1e,
+0x80202020,0x801e1e1e,0x801d1d1d,0x801f1f1f,0x801d1d1d,0x80181818,
+0x80191919,0x80181818,0x80171717,0x80181818,0x801b1b1b,0x801f1f1f,
+0x801f1f1f,0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801b1b1b,0x80171717,
+0x80171717,0x80191919,0x801a1a1a,0x80181818,0x801f1f1f,0x801e1e1e,
+0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801a1a1a,0x80181818,0x80171717,
+0x80191919,0x80181818,0x80191919,0x801d1d1d,0x801f1f1f,0x801e1e1e,
+0x801e1e1e,0x801e1e1e,0x801c1c1c,0x801a1a1a,0x80181818,0x80181818,
+0x80191919,0x801a1a1a,0x801c1c1c,0x801f1f1f,0x801f1f1f,0x801e1e1e,
+0x801e1e1e,0x801e1e1e,0x801a1a1a,0x80171717,0x80161616,0x80181818,
+0x80161616,0x801b1b1b,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801f1f1f,
+0x801e1e1e,0x801c1c1c,0x80161616,0x80191919,0x80191919,0x80181818,
+0x80191919,0x801d1d1d,0x80202020,0x801f1f1f,0x80181818,0x80181818,0x80181818,0x80191919,0x801a1a1a,0x801d1d1d,
+0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801c1c1c,0x80181818,
+0x80181818,0x801a1a1a,0x80161616,0x801a1a1a,0x801d1d1d,0x801e1e1e,
+0x801f1f1f,0x80202020,0x801e1e1e,0x801d1d1d,0x80181818,0x80191919,
+0x80191919,0x80171717,0x80181818,0x801b1b1b,0x801d1d1d,0x801d1d1d,
+0x801e1d1b,0x8021201e,0x801f1e1c,0x801a1917,0x80191816,0x801a1917,
+0x80191816,0x80181715,0x801b191a,0x801f1d1e,0x80211f20,0x80201e1f,
+0x80201e1f,0x80201e1f,0x801e1c1d,0x80191718,0x801a1819,0x80191718,
+0x80191718,0x801a1819,0x801d1b1c,0x801f1d1e,0x80201e1f,0x801f1d1e,
+0x80211f20,0x801d1b1c,0x801a1819,0x801a1819,0x80191718,0x80181617,
+0x80191718,0x801d1b1c,0x801f1d1e,0x80201e1f,0x80201e1f,0x801f1d1e,
+0x801d1b1c,0x801b191a,0x801a1819,0x801a1819,0x80191718,0x80191718,
+0x801b191a,0x801f1d1e,0x80201e1f,0x801f1d1e,0x801f1d1e,0x80201e1f,
+0x801b191a,0x80181617,0x801b191a,0x80161415,0x80191718,0x80181617,
+0x801d1c1a,0x80201f1d,0x801e1e1e,0x80202020,0x80202020,0x801c1c1c,
+0x80181818,0x80181818,0x80181818,0x80181818,0x80161616,0x801c1c1c,
+0x80202020,0x801d1d1d,0x80202020,0x801f1f1f,0x801c1c1c,0x801c1c1c,
+0x80191919,0x80191919,0x80181818,0x80181818,0x80191919,0x801e1e1e,
+0x801e1e1e,0x801e1e1e,0x801d1d1d,0x80202020,0x801a1a1a,0x80161616,
+0x80181818,0x80191919,0x80171717,0x80191919,0x801f1d1e,0x80201e1f,
+0x80211f20,0x80201e1f,0x801f1d1e,0x801c1a1b,0x801a1819,0x80191718,
+0x801a1819,0x80171516,0x80191718,0x801e1c1d,0x80211f20,0x801f1d1e,
+0x801f1d1e,0x80201e1f,0x801e1e1e,0x801a1a1a,0x80181818,0x80191919,
+0x80191919,0x80181818,0x801b1b1b,0x80212121,0x801e1e1e,0x801d1d1d,
+0x801e1e1e,0x801f1f1f,0x801c1c1c,0x80181818,0x80171717,0x801a1a1a,
+0x80171717,0x801a1a1a,0x801d1d1d,0x801e1e1e,0x801f1f1f,0x80202020,
+0x801e1e1e,0x801c1c1c,0x80181818,0x80191919,0x80191919,0x80181818,
+0x80191919,0x801c1c1c,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801f1f1f,
+0x801c1c1c,0x80181818,0x80171717,0x80191919,0x80181818,0x80161616,
+0x801c1c1c,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801f1f1f,
+0x801b1b1b,0x80161616,0x80191919,0x80171717,0x80171717,0x801b1b1b,
+0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801f1f1f,0x80171717,0x80181818,0x80191919,0x801a1a1a,0x801c1c1c,0x801e1e1e,
+0x801e1e1e,0x80202020,0x801f1f1f,0x801b1b1b,0x80191919,0x80191919,
+0x80191919,0x80181818,0x801a1a1a,0x801c1c1c,0x801f1f1f,0x801f1f1f,
+0x801f1f1f,0x801e1e1e,0x801c1c1c,0x801a1a1a,0x801a1a1a,0x80171717,
+0x80161616,0x801a1a1a,0x801c1c1c,0x801c1c1c,0x801e1e1e,0x80212121,
+0x801f1e1c,0x801f1e1c,0x801c1b19,0x801a1917,0x80191816,0x80181715,
+0x80191816,0x801b1a18,0x801e1e1e,0x801d1d1d,0x801d1d1d,0x801e1e1e,
+0x801d1d1d,0x801a1a1a,0x80191919,0x80191919,0x80181818,0x80181818,
+0x80191919,0x801c1c1c,0x801e1e1e,0x80202020,0x801f1f1f,0x801e1e1e,
+0x801c1c1c,0x80191919,0x80181818,0x80181818,0x80181818,0x80181818,
+0x801a1a1a,0x801d1d1d,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801c1c1c,
+0x801a1a1a,0x80181818,0x80171717,0x80181818,0x80181818,0x801a1a1a,
+0x801d1d1d,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801c1c1c,
+0x801b191a,0x80171516,0x80181617,0x801a1819,0x801d1b1c,0x801f1d1e,
+0x8022211f,0x801f1e1c,0x80202020,0x801e1e1e,0x801c1c1c,0x801a1a1a,
+0x80191919,0x80181818,0x80181818,0x80191919,0x801c1c1c,0x801e1e1e,
+0x80212121,0x801e1e1e,0x80222222,0x801c1c1c,0x801a1a1a,0x80171717,
+0x80171717,0x80161616,0x80181818,0x801c1c1c,0x801f1f1f,0x801f1f1f,
+0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801b1b1b,0x80181818,0x801a1a1a,
+0x80191919,0x80181818,0x80191919,0x801d1d1d,0x801f1d1e,0x80201e1f,
+0x801f1d1e,0x801e1c1d,0x801c1a1b,0x801a1819,0x80191718,0x80181617,
+0x80191718,0x80191718,0x801c1a1b,0x801e1c1d,0x80201e1f,0x80201e1f,
+0x801e1c1d,0x801d1b1c,0x80191919,0x80191919,0x80181818,0x80171717,
+0x80181818,0x801b1b1b,0x801d1d1d,0x801d1d1d,0x801d1d1d,0x80202020,
+0x801f1f1f,0x801a1a1a,0x80171717,0x80171717,0x80181818,0x80171717,
+0x801a1a1a,0x801d1d1d,0x801f1f1f,0x801f1f1f,0x801f1f1f,0x801e1e1e,
+0x801c1c1c,0x801a1a1a,0x80191919,0x80181818,0x80171717,0x80191919,
+0x801c1c1c,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801f1f1f,0x801b1b1b,
+0x80191919,0x80191919,0x80181818,0x80161616,0x80181818,0x801b1b1b,
+0x801e1e1e,0x801d1d1d,0x801d1d1d,0x80202020,0x801f1f1f,0x801a1a1a,
+0x80181818,0x80191919,0x80171717,0x80191919,0x801b1b1b,0x801d1d1d,
+0x801d1d1d,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x80171717,0x80191919,0x801b1b1b,0x801c1c1c,0x801e1e1e,0x801f1f1f,
+0x801e1e1e,0x801f1f1f,0x801d1d1d,0x80191919,0x80171717,0x80181818,
+0x80191919,0x80181818,0x801d1d1d,0x801f1f1f,0x80202020,0x801f1f1f,
+0x801e1e1e,0x801c1c1c,0x801a1a1a,0x80181818,0x80181818,0x80181818,
+0x80181818,0x80191919,0x801c1c1c,0x80202020,0x801f1f1f,0x801c1c1c,
+0x801f1d1e,0x801c1a1b,0x80191718,0x80191718,0x80191718,0x80181617,
+0x801a1819,0x801f1d1e,0x801f1f1f,0x801f1f1f,0x80202020,0x80202020,
+0x801e1e1e,0x80191919,0x80171717,0x80171717,0x80181818,0x80191919,
+0x801b1b1b,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801c1c1c,
+0x80191919,0x80181818,0x80181818,0x80181818,0x801a1a1a,0x801c1c1c,
+0x801e1e1e,0x80202020,0x80202020,0x801f1f1f,0x801d1d1d,0x801b1b1b,
+0x80191919,0x80181818,0x80181818,0x80191919,0x801b1b1b,0x801e1e1e,
+0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801d1d1d,0x801a1a1a,0x80171717,
+0x801a181b,0x801a181b,0x80191718,0x801b191a,0x801a1819,0x801d1b1c,
+0x801f1d1e,0x801e1c1d,0x80202020,0x801c1c1c,0x80181818,0x80181818,
+0x80181818,0x80181818,0x80191919,0x801c1c1c,0x801f1f1f,0x801d1d1d,
+0x801f1f1f,0x801e1e1e,0x801e1e1e,0x80191919,0x801a1a1a,0x80171717,
+0x80191919,0x80191919,0x801b1b1b,0x801d1d1d,0x801e1e1e,0x801e1e1e,
+0x801f1f1f,0x801f1f1f,0x801c1c1c,0x80161616,0x80171717,0x801a1a1a,
+0x80181818,0x80181818,0x801d1d1d,0x801f1f1f,0x80211f20,0x80201e1f,
+0x801f1d1e,0x801d1b1c,0x801b191a,0x801a1819,0x80191718,0x80191718,
+0x801a1819,0x801e1c1d,0x80201e1f,0x80201e1f,0x80201e1f,0x80211f20,
+0x801f1d1e,0x801b191a,0x80171717,0x80181818,0x80181818,0x80181818,
+0x801a1a1a,0x801e1e1e,0x80202020,0x80202020,0x801e1e1e,0x801e1e1e,
+0x801b1b1b,0x80181818,0x80181818,0x801a1a1a,0x801b1b1b,0x80181818,
+0x801d1d1d,0x801f1f1f,0x80202020,0x801f1f1f,0x801d1d1d,0x801c1c1c,
+0x801a1a1a,0x80181818,0x80191919,0x80171717,0x80181818,0x801d1d1d,
+0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801c1c1c,0x80191919,
+0x80181818,0x80181818,0x80171717,0x80171717,0x801a1a1a,0x801f1f1f,
+0x801e1e1e,0x801d1d1d,0x801e1e1e,0x801e1e1e,0x801c1c1c,0x80171717,
+0x80171717,0x80191919,0x80171717,0x801b1b1b,0x801e1e1e,0x801e1e1e,
+0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801c1c1c,0x80191919,0x801b1b1b,0x801d1d1d,0x801e1e1e,0x801f1f1f,0x801f1f1f,
+0x801f1f1f,0x801b1b1b,0x80191919,0x80191919,0x80181818,0x80171717,
+0x80191919,0x801c1c1c,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801e1e1e,
+0x801d1d1d,0x801b1b1b,0x80191919,0x80181818,0x801a1a1a,0x80181818,
+0x801a1a1a,0x801f1f1f,0x80212121,0x801f1f1f,0x801d1d1d,0x801e1e1e,
+0x801a1a1a,0x80181818,0x80161616,0x80181818,0x801b1b1b,0x801b1b1b,
+0x801c1c1c,0x801f1f1f,0x801c1c1e,0x801f1f21,0x801e1e20,0x801b1b1d,
+0x8019191b,0x801c1c1e,0x801d1d1f,0x801c1c1e,0x801e1e20,0x80202022,
+0x80212123,0x80232325,0x80232325,0x80222224,0x80202022,0x801f1f21,
+0x801a1a1c,0x801c1c1e,0x801c1c1e,0x801c1c1e,0x801d1d1f,0x80202022,
+0x80222224,0x80222224,0x80212123,0x80212123,0x801f1f21,0x801d1d1f,
+0x801b1b1d,0x801b1b1d,0x801c1c1e,0x801d1d1f,0x80222224,0x80232325,
+0x80242426,0x80222224,0x80212123,0x80202022,0x801e1e20,0x801b1b1d,
+0x801c1c1e,0x801d1d1f,0x801d1d1f,0x801f1f1f,0x80202020,0x802b2b2b,
+0x801a1a1a,0x801f1f1f,0x801c1c1c,0x801a1a1a,0x80181818,0x80171717,
+0x80171717,0x80181818,0x801b1b1b,0x801f1f1f,0x801e1e1e,0x801e1e1e,
+0x801b1b1b,0x801f1f1f,0x80171717,0x80181818,0x80181818,0x80161616,
+0x80161616,0x801b1b1b,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801c1c1c,
+0x801d1d1d,0x80191919,0x80151515,0x80181818,0x801a1a1a,0x80151515,
+0x80141414,0x801a1a1a,0x80202020,0x801d1d1d,0x801c1c1c,0x801b1b1b,
+0x801a1a1a,0x80181818,0x80171717,0x80161616,0x80171717,0x80171717,
+0x801a1a1a,0x801e1e1e,0x80202020,0x801e1e1e,0x801d1d1d,0x801d1d1d,
+0x801b1b1b,0x80171717,0x80181818,0x80171717,0x80181818,0x801d1d1d,
+0x801f1f1f,0x801d1d1d,0x801c1c1c,0x801e1e1e,0x801f1f1f,0x801b1b1b,
+0x80181818,0x80191919,0x80191919,0x80181818,0x80191919,0x801c1c1c,
+0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801c1c1c,0x801a1a1a,
+0x80191919,0x80181818,0x80181818,0x80191919,0x801d1d1d,0x80202020,
+0x80202020,0x801e1e1e,0x801d1d1d,0x801e1e1e,0x80181818,0x80191919,
+0x80181818,0x80161616,0x80171717,0x801b1b1b,0x801f1f1f,0x801f1f1f,
+0x801e1e1e,0x80202020,0x801e1e1e,0x801a1a1a,0x80171717,0x80181818,
+0x80191919,0x80181818,0x801b1b1b,0x801d1d1d,0x801e1e1e,0x801f1f1f,
+0x80202020,0x801f1f1f,0x801c1c1c,0x80181818,0x801b1b1b,0x801d1d1d,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801e1e1e,
+0x801c1c1c,0x80191919,0x80171717,0x80181818,0x80191919,0x80191919,
+0x801b1b1b,0x801f1f1f,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801d1d1d,
+0x801b1b1b,0x80191919,0x80171717,0x80171717,0x80141414,0x801c1c1c,
+0x80202020,0x801e1e1e,0x801c1c1c,0x801e1e1e,0x801f1f1f,0x801e1e1e,
+0x80161618,0x801a1a1c,0x8019191b,0x80151517,0x80161618,0x80222224,
+0x80353537,0x80464648,0x80515153,0x805b5b5d,0x80666668,0x806e6e70,
+0x80757577,0x807b7b7d,0x807c7c7e,0x807a7a7c,0x807b7b7d,0x807c7c7e,
+0x807d7d7f,0x807d7d7f,0x807c7c7e,0x807c7c7e,0x807b7b7d,0x807b7b7d,
+0x807a7a7c,0x807c7c7e,0x807c7c7e,0x807b7b7d,0x807b7b7d,0x807d7d7f,
+0x807e7e80,0x807d7d7f,0x807d7d7f,0x807d7d7f,0x807c7c7e,0x807b7b7d,
+0x807b7b7d,0x807b7b7d,0x807c7c7e,0x807c7c7e,0x807c7c7e,0x807c7c7e,
+0x807c7c7e,0x807d7d7f,0x807c7c7e,0x807b7b7d,0x807b7b7d,0x807c7c7e,
+0x807a7a7c,0x807a7a7c,0x807d7d7f,0x807d7d7f,0x807c7c7c,0x80777777,
+0x802b2b2b,0x801e1e1e,0x80181818,0x80191919,0x80181818,0x80171717,
+0x80181818,0x801b1b1b,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801c1c1c,
+0x800b0b0b,0x80131313,0x80040404,0x80171717,0x80181818,0x801a1a1a,
+0x801b1b1b,0x801d1d1d,0x801e1e1e,0x801d1d1d,0x801b1b1b,0x80101010,
+0x80101010,0x800d0d0d,0x800c0c0c,0x80161616,0x80141414,0x80020202,
+0x80010101,0x80030303,0x80040404,0x80000000,0x80030303,0x80030303,
+0x80020202,0x80010101,0x80010101,0x80010101,0x80010101,0x80020202,
+0x80070707,0x80090909,0x800b0b0b,0x800e0e0e,0x800f0f0f,0x80111111,
+0x80131313,0x80141414,0x80191919,0x80181818,0x80191919,0x801d1d1d,
+0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x80191919,0x80181818,
+0x80181818,0x80191919,0x80171717,0x80171717,0x801b1b1b,0x80212121,
+0x801f1f1f,0x801f1f1f,0x801d1d1d,0x801c1c1c,0x80191919,0x80181818,
+0x80181818,0x80191919,0x80191919,0x801c1c1c,0x801f1f1f,0x80202020,
+0x801f1f1f,0x801e1e1e,0x801c1c1c,0x801a1a1a,0x80171717,0x80181818,
+0x80171717,0x80171717,0x801a1a1a,0x801e1e1e,0x80202020,0x801e1e1e,
+0x801f1f1f,0x801f1f1f,0x801c1c1c,0x80171717,0x80161616,0x80191919,
+0x801a1a1a,0x80191919,0x801e1e1e,0x801d1d1d,0x801e1e1e,0x80202020,
+0x80202020,0x801d1d1d,0x80191919,0x80171717,0x801c1c1c,0x801e1e1e,0x801f1f1f,0x80202020,0x801e1e1e,0x801c1c1c,
+0x80181818,0x80191919,0x80181818,0x80171717,0x80191919,0x801d1d1d,
+0x801f1f1f,0x801e1e1e,0x80202020,0x801e1e1e,0x801c1c1c,0x801b1b1b,
+0x80191919,0x80171717,0x80171717,0x80181818,0x801c1c1c,0x801e1e1e,
+0x801f1f1f,0x801e1e1e,0x801f1f1f,0x80202020,0x801b1b1b,0x80141414,
+0x8019191b,0x802a2a2c,0x80404042,0x8059595b,0x80737375,0x80858587,
+0x808c8c8e,0x808c8c8e,0x80909092,0x808f8f91,0x808f8f91,0x80909092,
+0x808f8f91,0x808e8e90,0x808e8e90,0x80909092,0x808f8f91,0x808f8f91,
+0x80909092,0x80909092,0x80909092,0x80909092,0x80909092,0x80909092,
+0x808f8f91,0x80909092,0x80909092,0x808f8f91,0x808e8e90,0x808f8f91,
+0x808f8f91,0x808e8e90,0x808f8f91,0x808f8f91,0x808f8f91,0x808f8f91,
+0x808f8f91,0x808f8f91,0x80909092,0x80909092,0x80919193,0x808f8f91,
+0x808f8f91,0x80909092,0x80909092,0x808f8f91,0x80909092,0x80929294,
+0x80919193,0x808f8f91,0x808f8f91,0x808e8e90,0x80929294,0x808f8f8f,
+0x80292929,0x801a1a1a,0x80181818,0x80181818,0x80181818,0x80181818,
+0x801b1b1b,0x801f1f1f,0x80202020,0x801e1e1e,0x801d1d1d,0x801a1a1a,
+0x80030303,0x800d0d0d,0x80000000,0x80171717,0x80161616,0x80161616,
+0x80212121,0x801e1e1e,0x801f1f1f,0x80212121,0x801e1e1e,0x80090909,
+0x80080808,0x80080808,0x800b0b0b,0x80191919,0x80151515,0x80010101,
+0x80020202,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80010101,
+0x80000000,0x80000000,0x80000000,0x80010101,0x80010101,0x80000000,
+0x80020202,0x80040404,0x80050505,0x800c0c0c,0x80131313,0x80181818,
+0x801d1d1d,0x80202020,0x801e1e1e,0x80191919,0x80191919,0x80191919,
+0x80181818,0x80171717,0x80191919,0x801e1e1e,0x80202020,0x801f1f1f,
+0x80202020,0x801e1e1e,0x801c1c1c,0x801a1a1a,0x80181818,0x80171717,
+0x80181818,0x801a1a1a,0x801c1c1c,0x801e1e1e,0x801f1f1f,0x801e1e1e,
+0x801e1e1e,0x801d1d1d,0x801b1b1b,0x80171717,0x80191919,0x80161616,
+0x80171717,0x801b1b1b,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801f1f1f,
+0x801f1f1f,0x801a1a1a,0x80171717,0x80181818,0x80191919,0x80191919,
+0x801a1a1a,0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801f1f1f,0x801f1f1f,
+0x801d1d1d,0x80181818,0x80171717,0x80191919,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801c1c1c,0x80191919,
+0x80181818,0x80191919,0x80191919,0x80191919,0x801b1b1b,0x801f1f1f,
+0x80202020,0x801e1e1e,0x801e1e1e,0x801c1c1c,0x801a1a1a,0x80191919,
+0x80171717,0x80171717,0x80181818,0x801a1a1a,0x80212121,0x801d1d1d,
+0x801f1f1f,0x80212121,0x801b1b1b,0x801c1c1c,0x80363636,0x80575757,
+0x80757577,0x80848486,0x80909092,0x80919193,0x808f8f91,0x808d8d8f,
+0x808e8e90,0x80909092,0x808f8e93,0x808e8d92,0x808e8d92,0x80908f94,
+0x80908f94,0x808e8d92,0x808f8e93,0x80908f94,0x808e8d92,0x808e8d92,
+0x808e8d92,0x808e8d92,0x808e8d92,0x808f8e93,0x808f8e93,0x808f8e93,
+0x80908f94,0x80908f94,0x80908f94,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808e8d92,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x80908f94,0x80908f94,0x80908f94,0x80908f94,0x80908f94,0x808f8e93,
+0x808f8e93,0x808e8d92,0x808e8d92,0x808e8d92,0x808e8d92,0x808e8d92,
+0x808f8f91,0x80909092,0x808f8f91,0x808f8f91,0x808f8f91,0x808f8f91,
+0x80252525,0x80181818,0x80181818,0x80181818,0x80191919,0x801b1b1b,
+0x801e1e1e,0x80202020,0x801f1f1f,0x801e1e1e,0x80202020,0x80171717,
+0x80000000,0x80020202,0x80000000,0x80121212,0x801c1c1c,0x80202020,
+0x801d1d1d,0x801c1c1c,0x801f1f1f,0x80202020,0x801c1c1c,0x80040404,
+0x80020202,0x80000000,0x800b0b0b,0x801a1a1a,0x80171717,0x80010101,
+0x80010101,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80010101,0x80010101,0x80010101,0x80010101,0x80010101,0x80010101,
+0x80010101,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80010101,0x80000000,0x80010101,0x80010101,0x80000000,
+0x80040404,0x800d0d0d,0x80141414,0x80151515,0x80181818,0x80181818,
+0x80181818,0x80191919,0x801d1d1d,0x80202020,0x801f1f1f,0x801a1a1a,
+0x801e1e1e,0x801c1c1c,0x801a1a1a,0x80191919,0x80181818,0x80181818,
+0x801a1a1a,0x801c1c1c,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801d1d1d,
+0x801c1c1c,0x801b1b1b,0x80181818,0x80161616,0x80181818,0x80181818,
+0x801a1a1a,0x801f1f1f,0x80202020,0x801e1e1e,0x801d1d1d,0x801e1e1e,
+0x801b1b1b,0x80181818,0x80171717,0x80191919,0x801a1a1a,0x801a1a1a,
+0x801c1c1c,0x80202020,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801c1c1c,
+0x80191919,0x80171717,0x80171717,0x80191919,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801c1c1c,0x80191919,0x80161616,
+0x801a1a1a,0x80181818,0x80181818,0x801c1c1c,0x801f1f1f,0x801e1e1e,
+0x801e1e1e,0x801f1f1f,0x801d1d1d,0x801a1a1a,0x80181818,0x80181818,
+0x80171717,0x80181818,0x801a1a1a,0x801d1d1d,0x801d1d1d,0x801d1d1d,
+0x80202020,0x80303030,0x80535353,0x807a7a7a,0x808e8e8e,0x808f8f8f,
+0x808e8e90,0x80919193,0x80909092,0x808e8e90,0x80909092,0x80919193,
+0x80909092,0x808f8f91,0x808d8e92,0x80909195,0x80909195,0x808d8e92,
+0x808d8e92,0x80909195,0x80909195,0x808d8e92,0x808f9094,0x808f9094,
+0x808f9094,0x808f9094,0x808f9094,0x808f9094,0x808f9094,0x808e8f93,
+0x808f9094,0x808e8f93,0x808e8f93,0x808e8f93,0x808e8f93,0x808e8f93,
+0x808e8f93,0x808f9094,0x808f9094,0x808f9094,0x808f9094,0x808f9094,
+0x808f9094,0x808f9094,0x808e8f93,0x808e8f93,0x808d8e92,0x808f9094,
+0x80909195,0x808e8f93,0x808e8f93,0x80909195,0x808f9094,0x808e8f93,
+0x808f8f91,0x80919193,0x808d8d8f,0x80919193,0x808e8e90,0x808f8f91,
+0x80272727,0x80181818,0x80181818,0x80191919,0x801c1c1c,0x801f1f1f,
+0x801f1f1f,0x801e1e1e,0x801e1e1e,0x80202020,0x80191919,0x80131313,
+0x80060606,0x80060606,0x80030303,0x80020202,0x80070707,0x80050505,
+0x80060606,0x80070707,0x80070707,0x80030303,0x80060606,0x80000000,
+0x80070707,0x80050505,0x800b0b0b,0x801c1c1c,0x801c1c1c,0x80010101,
+0x80000000,0x80000000,0x80020202,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80010101,
+0x80000000,0x80000000,0x80000000,0x80010101,0x80080808,0x800d0d0d,
+0x80161616,0x801d1d1d,0x801f1f1f,0x801d1d1d,0x801d1d1d,0x80202020,
+0x801c1c1c,0x801a1a1a,0x80181818,0x80181818,0x80191919,0x801a1a1a,
+0x801c1c1c,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801e1e1e,
+0x801a1a1a,0x80171717,0x80161616,0x80181818,0x80161616,0x801b1b1b,
+0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801c1c1c,
+0x80161616,0x80191919,0x80191919,0x80181818,0x80191919,0x801d1d1d,
+0x80202020,0x801f1f1f,0x801f1f1f,0x801f1f1f,0x801c1c1c,0x80181818,
+0x80171717,0x80191919,0x80191919,0x80171717,0x801e1e1e,0x801f1f1f,0x801c1c1c,0x80181818,0x80181818,0x801a1a1a,
+0x80161616,0x80191919,0x80202020,0x801e1e1e,0x801c1c1c,0x80202020,
+0x801f1f1f,0x801f1f1f,0x801b1a18,0x80181715,0x801a1917,0x80191718,
+0x80191718,0x801c1a1b,0x801f1d1e,0x80201e1f,0x801c1b20,0x803e3d42,
+0x806b6a6f,0x8089888d,0x80919095,0x808e8d92,0x808e8d92,0x80919095,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808e8f91,0x808f8f91,0x808f8e93,0x808f8e93,0x808f8e93,0x808e8e90,
+0x80262626,0x80191718,0x80171717,0x801c1c1c,0x801f1f1f,0x801e1e1e,
+0x801d1d1d,0x801e1e1e,0x801d1d1d,0x801a1a1a,0x80191919,0x80141414,
+0x80060606,0x80101010,0x80000000,0x80020202,0x80000000,0x80000000,
+0x80010101,0x80000000,0x80000000,0x80000000,0x80010101,0x80000000,
+0x800e0e0e,0x800c0c0c,0x800d0d0d,0x801e1e1e,0x801a1a1a,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80020202,0x800a0a0a,0x80151515,0x801d1d1d,0x801f1f1f,0x801d1d1d,
+0x80191718,0x80191718,0x801a1819,0x801a1819,0x801a1819,0x801b191a,
+0x801e1c1d,0x80211f20,0x801f1f1f,0x80212121,0x801e1e1e,0x80181818,
+0x80151515,0x80171717,0x80191919,0x80171717,0x801c1c1c,0x801e1e1e,
+0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801b1b1b,0x80161616,
+0x80191919,0x80171717,0x80171717,0x801b1b1b,0x801e1e1e,0x801f1f1f,
+0x801f1f1f,0x801f1f1f,0x80202020,0x801b1b1b,0x80181818,0x80191919,
+0x80191919,0x80181818,0x80191919,0x801c1c1c,0x801f1f1f,0x801b1b1b,0x80191919,0x80191919,0x80191919,0x80181818,
+0x801b1b1b,0x801c1c1c,0x801d1d1d,0x801d1d1d,0x80202020,0x80212121,
+0x801c1c1c,0x80171717,0x80151513,0x801b1b19,0x80191919,0x80141414,
+0x801e1e1e,0x801c1c1c,0x801d1d1d,0x80434343,0x8079787d,0x8087868b,
+0x80929196,0x80919095,0x808e8d92,0x80908f94,0x80919095,0x808e8d92,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f9092,0x80909092,0x80908f94,0x80908f94,0x808f8e93,0x808d8d8f,
+0x80262626,0x80191718,0x801c1c1c,0x801d1d1d,0x801e1e1e,0x801e1e1e,
+0x801e1e1e,0x801d1d1d,0x801b1b1b,0x80181818,0x80191919,0x80171717,
+0x80000000,0x80040404,0x80000000,0x80111111,0x80151515,0x80181818,
+0x80171717,0x80131313,0x80131313,0x80141414,0x80121212,0x80020202,
+0x80030303,0x80000000,0x800e0e0e,0x801f1f1f,0x801a1a1a,0x80000000,
+0x80010101,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80010101,
+0x80010101,0x80000000,0x80020202,0x80070707,0x800f0f0f,0x80161616,
+0x801a1819,0x801b191a,0x80191718,0x80171516,0x801b191a,0x80222021,
+0x80211f20,0x801b191a,0x801e1e1e,0x801b1b1b,0x80181818,0x80191919,
+0x80191919,0x80181818,0x80181818,0x80191919,0x801e1e1e,0x801d1d1d,
+0x801d1d1d,0x80202020,0x801f1f1f,0x801a1a1a,0x80181818,0x80191919,
+0x80171717,0x80191919,0x801b1b1b,0x801d1d1d,0x801d1d1d,0x801e1e1e,
+0x801f1f1f,0x801f1f1f,0x801b1b1b,0x801a1a1a,0x80191919,0x80181818,
+0x80181818,0x80191919,0x801c1c1c,0x801f1f1f,0x801d1d1d,0x80191919,0x80171717,0x80181818,0x80191919,0x80181818,
+0x801d1d1d,0x801f1f1f,0x801f1f1f,0x80202020,0x801f1f1f,0x801b1b1b,
+0x801a1a1a,0x801b1b1b,0x801b1b1b,0x80181818,0x80171717,0x801b1b1b,
+0x801f1f1f,0x803a3a3a,0x806f6f71,0x808f8f91,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x80908f94,0x80908f94,0x80908f94,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f9092,0x80909092,0x80908f94,0x80908f94,0x808f8e93,0x808d8d8f,
+0x80272727,0x801c1a1b,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801f1f1f,
+0x801e1e1e,0x801a1a1a,0x80181818,0x80171717,0x80171717,0x80151515,
+0x80000000,0x80050505,0x80010101,0x801a1a1a,0x80212121,0x80202020,
+0x801c1c1c,0x80191919,0x80181818,0x80191919,0x80191919,0x80050505,
+0x80030303,0x80010101,0x80101010,0x801f1f1f,0x801a1a1a,0x80000000,
+0x80010101,0x80000000,0x80010101,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80010101,0x80000000,0x80000000,0x80000000,0x80010101,0x80030303,
+0x800c0a0b,0x80131112,0x801b191a,0x80201e1f,0x80201e1f,0x801e1c1d,
+0x801f1d1e,0x80201e1f,0x801f1f1f,0x801a1a1a,0x80171717,0x80181818,
+0x80191919,0x80181818,0x801a1a1a,0x801e1e1e,0x801e1e1e,0x801d1d1d,
+0x801e1e1e,0x801e1e1e,0x801c1c1c,0x80171717,0x80171717,0x80191919,
+0x80171717,0x801b1b1b,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801f1f1f,
+0x801e1e1e,0x801c1c1c,0x80181818,0x80191919,0x80191919,0x80181818,
+0x80181818,0x801c1c1c,0x801e1e1e,0x801f1f1f,0x80191919,0x80191919,0x80181818,0x80171717,0x80191919,0x801c1c1c,
+0x801e1e1e,0x801c1c1c,0x801c1c1c,0x80202020,0x801e1e1e,0x80191919,
+0x80191919,0x80191919,0x80161616,0x80161616,0x801b1b1b,0x80292929,
+0x805a5a5c,0x808b8b8d,0x80909092,0x808e8e90,0x80919095,0x808e8d92,
+0x808e8d92,0x80908f94,0x80908f94,0x808e8d92,0x808d8c91,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808e8f91,0x80909092,0x80908f94,0x808f8e93,0x808f8e93,0x808e8e90,
+0x80292929,0x801f1d1e,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801d1d1d,
+0x801a1a1a,0x80171717,0x80171717,0x80191919,0x801a1a1a,0x80151515,
+0x80060606,0x80121212,0x80060606,0x801c1c1c,0x80202020,0x801a1a1a,
+0x80171717,0x80191919,0x80171717,0x80161616,0x80191919,0x800b0b0b,
+0x800d0d0d,0x800e0e0e,0x800f0f0f,0x801e1e1e,0x80191919,0x80000000,
+0x80000000,0x80000000,0x80010101,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80020202,0x80000000,
+0x80000000,0x80000000,0x80010101,0x80020202,0x80000000,0x80000000,
+0x80010101,0x80030303,0x800c0c0c,0x80191919,0x80212121,0x80202020,
+0x801e1e1e,0x801e1e1e,0x801a1a1a,0x801a1a1a,0x80191919,0x80171717,
+0x80171717,0x801b1b1b,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x80202020,
+0x801e1e1e,0x801a1a1a,0x80171717,0x80181818,0x80191919,0x80181818,
+0x801b1b1b,0x801d1d1d,0x801e1e1e,0x801f1f1f,0x80202020,0x801f1f1f,
+0x801c1c1c,0x80181818,0x80191919,0x80181818,0x80181818,0x80191919,
+0x801c1c1c,0x801f1f1f,0x801f1f1f,0x801d1d1d,0x80171717,0x80181818,0x80191919,0x80191919,0x801b1b1b,0x801f1f1f,
+0x801f1f1f,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x80181818,0x80171717,
+0x801a1a1a,0x80181818,0x80181818,0x801c1c1e,0x803d3d3f,0x807b7b7d,
+0x80939395,0x808d8d8f,0x80919193,0x808e8e90,0x808e8d92,0x80929196,
+0x80929196,0x808d8c91,0x808c8b90,0x80908f94,0x80919095,0x808e8d92,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808e8f91,0x80909092,0x80908f94,0x808f8e93,0x808f8e93,0x808e8e90,
+0x802a2a2a,0x80201e1f,0x801d1d1d,0x801e1e1e,0x801e1e1e,0x801a1a1a,
+0x80171717,0x80161616,0x80181818,0x80191919,0x801c1c1c,0x80191919,
+0x80040404,0x800e0e0e,0x80030303,0x80191919,0x801b1b1b,0x80181818,
+0x80181818,0x801a1a1a,0x80191919,0x80181818,0x801c1c1c,0x800b0b0b,
+0x80090909,0x80080808,0x800e0e0e,0x801c1c1c,0x80181818,0x80000000,
+0x80000000,0x80000000,0x80010101,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80010101,0x80020202,
+0x80000000,0x80000000,0x80010101,0x80060606,0x80111111,0x801c1c1c,
+0x801e1e1e,0x801a1a1a,0x80151515,0x80171717,0x80181818,0x80181818,
+0x801a1a1a,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801f1f1f,0x801f1f1f,
+0x801c1c1c,0x80171717,0x80161616,0x80191919,0x801a1a1a,0x80191919,
+0x801e1e1e,0x801d1d1d,0x801e1e1e,0x80202020,0x80202020,0x801d1d1d,
+0x80191919,0x80171717,0x80191919,0x80181818,0x80181818,0x801c1c1c,
+0x801f1f1f,0x80202020,0x801e1e1e,0x801d1d1d,0x80181818,0x80171717,0x80191919,0x801d1d1d,0x801f1f1f,0x801e1e1e,
+0x801c1c1c,0x801e1e1e,0x801e1e1e,0x80191919,0x80171717,0x80191919,
+0x80171717,0x80171717,0x801a1a1c,0x8059595b,0x808f8f91,0x80919193,
+0x808c8c8e,0x80919095,0x808f8e93,0x80919095,0x808e8d92,0x80908f94,
+0x80919095,0x80919095,0x80919095,0x80919095,0x80908f94,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f9092,0x80909092,0x80908f94,0x808f8e93,0x808f8e93,0x808e8e90,
+0x802a2a2a,0x80201e1f,0x801e1e1e,0x801d1d1d,0x801a1a1a,0x80171717,
+0x80161616,0x80181818,0x80191919,0x80191919,0x801b1b1b,0x801e1e1e,
+0x80000000,0x80030303,0x80000000,0x80191919,0x80161616,0x80181818,
+0x80191919,0x80171717,0x80171717,0x801c1c1c,0x80202020,0x80080808,
+0x80010101,0x80000000,0x800c0c0c,0x80191919,0x80161616,0x80000000,
+0x80000000,0x80000000,0x80010101,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80010101,0x80020202,0x80010101,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80070707,
+0x80101010,0x80181818,0x801a1a1a,0x80171717,0x80171717,0x801a1a1a,
+0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801f1f1f,0x801f1f1f,0x801a1a1a,
+0x80171717,0x80181818,0x80191919,0x80191919,0x801a1a1a,0x801d1d1d,
+0x801f1f1f,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801d1d1d,0x80181818,
+0x80171717,0x80191919,0x80181818,0x80191919,0x801c1c1c,0x801f1f1f,
+0x80202020,0x801e1e1e,0x801d1d1d,0x801e1e1e,0x80191919,0x80191919,0x801b1b1b,0x801f1f1f,0x80202020,0x801e1e1e,
+0x80222222,0x801e1e1e,0x801a1a1a,0x80171717,0x801d1d1d,0x80181818,
+0x80131313,0x80282828,0x80717173,0x808c8c8e,0x808e8e90,0x808e8d92,
+0x80939297,0x808d8c91,0x808d8c91,0x808e8d92,0x80929196,0x808e8d92,
+0x808d8c91,0x80919095,0x80908f94,0x808d8c91,0x808d8c91,0x80908f94,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f9092,0x80909092,0x80908f94,0x808f8e93,0x808f8e93,0x808e8e90,
+0x802a2a2a,0x801f1d1e,0x801d1d1d,0x801b1b1b,0x80181818,0x80171717,
+0x80181818,0x80191919,0x801b1b1b,0x801c1c1c,0x801d1d1d,0x801f1f1f,
+0x80020202,0x80090909,0x80010101,0x80191919,0x80171717,0x80191919,
+0x80191919,0x80191919,0x801a1a1a,0x801f1f1f,0x80202020,0x800b0b0b,
+0x80070707,0x80060606,0x800c0c0c,0x80181818,0x80161616,0x80000000,
+0x80000000,0x80000000,0x80010101,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80020202,0x80010101,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80030303,0x80000000,0x80000000,0x80010101,0x80000000,0x80000000,
+0x80030303,0x800b0b0b,0x80151515,0x80181818,0x801b1b1b,0x801d1d1d,
+0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801b1b1b,0x80181818,
+0x80171717,0x80191919,0x801a1a1a,0x801a1a1a,0x801c1c1c,0x80202020,
+0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801c1c1c,0x80191919,0x80171717,
+0x80171717,0x80191919,0x80191919,0x801c1c1c,0x801e1e1e,0x801f1f1f,
+0x801e1e1e,0x801d1d1d,0x801c1c1c,0x801b1b1b,0x80181818,0x801c1c1c,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801f1f1f,
+0x801d1d1d,0x801a1a1a,0x80191919,0x80161616,0x801a1a1a,0x80161616,
+0x802f2f2f,0x80797979,0x808c8d8f,0x808f9092,0x808f9092,0x808f9094,
+0x808e8f93,0x808d8e92,0x80909195,0x80909195,0x808e8d92,0x80908f94,
+0x80919095,0x80908f94,0x808f8e93,0x80908f94,0x80919095,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808e8f91,0x808f8f91,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8f91,
+0x802b2b2b,0x80201e1f,0x801a1a1a,0x80181818,0x80171717,0x80191919,
+0x80191919,0x80191919,0x801c1c1c,0x80212121,0x801f1f1f,0x80171717,
+0x80050505,0x80161616,0x80010101,0x80151515,0x80181818,0x80181818,
+0x80171717,0x801d1d1d,0x80212121,0x801f1f1f,0x801c1c1c,0x800c0c0c,
+0x800d0d0d,0x800b0b0b,0x800b0b0b,0x80181818,0x80161616,0x80010101,
+0x80000000,0x80000000,0x80010101,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80010101,0x80000000,0x80000000,0x80000000,0x80000000,0x80010101,
+0x80000000,0x80000000,0x80010101,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80030303,0x80121212,0x801f1f1f,0x801f1f1f,
+0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801a1a1a,0x80161616,0x80191919,
+0x80191919,0x80181818,0x80191919,0x801d1d1d,0x80202020,0x801f1f1f,
+0x801f1f1f,0x801f1f1f,0x801c1c1c,0x80181818,0x80171717,0x80191919,
+0x80191919,0x80171717,0x801c1c1c,0x801f1f1f,0x801f1f1f,0x801d1d1d,
+0x801d1d1d,0x801e1e1e,0x801b1b1b,0x80161616,0x801d1d1d,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801e1e1e,
+0x801b191a,0x80151515,0x801b1b1b,0x80171717,0x80181818,0x80333335,
+0x80808082,0x808e8f91,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808e8f91,0x80919193,0x80908f94,0x808f8e93,0x808e8d92,0x808e8e90,
+0x80282828,0x801b191a,0x80181818,0x80191919,0x80181818,0x80171717,
+0x801b1b1b,0x801f1f1f,0x801f1f1f,0x801d1d1d,0x801e1e1e,0x801d1d1d,
+0x80020202,0x80000000,0x80020202,0x80151515,0x80181818,0x80191919,
+0x801e1e1e,0x80222222,0x801f1f1f,0x801d1d1d,0x80202020,0x800a0a0a,
+0x80020202,0x80010101,0x800c0c0c,0x80171717,0x80171717,0x80000000,
+0x80010101,0x80000000,0x80000000,0x80000000,0x80010101,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80010101,0x80010101,0x80010101,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80010101,0x800d0d0d,0x801d1d1d,
+0x80222222,0x801c1c1c,0x80181818,0x80191919,0x80171717,0x801a1a1a,
+0x801a1a1a,0x80191919,0x801b1b1b,0x80202020,0x80202020,0x801d1d1d,
+0x80202020,0x801b1b1b,0x80181818,0x80191919,0x80191919,0x80181818,
+0x80191919,0x801c1c1c,0x80202020,0x801e1e1e,0x801d1d1d,0x801e1e1e,
+0x801d1d1d,0x80191919,0x80181818,0x80191919,0x801e1e1e,0x801d1d1d,0x801e1e1e,0x80202020,0x801e1e1e,0x80191919,
+0x80171516,0x801e1e1e,0x80171717,0x80161616,0x80343434,0x80868688,
+0x808f8f91,0x80909193,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808e8f91,0x80909092,0x80908f94,0x808f8e93,0x808f8e93,0x808e8e90,
+0x80272727,0x801a1819,0x80191919,0x80171717,0x80181818,0x801b1b1b,
+0x801e1e1e,0x801d1d1d,0x801e1e1e,0x801f1f1f,0x80202020,0x80171717,
+0x80010101,0x80040404,0x80000000,0x80101010,0x80171717,0x80161616,
+0x801a1a1a,0x80181818,0x80191919,0x801a1a1a,0x80181818,0x80020202,
+0x80010101,0x80030303,0x800d0d0d,0x80191919,0x80181818,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80010101,0x80000000,0x80000000,
+0x80000000,0x80010101,0x80010101,0x80000000,0x80000000,0x80000000,
+0x80010101,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80010101,0x80000000,0x80010101,0x80090909,
+0x80151515,0x801c1c1c,0x801a1a1a,0x80161616,0x801b1b1b,0x80161616,
+0x80181818,0x801e1e1e,0x801f1f1f,0x801d1d1d,0x801e1e1e,0x80202020,
+0x801b1b1b,0x801a1a1a,0x80191919,0x80181818,0x80181818,0x80191919,
+0x801c1c1c,0x801f1f1f,0x801e1e1e,0x80202020,0x801f1f1f,0x801b1b1b,
+0x801a1a1a,0x801a1a1a,0x80191919,0x80171717,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801b1b1b,0x80181818,
+0x801c1a1b,0x80131313,0x80191919,0x802c2c2c,0x80818183,0x808e8e90,
+0x80949496,0x808c8d8f,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808e8f91,0x80909092,0x80908f94,0x808f8e93,0x808f8e93,0x808e8e90,
+0x80262626,0x80191718,0x80181818,0x80181818,0x801a1a1a,0x801e1e1e,
+0x801f1f1f,0x801d1d1d,0x801d1d1d,0x801f1f1f,0x801e1e1e,0x80141414,
+0x80050505,0x80111111,0x80010101,0x80000000,0x80000000,0x80040404,
+0x80000000,0x80000000,0x80020202,0x80010101,0x80030303,0x80000000,
+0x800c0c0c,0x800a0a0a,0x800a0a0a,0x801a1a1a,0x80191919,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80020202,0x80010101,0x80000000,0x80010101,0x80010101,0x80010101,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80050505,0x80101010,0x80181818,0x80191919,0x80181818,0x80191919,
+0x801e1e1e,0x80212121,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801d1d1d,
+0x80181818,0x80191919,0x80191919,0x80181818,0x80181818,0x801c1c1c,
+0x801e1e1e,0x801f1f1f,0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801a1a1a,
+0x80181818,0x80191919,0x80191919,0x80171717,0x801e1e1e,0x80202020,0x801e1e1e,0x80191919,0x80171717,0x801a1a1a,
+0x80181617,0x80161616,0x80292929,0x8078787a,0x80919193,0x80919193,
+0x808c8c8e,0x808e8f91,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808e8f91,0x808f8f91,0x808f8e93,0x808f8e93,0x808f8e93,0x808d8d8f,
+0x80262626,0x80181617,0x80171717,0x801b1b1b,0x801e1e1e,0x801e1e1e,
+0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801b1b1b,0x80161616,0x80141414,
+0x80010101,0x800b0b0b,0x80010101,0x80020202,0x80000000,0x80040404,
+0x80020202,0x80010101,0x80010101,0x80000000,0x80010101,0x80000000,
+0x800b0b0b,0x80050505,0x800e0e0e,0x801f1f1f,0x801c1c1c,0x80030303,
+0x80000000,0x80010101,0x80010101,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80010101,0x80010101,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80020202,0x80010101,
+0x80000000,0x80010101,0x800d0d0d,0x80181818,0x80191919,0x801f1f1f,
+0x80202020,0x801e1e1e,0x801e1e1e,0x80202020,0x801d1d1d,0x80181818,
+0x80191919,0x80181818,0x80181818,0x80191919,0x801c1c1c,0x801f1f1f,
+0x801f1f1f,0x801d1d1d,0x801e1e1e,0x801b1b1b,0x801a1a1a,0x801a1a1a,
+0x80181818,0x80161616,0x80181818,0x801b1b1b,0x801e1e1e,0x801e1e1e,0x801b1b1b,0x80171717,0x80171717,0x80191919,
+0x80181617,0x80202020,0x8069696b,0x80939395,0x808f8f91,0x80919193,
+0x80909092,0x80909193,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808e8f91,0x808f8f91,0x808f8e93,0x80908f94,0x808f8e93,0x808d8d8f,
+0x80262626,0x80191718,0x801b1b1b,0x801e1e1e,0x801f1f1f,0x801e1e1e,
+0x801e1e1e,0x801e1e1e,0x801b1b1b,0x80171717,0x80171717,0x80191919,
+0x80000000,0x80000000,0x80000000,0x80181818,0x801b1b1b,0x801b1b1b,
+0x801d1d1d,0x80191919,0x80171717,0x80181818,0x80171717,0x80030303,
+0x80000000,0x80000000,0x800e0e0e,0x801f1f1f,0x80191919,0x80020202,
+0x80000000,0x80000000,0x80010101,0x80010101,0x80000000,0x80000000,
+0x80010101,0x80010101,0x80010101,0x80010101,0x80010101,0x80010101,
+0x80000000,0x80000000,0x80010101,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80010101,0x80000000,0x80000000,0x80010101,
+0x80000000,0x80000000,0x80030303,0x800a0a0a,0x801d1d1d,0x80202020,
+0x801d1d1d,0x801c1c1c,0x80202020,0x801d1d1d,0x80181818,0x80191919,
+0x80191919,0x80181818,0x80181818,0x801c1c1c,0x801f1f1f,0x80202020,
+0x801e1e1e,0x801d1d1d,0x801d1d1d,0x801a1a1a,0x80181818,0x80181818,
+0x80181818,0x80171717,0x801a1a1a,0x801e1e1e,0x801e1e1e,0x80191919,0x80171717,0x801a1a1a,0x80191919,0x80161616,
+0x801a181b,0x8059595b,0x808d8d8f,0x808f8f91,0x80919193,0x808d8d8f,
+0x808e8e90,0x808f9094,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808e8f91,0x808f8f91,0x808f8e93,0x80908f94,0x808f8e93,0x808d8d8f,
+0x80272727,0x801c1a1b,0x801f1f1f,0x801d1d1d,0x801d1d1d,0x801f1f1f,
+0x801e1e1e,0x801a1a1a,0x80181818,0x80181818,0x80171717,0x80141414,
+0x80000000,0x80090909,0x80000000,0x80191919,0x80212121,0x801f1f1f,
+0x80191919,0x801a1a1a,0x80181818,0x80181818,0x80191919,0x80050505,
+0x80030303,0x80040404,0x800f0f0f,0x80212121,0x801e1e1e,0x80101010,
+0x800e0e0e,0x800f0f0f,0x800f0f0f,0x800f0f0f,0x800c0c0c,0x800d0d0d,
+0x800e0e0e,0x800d0d0d,0x800a0a0a,0x80070707,0x80030303,0x80000000,
+0x80000000,0x80010101,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80010101,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80010101,0x80010101,0x80000000,0x800e0e0e,0x801b1b1b,
+0x80212121,0x801e1e1e,0x801d1d1d,0x80191919,0x80161616,0x80191919,
+0x80181818,0x80191919,0x801c1c1c,0x801f1f1f,0x80202020,0x801e1e1e,
+0x801d1d1d,0x801e1e1e,0x80191919,0x801a1a1a,0x80191919,0x80161616,
+0x80171717,0x801c1c1c,0x801e1e1e,0x801e1e1e,0x801b1b1b,0x80171717,0x80171717,0x80191919,0x801b1b1b,0x801b1b1b,
+0x803b393c,0x80919193,0x808e8e90,0x808f8f91,0x808e8e90,0x80929294,
+0x80919095,0x808e8f93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808e8f91,0x808f8f91,0x808f8e93,0x80908f94,0x808f8e93,0x808e8e90,
+0x80292929,0x801f1d1e,0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801e1e1e,
+0x801b1b1b,0x80181818,0x80171717,0x80191919,0x80181818,0x80151515,
+0x80070707,0x80171717,0x80090909,0x801a1a1a,0x801d1d1d,0x801e1e1e,
+0x80171717,0x801a1a1a,0x80191919,0x80151515,0x80181818,0x800d0d0d,
+0x80101010,0x800e0e0e,0x800c0c0c,0x801e1e1e,0x801e1e1e,0x80181818,
+0x801a1a1a,0x80191919,0x80171717,0x80181818,0x801b1b1b,0x801d1d1d,
+0x801f1f1f,0x80202020,0x801f1f1f,0x801c1c1c,0x80191919,0x80171717,
+0x80131313,0x800f0f0f,0x800a0a0a,0x80050505,0x80020202,0x80010101,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80010101,0x80010101,0x80000000,
+0x80000000,0x80010101,0x80010101,0x80000000,0x80000000,0x800e0e0e,
+0x801c1c1c,0x801c1c1c,0x80181818,0x80181818,0x80181818,0x80171717,
+0x80191919,0x801c1c1c,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801d1d1d,
+0x801c1c1c,0x801b1b1b,0x80181818,0x80191919,0x80191919,0x80181818,
+0x801a1a1a,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x80181818,0x801a1a1a,0x80191919,0x80161616,0x801b1b1b,0x80232323,
+0x807f7d80,0x808d8d8f,0x80929294,0x808f8f91,0x808f8f91,0x808e8d92,
+0x808e8d92,0x808e8f93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808e8f91,0x808f8f91,0x808f8e93,0x80908f94,0x808f8e93,0x808e8e90,
+0x802a2a2a,0x80211f20,0x801d1d1d,0x801f1f1f,0x801f1f1f,0x801b1b1b,
+0x80171717,0x80181818,0x80191919,0x80181818,0x80181818,0x801b1b1b,
+0x80020202,0x80070707,0x80020202,0x801e1e1e,0x801c1c1c,0x80181818,
+0x801b1b1b,0x80181818,0x80171717,0x80191919,0x801a1a1a,0x80080808,
+0x80070707,0x80030303,0x800f0f0f,0x801e1e1e,0x801b1b1b,0x80171717,
+0x80191919,0x80181818,0x80171717,0x801b1b1b,0x801e1e1e,0x801f1f1f,
+0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801b1b1b,0x80191919,0x80181818,
+0x80181818,0x80191919,0x801a1a1a,0x801c1c1c,0x801c1c1c,0x80171717,
+0x800e0e0e,0x80070707,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80090909,0x80171717,0x80191919,0x80181818,0x80191919,0x80171717,
+0x801c1c1c,0x801f1f1f,0x801f1f1f,0x801d1d1d,0x801d1d1d,0x801e1e1e,
+0x801b1b1b,0x80161616,0x80191919,0x80171717,0x80171717,0x801b1b1b,
+0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x80171516,0x801a1a1a,0x80161616,0x801a1a1a,0x801d1d1d,0x805b5b5b,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f9092,0x808f8f91,0x80908f94,0x80908f94,0x808f8e93,0x808e8e90,
+0x802b2b2b,0x801f1d1e,0x801f1f1f,0x801f1f1f,0x801c1c1c,0x80181818,
+0x80171717,0x80181818,0x80191919,0x80191919,0x801c1c1c,0x801e1e1e,
+0x80020202,0x80010101,0x80000000,0x801a1a1a,0x801a1a1a,0x80171717,
+0x80191919,0x80161616,0x80161616,0x801d1d1d,0x80212121,0x80080808,
+0x80000000,0x80000000,0x800f0f0f,0x80191919,0x80181818,0x80191919,
+0x80181818,0x80171717,0x80191919,0x80202020,0x801f1f1f,0x801e1e1e,
+0x801e1e1e,0x801e1e1e,0x801b1b1b,0x80171717,0x80171717,0x80191919,
+0x80171717,0x801a1a1a,0x801d1d1d,0x801e1e1e,0x801f1f1f,0x80202020,
+0x801e1e1e,0x801c1c1c,0x80161616,0x800e0e0e,0x80050505,0x80010101,
+0x80010101,0x80000000,0x80000000,0x80000000,0x80010101,0x80000000,
+0x80000000,0x80010101,0x80000000,0x80000000,0x80000000,0x80010101,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80020202,
+0x80000000,0x80070707,0x80171717,0x801a1a1a,0x80171717,0x801d1d1d,
+0x801f1f1f,0x801d1d1d,0x801e1e1e,0x801f1f1f,0x801c1c1c,0x80181818,
+0x80181818,0x801a1a1a,0x80171717,0x80181818,0x801a1a1a,0x801d1d1d,
+0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801c1a1b,0x80151515,0x80191919,0x80202020,0x80323232,0x80878787,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f9092,0x808f8f91,0x80908f94,0x80908f94,0x808f8e93,0x808f8f91,
+0x802b2b2b,0x801f1d1e,0x801f1f1f,0x801a1a1a,0x80181818,0x80191919,
+0x80191919,0x80181818,0x80191919,0x801e1e1e,0x80212121,0x80191919,
+0x80050505,0x800e0e0e,0x80040404,0x80151515,0x80181818,0x80181818,
+0x80171717,0x80191919,0x801b1b1b,0x801d1d1d,0x801c1c1c,0x800c0c0c,
+0x800e0e0e,0x800b0b0b,0x800c0c0c,0x80191919,0x80171717,0x80171717,
+0x80181818,0x801c1c1c,0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801f1f1f,
+0x801f1f1f,0x801a1a1a,0x80181818,0x80191919,0x80191919,0x80181818,
+0x801a1a1a,0x801d1d1d,0x801f1f1f,0x801f1f1f,0x801f1f1f,0x801e1e1e,
+0x801c1c1c,0x801a1a1a,0x80171717,0x80191919,0x80191919,0x80151515,
+0x800d0d0d,0x80040404,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80010101,0x80000000,0x80010101,0x80020202,0x80010101,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80030303,0x800a0a0a,0x80171717,0x801f1f1f,0x801d1d1d,
+0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801c1c1c,0x801a1a1a,0x80191919,
+0x80181818,0x80171717,0x80181818,0x801c1c1c,0x801e1e1e,0x801d1d1d,
+0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801a1a1a,0x80191718,0x801b1b1b,0x801c1c1c,0x801f1f1f,0x80616163,0x80959597,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f9092,0x808f8f91,0x808f8e93,0x80908f94,0x808f8e93,0x808f8f91,
+0x802b2b2b,0x801f1d1e,0x801c1c1c,0x80181818,0x80161616,0x80181818,
+0x801a1a1a,0x80191919,0x801c1c1c,0x80202020,0x80202020,0x80181818,
+0x80070707,0x80121212,0x80080808,0x80151515,0x80181818,0x80181818,
+0x80161616,0x801c1c1c,0x80202020,0x801e1e1e,0x801d1d1d,0x800b0b0b,
+0x800a0a0a,0x80080808,0x800b0b0b,0x80181818,0x80171717,0x80171717,
+0x801a1a1a,0x801f1f1f,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801f1f1f,
+0x801d1d1d,0x80181818,0x80161616,0x80181818,0x80191919,0x80191919,
+0x801d1d1d,0x801f1f1f,0x80202020,0x801f1f1f,0x801d1d1d,0x801c1c1c,
+0x801a1a1a,0x80181818,0x80191919,0x80191919,0x80191919,0x801c1c1c,
+0x801e1e1e,0x801b1b1b,0x80121212,0x80090909,0x80010101,0x80000000,
+0x80000000,0x80020202,0x80010101,0x80000000,0x80000000,0x80010101,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80010101,0x80000000,
+0x80000000,0x80000000,0x80000000,0x800e0e0e,0x801e1e1e,0x80202020,
+0x801e1e1e,0x801f1f1f,0x801d1d1d,0x801a1a1a,0x80191919,0x80181818,
+0x80181818,0x80171717,0x801a1a1a,0x801e1e1e,0x80212121,0x801f1f1f,
+0x801d1d1d,0x801d1d1d,0x801b1b1b,0x80171717,0x80191718,0x80202020,0x801f1f1f,0x80323234,0x808d8d8f,0x808d8d8f,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f9092,0x808f8f91,0x808f8e93,0x80908f94,0x808f8e93,0x808e8e90,
+0x802a2a2a,0x801d1b1c,0x80181818,0x80191919,0x80181818,0x80171717,
+0x80191919,0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801c1c1c,
+0x80010101,0x80010101,0x80000000,0x80131313,0x80181818,0x801a1a1a,
+0x80191919,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x80202020,0x80080808,
+0x80000000,0x80000000,0x800d0d0d,0x80171717,0x80171717,0x801b1b1b,
+0x801e1e1e,0x801f1f1f,0x801d1d1d,0x80202020,0x801e1e1e,0x801a1a1a,
+0x80181818,0x80181818,0x80181818,0x80171717,0x80191919,0x801d1d1d,
+0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801c1c1c,0x801a1a1a,
+0x80191919,0x80181818,0x80181818,0x80191919,0x801b1b1b,0x801e1e1e,
+0x80202020,0x80212121,0x801e1e1e,0x801a1a1a,0x80101010,0x80070707,
+0x80000000,0x80000000,0x80010101,0x80020202,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80010101,
+0x80000000,0x80000000,0x80000000,0x80020202,0x800f0f0f,0x80202020,
+0x80202020,0x801c1c1c,0x80191919,0x80191919,0x80191919,0x80171717,
+0x80171717,0x801c1c1c,0x801d1d1d,0x801d1d1d,0x801f1f1f,0x80202020,
+0x801e1e1e,0x80191919,0x80171717,0x80181818,0x80232122,0x801d1d1d,0x80222224,0x80606062,0x80939395,0x808f8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f9092,0x808f8f91,0x808f8e93,0x80908f94,0x808e8d92,0x808d8d8f,
+0x80282828,0x801a1819,0x80171717,0x80191919,0x801a1a1a,0x80191919,
+0x801c1c1c,0x80202020,0x80202020,0x801d1d1d,0x801e1e1e,0x801a1a1a,
+0x80020202,0x80030303,0x80000000,0x800e0e0e,0x800f0f0f,0x80111111,
+0x80171717,0x80171717,0x80141414,0x80121212,0x80131313,0x80030303,
+0x80030303,0x80020202,0x800c0c0c,0x80181818,0x801a1a1a,0x801f1f1f,
+0x80202020,0x801f1f1f,0x801d1d1d,0x801f1f1f,0x801b1b1b,0x80181818,
+0x80161616,0x80181818,0x80191919,0x80191919,0x801c1c1c,0x801f1f1f,
+0x801f1f1f,0x801f1f1f,0x801d1d1d,0x801c1c1c,0x80191919,0x80181818,
+0x80181818,0x80191919,0x80191919,0x801d1d1d,0x80212121,0x80202020,
+0x801e1e1e,0x801d1d1d,0x801c1c1c,0x801b1b1b,0x80181818,0x80161616,
+0x800f0f0f,0x80050505,0x80000000,0x80000000,0x80020202,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80020202,
+0x80000000,0x80000000,0x80020202,0x80000000,0x80020202,0x80151515,
+0x801d1d1d,0x801b1b1b,0x80181818,0x80171717,0x80191919,0x80181818,
+0x801a1a1a,0x801f1f1f,0x801f1f1f,0x801d1d1d,0x801d1d1d,0x801e1e1e,
+0x801b1b1b,0x80171717,0x80161616,0x80191919,0x80222021,0x801c1c1e,0x802e2e30,0x80868688,0x808e8e90,0x80909092,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808e8f91,0x808f8f91,0x808f8e93,0x80908f94,0x808e8d92,0x808d8d8f,
+0x80262626,0x80181617,0x80181818,0x80181818,0x80191919,0x801d1d1d,
+0x80202020,0x801f1f1f,0x801e1e1e,0x801f1f1f,0x801d1d1d,0x80131313,
+0x80060606,0x80121212,0x80050505,0x80030303,0x80000000,0x80000000,
+0x80010101,0x80000000,0x80010101,0x80010101,0x80000000,0x80000000,
+0x80101010,0x800a0a0a,0x80090909,0x801b1b1b,0x801e1e1e,0x801e1e1e,
+0x801e1e1e,0x80202020,0x801e1e1e,0x801c1c1c,0x80171717,0x80191919,
+0x80181818,0x80171717,0x80191919,0x801e1e1e,0x80202020,0x801e1e1e,
+0x80202020,0x801e1e1e,0x801c1c1c,0x801a1a1a,0x80181818,0x80171717,
+0x80181818,0x801a1a1a,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801e1e1e,
+0x801f1f1f,0x801e1e1e,0x801a1a1a,0x80161616,0x80171717,0x80181818,
+0x801a1a1a,0x80181818,0x800d0d0d,0x80010101,0x80000000,0x80010101,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80010101,0x80000000,0x80000000,0x80040404,
+0x80141414,0x801a1a1a,0x801a1a1a,0x80151515,0x80171717,0x801c1c1c,
+0x801d1d1d,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801d1d1d,0x80191919,
+0x80171717,0x80181818,0x80181818,0x80171717,0x801b191c,0x801f1f21,0x80535355,0x80939395,0x80919193,0x808e8e90,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f9092,0x808f8f91,0x808f8e93,0x80908f94,0x808e8d92,0x808d8d8f,
+0x80262626,0x80181617,0x80191919,0x80191919,0x801c1c1c,0x801f1f1f,
+0x80202020,0x801e1e1e,0x801d1d1d,0x801d1d1d,0x801b1b1b,0x80111111,
+0x80030303,0x80090909,0x80000000,0x80030303,0x80070707,0x80060606,
+0x80070707,0x80050505,0x80070707,0x80050505,0x80030303,0x80000000,
+0x80070707,0x80010101,0x800b0b0b,0x801d1d1d,0x801f1f1f,0x801e1e1e,
+0x801d1d1d,0x801f1f1f,0x801b1b1b,0x80191919,0x80171717,0x80191919,
+0x80191919,0x80191919,0x801c1c1c,0x80202020,0x80202020,0x801e1e1e,
+0x801e1e1e,0x801c1c1c,0x801a1a1a,0x80191919,0x80181818,0x80181818,
+0x801a1a1a,0x801c1c1c,0x801f1f1f,0x80202020,0x80202020,0x801e1e1e,
+0x801b1b1b,0x80181818,0x80171717,0x80181818,0x801a1a1a,0x80151515,
+0x80171717,0x801f1f1f,0x801f1f1f,0x80141414,0x80070707,0x80010101,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80010101,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80010101,0x80010101,0x80000000,
+0x80080808,0x80151515,0x80191919,0x80171717,0x801a1a1a,0x801e1e1e,
+0x801e1e1e,0x801d1d1d,0x801e1e1e,0x801e1e1e,0x801b1b1b,0x80171717,
+0x80161616,0x80181818,0x80191919,0x80191919,0x80211f22,0x801f1f21,0x807a7a7c,0x80909092,0x808c8c8e,0x80919193,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f9092,0x808f8f91,0x808f8e93,0x80908f94,0x808e8d92,0x808d8d8f,
+0x80272727,0x80191718,0x80191919,0x801e1e1e,0x80202020,0x801e1e1e,
+0x801d1d1d,0x801f1f1f,0x801d1d1d,0x80181818,0x80161616,0x80191919,
+0x80030303,0x80000000,0x80010101,0x80181818,0x80202020,0x801e1e1e,
+0x801e1e1e,0x801f1f1f,0x80191919,0x80161616,0x80191919,0x80050505,
+0x80000000,0x80000000,0x80101010,0x801d1d1d,0x801d1d1d,0x801f1f1f,
+0x801e1e1e,0x801c1c1c,0x80171717,0x80171717,0x80191919,0x80181818,
+0x80191919,0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801e1e1e,
+0x801c1c1c,0x801a1a1a,0x80181818,0x80181818,0x80191919,0x801a1a1a,
+0x801c1c1c,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801e1e1e,
+0x801c1c1c,0x80181818,0x80171717,0x80191919,0x80151515,0x801d1d1d,
+0x80202020,0x801c1c1c,0x801e1e1e,0x80222222,0x801a1a1a,0x800c0c0c,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80010101,
+0x80000000,0x80000000,0x80010101,0x80000000,0x80000000,0x80020202,
+0x80000000,0x800d0d0d,0x80161616,0x801a1a1a,0x801e1e1e,0x801f1f1f,
+0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801a1a1a,0x80171717,0x80181818,
+0x80191919,0x80171717,0x80191919,0x801e1e1e,0x801f1f1f,0x8038383a,0x808e8e90,0x80909092,0x808f8e93,0x808d8e92,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x80919095,0x808d8c91,0x80908f94,0x80919095,
+0x80919095,0x808f8e93,0x808d8c91,0x80929196,0x808f9092,0x808f9092,
+0x808f9092,0x808e8f91,0x808d8e90,0x808d8e90,0x808e8f91,0x808f9092,
+0x808e8f93,0x808e8f93,0x808e8f93,0x808e8f93,0x808e8f93,0x808e8f93,
+0x808e8f93,0x808e8f93,0x808d8e92,0x808e8f93,0x808f9094,0x808e8f93,
+0x808e8f93,0x808f9094,0x808f9094,0x808d8e92,0x808e8f93,0x808f9094,
+0x808f9094,0x808e8f93,0x808e8f93,0x808e8f93,0x808f9094,0x808f9094,
+0x808e8f93,0x808f9094,0x80909195,0x808e8f91,0x808d8e90,0x808c8d8f,
+0x8028292b,0x80151618,0x80202020,0x801e1e1e,0x801e1e1e,0x801f1f1f,
+0x801f1f1f,0x801c1c1c,0x80191919,0x80191919,0x80181818,0x80151515,
+0x80030303,0x800c0c0c,0x80020202,0x801c1c1c,0x801e1e1e,0x801f1f1f,
+0x801c1c1c,0x801b1b1b,0x80181818,0x80171717,0x80191919,0x80090909,
+0x80070707,0x80050505,0x800e0e0e,0x801e1e1e,0x801d1d1d,0x801f1f1f,
+0x801b1b1b,0x80171717,0x80171717,0x80191919,0x80171717,0x801a1a1a,
+0x801d1d1d,0x801e1e1e,0x801f1f1f,0x80202020,0x801e1e1e,0x801c1c1c,
+0x80181818,0x80191919,0x80191919,0x80181818,0x80191919,0x801c1c1c,
+0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801f1f1f,0x801c1c1c,0x80181818,
+0x80171717,0x80191919,0x80181818,0x80161616,0x801c1c1c,0x801e1e1e,
+0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801b1b1b,0x80161616,
+0x800f0f0f,0x80020202,0x80000000,0x80020202,0x80000000,0x80000000,
+0x80010101,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80010101,0x80121212,0x80202020,0x801f1f1f,0x801c1c1c,
+0x801e1e1e,0x801f1f1f,0x80181818,0x801a1a1a,0x801a1a1a,0x80171717,
+0x80171717,0x801a1a1a,0x801d1d1d,0x801e1e1e,0x801b1b1b,0x80545456,0x808f8f91,0x80909092,0x80908f94,0x808e8f93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808e8d92,0x808f8e93,0x80919095,0x808c8b90,
+0x808d8c91,0x80919095,0x808f8e93,0x808e8d92,0x808e8d92,0x808f8e93,
+0x80908f94,0x80919095,0x80919095,0x80908f94,0x808f8e93,0x808d8c91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x80908f94,0x80908f94,0x80908f94,
+0x80908f94,0x80908f94,0x80908f94,0x80919095,0x80908f94,0x808f8e93,
+0x808f8e93,0x80908f94,0x80908f94,0x80908f94,0x808f8e93,0x80908f94,
+0x80908f94,0x80908f94,0x80908f94,0x808f8e93,0x808f8e93,0x808e8d92,
+0x80919095,0x808e8d92,0x80909092,0x80919193,0x80919193,0x808e8e90,
+0x8028282a,0x801d1d1f,0x801e1e1e,0x80202020,0x80202020,0x801e1e1e,
+0x801c1c1c,0x801a1a1a,0x80191919,0x80181818,0x801a1a1a,0x80131313,
+0x80070707,0x80161616,0x80060606,0x801b1b1b,0x801f1f1f,0x801d1d1d,
+0x801b1b1b,0x80151515,0x80181818,0x801b1b1b,0x80161616,0x800a0a0a,
+0x80121212,0x800e0e0e,0x800d0d0d,0x80202020,0x801e1e1e,0x801b1b1b,
+0x80181818,0x80181818,0x80191919,0x80171717,0x801a1a1a,0x801d1d1d,
+0x801f1f1f,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801c1c1c,0x801a1a1a,
+0x80191919,0x80181818,0x80171717,0x80191919,0x801c1c1c,0x801e1e1e,
+0x801f1f1f,0x801e1e1e,0x801f1f1f,0x801b1b1b,0x80191919,0x80191919,
+0x80181818,0x80161616,0x80181818,0x801b1b1b,0x801e1e1e,0x801d1d1d,
+0x801d1d1d,0x80202020,0x801f1f1f,0x801a1a1a,0x80181818,0x80191919,
+0x80181818,0x80121212,0x80050505,0x80000000,0x80020202,0x80010101,
+0x80000000,0x80030303,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80010101,0x80000000,0x80080808,0x80171717,0x80202020,0x801f1f1f,
+0x801c1c1c,0x801b1b1b,0x801a1a1a,0x80181818,0x80171717,0x80181818,
+0x801b1b1b,0x801d1d1d,0x801e1e1e,0x801f1f1f,0x80191919,0x80777779,0x808f8f91,0x808f8f91,0x80908f94,0x808f9094,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x80919095,0x808e8d92,0x808f8e93,0x80908f94,
+0x80919095,0x80908f94,0x808e8d92,0x808f8e93,0x80908f94,0x808f8e93,
+0x808e8d92,0x808e8d92,0x808e8d92,0x808f8e93,0x80908f94,0x80908f94,
+0x808e8e90,0x808e8e90,0x808f8f91,0x808f8f91,0x808f8f91,0x808f8f91,
+0x808f8f91,0x808f8f91,0x808f8f91,0x80909092,0x808f8f91,0x808e8e90,
+0x808e8e90,0x808f8f91,0x808f8f91,0x808f8f91,0x808f8f91,0x808f8f91,
+0x808f8f91,0x808f8f91,0x808f8f91,0x808f8f91,0x808f8f91,0x808e8e90,
+0x80908f94,0x808e8e90,0x808f8f91,0x808f8f91,0x808d8d8f,0x808d8d8f,
+0x80272729,0x80212123,0x801e1e1e,0x80202020,0x80202020,0x801c1c1c,
+0x80181818,0x80181818,0x80181818,0x80171717,0x80181818,0x80181818,
+0x80000000,0x80030303,0x80010101,0x801d1d1d,0x801d1d1d,0x801b1b1b,
+0x80191919,0x80181818,0x80161616,0x80181818,0x801c1c1c,0x80090909,
+0x80040404,0x80010101,0x800e0e0e,0x801f1f1f,0x801c1c1c,0x80191919,
+0x80161616,0x80181818,0x80191919,0x80191919,0x801d1d1d,0x801f1f1f,
+0x80202020,0x801f1f1f,0x801d1d1d,0x801c1c1c,0x801a1a1a,0x80181818,
+0x80191919,0x80171717,0x80181818,0x801d1d1d,0x801f1f1f,0x801f1f1f,
+0x801e1e1e,0x801e1e1e,0x801c1c1c,0x80191919,0x80181818,0x80181818,
+0x80171717,0x80171717,0x801a1a1a,0x801f1f1f,0x801e1e1e,0x801d1d1d,
+0x801e1e1e,0x801e1e1e,0x801c1c1c,0x80171717,0x80171717,0x80191919,
+0x80181818,0x801c1c1c,0x80171717,0x80090909,0x80000000,0x80000000,
+0x80010101,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80020202,0x80000000,0x80000000,0x800c0c0c,0x801d1d1d,0x80202020,
+0x80191919,0x80181818,0x801a1a1a,0x80171717,0x80171717,0x801a1a1a,
+0x801e1e1e,0x801e1e1e,0x801e1e1e,0x80202020,0x80232323,0x808c8c8e,0x808e8e90,0x808f8f91,0x808e8d92,0x808f9094,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x80908f94,0x80908f94,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x80908f94,0x808f8e93,
+0x80908f94,0x80908f94,0x808f8e93,0x808f8e93,0x808f8e93,0x80908f94,
+0x80909092,0x808f8f91,0x808f8f91,0x808f8f91,0x808f8f91,0x808f8f91,
+0x808f8f91,0x808e8e90,0x808f8f91,0x808f8f91,0x80909092,0x80909092,
+0x80909092,0x80909092,0x808f8f91,0x808f8f91,0x80909092,0x808f8f91,
+0x808f8f91,0x808e8e90,0x808f8f91,0x808f8f91,0x80909092,0x80919193,
+0x80909092,0x80909092,0x80919193,0x808f8f91,0x808f8f91,0x80909092,
+0x802c2c2c,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801c1c1c,0x80191919,
+0x80171717,0x80181818,0x80191919,0x80181818,0x801b1b1b,0x801e1e1e,
+0x80010101,0x80000000,0x80010101,0x801c1c1c,0x801b1b1b,0x80181818,
+0x80181818,0x801a1a1a,0x80161616,0x80181818,0x80202020,0x80090909,
+0x80000000,0x80000000,0x800f0f0f,0x801b1b1b,0x80181818,0x80191919,
+0x80181818,0x80171717,0x80191919,0x801d1d1d,0x801e1e1e,0x801f1f1f,
+0x801f1f1f,0x801e1e1e,0x801c1c1c,0x801a1a1a,0x80191919,0x80181818,
+0x80181818,0x80191919,0x801d1d1d,0x80202020,0x80202020,0x801e1e1e,
+0x801d1d1d,0x801e1e1e,0x80181818,0x80191919,0x80181818,0x80161616,
+0x80171717,0x801b1b1b,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x80202020,
+0x801e1e1e,0x801a1a1a,0x80171717,0x80181818,0x80191919,0x80181818,
+0x80171717,0x801d1d1d,0x80222222,0x80191919,0x80090909,0x80010101,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80040404,0x80141414,0x801b1b1b,
+0x80181818,0x80181818,0x80171717,0x80181818,0x801a1a1a,0x801d1d1d,
+0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x803a3a3a,0x80909092,0x808f8f91,0x80909092,0x808e8d92,0x808e8f93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x80929196,0x808f8e93,0x808e8d92,0x80908f94,
+0x80908f94,0x808e8d92,0x808e8d92,0x80919095,0x80908f94,0x808e8d92,
+0x808e8d92,0x808f8e93,0x80908f94,0x808f8e93,0x808e8d92,0x808e8d92,
+0x80909092,0x808f8f91,0x808f8f91,0x808f8f91,0x80909092,0x80909092,
+0x80909092,0x80909092,0x80919193,0x80919193,0x80909092,0x80909092,
+0x80909092,0x808f8f91,0x808f8f91,0x808f8f91,0x80909092,0x80909092,
+0x808f8f91,0x808f8f91,0x808f8f91,0x808f8f91,0x808f8f91,0x808f8f91,
+0x808e8e90,0x808f8f91,0x80919193,0x80919193,0x80909092,0x808b8b8b,
+0x80313131,0x801d1d1d,0x801f1f1f,0x801c1c1c,0x80181818,0x80171717,
+0x80181818,0x80181818,0x80191919,0x801b1b1b,0x80202020,0x80181818,
+0x80090909,0x80141414,0x80060606,0x80151515,0x801a1a1a,0x80141414,
+0x80181818,0x80171717,0x801c1c1c,0x80202020,0x801d1d1d,0x800c0c0c,
+0x800f0f0f,0x800f0f0f,0x800d0d0d,0x80181818,0x80161616,0x80191919,
+0x80191919,0x80191919,0x801b1b1b,0x80202020,0x801f1f1f,0x801f1f1f,
+0x801d1d1d,0x801c1c1c,0x80191919,0x80181818,0x80181818,0x80191919,
+0x80191919,0x801c1c1c,0x801f1f1f,0x80202020,0x801f1f1f,0x801e1e1e,
+0x801c1c1c,0x801a1a1a,0x80171717,0x80181818,0x80171717,0x80171717,
+0x801a1a1a,0x801e1e1e,0x80202020,0x801e1e1e,0x801f1f1f,0x801f1f1f,
+0x801c1c1c,0x80171717,0x80161616,0x80191919,0x801a1a1a,0x80191919,
+0x801f1f1f,0x801f1f1f,0x801c1c1c,0x801f1f1f,0x801e1e1e,0x800b0b0b,
+0x80000000,0x80020202,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80080808,0x80141414,
+0x80191919,0x80181818,0x80171717,0x801b1b1b,0x801e1e1e,0x801f1f1f,
+0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801c1c1c,0x80575757,0x808d8d8f,0x80909092,0x80919193,0x808f8e93,0x808e8f93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808e8d92,0x80919095,0x80908f94,0x808f8e93,
+0x808f8e93,0x808f8e93,0x80908f94,0x808e8d92,0x807a7a7c,0x806b6b6d,
+0x80575759,0x8048484a,0x80404042,0x803b3b3d,0x8039393b,0x8039393b,
+0x80373737,0x80373737,0x80373737,0x80383838,0x803a3a3a,0x803b3b3b,
+0x803c3c3c,0x803b3b3b,0x803d3d3d,0x803b3b3b,0x80383838,0x80373737,
+0x80363636,0x80373737,0x80383838,0x803a3a3a,0x803b3b3b,0x803c3c3c,
+0x803c3c3c,0x803c3c3c,0x803a3a3a,0x80393939,0x80373737,0x80373737,
+0x8039393b,0x8038383a,0x80373739,0x8039393b,0x803c3c3c,0x80404040,
+0x801e1e1e,0x80202020,0x801c1c1c,0x801a1a1a,0x80181818,0x80181818,
+0x80181818,0x80181818,0x801b1b1b,0x801f1f1f,0x801f1f1f,0x80181818,
+0x80050505,0x800e0e0e,0x80040404,0x80141414,0x801c1c1c,0x80191919,
+0x80181818,0x801a1a1a,0x801d1d1d,0x80202020,0x801e1e1e,0x80090909,
+0x80080808,0x80070707,0x800a0a0a,0x80191919,0x80171717,0x80181818,
+0x801a1a1a,0x801d1d1d,0x801f1f1f,0x801f1f1f,0x80202020,0x801e1e1e,
+0x801c1c1c,0x801a1a1a,0x80181818,0x80171717,0x80181818,0x801a1a1a,
+0x801c1c1c,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801d1d1d,
+0x801b1b1b,0x80171717,0x80191919,0x80161616,0x80171717,0x801b1b1b,
+0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801a1a1a,
+0x80171717,0x80181818,0x80191919,0x80191919,0x801a1a1a,0x801d1d1d,
+0x80202020,0x801f1f1f,0x801d1d1d,0x801e1e1e,0x801f1f1f,0x80151515,
+0x80080808,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80010101,0x800d0d0d,
+0x80171717,0x80181818,0x801a1a1a,0x801d1d1d,0x801e1e1e,0x801e1e1e,
+0x801f1f1f,0x801f1f1f,0x801c1c1c,0x80181818,0x806d6d6d,0x808e8e90,0x80909092,0x808f8f91,0x80908f94,0x808e8f93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x80908f94,0x80929196,0x808e8d92,0x808f8e93,
+0x80929196,0x80858489,0x805e5d62,0x80333237,0x80242424,0x80202020,
+0x801e1e1e,0x801f1f1f,0x80202020,0x801e1e1e,0x801a1a1a,0x80181818,
+0x80181818,0x80181818,0x80191919,0x801b1b1b,0x801e1e1e,0x801f1f1f,
+0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801b1b1b,0x80181818,0x80181818,
+0x80181818,0x80191919,0x801b1b1b,0x801e1e1e,0x801f1f1f,0x80202020,
+0x80202020,0x801f1f1f,0x801c1c1c,0x801a1a1a,0x80191919,0x80191919,
+0x80151517,0x8019191b,0x801d1d1f,0x80202020,0x801e1e1e,0x801e1e1e,
+0x801c1c1c,0x80202020,0x80191919,0x80191919,0x80181818,0x80191919,
+0x80191919,0x801b1b1b,0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801e1e1e,
+0x80000000,0x80000000,0x80010101,0x80131313,0x80181818,0x80191919,
+0x801b1b1b,0x801f1f1f,0x801d1d1d,0x801d1d1d,0x80202020,0x800a0a0a,
+0x80020202,0x80000000,0x800a0a0a,0x80191919,0x80181818,0x801b1b1b,
+0x801d1d1d,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801c1c1c,
+0x801a1a1a,0x80191919,0x80181818,0x80181818,0x801a1a1a,0x801c1c1c,
+0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801c1c1c,0x801b1b1b,
+0x80181818,0x80161616,0x80181818,0x80181818,0x801a1a1a,0x801f1f1f,
+0x80202020,0x801e1e1e,0x801d1d1d,0x801e1e1e,0x801b1b1b,0x80181818,
+0x80171717,0x80191919,0x801a1a1a,0x801a1a1a,0x801c1c1c,0x80202020,
+0x801b1b1b,0x801e1e1e,0x80222222,0x801c1c1c,0x80151515,0x801a1a1a,
+0x80171717,0x80040404,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80010101,0x80000000,0x80000000,0x80000000,0x80000000,0x80060606,
+0x80121212,0x801a1a1a,0x801d1d1d,0x801e1e1e,0x801e1e1e,0x801e1e1e,
+0x801e1e1e,0x801c1c1c,0x801a1a1a,0x80181818,0x80787878,0x80909092,0x808f8f91,0x808c8c8e,0x80919095,0x808e8f93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x80908f94,0x808e8d92,0x80919095,0x80908f94,
+0x8068676c,0x802d2c31,0x8017161b,0x801d1c21,0x80201f1d,0x801f1e1c,
+0x801f1e1c,0x80201f1d,0x801e1d1b,0x801a1917,0x80181715,0x80191816,
+0x80191718,0x801a1819,0x801b191a,0x801e1c1d,0x80201e1f,0x80211f20,
+0x80201e1f,0x801f1d1e,0x801b191a,0x80191718,0x80181617,0x80191718,
+0x801a1819,0x801b191a,0x801e1c1d,0x80211f20,0x801f1d1e,0x801f1d1e,
+0x801f1d1e,0x801c1a1b,0x80191718,0x80181617,0x80191718,0x801a1819,
+0x801a181b,0x801f1d20,0x801f1d20,0x80201e1f,0x80201e1f,0x801d1b1c,
+0x80222021,0x80161415,0x80191919,0x80181818,0x80171717,0x80181818,
+0x801b1b1b,0x801f1f1f,0x801f1f1f,0x801d1d1d,0x801d1d1d,0x80191919,
+0x80030303,0x80080808,0x80000000,0x80070707,0x800a0a0a,0x80080808,
+0x800c0c0c,0x80080808,0x800c0c0c,0x800e0e0e,0x800b0b0b,0x80000000,
+0x80080808,0x80040404,0x800d0d0d,0x80181818,0x80171717,0x801e1e1e,
+0x80202020,0x801e1e1e,0x801d1d1d,0x801f1f1f,0x801c1c1c,0x801a1a1a,
+0x80181818,0x80181818,0x80191919,0x801a1a1a,0x801c1c1c,0x801f1f1f,
+0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801a1a1a,0x80171717,
+0x80161616,0x80181818,0x80161616,0x801b1b1b,0x801f1f1f,0x801f1f1f,
+0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801c1c1c,0x80161616,0x80191919,
+0x80191919,0x80181818,0x80191919,0x801d1d1d,0x80202020,0x801f1f1f,
+0x801e1e1e,0x80202020,0x801d1d1d,0x80181818,0x80181818,0x801a1a1a,
+0x80181818,0x80141414,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80010101,0x80010101,0x80000000,0x80010101,
+0x800d0d0d,0x801c1c1c,0x801e1e1e,0x801f1f1f,0x80202020,0x801f1f1f,
+0x801c1c1c,0x80181818,0x80181818,0x801a1a1a,0x80868688,0x808e8d92,0x808e8d92,0x80919095,0x808f8f91,0x808f9092,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808e8e90,0x80909092,0x80919193,0x80646464,
+0x801a1a1a,0x801e1c1d,0x801b191a,0x80222021,0x801e1e1e,0x80202020,
+0x80202020,0x801c1c1c,0x80181818,0x80181818,0x80181818,0x80181818,
+0x80171717,0x801c1c1c,0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801e1e1e,
+0x801d1d1d,0x801a1a1a,0x80181818,0x80191919,0x80181818,0x80171717,
+0x801b1b1b,0x801f1f1f,0x801f1f1f,0x801d1d1d,0x801f1f1f,0x801f1f1f,
+0x801c1c1c,0x80181818,0x80171717,0x80181818,0x80191919,0x80191919,
+0x80202020,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801c1c1c,
+0x80191919,0x80191919,0x80191919,0x80171717,0x80181818,0x801c1c1c,
+0x80202020,0x80202020,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x80151515,
+0x80020202,0x80141414,0x80020202,0x80020202,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80010101,0x80000000,0x80010101,
+0x800e0e0e,0x80090909,0x80090909,0x801c1c1c,0x801d1d1d,0x801f1f1f,
+0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801c1c1c,0x80181818,0x80191919,
+0x80191919,0x80181818,0x80191919,0x801c1c1c,0x801f1f1f,0x801f1f1f,
+0x801e1e1e,0x801f1f1f,0x801c1c1c,0x80181818,0x80171717,0x80191919,
+0x80181818,0x80161616,0x801c1c1c,0x801e1e1e,0x801e1e1e,0x801e1e1e,
+0x801f1f1f,0x801f1f1f,0x801b1b1b,0x80161616,0x80191919,0x80171717,
+0x80171717,0x801b1b1b,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801f1f1f,
+0x80202020,0x801b1b1b,0x80181818,0x80191919,0x80191919,0x80181818,
+0x80191919,0x801c1c1c,0x80161616,0x80010101,0x80000000,0x80020202,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80010101,0x80010101,0x80030303,0x80000000,
+0x80040404,0x80191919,0x801f1f1f,0x801e1e1e,0x80202020,0x801d1d1d,
+0x80171717,0x80171717,0x80191919,0x80181818,0x808a8a8c,0x808f8e93,0x808e8d92,0x80908f94,0x808e8e90,0x808e8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x80919193,0x80909092,0x80767678,0x80222222,
+0x80171717,0x801b191a,0x80222021,0x801f1d1e,0x80202020,0x801e1e1e,
+0x801c1c1c,0x801a1a1a,0x80191919,0x80181818,0x80181818,0x80191919,
+0x801c1c1c,0x801d1d1d,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801d1d1d,
+0x801b1b1b,0x80181818,0x80191919,0x80171717,0x80181818,0x801b1b1b,
+0x801e1e1e,0x801d1d1d,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801a1a1a,
+0x80181818,0x80191919,0x80191919,0x80181818,0x80191919,0x801e1e1e,
+0x801e1e1e,0x80202020,0x80202020,0x801e1e1e,0x801c1c1c,0x801a1a1a,
+0x80191919,0x80181818,0x80171717,0x80191919,0x801c1c1c,0x801d1d1d,
+0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x80171717,0x80161616,
+0x80030303,0x80000000,0x80000000,0x80080808,0x80101010,0x800e0e0e,
+0x800d0d0d,0x80121212,0x800f0f0f,0x800e0e0e,0x800c0c0c,0x80010101,
+0x80010101,0x80000000,0x800d0d0d,0x801e1e1e,0x801d1d1d,0x801f1f1f,
+0x801f1f1f,0x801f1f1f,0x801c1c1c,0x80181818,0x80191919,0x80181818,
+0x80171717,0x80191919,0x801c1c1c,0x801e1e1e,0x801f1f1f,0x801e1e1e,
+0x801f1f1f,0x801b1b1b,0x80191919,0x80191919,0x80181818,0x80161616,
+0x80181818,0x801b1b1b,0x801e1e1e,0x801d1d1d,0x801d1d1d,0x80202020,
+0x801f1f1f,0x801a1a1a,0x80181818,0x80191919,0x80171717,0x80191919,
+0x801b1b1b,0x801d1d1d,0x801d1d1d,0x801e1e1e,0x801f1f1f,0x801f1f1f,
+0x801b1b1b,0x801a1a1a,0x80191919,0x80181818,0x80181818,0x80191919,
+0x801c1c1c,0x801f1f1f,0x801e1e1e,0x800f0f0f,0x80050505,0x80000000,
+0x80000000,0x80020202,0x80000000,0x80010101,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80010101,0x80000000,0x80010101,0x80000000,
+0x80010101,0x800e0e0e,0x80202020,0x801e1e1e,0x801b1b1b,0x801a1a1a,
+0x80181818,0x80181818,0x80191919,0x80181818,0x808d8d8f,0x80919095,0x808f8e93,0x808f8e93,0x808e8e90,0x808f9092,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808e8e90,0x80909092,0x80424244,0x80181818,
+0x801a1a1a,0x80262425,0x801c1a1b,0x80201e1f,0x80202020,0x801c1c1c,
+0x80181818,0x80181818,0x80181818,0x80181818,0x80191919,0x801c1c1c,
+0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801a1a1a,
+0x80181818,0x80171717,0x80181818,0x80181818,0x801a1a1a,0x801e1e1e,
+0x801f1f1f,0x801d1d1d,0x801d1d1d,0x801f1f1f,0x801c1c1c,0x80181818,
+0x80161616,0x80181818,0x801a1a1a,0x80191919,0x801c1c1c,0x80202020,
+0x801e1e1e,0x80202020,0x80202020,0x801c1c1c,0x80181818,0x80181818,
+0x80181818,0x80171717,0x80181818,0x801c1c1c,0x801f1f1f,0x801f1f1f,
+0x801e1e1e,0x801e1e1e,0x801d1d1d,0x801b1b1b,0x80181818,0x80161616,
+0x80030303,0x80000000,0x80030303,0x80181818,0x801f1f1f,0x801d1d1d,
+0x801e1e1e,0x801e1e1e,0x80191919,0x80191919,0x80191919,0x80070707,
+0x80000000,0x80000000,0x800f0f0f,0x801f1f1f,0x801f1f1f,0x801f1f1f,
+0x801e1e1e,0x801d1d1d,0x801a1a1a,0x80161616,0x80191919,0x80171717,
+0x80181818,0x801d1d1d,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801e1e1e,
+0x801c1c1c,0x80191919,0x80181818,0x80181818,0x80171717,0x80171717,
+0x801a1a1a,0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801e1e1e,0x801e1e1e,
+0x801c1c1c,0x80171717,0x80171717,0x80191919,0x80171717,0x801b1b1b,
+0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801c1c1c,
+0x80181818,0x80191919,0x80191919,0x80181818,0x80181818,0x801c1c1c,
+0x801e1e1e,0x801f1f1f,0x80202020,0x801c1c1c,0x800b0b0b,0x80000000,
+0x80000000,0x80020202,0x80000000,0x80010101,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80030303,0x801a1a1a,0x801e1e1e,0x80181818,0x80171717,
+0x80191919,0x80181818,0x801a1a1a,0x801b1b1b,0x808e8e90,0x80919095,0x808f8e93,0x80908f94,0x808f8f91,0x80909193,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x80909092,0x807f7f81,0x801f1f21,0x801f1f1f,
+0x80202020,0x801e1c1d,0x801f1d1e,0x80222021,0x801c1c1c,0x801a1a1a,
+0x80181818,0x80171717,0x80171717,0x80181818,0x801b1b1b,0x801f1f1f,
+0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801d1d1d,0x801a1a1a,0x80171717,
+0x80171717,0x80191919,0x80171717,0x801b1b1b,0x801e1e1e,0x801e1e1e,
+0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801b1b1b,0x80181818,0x80191919,
+0x80181818,0x80171717,0x80191919,0x801d1d1d,0x801f1f1f,0x801e1e1e,
+0x801f1f1f,0x801e1e1e,0x801c1c1c,0x80191919,0x80171717,0x80181818,
+0x80191919,0x80181818,0x801c1c1c,0x801d1d1d,0x801f1f1f,0x801f1f1f,
+0x801f1f1f,0x801e1e1e,0x801b1b1b,0x80171717,0x801a1a1a,0x80111111,
+0x80010101,0x800f0f0f,0x80040404,0x801e1e1e,0x801e1e1e,0x801f1f1f,
+0x801e1e1e,0x80191919,0x80171717,0x80181818,0x80171717,0x80080808,
+0x80090909,0x80070707,0x800e0e0e,0x801f1f1f,0x80202020,0x801f1f1f,
+0x801b1b1b,0x80191919,0x80181818,0x80181818,0x80181818,0x80191919,
+0x801d1d1d,0x80202020,0x80202020,0x801e1e1e,0x801d1d1d,0x801e1e1e,
+0x80181818,0x80191919,0x80181818,0x80161616,0x80171717,0x801b1b1b,
+0x801f1f1f,0x801f1f1f,0x801e1e1e,0x80202020,0x801e1e1e,0x801a1a1a,
+0x80171717,0x80181818,0x80191919,0x80181818,0x801b1b1b,0x801d1d1d,
+0x801e1e1e,0x801f1f1f,0x80202020,0x801f1f1f,0x801c1c1c,0x80181818,
+0x80191919,0x80181818,0x80181818,0x80191919,0x801c1c1c,0x801f1f1f,
+0x801f1f1f,0x801d1d1d,0x801e1e1e,0x801e1e1e,0x80121212,0x80030303,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80010101,
+0x80000000,0x80000000,0x800d0d0d,0x801b1b1b,0x80181818,0x80161616,
+0x80181818,0x80181818,0x801d1d1d,0x801f1f1f,0x808e8e90,0x80908f94,0x80908f94,0x80908f94,0x80909092,0x808f9092,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x80909092,0x8068686a,0x801c1c1e,0x801c1c1c,
+0x801f1f1f,0x801a1819,0x80252324,0x801d1b1c,0x80181818,0x80191919,
+0x80181818,0x80171717,0x80181818,0x801b1b1b,0x801e1e1e,0x801f1f1f,
+0x801d1d1d,0x801e1e1e,0x801e1e1e,0x801a1a1a,0x80171717,0x80161616,
+0x80181818,0x80191919,0x801b1b1b,0x801e1e1e,0x801f1f1f,0x801e1e1e,
+0x801e1e1e,0x801e1e1e,0x801b1b1b,0x80171717,0x80171717,0x80191919,
+0x801a1a1a,0x80191919,0x801c1c1c,0x80202020,0x80202020,0x801d1d1d,
+0x801f1f1f,0x801c1c1c,0x80181818,0x80171717,0x80181818,0x80181818,
+0x80191919,0x801b1b1b,0x80202020,0x801e1e1e,0x801e1e1e,0x801f1f1f,
+0x801d1d1d,0x801a1a1a,0x80181818,0x80171717,0x80191919,0x80151515,
+0x80060606,0x80131313,0x80040404,0x801e1e1e,0x801e1e1e,0x80212121,
+0x801a1a1a,0x801a1a1a,0x801a1a1a,0x80191919,0x80181818,0x80080808,
+0x800d0d0d,0x800d0d0d,0x800e0e0e,0x801f1f1f,0x801e1e1e,0x801d1d1d,
+0x80191919,0x80171717,0x80171717,0x80191919,0x80191919,0x801c1c1c,
+0x801f1f1f,0x80202020,0x801f1f1f,0x801e1e1e,0x801c1c1c,0x801a1a1a,
+0x80171717,0x80181818,0x80171717,0x80171717,0x801a1a1a,0x801e1e1e,
+0x80202020,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801c1c1c,0x80171717,
+0x80161616,0x80191919,0x801a1a1a,0x80191919,0x801e1e1e,0x801d1d1d,
+0x801e1e1e,0x80202020,0x80202020,0x801d1d1d,0x80191919,0x80171717,
+0x80191919,0x80181818,0x80181818,0x801c1c1c,0x801f1f1f,0x80202020,
+0x801e1e1e,0x801d1d1d,0x801c1c1c,0x801b1b1b,0x80181818,0x800f0f0f,
+0x80020202,0x80000000,0x80010101,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80010101,0x80000000,0x80000000,0x80010101,0x80000000,0x80000000,
+0x80010101,0x80000000,0x80030303,0x80151515,0x80191919,0x80181818,
+0x80191919,0x801b1b1b,0x801f1f1f,0x80202020,0x808f8f91,0x808f8e93,0x80908f94,0x80908f94,0x808f8f91,0x808e8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808e8e90,0x80565658,0x80202022,0x801e1e1e,
+0x801e1e1e,0x80252324,0x801e1c1d,0x80171516,0x80181818,0x80181818,
+0x80181818,0x80181818,0x801b1b1b,0x801f1f1f,0x80202020,0x801e1e1e,
+0x801e1e1e,0x801d1d1d,0x801a1a1a,0x80171717,0x80161616,0x80181818,
+0x80191919,0x80191919,0x801f1f1f,0x801d1d1d,0x801d1d1d,0x801f1f1f,
+0x801e1e1e,0x801a1a1a,0x80181818,0x80181818,0x80181818,0x80181818,
+0x80191919,0x801d1d1d,0x80202020,0x801f1f1f,0x801e1e1e,0x801f1f1f,
+0x801c1c1c,0x801a1a1a,0x80181818,0x80181818,0x80181818,0x80181818,
+0x801b1b1b,0x801f1f1f,0x80202020,0x801f1f1f,0x801e1e1e,0x801e1e1e,
+0x801a1a1a,0x80171717,0x80171717,0x80191919,0x80161616,0x80171717,
+0x80020202,0x80000000,0x80000000,0x801a1a1a,0x801e1e1e,0x801a1a1a,
+0x80151515,0x80191919,0x80171717,0x80141414,0x801b1b1b,0x80070707,
+0x80010101,0x80000000,0x80101010,0x801e1e1e,0x801a1a1a,0x801a1a1a,
+0x80181818,0x80171717,0x80181818,0x80191919,0x801c1c1c,0x801e1e1e,
+0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801d1d1d,0x801b1b1b,0x80171717,
+0x80191919,0x80161616,0x80171717,0x801b1b1b,0x801e1e1e,0x801e1e1e,
+0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801a1a1a,0x80171717,0x80181818,
+0x80191919,0x80191919,0x801a1a1a,0x801d1d1d,0x801f1f1f,0x801e1e1e,
+0x801f1f1f,0x801f1f1f,0x801d1d1d,0x80181818,0x80171717,0x80191919,
+0x80181818,0x80191919,0x801c1c1c,0x801f1f1f,0x80202020,0x801e1e1e,
+0x801d1d1d,0x801e1e1e,0x801a1a1a,0x80171717,0x80191919,0x80171717,
+0x80070707,0x80000000,0x80010101,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80010101,0x80000000,0x80000000,0x80010101,0x80000000,0x80000000,
+0x80000000,0x80010101,0x80000000,0x800e0e0e,0x80191919,0x801a1a1a,
+0x801b1b1b,0x801e1e1e,0x801f1f1f,0x801d1d1d,0x808f8f91,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8f91,0x808e8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x80909092,0x8048484a,0x80202022,0x801c1c1c,
+0x801f1f1f,0x801e1c1d,0x80181617,0x80181617,0x80181818,0x80181818,
+0x80191919,0x801b1b1b,0x801e1e1e,0x80202020,0x801f1f1f,0x801e1e1e,
+0x801d1d1d,0x801b1b1b,0x80181818,0x80171717,0x80181818,0x80191919,
+0x801b1b1b,0x801c1c1c,0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801e1e1e,
+0x801b1b1b,0x80181818,0x80171717,0x80191919,0x80191919,0x80191919,
+0x801c1c1c,0x801f1f1f,0x80202020,0x801e1e1e,0x801d1d1d,0x801d1d1d,
+0x80191919,0x80191919,0x80181818,0x80191919,0x80191919,0x801b1b1b,
+0x801d1d1d,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801b1b1b,
+0x80181818,0x80171717,0x80181818,0x801a1a1a,0x801c1c1c,0x801c1c1c,
+0x80020202,0x80030303,0x80040404,0x801b1b1b,0x801e1e1e,0x80171717,
+0x80191919,0x80191919,0x80181818,0x80171717,0x80202020,0x800b0b0b,
+0x80050505,0x80010101,0x800f0f0f,0x801c1c1c,0x80181818,0x80181818,
+0x80181818,0x80181818,0x801a1a1a,0x801c1c1c,0x801f1f1f,0x801f1f1f,
+0x801e1e1e,0x801d1d1d,0x801c1c1c,0x801b1b1b,0x80181818,0x80161616,
+0x80181818,0x80181818,0x801a1a1a,0x801f1f1f,0x80202020,0x801e1e1e,
+0x801d1d1d,0x801e1e1e,0x801b1b1b,0x80181818,0x80171717,0x80191919,
+0x801a1a1a,0x801a1a1a,0x801c1c1c,0x80202020,0x801f1f1f,0x801f1f1f,
+0x801e1e1e,0x801c1c1c,0x80191919,0x80171717,0x80171717,0x80191919,
+0x80191919,0x801c1c1c,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801d1d1d,
+0x801c1c1c,0x801b1b1b,0x80181818,0x80181818,0x80171717,0x80191919,
+0x80111111,0x80030303,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80010101,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80010101,0x80060606,0x80171717,0x801e1e1e,
+0x801d1d1d,0x80202020,0x801e1e1e,0x801d1d1d,0x808f8f91,0x80908f94,0x80908f94,0x808f8e93,0x80909092,0x80909193,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8f91,0x8049494b,0x801d1d1f,0x80232323,
+0x801c1c1c,0x80191718,0x801b191a,0x801b191a,0x80181818,0x80191919,
+0x801c1c1c,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x80202020,
+0x801a1a1a,0x80181818,0x80171717,0x80191919,0x80191919,0x80191919,
+0x801c1c1c,0x80212121,0x801d1d1d,0x801f1f1f,0x801f1f1f,0x801b1b1b,
+0x80171717,0x80181818,0x80191919,0x80181818,0x80191919,0x801e1e1e,
+0x80202020,0x801e1e1e,0x801d1d1d,0x801f1f1f,0x801d1d1d,0x80181818,
+0x80191919,0x80181818,0x80171717,0x80181818,0x801b1b1b,0x801f1f1f,
+0x801f1f1f,0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801b1b1b,0x80171717,
+0x80171717,0x80191919,0x801a1a1a,0x80181818,0x801e1e1e,0x801b1b1b,
+0x80050505,0x801a1a1a,0x80070707,0x80171717,0x80171717,0x80171717,
+0x80191919,0x80151515,0x801c1c1c,0x801d1d1d,0x801d1d1d,0x800b0b0b,
+0x80121212,0x80101010,0x800b0b0b,0x801a1a1a,0x80181818,0x80191919,
+0x80171717,0x80181818,0x801c1c1c,0x80202020,0x801f1f1f,0x801e1e1e,
+0x801e1e1e,0x801e1e1e,0x801a1a1a,0x80171717,0x80161616,0x80181818,
+0x80161616,0x801b1b1b,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801f1f1f,
+0x801e1e1e,0x801c1c1c,0x80161616,0x80191919,0x80191919,0x80181818,
+0x80191919,0x801d1d1d,0x80202020,0x801f1f1f,0x801f1f1f,0x801f1f1f,
+0x801c1c1c,0x80181818,0x80171717,0x80191919,0x80191919,0x80171717,
+0x801c1c1c,0x801f1f1f,0x801f1f1f,0x801d1d1d,0x801d1d1d,0x801e1e1e,
+0x801b1b1b,0x80161616,0x80171717,0x801b1b1b,0x80161616,0x801b1b1b,
+0x801d1d1d,0x800c0c0c,0x80000000,0x80010101,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80020202,0x80000000,0x80000000,0x80020202,0x80000000,
+0x80010101,0x80000000,0x80010101,0x80000000,0x80171717,0x80202020,
+0x801d1d1d,0x80202020,0x801d1d1d,0x801f1f1f,0x808f8f91,0x808f8e93,0x80908f94,0x80908f94,0x808f8f91,0x808f9092,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808d8d8f,0x8049494b,0x80212121,0x801c1c1a,
+0x80181816,0x80171715,0x80191919,0x80181818,0x80171717,0x801c1c1c,
+0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801e1e1e,0x801d1d1d,0x801a1a1a,
+0x80181818,0x80191919,0x80181818,0x80171717,0x801b1b1b,0x801f1f1f,
+0x801f1f1f,0x801d1d1d,0x801f1f1f,0x801f1f1f,0x801c1c1c,0x80181818,
+0x80171717,0x80181818,0x80191919,0x80191919,0x80202020,0x801e1e1e,
+0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801c1c1c,0x80191919,0x80191919,
+0x80191919,0x80171717,0x80181818,0x801c1c1c,0x80202020,0x80202020,
+0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801a1a1a,0x80171717,0x80191919,
+0x80191919,0x80171717,0x801a1a1a,0x801f1f1f,0x801e1e1e,0x801c1c1c,
+0x80010101,0x80080808,0x80050505,0x80151515,0x80191919,0x80181818,
+0x80171717,0x801a1a1a,0x801c1c1c,0x801f1f1f,0x80202020,0x80090909,
+0x80040404,0x80050505,0x800a0a0a,0x801a1a1a,0x80181818,0x80181818,
+0x80181818,0x801c1c1c,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801f1f1f,
+0x801c1c1c,0x80181818,0x80171717,0x80191919,0x80181818,0x80161616,
+0x801c1c1c,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801f1f1f,
+0x801b1b1b,0x80161616,0x80191919,0x80171717,0x80171717,0x801b1b1b,
+0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801f1f1f,0x80202020,0x801b1b1b,
+0x80181818,0x80191919,0x80191919,0x80181818,0x80191919,0x801c1c1c,
+0x80202020,0x801e1e1e,0x801d1d1d,0x801e1e1e,0x801d1d1d,0x80191919,
+0x80181818,0x80191919,0x801a1a1a,0x80151515,0x801b1b1b,0x801e1e1e,
+0x80202020,0x80161616,0x80010101,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80010101,0x80000000,0x80000000,0x80010101,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80020202,0x800e0e0e,0x801e1e1e,
+0x801e1e1e,0x80222021,0x801e1c1d,0x80181617,0x808f8f91,0x808f8e93,0x80908f94,0x80908f94,0x808f8f91,0x808e8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8f91,0x80474749,0x801c1c1c,0x801a1a18,
+0x80191917,0x80181816,0x80191919,0x80181818,0x801c1c1c,0x801d1d1d,
+0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801d1d1d,0x801b1b1b,0x80181818,
+0x80191919,0x80171717,0x80181818,0x801b1b1b,0x801e1e1e,0x801d1d1d,
+0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801a1a1a,0x80181818,0x80191919,
+0x80191919,0x80181818,0x80191919,0x801e1e1e,0x801e1e1e,0x80202020,
+0x80202020,0x801e1e1e,0x801c1c1c,0x801a1a1a,0x80191919,0x80181818,
+0x80171717,0x80191919,0x801c1c1c,0x801d1d1d,0x801e1e1e,0x801f1f1f,
+0x801e1e1e,0x801e1e1e,0x801a1a1a,0x801a1a1a,0x80181818,0x80171717,
+0x80181818,0x801b1b1b,0x801e1e1e,0x801e1e1e,0x801d1d1d,0x801d1d1d,
+0x80030303,0x80000000,0x80000000,0x80121212,0x801a1a1a,0x80171717,
+0x801a1a1a,0x801c1c1c,0x801f1f1f,0x801e1e1e,0x801b1b1b,0x80080808,
+0x80050505,0x80000000,0x800b0b0b,0x80191919,0x80161616,0x80191919,
+0x801c1c1c,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801f1f1f,0x801b1b1b,
+0x80191919,0x80191919,0x80181818,0x80161616,0x80181818,0x801b1b1b,
+0x801e1e1e,0x801d1d1d,0x801d1d1d,0x80202020,0x801f1f1f,0x801a1a1a,
+0x80181818,0x80191919,0x80171717,0x80191919,0x801b1b1b,0x801d1d1d,
+0x801d1d1d,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801b1b1b,0x801a1a1a,
+0x80191919,0x80181818,0x80181818,0x80191919,0x801c1c1c,0x801f1f1f,
+0x801e1e1e,0x80202020,0x801f1f1f,0x801b1b1b,0x801a1a1a,0x801a1a1a,
+0x80191919,0x80171717,0x80181818,0x801a1a1a,0x801e1e1e,0x801d1d1d,
+0x801f1f1f,0x801d1d1d,0x800c0c0c,0x80000000,0x80010101,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80010101,0x80000000,0x80070707,0x801c1c1c,
+0x801f1f1f,0x801d1b1c,0x801a1819,0x801b191a,0x808f8f91,0x808f8e93,0x80908f94,0x80908f94,0x808f8f91,0x808e8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x80919193,0x80464648,0x80191919,0x80181816,
+0x80191917,0x80171715,0x80191919,0x801a1a1a,0x801f1f1f,0x801e1e1e,
+0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801a1a1a,0x80181818,0x80171717,
+0x80181818,0x80181818,0x801a1a1a,0x801e1e1e,0x801f1f1f,0x801d1d1d,
+0x801d1d1d,0x801f1f1f,0x801c1c1c,0x80181818,0x80161616,0x80181818,
+0x801a1a1a,0x80191919,0x801c1c1c,0x80202020,0x801e1e1e,0x80202020,
+0x80202020,0x801c1c1c,0x80181818,0x80181818,0x80181818,0x80171717,
+0x80181818,0x801c1c1c,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801e1e1e,
+0x801d1d1d,0x801b1b1b,0x80171717,0x80181818,0x80181818,0x80171717,
+0x801a1a1a,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801f1f1f,0x80191919,
+0x80060606,0x80090909,0x80030303,0x80040404,0x80060606,0x80070707,
+0x80070707,0x80080808,0x800a0a0a,0x80070707,0x80070707,0x80010101,
+0x800a0a0a,0x80060606,0x800b0b0b,0x80181818,0x80171717,0x801c1c1c,
+0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801c1c1c,0x80191919,
+0x80181818,0x80181818,0x80171717,0x80171717,0x801a1a1a,0x801f1f1f,
+0x801e1e1e,0x801d1d1d,0x801e1e1e,0x801e1e1e,0x801c1c1c,0x80171717,
+0x80171717,0x80191919,0x80171717,0x801b1b1b,0x801e1e1e,0x801e1e1e,
+0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801c1c1c,0x80181818,0x80191919,
+0x80191919,0x80181818,0x80181818,0x801c1c1c,0x801e1e1e,0x801f1f1f,
+0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801a1a1a,0x80181818,0x80191919,
+0x80191919,0x80171717,0x801a1a1a,0x801f1f1f,0x80212121,0x801d1d1d,
+0x801e1e1e,0x801f1f1f,0x80131313,0x80010101,0x80010101,0x80010101,
+0x80000000,0x80000000,0x80000000,0x80010101,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80010101,0x80000000,0x80010101,0x80161616,
+0x801e1e1e,0x801a1819,0x80181617,0x801b191a,0x808f8f91,0x808f8e93,0x80908f94,0x80908f94,0x808f8f91,0x808e8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8f91,0x80454547,0x80191919,0x80181816,
+0x80171715,0x80171715,0x801b1b1b,0x801e1e1e,0x801e1e1e,0x801e1e1e,
+0x801f1f1f,0x801d1d1d,0x801a1a1a,0x80171717,0x80171717,0x80191919,
+0x80171717,0x801b1b1b,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801f1f1f,
+0x801e1e1e,0x801b1b1b,0x80181818,0x80191919,0x80181818,0x80171717,
+0x80191919,0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801f1f1f,0x801e1e1e,
+0x801c1c1c,0x80191919,0x80171717,0x80181818,0x80191919,0x80181818,
+0x801c1c1c,0x801d1d1d,0x801f1f1f,0x801f1f1f,0x801f1f1f,0x801e1e1e,
+0x801b1b1b,0x80171717,0x80191919,0x80171717,0x80171717,0x801c1c1c,
+0x801e1e1e,0x801d1d1d,0x801e1e1e,0x801f1f1f,0x80202020,0x80141414,
+0x80050505,0x800d0d0d,0x80070707,0x80000000,0x80000000,0x80010101,
+0x80000000,0x80010101,0x80010101,0x80000000,0x80020202,0x80000000,
+0x800a0a0a,0x80090909,0x800a0a0a,0x801a1a1a,0x801b1b1b,0x801f1f1f,
+0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801d1d1d,0x80181818,0x80191919,
+0x80181818,0x80161616,0x80171717,0x801b1b1b,0x801f1f1f,0x801f1f1f,
+0x801e1e1e,0x80202020,0x801e1e1e,0x801a1a1a,0x80171717,0x80181818,
+0x80191919,0x80181818,0x801b1b1b,0x801d1d1d,0x801e1e1e,0x801f1f1f,
+0x80202020,0x801f1f1f,0x801c1c1c,0x80181818,0x80191919,0x80181818,
+0x80181818,0x80191919,0x801c1c1c,0x801f1f1f,0x801f1f1f,0x801d1d1d,
+0x801e1e1e,0x801b1b1b,0x801a1a1a,0x801a1a1a,0x80181818,0x80161616,
+0x80181818,0x801b1b1b,0x801e1e1e,0x80202020,0x801e1e1e,0x801f1f1f,
+0x801e1e1e,0x801b1b1b,0x80151515,0x80070707,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80010101,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80010101,0x80000000,0x800d0d0d,
+0x80191919,0x801a1819,0x801a1819,0x80181617,0x80909092,0x808f8e93,0x80908f94,0x808f8e93,0x808f8f91,0x808f9092,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808e8e90,0x80454547,0x80191919,0x80171715,
+0x80181816,0x801b1b19,0x801f1f1f,0x801f1f1f,0x801d1d1d,0x801e1e1e,
+0x801e1e1e,0x801a1a1a,0x80171717,0x80161616,0x80181818,0x80191919,
+0x801b1b1b,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801e1e1e,
+0x801b1b1b,0x80171717,0x80171717,0x80191919,0x801a1a1a,0x80191919,
+0x801c1c1c,0x80202020,0x80202020,0x801d1d1d,0x801f1f1f,0x801c1c1c,
+0x80181818,0x80171717,0x80181818,0x80181818,0x80191919,0x801b1b1b,
+0x80202020,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801d1d1d,0x801a1a1a,
+0x80181818,0x80171717,0x80191919,0x80181818,0x801a1a1a,0x801e1e1e,
+0x80202020,0x801f1f1f,0x801d1d1d,0x801e1e1e,0x801b1b1b,0x80141414,
+0x80010101,0x80000000,0x80000000,0x800c0c0c,0x80131313,0x80131313,
+0x80121212,0x80151515,0x80131313,0x80101010,0x80111111,0x80020202,
+0x80010101,0x80000000,0x800b0b0b,0x801e1e1e,0x801e1e1e,0x801f1f1f,
+0x801e1e1e,0x801e1e1e,0x801c1c1c,0x801a1a1a,0x80171717,0x80181818,
+0x80171717,0x80171717,0x801a1a1a,0x801e1e1e,0x80202020,0x801e1e1e,
+0x801f1f1f,0x801f1f1f,0x801c1c1c,0x80171717,0x80161616,0x80191919,
+0x801a1a1a,0x80191919,0x801e1e1e,0x801d1d1d,0x801e1e1e,0x80202020,
+0x80202020,0x801d1d1d,0x80191919,0x80171717,0x80191919,0x80181818,
+0x80181818,0x801c1c1c,0x801f1f1f,0x80202020,0x801e1e1e,0x801d1d1d,
+0x801d1d1d,0x801a1a1a,0x80181818,0x80181818,0x80181818,0x80171717,
+0x801a1a1a,0x801e1e1e,0x801d1d1d,0x801e1e1e,0x801c1c1c,0x801e1e1e,
+0x801b1b1b,0x80181818,0x80181818,0x80101010,0x80000000,0x80000000,
+0x80010101,0x80000000,0x80000000,0x80010101,0x80000000,0x80010101,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80030303,0x80000000,0x80060606,
+0x80151515,0x801a1819,0x801b191a,0x80181617,0x80919193,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8f91,0x808f9092,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8f91,0x80454547,0x80181818,0x80181816,
+0x801b1b19,0x801f1f1d,0x80212121,0x801e1e1e,0x801e1e1e,0x801d1d1d,
+0x801a1a1a,0x80171717,0x80161616,0x80181818,0x80191919,0x80191919,
+0x801f1f1f,0x801d1d1d,0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801a1a1a,
+0x80181818,0x80181818,0x80181818,0x80181818,0x80191919,0x801d1d1d,
+0x80202020,0x801f1f1f,0x801e1e1e,0x801f1f1f,0x801c1c1c,0x801a1a1a,
+0x80181818,0x80181818,0x80181818,0x80181818,0x801b1b1b,0x801f1f1f,
+0x80202020,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801a1a1a,0x80171717,
+0x80171717,0x80191919,0x80171717,0x801b1b1b,0x801e1e1e,0x801d1d1d,
+0x801f1f1f,0x80212121,0x801f1f1f,0x801a1a1a,0x80171717,0x80161616,
+0x80030303,0x80020202,0x80000000,0x801a1a1a,0x80212121,0x801e1e1e,
+0x801f1f1f,0x801f1f1f,0x801b1b1b,0x80191919,0x801a1a1a,0x80050505,
+0x80010101,0x80010101,0x800e0e0e,0x801f1f1f,0x801e1e1e,0x801e1e1e,
+0x801d1d1d,0x801d1d1d,0x801a1a1a,0x80161616,0x80191919,0x80161616,
+0x80171717,0x801b1b1b,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801f1f1f,
+0x801f1f1f,0x801a1a1a,0x80171717,0x80181818,0x80191919,0x80191919,
+0x801a1a1a,0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801f1f1f,0x801f1f1f,
+0x801d1d1d,0x80181818,0x80171717,0x80191919,0x80181818,0x80191919,
+0x801c1c1c,0x801f1f1f,0x80202020,0x801e1e1e,0x801d1d1d,0x801e1e1e,
+0x80191919,0x801a1a1a,0x80191919,0x80161616,0x80171717,0x801c1c1c,
+0x801e1e1e,0x801e1e1e,0x801e1e1e,0x80202020,0x801d1d1d,0x801b1b1b,
+0x80181818,0x80171717,0x801a1a1a,0x80151515,0x80040404,0x80000000,
+0x80010101,0x80010101,0x80000000,0x80010101,0x80000000,0x80010101,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80010101,0x80010101,0x80000000,0x80020202,
+0x80131313,0x80191718,0x801a1819,0x801c1a1b,0x80919193,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8f91,0x808f9092,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8f91,0x80454547,0x80191919,0x801b1b19,
+0x801e1e1c,0x801f1f1d,0x80202020,0x801e1e1e,0x801d1d1d,0x801b1b1b,
+0x80181818,0x80171717,0x80181818,0x80191919,0x801b1b1b,0x801c1c1c,
+0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801e1e1e,0x801b1b1b,0x80181818,
+0x80171717,0x80191919,0x80191919,0x80191919,0x801c1c1c,0x801f1f1f,
+0x80202020,0x801e1e1e,0x801d1d1d,0x801d1d1d,0x80191919,0x80191919,
+0x80181818,0x80191919,0x80191919,0x801b1b1b,0x801d1d1d,0x801f1f1f,
+0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801b1b1b,0x80181818,0x80171717,
+0x80181818,0x801a1a1a,0x801a1a1a,0x801e1e1e,0x801f1f1f,0x801e1e1e,
+0x801d1d1d,0x801f1f1f,0x801c1c1c,0x80181818,0x80171717,0x80151515,
+0x80050505,0x800f0f0f,0x80060606,0x801d1d1d,0x801d1d1d,0x801d1d1d,
+0x801e1e1e,0x801b1b1b,0x80171717,0x80171717,0x80191919,0x80090909,
+0x800b0b0b,0x800d0d0d,0x800f0f0f,0x801f1f1f,0x801e1e1e,0x801e1e1e,
+0x801c1c1c,0x801b1b1b,0x80191919,0x80171717,0x80181818,0x80181818,
+0x801a1a1a,0x801f1f1f,0x80202020,0x801e1e1e,0x801d1d1d,0x801e1e1e,
+0x801b1b1b,0x80181818,0x80171717,0x80191919,0x801a1a1a,0x801a1a1a,
+0x801c1c1c,0x80202020,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801c1c1c,
+0x80191919,0x80171717,0x80171717,0x80191919,0x80191919,0x801c1c1c,
+0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801c1c1c,0x801b1b1b,
+0x80181818,0x80191919,0x80191919,0x80181818,0x801a1a1a,0x801e1e1e,
+0x801f1f1f,0x801e1e1e,0x801f1f1f,0x80202020,0x801c1c1c,0x80181818,
+0x80181818,0x80181818,0x80191919,0x80191919,0x800d0d0d,0x80000000,
+0x80000000,0x80010101,0x80000000,0x80010101,0x80000000,0x80010101,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80020202,0x80000000,0x80000000,0x80000000,
+0x800f0f0f,0x80191718,0x801b191a,0x80201e1f,0x80919193,0x808f8e93,0x80908f94,0x80908f94,0x808f8f91,0x808e8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8f91,0x80444446,0x801b1b1b,0x801e1e1c,
+0x801f1f1d,0x801d1d1b,0x801e1e1e,0x801f1f1f,0x801a1a1a,0x80181818,
+0x80171717,0x80191919,0x80191919,0x80191919,0x801c1c1c,0x80212121,
+0x801d1d1d,0x801f1f1f,0x801f1f1f,0x801b1b1b,0x80171717,0x80181818,
+0x80191919,0x80181818,0x80191919,0x801e1e1e,0x80202020,0x801e1e1e,
+0x801d1d1d,0x801f1f1f,0x801d1d1d,0x80181818,0x80191919,0x80181818,
+0x80171717,0x80181818,0x801b1b1b,0x801f1f1f,0x801f1f1f,0x801d1d1d,
+0x801f1f1f,0x801e1e1e,0x801b1b1b,0x80171717,0x80171717,0x80191919,
+0x801a1a1a,0x80181818,0x801f1f1f,0x801e1e1e,0x801f1f1f,0x801f1f1f,
+0x801e1e1e,0x801a1a1a,0x80181818,0x80171717,0x80161616,0x80151515,
+0x80020202,0x800e0e0e,0x80020202,0x801d1d1d,0x801d1d1d,0x80212121,
+0x801d1d1d,0x80181818,0x80181818,0x801a1a1a,0x80191919,0x80080808,
+0x800b0b0b,0x80080808,0x800e0e0e,0x801e1e1e,0x801e1e1e,0x801f1f1f,
+0x801b1b1b,0x80171717,0x80171717,0x801a1a1a,0x80161616,0x801b1b1b,
+0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801c1c1c,
+0x80161616,0x80191919,0x80191919,0x80181818,0x80191919,0x801d1d1d,
+0x80202020,0x801f1f1f,0x801f1f1f,0x801f1f1f,0x801c1c1c,0x80181818,
+0x80171717,0x80191919,0x80191919,0x80171717,0x801c1c1c,0x801f1f1f,
+0x801f1f1f,0x801d1d1d,0x801d1d1d,0x801e1e1e,0x801b1b1b,0x80161616,
+0x80191919,0x80171717,0x80171717,0x801b1b1b,0x801e1e1e,0x801e1e1e,
+0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801b1b1b,0x80171717,0x80171717,
+0x801a1a1a,0x80181818,0x80181818,0x801d1d1d,0x80151515,0x80010101,
+0x80000000,0x80000000,0x80000000,0x80010101,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80020202,0x80000000,
+0x800a0a0a,0x801b191a,0x801d1b1c,0x80211f20,0x808f8f91,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8f91,0x808f9092,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x80918f90,0x80484647,0x80222021,0x80201e1f,
+0x801f1d1e,0x801f1e1c,0x801d1c1a,0x801b1a18,0x801a1917,0x80181715,
+0x80171614,0x80191816,0x801c1b19,0x801f1e1c,0x80201f1d,0x80201f1d,
+0x80201f1d,0x801e1d1b,0x801c1b19,0x801b1a18,0x801a1917,0x80191816,
+0x801a1917,0x801a1917,0x801f1e1c,0x801f1e1c,0x801f1e1c,0x80201f1d,
+0x80201f1d,0x801e1d1b,0x801b1a18,0x80181715,0x801a1917,0x80181715,
+0x80191816,0x801d1c1a,0x801f1e1c,0x801f1e1c,0x801f1e1c,0x80201f1d,
+0x801e1c1d,0x801b191a,0x80181617,0x80181617,0x80181617,0x801a1819,
+0x80181715,0x8021201e,0x801d1d1d,0x801d1d1d,0x801f1f1f,0x801f1f1f,
+0x801c1c1c,0x80171717,0x80171717,0x80191919,0x80171717,0x80171717,
+0x80010101,0x80040404,0x80000000,0x801e1e1e,0x80202020,0x801b1b1b,
+0x80181818,0x801a1a1a,0x80161616,0x80171717,0x801c1c1c,0x80060606,
+0x80000000,0x80020202,0x80101010,0x80202020,0x801d1d1d,0x80181818,
+0x80181818,0x801a1a1a,0x80171717,0x80171717,0x801c1c1c,0x801e1e1e,
+0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801b1b1b,0x80161616,
+0x80191919,0x80171717,0x80171717,0x801b1b1b,0x801e1e1e,0x801f1f1f,
+0x801f1f1f,0x801f1f1f,0x80202020,0x801b1b1b,0x80181818,0x80191919,
+0x80191919,0x80181818,0x80191919,0x801c1c1c,0x80202020,0x801e1e1e,
+0x801d1d1d,0x801e1e1e,0x801d1d1d,0x80191919,0x80181818,0x80191919,
+0x80171717,0x80181818,0x801a1a1a,0x801d1d1d,0x801f1f1f,0x801f1f1f,
+0x801e1e1e,0x801e1e1e,0x80181818,0x801a1a1a,0x801a1a1a,0x80171717,
+0x80171717,0x801a1a1a,0x801d1d1d,0x801e1e1e,0x801d1d1d,0x80050505,
+0x80010101,0x80000000,0x80020202,0x80000000,0x80010101,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000100,0x80000000,0x80030303,0x80000000,
+0x80030303,0x801d1d1d,0x801e1e1e,0x80201e1f,0x808f8f91,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8f91,0x808f9092,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x80919191,0x80464646,0x801e1e1e,0x801d1d1d,
+0x801e1e1e,0x80202020,0x801d1d1b,0x80181816,0x80191816,0x80181715,
+0x80191816,0x801a1917,0x801d1c1a,0x801f1e1c,0x80201f1d,0x801f1e1c,
+0x801f1e1c,0x801d1c1a,0x801b1a18,0x80191816,0x80181715,0x80191816,
+0x801a1917,0x801b1a18,0x801f1e1c,0x80201f1d,0x80201f1d,0x801f1e1c,
+0x801e1d1b,0x801b1a18,0x80191816,0x80181715,0x80181715,0x80191816,
+0x801a1917,0x801d1c1a,0x80201f1d,0x80201f1d,0x801f1e1c,0x801f1e1c,
+0x801d1b1c,0x801a1819,0x80181617,0x801b191a,0x801a1819,0x801a1819,
+0x801d1c1a,0x801f1e1c,0x801d1d1d,0x80202020,0x801f1f1f,0x801b1b1b,
+0x80191919,0x80191919,0x80181818,0x80161616,0x801c1c1c,0x80161616,
+0x80010101,0x80090909,0x80020202,0x801c1c1c,0x801b1b1b,0x80191919,
+0x80181818,0x80171717,0x80191919,0x801b1b1b,0x801a1a1a,0x80090909,
+0x80080808,0x80010101,0x800f0f0f,0x801c1c1c,0x801a1a1a,0x80191919,
+0x80181818,0x80181818,0x80171717,0x801d1d1d,0x801e1e1e,0x801d1d1d,
+0x801d1d1d,0x80202020,0x801f1f1f,0x801a1a1a,0x80181818,0x80191919,
+0x80171717,0x80191919,0x801b1b1b,0x801d1d1d,0x801d1d1d,0x801e1e1e,
+0x801f1f1f,0x801f1f1f,0x801b1b1b,0x801a1a1a,0x80191919,0x80181818,
+0x80181818,0x80191919,0x801c1c1c,0x801f1f1f,0x801e1e1e,0x80202020,
+0x801f1f1f,0x801b1b1b,0x801a1a1a,0x801a1a1a,0x80191919,0x80171717,
+0x80181818,0x801c1c1c,0x801e1e1e,0x801d1d1d,0x801d1d1d,0x801f1f1f,
+0x801e1e1e,0x801a1a1a,0x801a1a1a,0x80181818,0x80171717,0x80181818,
+0x801b1b1b,0x801d1d1d,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x800a0a0a,
+0x80010101,0x80000000,0x80010101,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000100,0x80000000,0x80010101,0x80000000,
+0x80020202,0x80191919,0x801f1f1f,0x801f1d1e,0x808f8f91,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8f91,0x808e8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8f91,0x80474749,0x80222222,0x80232323,
+0x801f1f1f,0x801b1b1b,0x80191919,0x80191919,0x80191718,0x801a1819,
+0x801b191a,0x801d1b1c,0x801f1d1e,0x80201e1f,0x801f1d1e,0x801f1d1e,
+0x801d1b1c,0x801c1a1b,0x801a1819,0x80181617,0x80191718,0x801a1819,
+0x801c1a1b,0x801d1b1c,0x801f1d1e,0x80201e1f,0x80201e1f,0x801e1c1d,
+0x801b191a,0x80191718,0x80181617,0x80191718,0x801a1819,0x801b191a,
+0x801d1b1c,0x801f1d1e,0x80201e1f,0x80211f20,0x801f1d1e,0x801d1b1c,
+0x8019171a,0x80181619,0x80181617,0x801c1a1b,0x801b191a,0x801b191a,
+0x80222021,0x80201e1f,0x801f1f1f,0x801f1f1f,0x801d1d1d,0x80191919,
+0x80181818,0x80191919,0x80191919,0x80171717,0x80191919,0x80191919,
+0x800a0a0a,0x80131313,0x80080808,0x80181818,0x80161616,0x80181818,
+0x801a1a1a,0x80181818,0x801a1a1a,0x801c1c1c,0x801c1c1c,0x800e0e0e,
+0x80111111,0x800e0e0e,0x800d0d0d,0x80191919,0x80181818,0x80171717,
+0x80171717,0x80181818,0x80191919,0x80202020,0x801e1e1e,0x801d1d1d,
+0x801e1e1e,0x801e1e1e,0x801c1c1c,0x80171717,0x80171717,0x80191919,
+0x80171717,0x801b1b1b,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801f1f1f,
+0x801e1e1e,0x801c1c1c,0x80181818,0x80191919,0x80191919,0x80181818,
+0x80181818,0x801c1c1c,0x801e1e1e,0x801f1f1f,0x801d1d1d,0x801f1f1f,
+0x801e1e1e,0x801a1a1a,0x80181818,0x80191919,0x80191919,0x80171717,
+0x801a1a1a,0x801e1e1e,0x80212121,0x801f1f1f,0x801d1d1d,0x801d1d1d,
+0x801b1b1b,0x80171717,0x801a1a1a,0x80171717,0x80171717,0x801a1a1a,
+0x801e1e1e,0x801e1e1e,0x801e1e1e,0x80202020,0x801f1f1f,0x80111111,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000201,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80131313,0x801f1f1f,0x801e1c1d,0x808f8f91,0x80908f94,0x808f8e93,0x808f8e93,0x808f8f91,0x808e8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x80909092,0x80464648,0x801c1c1e,0x801c1c1e,
+0x801c1c1c,0x80181818,0x80171717,0x80181818,0x80191919,0x801a1a1a,
+0x801c1c1c,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801d1d1d,
+0x801a1a1a,0x80191919,0x80181818,0x80181818,0x80191919,0x801b1b1b,
+0x801d1d1d,0x801f1f1f,0x801d1d1d,0x801e1e1e,0x801e1e1e,0x801c1c1c,
+0x80191919,0x80171717,0x80171717,0x80181818,0x801b1b1b,0x801d1d1d,
+0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801c1c1c,0x80191919,
+0x801a1a1c,0x8018181a,0x80171719,0x80171717,0x801a1a1a,0x801f1f1f,
+0x801d1d1d,0x801f1f1f,0x80202020,0x801c1c1c,0x80191919,0x80191919,
+0x80181818,0x80171717,0x80181818,0x801b1b1b,0x801f1f1f,0x80191919,
+0x80010101,0x80060606,0x80010101,0x80181818,0x801a1a1a,0x80191919,
+0x80181818,0x801a1a1a,0x801b1b1b,0x801e1e1e,0x80212121,0x80080808,
+0x80010101,0x80020202,0x800a0a0a,0x801a1a1a,0x80181818,0x80151515,
+0x80161616,0x801c1c1c,0x801d1d1d,0x801e1e1e,0x801e1e1e,0x80202020,
+0x801e1e1e,0x801a1a1a,0x80171717,0x80181818,0x80191919,0x80181818,
+0x801b1b1b,0x801d1d1d,0x801e1e1e,0x801f1f1f,0x80202020,0x801f1f1f,
+0x801c1c1c,0x80181818,0x80191919,0x80181818,0x80181818,0x80191919,
+0x801c1c1c,0x801f1f1f,0x801f1f1f,0x801d1d1d,0x801e1e1e,0x801b1b1b,
+0x801a1a1a,0x801a1a1a,0x80181818,0x80161616,0x80181818,0x801b1b1b,
+0x801d1d1d,0x801d1d1d,0x801f1f1f,0x80202020,0x801e1e1e,0x80191919,
+0x80171717,0x80181818,0x80171717,0x80181818,0x801a1a1a,0x801d1d1d,
+0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801d1d1d,0x80161616,
+0x80010101,0x80000000,0x80000000,0x80000000,0x80000000,0x80010101,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000100,0x80000000,0x80000000,0x80010101,
+0x80000000,0x800c0c0c,0x801e1e1e,0x801c1a1b,0x808f8f91,0x80908f94,0x808f8e93,0x808f8e93,0x808f8f91,0x808e8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x80919193,0x80636365,0x8049494b,0x8048484a,
+0x80464648,0x80454547,0x80454547,0x80444444,0x80454547,0x80464648,
+0x80474749,0x8048484a,0x8048484a,0x8048484a,0x80474749,0x80464648,
+0x80444446,0x80444446,0x80444446,0x80444446,0x80454547,0x80474749,
+0x8048484a,0x8049494b,0x80474749,0x80474749,0x80464648,0x80454547,
+0x80444446,0x80444446,0x80444446,0x80454547,0x80464648,0x8048484a,
+0x8049494b,0x8048484a,0x8048484a,0x8048484a,0x80464648,0x80444446,
+0x80454547,0x80434345,0x8048484a,0x80454547,0x804b4b4b,0x804c4c4c,
+0x80222222,0x801f1f1f,0x801d1d1d,0x801a1a1a,0x80181818,0x80181818,
+0x80181818,0x80181818,0x801b1b1b,0x801f1f1f,0x80202020,0x80191919,
+0x80000000,0x80040404,0x80000000,0x80101010,0x80131313,0x80141414,
+0x80141414,0x80191919,0x80191919,0x80191919,0x801b1b1b,0x80060606,
+0x80010101,0x80000000,0x800b0b0b,0x80191919,0x80181818,0x80171717,
+0x80191919,0x801f1f1f,0x801f1f1f,0x801d1d1d,0x801f1f1f,0x801f1f1f,
+0x801c1c1c,0x80171717,0x80161616,0x80191919,0x801a1a1a,0x80191919,
+0x801e1e1e,0x801d1d1d,0x801e1e1e,0x80202020,0x80202020,0x801d1d1d,
+0x80191919,0x80171717,0x80191919,0x80181818,0x80181818,0x801c1c1c,
+0x801f1f1f,0x80202020,0x801e1e1e,0x801d1d1d,0x801d1d1d,0x801a1a1a,
+0x80181818,0x80181818,0x80181818,0x80171717,0x801a1a1a,0x801e1e1e,
+0x801f1f1f,0x801d1d1d,0x801d1d1d,0x801e1e1e,0x801b1b1b,0x80171717,
+0x80161616,0x80191919,0x80171717,0x801b1b1b,0x801e1e1e,0x801f1f1f,
+0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801c1c1c,0x80191919,0x80181818,
+0x80040404,0x80010101,0x80000000,0x80010101,0x80000000,0x80010101,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000100,0x80000000,0x80000000,0x80010101,
+0x80000000,0x80070707,0x801c1c1c,0x801a1819,0x80909092,0x80908f94,0x808f8e93,0x808f8e93,0x80909092,0x808e8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x80908f94,0x808e8d92,0x80919095,0x80919193,
+0x808d8d8f,0x808e8e90,0x80919193,0x80919193,0x808f8f91,0x80909092,
+0x80909092,0x80909092,0x80909092,0x808f8f91,0x808f8f91,0x808f8f91,
+0x808f8f91,0x808f8f91,0x808f8f91,0x808f8f91,0x808f8f91,0x808f8f91,
+0x808f8f91,0x808f8f91,0x80919193,0x80909092,0x808f8f91,0x808f8f91,
+0x808f8f91,0x80909092,0x80909092,0x808f8f91,0x808f8f91,0x80909092,
+0x80909092,0x80909092,0x80909092,0x80909092,0x80909092,0x808f8f91,
+0x808f8f91,0x808d8d8f,0x80929294,0x808e8e90,0x80919193,0x80898989,
+0x80303030,0x80202020,0x80181818,0x801a1a1a,0x80191919,0x80171717,
+0x80181818,0x801c1c1c,0x801f1f1f,0x801f1f1f,0x801c1c1c,0x801b1b1b,
+0x80090909,0x80111111,0x80030303,0x80020202,0x80000000,0x80020202,
+0x80010101,0x80010101,0x80030303,0x80000000,0x80010101,0x80010101,
+0x800d0d0d,0x80090909,0x800c0c0c,0x80161616,0x80171717,0x801c1c1c,
+0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801a1a1a,
+0x80171717,0x80181818,0x80191919,0x80191919,0x801a1a1a,0x801d1d1d,
+0x801f1f1f,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801d1d1d,0x80181818,
+0x80171717,0x80191919,0x80181818,0x80191919,0x801c1c1c,0x801f1f1f,
+0x80202020,0x801e1e1e,0x801d1d1d,0x801e1e1e,0x80191919,0x801a1a1a,
+0x80191919,0x80161616,0x80171717,0x801c1c1c,0x801e1e1e,0x801e1e1e,
+0x801f1f1f,0x801f1f1f,0x801d1d1d,0x80191919,0x80171717,0x80181818,
+0x80181818,0x80171717,0x801a1a1a,0x801d1d1d,0x801e1e1e,0x801e1e1e,
+0x801f1f1f,0x801f1f1f,0x801c1c1c,0x80181818,0x80171717,0x80181818,
+0x80090909,0x80000000,0x80000000,0x80010101,0x80000000,0x80010101,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000100,0x80000000,0x80000000,0x80010101,
+0x80000000,0x80040404,0x80181818,0x80191718,0x80909092,0x808f8e93,0x808f8e93,0x80908f94,0x80909092,0x808e8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808d8c91,0x80908f94,0x80919095,0x80908f94,
+0x80908f94,0x80909092,0x808f8f91,0x808c8c8e,0x80909092,0x80909092,
+0x808f8f91,0x808f8f91,0x808f8f91,0x808f8f91,0x808f8f91,0x808f8f91,
+0x808f8f91,0x808f8f91,0x80909092,0x80909092,0x808f8f91,0x808f8f91,
+0x808f8f91,0x808e8e90,0x80909092,0x80909092,0x80909092,0x80909092,
+0x80909092,0x80909092,0x80909092,0x80909092,0x808f8f91,0x808f8f91,
+0x808f8f91,0x808f8f91,0x808f8f91,0x808f8f91,0x808f8f91,0x80909092,
+0x80909092,0x808e8e90,0x80909092,0x808f8f91,0x80909092,0x808f8f91,
+0x80292929,0x80191919,0x80181818,0x80191919,0x80191919,0x80181818,
+0x801a1a1a,0x801e1e1e,0x80202020,0x801e1e1e,0x80202020,0x801a1a1a,
+0x80020202,0x800a0a0a,0x80010101,0x80020202,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80020202,0x80000000,0x80020202,0x80000000,
+0x800a0a0a,0x80050505,0x800c0c0c,0x80171717,0x801a1a1a,0x801f1f1f,
+0x801e1e1e,0x801f1f1f,0x801d1d1d,0x801e1e1e,0x801b1b1b,0x80181818,
+0x80171717,0x80191919,0x801a1a1a,0x801a1a1a,0x801c1c1c,0x80202020,
+0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801c1c1c,0x80191919,0x80171717,
+0x80171717,0x80191919,0x80191919,0x801c1c1c,0x801e1e1e,0x801f1f1f,
+0x801e1e1e,0x801d1d1d,0x801c1c1c,0x801b1b1b,0x80181818,0x80191919,
+0x80191919,0x80181818,0x801a1a1a,0x801e1e1e,0x801f1f1f,0x801e1e1e,
+0x801e1e1e,0x801e1e1e,0x801b1b1b,0x80171717,0x80161616,0x80181818,
+0x80191919,0x80191919,0x801d1d1d,0x801e1e1e,0x801e1e1e,0x801e1e1e,
+0x801e1e1e,0x801c1c1c,0x801a1a1a,0x80181818,0x80181818,0x80171717,
+0x800f0f0f,0x80000000,0x80000000,0x80010101,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000100,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80020202,0x80151515,0x80191718,0x80909092,0x808f8e93,0x808f8e93,0x80908f94,0x80909092,0x808e8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808e8f93,0x808e8f93,0x808c8d91,0x808e8f93,
+0x80919296,0x808d8e90,0x808c8d8f,0x80919294,0x80909092,0x80909092,
+0x808f8f91,0x808f8f91,0x808f8f91,0x80909092,0x80909092,0x80909092,
+0x808f8f91,0x808f8f91,0x808f8f91,0x80909092,0x80909092,0x808f8f91,
+0x808f8f91,0x808f8f91,0x808f8f91,0x80909092,0x80909092,0x80909092,
+0x808f8f91,0x808e8e90,0x808f8f91,0x808f8f91,0x80909092,0x808f8f91,
+0x808f8f91,0x80909092,0x80909092,0x808e8e90,0x808f8f91,0x80909092,
+0x808f8f91,0x80909092,0x808f8f91,0x80919193,0x808d8d8f,0x808f8f91,
+0x80272727,0x80171717,0x801a1a1a,0x80171717,0x80171717,0x801b1b1b,
+0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801c1c1c,0x80191919,
+0x80000000,0x80030303,0x80000000,0x800c0c0c,0x80151515,0x80191919,
+0x80191919,0x80191919,0x80171717,0x80161616,0x80161616,0x80030303,
+0x80000000,0x80000000,0x800b0b0b,0x801b1b1b,0x801f1f1f,0x801e1e1e,
+0x801c1c1c,0x801f1f1f,0x801d1d1d,0x801b1b1b,0x80161616,0x80191919,
+0x80191919,0x80181818,0x80191919,0x801d1d1d,0x80202020,0x801f1f1f,
+0x801f1f1f,0x801f1f1f,0x801c1c1c,0x80181818,0x80171717,0x80191919,
+0x80191919,0x80171717,0x801c1c1c,0x801f1f1f,0x801f1f1f,0x801d1d1d,
+0x801d1d1d,0x801e1e1e,0x801b1b1b,0x80161616,0x80191919,0x80171717,
+0x80171717,0x801b1b1b,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801f1f1f,
+0x801e1e1e,0x801a1a1a,0x80171717,0x80181818,0x80191919,0x80171717,
+0x80191919,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x80202020,0x801f1f1f,
+0x801c1c1c,0x80181818,0x80181818,0x801a1a1a,0x80191919,0x80171717,
+0x80141414,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000100,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80010101,0x80131313,0x80191718,0x808f8f91,0x808e8d92,0x80908f94,0x808e8d92,0x808f8f91,0x808e8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f9092,0x80909092,0x808f8e93,0x808f8e93,0x808f8e93,0x808e8e90,
+0x80272727,0x801a1819,0x80171717,0x80181818,0x801a1a1a,0x801e1e1e,
+0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801f1f1f,0x80191919,0x80151515,
+0x80010101,0x80050505,0x80000000,0x801a1a1a,0x801e1e1e,0x801d1d1d,
+0x801e1e1e,0x80202020,0x801e1e1e,0x801a1a1a,0x80191919,0x80080808,
+0x80050505,0x80000000,0x800b0b0b,0x80202020,0x801e1e1e,0x801d1d1d,
+0x801e1e1e,0x801f1f1f,0x801a1a1a,0x80161616,0x80191919,0x80171717,
+0x80171717,0x801b1b1b,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801f1f1f,
+0x80202020,0x801b1b1b,0x80181818,0x80191919,0x80191919,0x80181818,
+0x80191919,0x801c1c1c,0x80202020,0x801e1e1e,0x801d1d1d,0x801e1e1e,
+0x801d1d1d,0x80191919,0x80181818,0x80191919,0x80171717,0x80181818,
+0x801a1a1a,0x801d1d1d,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801e1e1e,
+0x80181818,0x801a1a1a,0x801a1a1a,0x80171717,0x80171717,0x801a1a1a,
+0x801d1d1d,0x801e1e1e,0x801d1d1d,0x80202020,0x80202020,0x801c1c1c,
+0x80181818,0x80171717,0x80181818,0x80181818,0x801b191a,0x801d1b1c,
+0x801b191a,0x80000000,0x80000000,0x80000000,0x80010101,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80020202,0x80000000,0x80000000,
+0x80000000,0x80000000,0x800e0e0e,0x801a1a1a,0x808f8f91,0x808e8d92,0x80908f94,0x808e8d92,0x808f8f91,0x808e8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f9092,0x80909092,0x808f8e93,0x808f8e93,0x808f8e93,0x808d8d8f,
+0x80262626,0x80191718,0x80181818,0x801c1c1c,0x801f1f1f,0x801d1d1d,
+0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801a1a1a,0x80171717,0x80131313,
+0x80050505,0x800f0f0f,0x80070707,0x80191919,0x801c1c1c,0x80202020,
+0x801e1e1e,0x801e1e1e,0x801c1c1c,0x80181818,0x80161616,0x80080808,
+0x800c0c0c,0x800e0e0e,0x800e0e0e,0x801f1f1f,0x801e1e1e,0x801f1f1f,
+0x801e1e1e,0x801a1a1a,0x80171717,0x80191919,0x80171717,0x80191919,
+0x801b1b1b,0x801d1d1d,0x801d1d1d,0x801e1e1e,0x801f1f1f,0x801f1f1f,
+0x801b1b1b,0x801a1a1a,0x80191919,0x80181818,0x80181818,0x80191919,
+0x801c1c1c,0x801f1f1f,0x801e1e1e,0x80202020,0x801f1f1f,0x801b1b1b,
+0x801a1a1a,0x801a1a1a,0x80191919,0x80171717,0x80181818,0x801c1c1c,
+0x801e1e1e,0x801d1d1d,0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801a1a1a,
+0x801a1a1a,0x80181818,0x80171717,0x80181818,0x801b1b1b,0x801d1d1d,
+0x801e1e1e,0x801f1f1f,0x80202020,0x801e1e1e,0x801c1c1c,0x801a1a1a,
+0x80191919,0x80181818,0x80181818,0x80191919,0x801d1b1c,0x801f1d1e,
+0x801d1b1c,0x80030303,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80010101,0x80000000,0x80010101,
+0x80000000,0x80010101,0x800f0f0f,0x801d1d1d,0x808f8f91,0x808e8d92,0x80908f94,0x808f8e93,0x808f8f91,0x808e8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808e8f91,0x80909092,0x808f8e93,0x80908f94,0x808f8e93,0x808d8d8f,
+0x80262626,0x80191718,0x801a1a1a,0x801f1f1f,0x80212121,0x801f1f1f,
+0x801d1d1d,0x801e1e1e,0x801b1b1b,0x80171717,0x80191919,0x80151515,
+0x80040404,0x80090909,0x80020202,0x801b1b1b,0x801f1f1f,0x801c1c1c,
+0x801e1e1e,0x801b1b1b,0x80191919,0x80191919,0x80191919,0x80070707,
+0x80070707,0x80050505,0x800f0f0f,0x801f1f1f,0x801e1e1e,0x801e1e1e,
+0x801b1b1b,0x80171717,0x80171717,0x80191919,0x80171717,0x801b1b1b,
+0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801c1c1c,
+0x80181818,0x80191919,0x80191919,0x80181818,0x80181818,0x801c1c1c,
+0x801e1e1e,0x801f1f1f,0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801a1a1a,
+0x80181818,0x80191919,0x80191919,0x80171717,0x801a1a1a,0x801e1e1e,
+0x80212121,0x801f1f1f,0x801d1d1d,0x801d1d1d,0x801b1b1b,0x80171717,
+0x801a1a1a,0x80171717,0x80171717,0x801a1a1a,0x801e1e1e,0x801e1e1e,
+0x801e1e1e,0x80202020,0x80202020,0x801c1c1c,0x80181818,0x80191919,
+0x80191919,0x80181818,0x80191919,0x801c1c1c,0x801f1d1e,0x80211f20,
+0x801e1c1d,0x80050505,0x80010101,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80010101,0x80000000,0x80010101,
+0x80010101,0x80010101,0x800e0e0e,0x801f1f1f,0x80909092,0x808e8d92,0x80908f94,0x808f8e93,0x808f8f91,0x808e8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808e8f91,0x80909092,0x808f8e93,0x808f8e93,0x808f8e93,0x808e8e90,
+0x80272727,0x801b191a,0x801e1e1e,0x801d1d1d,0x801f1f1f,0x80202020,
+0x801e1e1e,0x801a1a1a,0x80181818,0x80191919,0x80181818,0x80141414,
+0x80010101,0x80030303,0x80000000,0x801d1d1d,0x80232323,0x801c1c1c,
+0x801b1b1b,0x80181818,0x80171717,0x80191919,0x801a1a1a,0x80070707,
+0x80020202,0x80000000,0x800e0e0e,0x80202020,0x801e1e1e,0x801a1a1a,
+0x80171717,0x80181818,0x80191919,0x80181818,0x801b1b1b,0x801d1d1d,
+0x801e1e1e,0x801f1f1f,0x80202020,0x801f1f1f,0x801c1c1c,0x80181818,
+0x80191919,0x80181818,0x80181818,0x80191919,0x801c1c1c,0x801f1f1f,
+0x801f1f1f,0x801d1d1d,0x801e1e1e,0x801b1b1b,0x801a1a1a,0x801a1a1a,
+0x80181818,0x80161616,0x80181818,0x801b1b1b,0x801d1d1d,0x801d1d1d,
+0x801f1f1f,0x80202020,0x801e1e1e,0x80191919,0x80171717,0x80181818,
+0x80171717,0x80181818,0x801a1a1a,0x801d1d1d,0x801f1f1f,0x801e1e1e,
+0x801e1e1e,0x801f1f1f,0x801c1c1c,0x801a1a1a,0x80191919,0x80181818,
+0x80181818,0x80191919,0x801b1b1b,0x801f1f1f,0x801f1d1e,0x80201e1f,
+0x801e1c1d,0x80070707,0x80000000,0x80010101,0x80000000,0x80010101,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80010101,
+0x80000000,0x80000000,0x800c0c0c,0x801f1f1f,0x80909092,0x808f8e93,0x808f8e93,0x80908f94,0x808f8f91,0x808e8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f9092,0x80909092,0x808f8e93,0x808f8e93,0x808f8e93,0x808e8e90,
+0x80292929,0x801e1c1d,0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801e1e1e,
+0x801c1c1c,0x80171717,0x80171717,0x80191919,0x80181818,0x80141414,
+0x80060606,0x800f0f0f,0x80060606,0x801a1a1a,0x801d1d1d,0x801c1c1c,
+0x80171717,0x80181818,0x80191919,0x80181818,0x80181818,0x800a0a0a,
+0x800c0c0c,0x800b0b0b,0x800e0e0e,0x801e1e1e,0x801a1a1a,0x80181818,
+0x80161616,0x80191919,0x801a1a1a,0x80181818,0x801e1e1e,0x801d1d1d,
+0x801e1e1e,0x80202020,0x80202020,0x801d1d1d,0x80191919,0x80171717,
+0x80191919,0x80181818,0x80181818,0x801c1c1c,0x801f1f1f,0x80202020,
+0x801e1e1e,0x801d1d1d,0x801d1d1d,0x801a1a1a,0x80181818,0x80181818,
+0x80181818,0x80171717,0x801a1a1a,0x801e1e1e,0x801f1f1f,0x801d1d1d,
+0x801d1d1d,0x801e1e1e,0x801b1b1b,0x80171717,0x80161616,0x80191919,
+0x80171717,0x801b1b1b,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801f1f1f,
+0x801e1e1e,0x801c1c1c,0x80181818,0x80191919,0x80191919,0x80181818,
+0x80191919,0x801c1c1c,0x801e1e1e,0x801f1f1f,0x801f1d1e,0x80201e1f,
+0x801c1a1b,0x80080808,0x80000000,0x80000000,0x80000000,0x80010101,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80010101,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x800a0a0a,0x801e1e1e,0x80909092,0x808f8e93,0x808f8e93,0x80908f94,0x808f8f91,0x808f9092,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f9092,0x80909092,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8f91,
+0x802a2a2a,0x80201e1f,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801a1a1a,
+0x80171717,0x80181818,0x80181818,0x80171717,0x801c1c1c,0x80191919,
+0x80080808,0x800d0d0d,0x80060606,0x801b1b1b,0x801a1a1a,0x80181818,
+0x80181818,0x80191919,0x801a1a1a,0x801a1a1a,0x801b1b1b,0x800c0c0c,
+0x800d0d0d,0x800a0a0a,0x800f0f0f,0x80191919,0x80161616,0x80191919,
+0x80191919,0x80181818,0x801a1a1a,0x801c1c1c,0x801f1f1f,0x801e1e1e,
+0x801f1f1f,0x801f1f1f,0x801d1d1d,0x80181818,0x80171717,0x80191919,
+0x80181818,0x80191919,0x801c1c1c,0x801f1f1f,0x80202020,0x801e1e1e,
+0x801d1d1d,0x801e1e1e,0x80191919,0x801a1a1a,0x80191919,0x80161616,
+0x80171717,0x801c1c1c,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801f1f1f,
+0x801d1d1d,0x80191919,0x80171717,0x80181818,0x80181818,0x80171717,
+0x801a1a1a,0x801d1d1d,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801f1f1f,
+0x801c1c1c,0x80181818,0x80171717,0x80181818,0x80181818,0x80191919,
+0x801c1c1c,0x80202020,0x80202020,0x801d1d1d,0x801f1d1e,0x801e1c1d,
+0x801b191a,0x80080808,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80010101,0x80000000,0x800a0a0a,0x801e1e1e,0x80909092,0x808f8e93,0x808e8d92,0x80908f94,0x808f8f91,0x808f9092,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808e8f91,0x80909092,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8f91,
+0x802a2a2a,0x801f1d1e,0x801e1e1e,0x801e1e1e,0x801b1b1b,0x80181818,
+0x80171717,0x80181818,0x801a1a1a,0x801a1a1a,0x801c1c1c,0x801a1a1a,
+0x80020202,0x80020202,0x80000000,0x801a1a1a,0x801a1a1a,0x80171717,
+0x80181818,0x80171717,0x80181818,0x801b1b1b,0x801c1c1c,0x80090909,
+0x80040404,0x80000000,0x800e0e0e,0x80171717,0x80161616,0x801a1a1a,
+0x80191919,0x801a1a1a,0x801c1c1c,0x801f1f1f,0x801f1f1f,0x801f1f1f,
+0x801e1e1e,0x801c1c1c,0x80191919,0x80171717,0x80171717,0x80191919,
+0x80191919,0x801c1c1c,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801d1d1d,
+0x801c1c1c,0x801b1b1b,0x80181818,0x80191919,0x80191919,0x80181818,
+0x801a1a1a,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801e1e1e,
+0x801b1b1b,0x80171717,0x80161616,0x80181818,0x80191919,0x80191919,
+0x801d1d1d,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801c1c1c,
+0x801a1a1a,0x80181818,0x80181818,0x80181818,0x80191919,0x801b1b1b,
+0x801e1e1e,0x80202020,0x801f1f1f,0x801d1d1d,0x801d1b1c,0x801c1a1b,
+0x80191718,0x80090909,0x80000000,0x80010101,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80010101,0x80010101,0x80080808,0x801c1c1c,0x80919193,0x80908f94,0x808e8d92,0x80908f94,0x808e8e90,0x808f9092,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808e8f91,0x80909092,0x808f8e93,0x808f8e93,0x808f8e93,0x808e8e90,
+0x80292929,0x801f1d1e,0x801f1f1f,0x801a1a1a,0x80171717,0x80191919,
+0x80191919,0x80171717,0x801a1a1a,0x801e1e1e,0x801f1f1f,0x801a1a1a,
+0x80020202,0x80060606,0x80000000,0x800f0f0f,0x800e0e0e,0x80141414,
+0x80111111,0x80111111,0x80141414,0x80181818,0x80171717,0x80030303,
+0x80020202,0x80030303,0x800b0b0b,0x80191919,0x80181818,0x80191919,
+0x80181818,0x801c1c1c,0x80202020,0x801f1f1f,0x801f1f1f,0x801f1f1f,
+0x801c1c1c,0x80181818,0x80171717,0x80191919,0x80191919,0x80171717,
+0x801c1c1c,0x801f1f1f,0x801f1f1f,0x801d1d1d,0x801d1d1d,0x801e1e1e,
+0x801b1b1b,0x80161616,0x80191919,0x80171717,0x80171717,0x801b1b1b,
+0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801a1a1a,
+0x80171717,0x80181818,0x80191919,0x80171717,0x80191919,0x801e1e1e,
+0x801e1e1e,0x801f1f1f,0x80202020,0x801f1f1f,0x801c1c1c,0x80181818,
+0x80181818,0x801a1a1a,0x80181818,0x80191919,0x801c1c1c,0x801f1f1f,
+0x801f1f1f,0x801d1d1d,0x801d1d1d,0x801f1f1f,0x801a1819,0x80191718,
+0x80181617,0x800a0a0a,0x80000000,0x80020202,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80010101,0x80010101,0x80010101,0x80000000,
+0x80000000,0x80000000,0x80050505,0x80181818,0x808e8e90,0x808f8e93,0x80908f94,0x808f8e93,0x80909092,0x808e8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808e8f91,0x808f8f91,0x80908f94,0x808f8e93,0x808e8d92,0x808f8f91,
+0x802c2c2c,0x801f1d1e,0x80181818,0x801a1a1a,0x80191919,0x80171717,
+0x80171717,0x801b1b1b,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801a1a1a,
+0x80070707,0x80151515,0x80060606,0x80000000,0x80020202,0x80000000,
+0x80000000,0x80000000,0x80020202,0x80000000,0x80000000,0x80020202,
+0x80121212,0x800c0c0c,0x80090909,0x801b1b1b,0x80171717,0x80181818,
+0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x80202020,0x801b1b1b,
+0x80181818,0x80191919,0x80191919,0x80181818,0x80181818,0x801b1b1b,
+0x80202020,0x801e1e1e,0x801d1d1d,0x801e1e1e,0x801d1d1d,0x80191919,
+0x80181818,0x80191919,0x80171717,0x80181818,0x801a1a1a,0x801d1d1d,
+0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x80181818,0x801a1a1a,
+0x801a1a1a,0x80171717,0x80171717,0x801a1a1a,0x801d1d1d,0x801e1e1e,
+0x801d1d1d,0x80202020,0x80202020,0x801c1c1c,0x80181818,0x80171717,
+0x80181818,0x80181818,0x80191919,0x801c1c1c,0x801e1e1e,0x801d1d1d,
+0x801f1f1f,0x80212121,0x801e1e1e,0x80181818,0x80191718,0x80191718,
+0x80191718,0x800a0a0a,0x80000000,0x80010101,0x80000000,0x80010101,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80020202,0x80000000,
+0x80010101,0x80010101,0x80040404,0x80191919,0x808e8e90,0x808f8e93,0x80908f94,0x808f8e93,0x80909092,0x808f9092,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f9092,0x80909092,0x80908f94,0x808f8e93,0x808e8d92,0x808e8e90,
+0x802a2a2a,0x801c1a1b,0x801a1a1a,0x80181818,0x80171717,0x80181818,
+0x801b1b1b,0x801d1d1d,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801c1c1c,
+0x80020202,0x80060606,0x80000000,0x80030303,0x80040404,0x80050505,
+0x80080808,0x80040404,0x80060606,0x80080808,0x80080808,0x80000000,
+0x80050505,0x80030303,0x800c0c0c,0x80171717,0x80171717,0x801d1d1d,
+0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801e1e1e,0x801b1b1b,0x801a1a1a,
+0x80191919,0x80181818,0x80181818,0x80191919,0x801c1c1c,0x801f1f1f,
+0x801e1e1e,0x80202020,0x801f1f1f,0x801b1b1b,0x801a1a1a,0x801a1a1a,
+0x80191919,0x80171717,0x80181818,0x801c1c1c,0x801e1e1e,0x801d1d1d,
+0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801a1a1a,0x801a1a1a,0x80181818,
+0x80171717,0x80181818,0x801b1b1b,0x801d1d1d,0x801e1e1e,0x801f1f1f,
+0x80202020,0x801e1e1e,0x801c1c1c,0x801a1a1a,0x80191919,0x80181818,
+0x80181818,0x80191919,0x801c1c1c,0x801d1d1d,0x801f1f1f,0x80202020,
+0x801f1f1f,0x801c1c1c,0x80191919,0x80191919,0x80181617,0x80191718,
+0x801a1819,0x800a0a0a,0x80000000,0x80010101,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80010101,0x80000000,
+0x80010101,0x80010101,0x80040404,0x80191919,0x808f8f91,0x808f8e93,0x80908f94,0x808f8e93,0x80909092,0x808f9092,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f9092,0x80909092,0x80908f94,0x80908f94,0x808e8d92,0x808e8e90,
+0x80282828,0x801a1819,0x80191919,0x80171717,0x80171717,0x801a1a1a,
+0x801e1e1e,0x801e1e1e,0x801f1f1f,0x80202020,0x801e1e1e,0x801a1a1a,
+0x80010101,0x80020202,0x80000000,0x80121212,0x80171717,0x801c1c1c,
+0x801f1f1f,0x801c1c1c,0x801d1d1d,0x801f1f1f,0x801a1a1a,0x80040404,
+0x80020202,0x80000000,0x800d0d0d,0x80171717,0x80191919,0x80202020,
+0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801c1c1c,0x80181818,0x80191919,
+0x80181818,0x80171717,0x80191919,0x801c1c1c,0x801f1f1f,0x80202020,
+0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801a1a1a,0x80181818,0x80191919,
+0x80191919,0x80171717,0x801a1a1a,0x801e1e1e,0x80212121,0x801f1f1f,
+0x801d1d1d,0x801d1d1d,0x801b1b1b,0x80171717,0x801a1a1a,0x80171717,
+0x80171717,0x801a1a1a,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x80202020,
+0x80202020,0x801c1c1c,0x80181818,0x80191919,0x80191919,0x80181818,
+0x80191919,0x801c1c1c,0x801e1e1e,0x801f1f1f,0x80202020,0x80202020,
+0x801d1d1d,0x80181818,0x80171717,0x80191919,0x80181617,0x801a1819,
+0x801c1a1b,0x800b0b0b,0x80000000,0x80010101,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80010101,0x80000000,
+0x80000000,0x80000000,0x80050505,0x80191919,0x808f8f91,0x808f8e93,0x80908f94,0x808e8d92,0x80909092,0x808f9092,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808e8f91,0x808f8f91,0x808f8e93,0x808f8e93,0x808f8e93,0x808e8e90,
+0x80272727,0x80191718,0x80171717,0x80181818,0x801a1a1a,0x801d1d1d,
+0x801f1f1f,0x801e1e1e,0x801e1e1e,0x80202020,0x801b1b1b,0x80121212,
+0x80020202,0x800a0a0a,0x80000000,0x80161616,0x801d1d1d,0x80212121,
+0x801e1e1e,0x80202020,0x80212121,0x801d1d1d,0x801a1a1a,0x80070707,
+0x80050505,0x80030303,0x800b0b0b,0x801c1c1c,0x801e1e1e,0x80202020,
+0x801e1e1e,0x801f1f1f,0x801e1e1e,0x80181818,0x80191919,0x80181818,
+0x80181818,0x80191919,0x801c1c1c,0x801f1f1f,0x80202020,0x801f1f1f,
+0x801e1e1e,0x801b1b1b,0x801a1a1a,0x801a1a1a,0x80181818,0x80161616,
+0x80181818,0x801b1b1b,0x801d1d1d,0x801d1d1d,0x801f1f1f,0x80202020,
+0x801e1e1e,0x80191919,0x80171717,0x80181818,0x80171717,0x80181818,
+0x801a1a1a,0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801f1f1f,
+0x801c1c1c,0x801a1a1a,0x80191919,0x80181818,0x80181818,0x80191919,
+0x801b1b1b,0x801f1f1f,0x801d1d1d,0x80202020,0x80202020,0x801b1b1b,
+0x80181818,0x80191919,0x80191919,0x80181818,0x801a1819,0x801d1b1c,
+0x801e1c1d,0x800b0b0b,0x80010101,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80010101,0x80000000,
+0x80000000,0x80000000,0x80060606,0x801a1a1a,0x808f8f91,0x808f8e93,0x80908f94,0x808e8d92,0x80909092,0x808f9092,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808d8e90,0x808f8f91,0x808f8e93,0x808f8e93,0x80908f94,0x808d8d8f,
+0x80262626,0x80191718,0x80171717,0x801b1b1b,0x801e1e1e,0x801f1f1f,
+0x801f1f1f,0x801f1f1f,0x801d1d1d,0x801c1c1c,0x801a1a1a,0x80131313,
+0x80070707,0x80101010,0x80050505,0x801c1c1c,0x801e1e1e,0x801f1f1f,
+0x801d1d1d,0x801f1f1f,0x801c1c1c,0x80171717,0x80181818,0x800a0a0a,
+0x800c0c0c,0x800b0b0b,0x800b0b0b,0x80202020,0x801f1f1f,0x801e1e1e,
+0x801f1f1f,0x801e1e1e,0x801a1a1a,0x80171717,0x80191919,0x80181818,
+0x80191919,0x801c1c1c,0x801f1f1f,0x80202020,0x801f1f1f,0x801e1e1e,
+0x801d1d1d,0x801a1a1a,0x80181818,0x80181818,0x80181818,0x80171717,
+0x801a1a1a,0x801e1e1e,0x801f1f1f,0x801d1d1d,0x801d1d1d,0x801e1e1e,
+0x801b1b1b,0x80171717,0x80161616,0x80191919,0x80171717,0x801b1b1b,
+0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801c1c1c,
+0x80181818,0x80191919,0x80191919,0x80181818,0x80191919,0x801c1c1c,
+0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801f1f1f,0x801d1d1d,0x80181818,
+0x80171717,0x80181818,0x80191919,0x80181818,0x801d1b1c,0x801f1d1e,
+0x80201e1f,0x800a0a0a,0x80010101,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80080808,0x801b1b1b,0x808f8f91,0x808f8e93,0x80908f94,0x808f8e93,0x80909092,0x808e8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808e8f91,0x80909092,0x808f8e93,0x808f8e93,0x80908f94,0x808d8d8f,
+0x80252525,0x801a1819,0x801b1b1b,0x801d1d1d,0x801e1e1e,0x801e1e1e,
+0x801f1f1f,0x801f1f1f,0x801c1c1c,0x80181818,0x80161616,0x80161616,
+0x80010101,0x80050505,0x80010101,0x801e1e1e,0x801e1e1e,0x801e1e1e,
+0x80212121,0x801d1d1d,0x80181818,0x80181818,0x80191919,0x80060606,
+0x80040404,0x80010101,0x800e0e0e,0x80202020,0x801e1e1e,0x801e1e1e,
+0x801f1f1f,0x801a1a1a,0x80161616,0x80191919,0x80171717,0x80191919,
+0x801d1d1d,0x80202020,0x80202020,0x801e1e1e,0x801d1d1d,0x801e1e1e,
+0x80191919,0x801a1a1a,0x80191919,0x80161616,0x80171717,0x801c1c1c,
+0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801d1d1d,0x80191919,
+0x80171717,0x80181818,0x80181818,0x80171717,0x801a1a1a,0x801d1d1d,
+0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801c1c1c,0x80181818,
+0x80171717,0x80181818,0x80181818,0x80191919,0x801c1c1c,0x80202020,
+0x80202020,0x801d1d1d,0x80212121,0x801c1c1c,0x80181818,0x80191919,
+0x80181818,0x80171717,0x80181818,0x801b1b1b,0x801f1d1e,0x80211f20,
+0x80201e1f,0x80080808,0x80010101,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x800b0b0b,0x801d1d1d,0x808f8f91,0x808f8e93,0x80908f94,0x808f8e93,0x80909092,0x808e8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808e8f91,0x80909092,0x808f8e93,0x808f8e93,0x80908f94,0x808d8d8f,
+0x80262626,0x801c1a1b,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801e1e1e,
+0x801d1d1d,0x801c1c1c,0x80191919,0x80171717,0x80191919,0x80191919,
+0x80000000,0x80040404,0x80000000,0x801b1b1b,0x801e1e1e,0x801d1d1d,
+0x801d1d1d,0x80181818,0x80181818,0x801a1a1a,0x80191919,0x80050505,
+0x80030303,0x80000000,0x800f0f0f,0x801f1f1f,0x801d1d1d,0x801d1d1d,
+0x801b1b1b,0x80181818,0x80171717,0x80191919,0x80171717,0x801b1b1b,
+0x801f1f1f,0x80202020,0x801f1f1f,0x801d1d1d,0x801c1c1c,0x801c1c1c,
+0x80181818,0x80191919,0x80191919,0x80181818,0x801a1a1a,0x801e1e1e,
+0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801b1b1b,0x80171717,
+0x80161616,0x80181818,0x80191919,0x80191919,0x801d1d1d,0x801e1e1e,
+0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801c1c1c,0x801a1a1a,0x80181818,
+0x80181818,0x80181818,0x80191919,0x801b1b1b,0x801e1e1e,0x80202020,
+0x801f1f1f,0x801d1d1d,0x801e1e1e,0x80191919,0x80171717,0x80191919,
+0x80191919,0x80181818,0x801a1a1a,0x801e1e1e,0x80201e1f,0x80201e1f,
+0x801e1c1d,0x80050505,0x80010101,0x80000000,0x80010101,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x800d0d0d,0x801f1f1f,0x808f8f91,0x808f8e93,0x80908f94,0x808f8e93,0x80909092,0x808e8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808e8f91,0x80909092,0x808f8e93,0x808f8e93,0x80908f94,0x808e8e90,
+0x80272727,0x801e1c1d,0x801f1f1f,0x801f1f1f,0x80202020,0x80202020,
+0x801c1c1c,0x80181818,0x80171717,0x80191919,0x80191919,0x80151515,
+0x80050505,0x80121212,0x80040404,0x801b1b1b,0x80212121,0x801d1d1d,
+0x80191919,0x80181818,0x801a1a1a,0x80191919,0x80171717,0x80090909,
+0x800d0d0d,0x800d0d0d,0x800e0e0e,0x801f1f1f,0x801f1f1f,0x801b1b1b,
+0x80161616,0x80181818,0x801b1b1b,0x80161616,0x80191919,0x801d1d1d,
+0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801b1b1b,0x80171717,
+0x80191919,0x80171717,0x80171717,0x801b1b1b,0x801e1e1e,0x801e1e1e,
+0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801a1a1a,0x80171717,0x80181818,
+0x80191919,0x80171717,0x80191919,0x801e1e1e,0x801e1e1e,0x801f1f1f,
+0x80202020,0x801f1f1f,0x801c1c1c,0x80181818,0x80181818,0x801a1a1a,
+0x80181818,0x80191919,0x801c1c1c,0x801f1f1f,0x801f1f1f,0x801d1d1d,
+0x801d1d1d,0x801f1f1f,0x80181818,0x80191919,0x80191919,0x80181818,
+0x80181818,0x801b1b1b,0x801e1e1e,0x80202020,0x801f1d1e,0x801f1d1e,
+0x801d1b1c,0x80040404,0x80000000,0x80000000,0x80010101,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80010101,0x800e0e0e,0x80202020,0x80909092,0x80908f94,0x808f8e93,0x80908f94,0x808f8f91,0x808e8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808e8f91,0x80909092,0x808f8e93,0x80908f94,0x808f8e93,0x808e8e90,
+0x802b2b2b,0x801e1c1d,0x801d1d1d,0x801f1f1f,0x801f1f1f,0x801b1b1b,
+0x80181818,0x80171717,0x80181818,0x80191919,0x80161616,0x80191919,
+0x80050505,0x800c0c0c,0x80050505,0x801f1f1f,0x80181818,0x801b1b1b,
+0x80191919,0x801a1a1a,0x80171717,0x80171717,0x801d1d1d,0x800c0c0c,
+0x80080808,0x80080808,0x80101010,0x801c1c1c,0x801b1b1b,0x80191919,
+0x80171717,0x80171717,0x80171717,0x801a1a1a,0x801f1f1f,0x801e1e1e,
+0x801e1e1e,0x801f1f1f,0x801d1d1d,0x801a1a1a,0x80181818,0x80181818,
+0x80181818,0x80181818,0x801b1b1b,0x801e1e1e,0x801f1f1f,0x801f1f1f,
+0x801e1e1e,0x801e1e1e,0x80181818,0x801a1a1a,0x801a1a1a,0x80171717,
+0x80171717,0x801a1a1a,0x801d1d1d,0x801e1e1e,0x801d1d1d,0x80202020,
+0x80202020,0x801c1c1c,0x80181818,0x80171717,0x80181818,0x80181818,
+0x80191919,0x801c1c1c,0x801e1e1e,0x801d1d1d,0x801f1f1f,0x80212121,
+0x801e1e1e,0x80181818,0x80181818,0x80191919,0x80191919,0x80181818,
+0x801a1a1a,0x801e1e1e,0x801f1f1f,0x801d1d1d,0x801f1f1f,0x801e1e1e,
+0x80151515,0x80020202,0x80000000,0x80000000,0x80010101,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80010101,0x80000000,
+0x80010101,0x80000000,0x80151515,0x801f1f1f,0x80909092,0x80908f94,0x808f8e93,0x80908f94,0x80909092,0x808f9092,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808e8f91,0x80909092,0x808f8e93,0x80908f94,0x808f8e93,0x808e8e90,
+0x802c2c2c,0x801f1d1e,0x801f1f1f,0x801d1d1d,0x801b1b1b,0x80191919,
+0x80191919,0x80181818,0x80191919,0x80191919,0x801f1f1f,0x801b1b1b,
+0x80000000,0x80020202,0x80000000,0x801b1b1b,0x801c1c1c,0x80181818,
+0x80181818,0x80171717,0x801a1a1a,0x801e1e1e,0x801d1d1d,0x80080808,
+0x80040404,0x80000000,0x800e0e0e,0x801b1b1b,0x80191919,0x80171717,
+0x80171717,0x80191919,0x801a1a1a,0x801d1d1d,0x801d1d1d,0x801f1f1f,
+0x80202020,0x801e1e1e,0x801a1a1a,0x80181818,0x80181818,0x80181818,
+0x80171717,0x801c1c1c,0x801e1e1e,0x801d1d1d,0x801e1e1e,0x80202020,
+0x801e1e1e,0x801b1b1b,0x801a1a1a,0x80181818,0x80171717,0x80181818,
+0x801b1b1b,0x801d1d1d,0x801e1e1e,0x801f1f1f,0x80202020,0x801e1e1e,
+0x801c1c1c,0x801a1a1a,0x80191919,0x80181818,0x80181818,0x80191919,
+0x801c1c1c,0x801d1d1d,0x801f1f1f,0x80202020,0x801f1f1f,0x801c1c1c,
+0x80191919,0x80191919,0x80191919,0x80171717,0x80171717,0x801b1b1b,
+0x801e1e1e,0x801d1d1d,0x801e1e1e,0x801f1f1f,0x801d1d1d,0x801c1c1c,
+0x80131313,0x80010101,0x80000000,0x80000000,0x80010101,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80010101,0x80000000,0x80151515,0x801d1d1d,0x808f8f91,0x80908f94,0x808f8e93,0x80908f94,0x80909092,0x808f9092,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f9092,0x80909092,0x808e8d92,0x808f8e93,0x808e8d92,0x808e8e90,
+0x802c2c2c,0x801f1d1e,0x801f1f1f,0x801b1b1b,0x80181818,0x80181818,
+0x80181818,0x80181818,0x801a1a1a,0x801c1c1c,0x80202020,0x80181818,
+0x80030303,0x800a0a0a,0x80000000,0x80090909,0x800b0b0b,0x800b0b0b,
+0x800e0e0e,0x800b0b0b,0x800e0e0e,0x80101010,0x800d0d0d,0x80010101,
+0x80080808,0x80030303,0x800c0c0c,0x80191919,0x80171717,0x80161616,
+0x80171717,0x801c1c1c,0x801d1d1d,0x801f1f1f,0x801d1d1d,0x80202020,
+0x80202020,0x801b1b1b,0x80171717,0x80171717,0x80181818,0x80181818,
+0x80191919,0x801e1e1e,0x80202020,0x801f1f1f,0x801e1e1e,0x801e1e1e,
+0x801c1c1c,0x80181818,0x801a1a1a,0x80171717,0x80171717,0x801a1a1a,
+0x801e1e1e,0x801e1e1e,0x801e1e1e,0x80202020,0x80202020,0x801c1c1c,
+0x80181818,0x80191919,0x80191919,0x80181818,0x80191919,0x801c1c1c,
+0x801e1e1e,0x801f1f1f,0x80202020,0x80202020,0x801d1d1d,0x80181818,
+0x80171717,0x80191919,0x80191919,0x80171717,0x80191919,0x801e1e1e,
+0x80202020,0x801e1e1e,0x801d1d1d,0x801e1e1e,0x801b1b1b,0x80191919,
+0x800f0f0f,0x80010101,0x80000000,0x80000000,0x80010101,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80171717,0x801a1a1a,0x808f8f91,0x80908f94,0x808f8e93,0x808f8e93,0x808f8f91,0x808e8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f9092,0x80909092,0x808e8d92,0x80908f94,0x808f8e93,0x808e8e90,
+0x802c2c2c,0x801f1d1e,0x801b1b1b,0x80191919,0x80181818,0x80181818,
+0x80171717,0x80181818,0x801c1c1c,0x801f1f1f,0x801e1e1e,0x801b1b1b,
+0x80090909,0x80121212,0x80060606,0x80000000,0x80000000,0x80020202,
+0x80000000,0x80000000,0x80010101,0x80000000,0x80010101,0x80010101,
+0x80101010,0x800c0c0c,0x800c0c0c,0x80181818,0x80171717,0x80181818,
+0x801a1a1a,0x801d1d1d,0x801e1e1e,0x80202020,0x801f1f1f,0x801e1e1e,
+0x801b1b1b,0x80181818,0x80171717,0x80181818,0x80191919,0x80191919,
+0x801e1e1e,0x801d1d1d,0x801f1f1f,0x80202020,0x801e1e1e,0x801a1a1a,
+0x80181818,0x80191919,0x80171717,0x80181818,0x801a1a1a,0x801d1d1d,
+0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801c1c1c,0x801a1a1a,
+0x80191919,0x80181818,0x80181818,0x80191919,0x801b1b1b,0x801f1f1f,
+0x801d1d1d,0x80202020,0x80202020,0x801b1b1b,0x80181818,0x80191919,
+0x80191919,0x80181818,0x80181818,0x801b1b1b,0x801e1e1e,0x801e1e1e,
+0x801f1f1f,0x80202020,0x801e1e1e,0x801a1a1a,0x80191919,0x80171717,
+0x800b0b0b,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80010101,
+0x80000000,0x80010101,0x80181818,0x80171717,0x808f8f91,0x80908f94,0x808f8e93,0x808f8e93,0x808f8f91,0x808e8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f9092,0x80909092,0x808f8e93,0x80908f94,0x808f8e93,0x808e8e90,
+0x802b2b2b,0x801d1b1c,0x80181818,0x80191919,0x80181818,0x80171717,
+0x80191919,0x801c1c1c,0x801e1e1e,0x801f1f1f,0x801b1b1b,0x801b1b1b,
+0x80020202,0x80020202,0x80000000,0x80060606,0x80080808,0x80050505,
+0x80080808,0x80090909,0x800b0b0b,0x800a0a0a,0x800b0b0b,0x80010101,
+0x80040404,0x80000000,0x800c0c0c,0x80181818,0x80181818,0x801b1b1b,
+0x801d1d1d,0x801f1f1f,0x801e1e1e,0x80212121,0x801e1e1e,0x801b1b1b,
+0x80181818,0x80171717,0x80171717,0x80181818,0x801a1a1a,0x801d1d1d,
+0x80202020,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801c1c1c,0x80171717,
+0x80161616,0x80191919,0x80171717,0x801b1b1b,0x801e1e1e,0x801f1f1f,
+0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801c1c1c,0x80181818,0x80191919,
+0x80191919,0x80181818,0x80191919,0x801c1c1c,0x801e1e1e,0x801f1f1f,
+0x801f1f1f,0x801f1f1f,0x801d1d1d,0x80181818,0x80171717,0x80181818,
+0x80191919,0x80181818,0x801a1a1a,0x801e1e1e,0x80202020,0x801f1f1f,
+0x801e1e1e,0x801e1e1e,0x801b1b1b,0x80181818,0x80191919,0x80161616,
+0x80080808,0x80010101,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80010101,0x80000000,0x80010101,
+0x80000000,0x80040404,0x80181818,0x80161616,0x808f8f91,0x808f8e93,0x80908f94,0x808f8e93,0x80909092,0x808f9092,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f9092,0x80909092,0x808f8e93,0x80919095,0x808f8e93,0x808d8d8f,
+0x80292929,0x801b191a,0x80171717,0x80181818,0x80181818,0x80181818,
+0x801c1c1c,0x80202020,0x80202020,0x801e1e1e,0x80202020,0x801c1c1c,
+0x80000000,0x80020202,0x80010101,0x80121212,0x80181818,0x801b1b1b,
+0x80202020,0x801e1e1e,0x801e1e1e,0x80202020,0x801e1e1e,0x80060606,
+0x80010101,0x80000000,0x800b0b0b,0x80181818,0x80191919,0x801d1d1d,
+0x801f1f1f,0x80202020,0x801e1e1e,0x801f1f1f,0x801b1b1b,0x80191919,
+0x80181818,0x80181818,0x80181818,0x80181818,0x801c1c1c,0x80202020,
+0x801e1e1e,0x801f1f1f,0x801d1d1d,0x801a1a1a,0x80171717,0x80181818,
+0x80191919,0x80181818,0x801a1a1a,0x801d1d1d,0x801e1e1e,0x801e1e1e,
+0x801f1f1f,0x801f1f1f,0x801c1c1c,0x80181818,0x80171717,0x80181818,
+0x80181818,0x80191919,0x801c1c1c,0x80202020,0x80202020,0x801d1d1d,
+0x80212121,0x801c1c1c,0x80181818,0x80191919,0x80181818,0x80171717,
+0x80181818,0x801b1b1b,0x801e1e1e,0x801d1d1d,0x801e1e1e,0x80202020,
+0x801e1e1e,0x80191919,0x80171717,0x80191919,0x80191919,0x80151515,
+0x80040404,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80010101,0x80000000,0x80000000,
+0x80000000,0x80090909,0x80181818,0x80181818,0x808f8f91,0x808f8e93,0x80908f94,0x808f8e93,0x80919193,0x808f9092,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f9092,0x80909092,0x808f8e93,0x80908f94,0x808f8e93,0x808d8d8f,
+0x80282828,0x80191718,0x80181818,0x80191919,0x801a1a1a,0x801c1c1c,
+0x801e1e1e,0x80202020,0x80202020,0x801e1e1e,0x801d1d1d,0x80161616,
+0x80030303,0x800d0d0d,0x80030303,0x80161616,0x801b1b1b,0x80222222,
+0x801f1f1f,0x801d1d1d,0x801d1d1d,0x801d1d1d,0x801c1c1c,0x80070707,
+0x80070707,0x80080808,0x800b0b0b,0x801b1b1b,0x801d1d1d,0x801e1e1e,
+0x801f1f1f,0x80212121,0x801d1d1d,0x801b1b1b,0x80181818,0x80181818,
+0x80181818,0x80191919,0x801a1a1a,0x801c1c1c,0x801e1e1e,0x801f1f1f,
+0x801e1e1e,0x801e1e1e,0x801b1b1b,0x80181818,0x80171717,0x80181818,
+0x801a1a1a,0x801a1a1a,0x801d1d1d,0x801e1e1e,0x801e1e1e,0x801e1e1e,
+0x801e1e1e,0x801c1c1c,0x801a1a1a,0x80181818,0x80181818,0x80181818,
+0x80191919,0x801b1b1b,0x801e1e1e,0x80202020,0x801f1f1f,0x801d1d1d,
+0x801e1e1e,0x80191919,0x80171717,0x80191919,0x80191919,0x80181818,
+0x801a1a1a,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801e1e1e,
+0x801b1b1b,0x80171717,0x80171717,0x80191919,0x80191919,0x80141414,
+0x80010101,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80010101,0x80000000,0x80000000,
+0x80010101,0x800d0d0d,0x80181818,0x801a1a1a,0x80909092,0x808f8e93,0x80908f94,0x808f8e93,0x80909092,0x808e8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f9092,0x80909092,0x808e8d92,0x80908f94,0x808f8e93,0x808c8c8e,
+0x80272727,0x80181617,0x80191919,0x80191919,0x801c1c1c,0x801f1f1f,
+0x801f1f1f,0x801e1e1e,0x801e1e1e,0x80202020,0x80191919,0x80141414,
+0x80060606,0x80101010,0x80000000,0x801c1c1c,0x801e1e1e,0x801d1d1d,
+0x801d1d1d,0x801f1f1f,0x801f1f1f,0x801b1b1b,0x80171717,0x80090909,
+0x800d0d0d,0x800a0a0a,0x800b0b0b,0x801e1e1e,0x80202020,0x801d1d1d,
+0x801d1d1d,0x80212121,0x801c1c1c,0x80171717,0x80171717,0x80171717,
+0x80171717,0x80181818,0x801c1c1c,0x80202020,0x801f1f1f,0x801c1c1c,
+0x80202020,0x801b1b1b,0x80181818,0x80191919,0x80181818,0x80171717,
+0x80181818,0x801d1d1d,0x801e1e1e,0x801f1f1f,0x80202020,0x801f1f1f,
+0x801c1c1c,0x80181818,0x80181818,0x801a1a1a,0x80181818,0x80191919,
+0x801c1c1c,0x801f1f1f,0x801f1f1f,0x801d1d1d,0x801d1d1d,0x801f1f1f,
+0x80181818,0x80191919,0x80191919,0x80181818,0x80181818,0x801b1b1b,
+0x801e1e1e,0x80202020,0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801a1a1a,
+0x80181818,0x80191919,0x80191919,0x80181818,0x80181818,0x80131313,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80010101,0x80010101,0x80000000,
+0x80010101,0x80101010,0x80181818,0x801c1c1c,0x80909092,0x808f8e93,0x808f8e93,0x80908f94,0x80909092,0x808e8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f9094,0x808f9094,0x808f9094,0x808f9094,
+0x808e8f93,0x808e8f93,0x808f9094,0x808d8e92,0x808f9094,0x808e8f93,
+0x808e8f93,0x808f9094,0x808f9094,0x808e8f93,0x808e8f93,0x808f9094,
+0x808f9094,0x808f9094,0x808e8f93,0x808e8f93,0x808e8f93,0x808f9094,
+0x808e8f93,0x808e8f93,0x808e8f93,0x808f9094,0x808f9094,0x808e8f93,
+0x808e8f93,0x80909195,0x80909195,0x808e8f93,0x808f9094,0x808f9094,
+0x808f9094,0x808e8f93,0x808e8f93,0x808e8f93,0x808e8f93,0x808e8f93,
+0x808f9092,0x80909193,0x808c8d8f,0x80909193,0x808c8d8f,0x808d8e90,
+0x80282a29,0x80171918,0x80181818,0x801d1d1d,0x801f1f1f,0x801d1d1d,
+0x801e1e1e,0x80202020,0x801e1e1e,0x80191919,0x80161616,0x80191919,
+0x80010101,0x80000000,0x80030303,0x801d1d1d,0x801d1d1d,0x80212121,
+0x801d1d1d,0x80212121,0x801b1b1b,0x80161616,0x801a1a1a,0x80070707,
+0x80010101,0x80000000,0x80101010,0x801e1e1e,0x801d1d1d,0x801f1f1f,
+0x801e1e1e,0x801a1a1a,0x80181818,0x80181818,0x80181818,0x80171717,
+0x80191919,0x801e1e1e,0x80202020,0x801f1f1f,0x801e1e1e,0x80202020,
+0x801a1a1a,0x80181818,0x80181818,0x80191919,0x80191919,0x80181818,
+0x801c1c1c,0x80202020,0x801d1d1d,0x801f1f1f,0x801f1f1f,0x801c1c1c,
+0x80181818,0x80181818,0x80181818,0x80181818,0x80191919,0x801c1c1c,
+0x801e1e1e,0x801d1d1d,0x801f1f1f,0x80212121,0x801e1e1e,0x80181818,
+0x80181818,0x80191919,0x80191919,0x80181818,0x801a1a1a,0x801e1e1e,
+0x801f1f1f,0x801d1d1d,0x801e1e1e,0x801f1f1f,0x80191919,0x80161616,
+0x801a1a1a,0x80171717,0x80141414,0x801b1b1b,0x80202020,0x80060606,
+0x80000000,0x80000000,0x80000000,0x80020202,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80020202,0x80010101,
+0x80000000,0x80171516,0x801d1b1c,0x80201e1f,0x80909092,0x808f8e93,0x808f8e93,0x808f8e93,0x80909092,0x808f9092,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808e8d92,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x80929196,0x80908f94,0x808f8e93,
+0x808f8e93,0x80908f94,0x80908f94,0x808f8e93,0x808f8e93,0x80908f94,
+0x808e8d92,0x808e8d92,0x808f8e93,0x808f8e93,0x80908f94,0x80908f94,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x80908f94,0x808f8e93,0x808f8e93,0x808f8e93,0x80908f94,0x808f8e93,
+0x808f8e93,0x80908f94,0x80908f94,0x808f8e93,0x808e8d92,0x808f8e93,
+0x808e8e90,0x808f8f91,0x808f8f91,0x808e8e90,0x808e8e90,0x808e8e90,
+0x80232323,0x80171717,0x801d1d1d,0x801d1d1d,0x801e1e1e,0x80202020,
+0x801f1f1f,0x801c1c1c,0x80191919,0x80191919,0x80171717,0x80121212,
+0x80010101,0x80070707,0x80000000,0x801a1a1a,0x801f1f1f,0x801c1c1c,
+0x801f1f1f,0x80181818,0x80171717,0x801a1a1a,0x80191919,0x80050505,
+0x80050505,0x80040404,0x800d0d0d,0x801f1f1f,0x801f1f1f,0x801e1e1e,
+0x801b1b1b,0x80191919,0x80191919,0x80191919,0x80171717,0x801b1b1b,
+0x801d1d1d,0x801d1d1d,0x801f1f1f,0x80202020,0x801f1f1f,0x801c1c1c,
+0x80191919,0x801a1a1a,0x80191919,0x80171717,0x80191919,0x801d1d1d,
+0x801f1f1f,0x801e1e1e,0x801f1f1f,0x801d1d1d,0x801b1b1b,0x801a1a1a,
+0x80191919,0x80191919,0x80191919,0x80191919,0x801c1c1c,0x801d1d1d,
+0x801f1f1f,0x80202020,0x801f1f1f,0x801c1c1c,0x80191919,0x80191919,
+0x80191919,0x80171717,0x80171717,0x801b1b1b,0x801e1e1e,0x801d1d1d,
+0x801e1e1e,0x801f1f1f,0x801d1d1d,0x80191919,0x80181818,0x80191919,
+0x80171717,0x80181818,0x801a1a1a,0x801c1c1c,0x801b1b1b,0x80040404,
+0x80000000,0x80000000,0x80000000,0x80010101,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80020202,0x80000000,0x80000000,0x80000000,
+0x80060606,0x801b191a,0x801f1d1e,0x801f1d1e,0x80909092,0x808f8e93,0x808f8e93,0x808f8e93,0x80909092,0x808f9092,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x80919193,0x80929294,0x808f8f91,0x808d8d8f,
+0x808f8f91,0x80909092,0x808e8e90,0x80909092,0x80909092,0x808f8f91,
+0x808f8f91,0x80909092,0x80909092,0x808f8f91,0x808f8f91,0x808f8f91,
+0x808e8e90,0x808f8f91,0x808f8f91,0x80909092,0x80909092,0x80909092,
+0x808f8f91,0x808f8f91,0x80909092,0x808e8e90,0x808e8e90,0x80909092,
+0x80919193,0x808f8f91,0x808f8f91,0x80919193,0x80909092,0x808f8f91,
+0x808f8f91,0x80909092,0x80909092,0x808f8f91,0x808f8f91,0x80909092,
+0x808f8f91,0x808e8e90,0x80919193,0x808e8e90,0x80929294,0x80909090,
+0x80262626,0x801c1c1c,0x801f1f1f,0x801e1e1e,0x801f1f1f,0x80202020,
+0x801d1d1d,0x80191919,0x80181818,0x80181818,0x801a1a1a,0x80131313,
+0x80070707,0x80171717,0x80050505,0x801c1c1c,0x80202020,0x801e1e1e,
+0x801c1c1c,0x80171717,0x80171717,0x80181818,0x80191919,0x800b0b0b,
+0x800f0f0f,0x800d0d0d,0x800c0c0c,0x801f1f1f,0x801e1e1e,0x801c1c1c,
+0x80181818,0x80181818,0x80191919,0x80181818,0x80191919,0x801d1d1d,
+0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801f1f1f,0x801c1c1c,0x80191919,
+0x80181818,0x80191919,0x80181818,0x80181818,0x801b1b1b,0x801f1f1f,
+0x80202020,0x801d1d1d,0x801f1f1f,0x801b1b1b,0x80181818,0x80191919,
+0x80191919,0x80191919,0x801a1a1a,0x801c1c1c,0x801e1e1e,0x801f1f1f,
+0x80202020,0x80202020,0x801d1d1d,0x80181818,0x80171717,0x80191919,
+0x80191919,0x80171717,0x80191919,0x801e1e1e,0x80202020,0x801e1e1e,
+0x801d1d1d,0x801e1e1e,0x801b1b1b,0x80171717,0x80171717,0x80191919,
+0x80181818,0x80191919,0x801e1e1e,0x801f1f1f,0x80131313,0x80020202,
+0x80000000,0x80010101,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80010101,0x80000000,0x80000000,0x80000000,
+0x800e0e0e,0x801f1d1e,0x80211f20,0x801f1d1e,0x80909092,0x808f8e93,0x808f8e93,0x808f8e93,0x80909092,0x808e8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x80909092,0x808e8e90,0x80919193,0x80919193,
+0x808f8f91,0x80909092,0x808f8f91,0x80909092,0x808f8f91,0x808f8f91,
+0x808f8f91,0x80909092,0x80909092,0x808f8f91,0x808f8f91,0x808f8f91,
+0x80909092,0x80909092,0x80909092,0x808f8f91,0x808f8f91,0x808f8f91,
+0x808f8f91,0x808f8f91,0x80909092,0x808f8f91,0x808f8f91,0x80919193,
+0x80919193,0x80909092,0x808f8f91,0x80909092,0x80909092,0x808f8f91,
+0x808f8f91,0x808e8e90,0x808f8f91,0x80909092,0x80909092,0x80909092,
+0x808e8e90,0x808d8d8f,0x80919193,0x808f8f91,0x80919191,0x808a8a8a,
+0x802c2c2c,0x801e1e1e,0x801d1d1d,0x80202020,0x80202020,0x801c1c1c,
+0x80191919,0x801a1a1a,0x80191919,0x80171717,0x80161616,0x80171717,
+0x80010101,0x800b0b0b,0x80000000,0x801c1c1c,0x801d1d1d,0x801b1b1b,
+0x80161616,0x801a1a1a,0x80181818,0x80161616,0x80191919,0x80090909,
+0x80060606,0x80040404,0x800f0f0f,0x801e1e1e,0x801b1b1b,0x80191919,
+0x80171717,0x80181818,0x80191919,0x80181818,0x801e1e1e,0x801d1d1d,
+0x801f1f1f,0x80212121,0x801f1f1f,0x801a1a1a,0x80181818,0x80191919,
+0x80191919,0x80161616,0x80171717,0x801c1c1c,0x801f1f1f,0x801f1f1f,
+0x801e1e1e,0x801f1f1f,0x801b1b1b,0x801a1a1a,0x80181818,0x80181818,
+0x80181818,0x80191919,0x801c1c1c,0x801f1f1f,0x801d1d1d,0x80202020,
+0x80202020,0x801b1b1b,0x80181818,0x80191919,0x80191919,0x80181818,
+0x80181818,0x801b1b1b,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x80202020,
+0x801e1e1e,0x801a1a1a,0x80171717,0x80191919,0x80161616,0x80181818,
+0x801c1c1c,0x801c1c1c,0x801d1d1d,0x80202020,0x800a0a0a,0x80000000,
+0x80000000,0x80010101,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80010101,0x80000000,0x80000000,
+0x80151515,0x801f1d1e,0x80211f20,0x80201e1f,0x808f8f91,0x808f8e93,0x808f8e93,0x808f8e93,0x80909092,0x808e8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x80929294,0x806e6e70,0x805d5d5f,0x805d5d5f,
+0x805c5c5e,0x805d5d5f,0x805b5b5d,0x8059595b,0x805a5a5c,0x805a5a5c,
+0x805c5c5e,0x805c5c5e,0x805d5d5f,0x805d5d5f,0x805d5d5f,0x805d5d5f,
+0x805c5c5e,0x805b5b5d,0x805a5a5c,0x8059595b,0x8059595b,0x805a5a5c,
+0x805c5c5e,0x805c5c5e,0x805d5d5f,0x805e5e60,0x805d5d5f,0x805c5c5e,
+0x805b5b5d,0x805b5b5d,0x805a5a5c,0x8059595b,0x805a5a5c,0x805d5d5f,
+0x805d5d5f,0x805b5b5d,0x805c5c5e,0x805e5e60,0x805d5d5f,0x805a5a5c,
+0x805b5b5d,0x8059595b,0x8059595b,0x805b5b5b,0x805b5b5b,0x805a5a5a,
+0x80272727,0x801f1f1f,0x801e1e1e,0x801f1f1f,0x801d1d1d,0x80191919,
+0x80171717,0x80181818,0x80191919,0x80181818,0x801a1a1a,0x801e1e1e,
+0x80000000,0x80020202,0x80000000,0x801b1b1b,0x801b1b1b,0x80151515,
+0x80181818,0x80181818,0x80181818,0x801b1b1b,0x801d1d1d,0x80050505,
+0x80000000,0x80020202,0x800f0f0f,0x801c1c1c,0x80181818,0x80181818,
+0x80181818,0x80181818,0x801a1a1a,0x801c1c1c,0x80202020,0x801f1f1f,
+0x801e1e1e,0x801f1f1f,0x801d1d1d,0x80191919,0x80171717,0x80181818,
+0x80181818,0x80171717,0x801a1a1a,0x801e1e1e,0x80202020,0x801e1e1e,
+0x801d1d1d,0x801e1e1e,0x80181818,0x80191919,0x80191919,0x80181818,
+0x80191919,0x801c1c1c,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801f1f1f,
+0x801d1d1d,0x80181818,0x80171717,0x80181818,0x80191919,0x80181818,
+0x801a1a1a,0x801e1e1e,0x80202020,0x801f1f1f,0x801e1e1e,0x801e1e1e,
+0x801b1b1b,0x80181818,0x80161616,0x80191919,0x80171717,0x801a1a1a,
+0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801c1c1c,0x80040404,0x80000000,
+0x80000000,0x80010101,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80010101,0x80000000,0x80030303,
+0x801a1a1a,0x801f1d1e,0x80201e1f,0x801f1d1e,0x808f8f91,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8f91,0x808e8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x80909090,0x80474747,0x801e1e1e,0x801d1d1d,
+0x801c1c1c,0x801a1a1a,0x80171717,0x80171717,0x80181818,0x801a1a1a,
+0x801c1c1c,0x801d1d1d,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801d1d1d,
+0x80191919,0x80181818,0x80171717,0x80171717,0x80191919,0x801b1b1b,
+0x801d1d1d,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801d1d1d,0x80191919,
+0x80181818,0x80181818,0x80181818,0x80161616,0x80191919,0x801d1d1d,
+0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801c1c1c,0x80171717,
+0x8019191b,0x8018181a,0x80161616,0x801b1b1b,0x801b1b1b,0x80242424,
+0x801c1c1c,0x801d1d1d,0x80202020,0x801c1c1c,0x80191919,0x801a1a1a,
+0x80181818,0x80161616,0x80181818,0x801c1c1c,0x80202020,0x801a1a1a,
+0x80060606,0x80101010,0x80000000,0x80050505,0x80050505,0x80050505,
+0x80060606,0x80030303,0x80050505,0x80070707,0x80080808,0x80000000,
+0x800a0a0a,0x80090909,0x800c0c0c,0x80191919,0x80171717,0x80191919,
+0x80181818,0x80191919,0x801c1c1c,0x80212121,0x801f1f1f,0x80202020,
+0x801f1f1f,0x801a1a1a,0x80191919,0x80191919,0x80191919,0x80171717,
+0x80171717,0x801c1c1c,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801e1e1e,
+0x801d1d1d,0x801a1a1a,0x80171717,0x80181818,0x80181818,0x80191919,
+0x801c1c1c,0x80202020,0x80202020,0x801d1d1d,0x80212121,0x801c1c1c,
+0x80181818,0x80191919,0x80181818,0x80171717,0x80181818,0x801b1b1b,
+0x801e1e1e,0x801d1d1d,0x801e1e1e,0x80202020,0x801e1e1e,0x80191919,
+0x80171717,0x80191919,0x80171717,0x80171717,0x801a1a1a,0x801f1f1f,
+0x801c1c1c,0x801f1f1f,0x80212121,0x80111111,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80010101,0x80010101,0x80000000,0x80090909,
+0x801d1d1d,0x80201e1f,0x801e1c1d,0x801b191a,0x808f8f91,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8f91,0x808e8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8f8f,0x80484848,0x80202020,0x801e1e1e,
+0x801b1b1b,0x80161616,0x80161616,0x801c1c1c,0x801a1a1a,0x801c1c1c,
+0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801f1f1f,0x801d1d1d,0x801b1b1b,
+0x80181818,0x80181818,0x80171717,0x80191919,0x801b1b1b,0x801e1e1e,
+0x801f1f1f,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801b1b1b,0x80181818,
+0x80171717,0x80181818,0x80191919,0x80191919,0x801d1d1d,0x801e1e1e,
+0x801f1f1f,0x80202020,0x801e1e1e,0x801c1c1c,0x80191919,0x80181818,
+0x80161616,0x80181818,0x80191919,0x801f1f1f,0x801c1c1c,0x80202020,
+0x8020201e,0x8020201e,0x801e1e1e,0x80191919,0x80181818,0x80191919,
+0x80191919,0x80181818,0x801a1a1a,0x801f1f1f,0x80212121,0x80161616,
+0x80080808,0x80151515,0x80050505,0x80000000,0x80000000,0x80030303,
+0x80000000,0x80000000,0x80010101,0x80000000,0x80000000,0x80010101,
+0x800f0f0f,0x800b0b0b,0x800a0a0a,0x80191919,0x80171717,0x80191919,
+0x801a1a1a,0x801c1c1c,0x801f1f1f,0x80202020,0x801e1e1e,0x801f1f1f,
+0x801c1c1c,0x80181818,0x80171717,0x80191919,0x80191919,0x80181818,
+0x801b1b1b,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801d1d1d,
+0x801b1b1b,0x80171717,0x80181818,0x80181818,0x80191919,0x801b1b1b,
+0x801e1e1e,0x80202020,0x801f1f1f,0x801d1d1d,0x801e1e1e,0x80191919,
+0x80171717,0x80191919,0x80191919,0x80181818,0x801a1a1a,0x801e1e1e,
+0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801e1e1e,0x801b1b1b,0x80171717,
+0x80171717,0x80191919,0x80181818,0x80191919,0x801c1c1c,0x80202020,
+0x801d1d1d,0x801f1f1f,0x801e1e1e,0x80060606,0x80000000,0x80010101,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80010101,0x80010101,0x80000000,0x80131313,
+0x801e1e1e,0x801e1c1d,0x801c1a1b,0x80181617,0x808f8f91,0x80908f94,0x808f8e93,0x808f8e93,0x808f8f91,0x808e8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x80908e8f,0x804b494a,0x801e1c1d,0x80161415,
+0x801a1819,0x801d1b1c,0x80191718,0x80181617,0x801d1b1c,0x801f1d1e,
+0x80211f20,0x80201e1f,0x801f1d1e,0x801e1c1d,0x801b191a,0x80181617,
+0x801a1819,0x80191718,0x80191718,0x801c1a1b,0x801e1c1d,0x80201e1f,
+0x80201e1f,0x801f1d1e,0x801f1d1e,0x801c1a1b,0x80191718,0x80181617,
+0x80181617,0x80191718,0x801b191a,0x801f1d1e,0x80222021,0x801f1d1e,
+0x801e1c1d,0x801f1d1e,0x801d1b1c,0x80191718,0x80181617,0x801a1819,
+0x801a1819,0x801a1819,0x801c1a1b,0x80211f20,0x801f1d1e,0x80201e1f,
+0x801f1e1c,0x801e1d1b,0x80191919,0x80191919,0x80181818,0x80171717,
+0x80181818,0x801c1c1c,0x801f1f1f,0x801f1f1f,0x801f1f1f,0x80191919,
+0x80010101,0x80000000,0x80000000,0x800b0b0b,0x80131313,0x800e0e0e,
+0x80101010,0x80151515,0x80161616,0x80131313,0x80141414,0x80040404,
+0x80020202,0x80000000,0x800b0b0b,0x801a1a1a,0x80171717,0x80191919,
+0x801c1c1c,0x80202020,0x80202020,0x801d1d1d,0x80202020,0x801c1c1c,
+0x80191919,0x80191919,0x80181818,0x80171717,0x80181818,0x801a1a1a,
+0x80202020,0x801e1e1e,0x801d1d1d,0x801f1f1f,0x801f1f1f,0x801a1a1a,
+0x80171717,0x80171717,0x80181818,0x80181818,0x801b1b1b,0x801f1f1f,
+0x801f1f1f,0x801d1d1d,0x801d1d1d,0x801f1f1f,0x80181818,0x80191919,
+0x80191919,0x80181818,0x80181818,0x801b1b1b,0x801e1e1e,0x80202020,
+0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801a1a1a,0x80181818,0x80191919,
+0x80191919,0x80181818,0x80181818,0x80202020,0x801e1e1e,0x801f1f1f,
+0x80202020,0x801f1f1f,0x80161616,0x80000000,0x80000000,0x80020202,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80010101,0x80020202,0x801a1a1a,
+0x801d1d1d,0x801b191a,0x801a1819,0x80181617,0x80909092,0x808f8e93,0x808f8e93,0x80908f94,0x808f8f91,0x808f9092,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x80919193,0x80464646,0x80191919,0x80191919,
+0x80181818,0x80161616,0x80191919,0x801c1c1a,0x801e1e1e,0x801e1e1e,
+0x801e1e1e,0x801f1f1f,0x801d1d1d,0x80191919,0x80181818,0x80191919,
+0x80171717,0x80181818,0x801a1a1a,0x801e1e1e,0x801f1f1f,0x801f1f1f,
+0x801e1e1e,0x801f1f1f,0x80181818,0x801a1a1a,0x80191919,0x80171717,
+0x80171717,0x801b1b1b,0x801e1e1e,0x801f1f1f,0x801d1d1d,0x801f1f1f,
+0x801f1f1f,0x801b1b1b,0x80181818,0x80171717,0x80181818,0x80191919,
+0x80181818,0x801d1d1d,0x801f1f1f,0x801d1d1d,0x801e1e1e,0x80202020,
+0x801e1e1e,0x80191919,0x80181818,0x80191919,0x80181818,0x80171717,
+0x801b1b1b,0x801f1f1f,0x801f1f1f,0x801d1d1d,0x801e1e1e,0x801b1b1b,
+0x80000000,0x80000000,0x80000000,0x80161616,0x80161616,0x80191919,
+0x801c1c1c,0x801f1f1f,0x801e1e1e,0x801f1f1f,0x80202020,0x80080808,
+0x80010101,0x80000000,0x800b0b0b,0x80171717,0x80191919,0x801f1f1f,
+0x801f1f1f,0x801d1d1d,0x801e1e1e,0x80202020,0x80191919,0x80181818,
+0x80181818,0x80191919,0x80181818,0x80171717,0x801b1b1b,0x80202020,
+0x801d1d1d,0x80202020,0x80202020,0x801c1c1c,0x80191919,0x80181818,
+0x80181818,0x80171717,0x80171717,0x801b1b1b,0x801e1e1e,0x801e1e1e,
+0x801f1f1f,0x80202020,0x801d1d1d,0x80191919,0x80181818,0x80191919,
+0x80191919,0x80181818,0x801a1a1a,0x801e1e1e,0x801f1f1f,0x801d1d1d,
+0x80212121,0x801c1c1c,0x80191919,0x80191919,0x80191919,0x80171717,
+0x80181818,0x801a1a1a,0x801f1d1e,0x801f1d1e,0x80201e1f,0x801d1d1d,
+0x80202020,0x801c1c1c,0x80090909,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80010101,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80020202,0x80000000,0x800b0b0b,0x801d1d1d,
+0x801c1c1c,0x80161616,0x80191919,0x80181818,0x80919193,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8f91,0x808e8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8f91,0x80444444,0x80181818,0x80181818,
+0x80191919,0x80181818,0x801c1c1c,0x801e1e1c,0x801e1e1e,0x80202020,
+0x80202020,0x801c1c1c,0x80191919,0x80191919,0x80191919,0x80171717,
+0x80181818,0x801c1c1c,0x801f1f1f,0x801d1d1d,0x801e1e1e,0x801f1f1f,
+0x801e1e1e,0x801a1a1a,0x801a1a1a,0x80181818,0x80171717,0x80181818,
+0x801b1b1b,0x801d1d1d,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801d1d1d,
+0x801b1b1b,0x80191919,0x80191919,0x80181818,0x80191919,0x80191919,
+0x801d1d1d,0x801d1d1d,0x801e1e1e,0x80202020,0x801f1f1f,0x801c1c1c,
+0x80191919,0x80191919,0x80191919,0x80171717,0x80181818,0x801b1b1b,
+0x801e1e1e,0x801d1d1d,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x80151515,
+0x80050505,0x800f0f0f,0x80030303,0x80121212,0x80191919,0x80202020,
+0x801f1f1f,0x801d1d1d,0x80202020,0x801e1e1e,0x80191919,0x80080808,
+0x800a0a0a,0x80060606,0x800a0a0a,0x801a1a1a,0x801c1c1c,0x801e1e1e,
+0x801e1e1e,0x80202020,0x801f1f1f,0x801b1b1b,0x80181818,0x80191919,
+0x80191919,0x80171717,0x80181818,0x801c1c1c,0x801e1e1e,0x801e1e1e,
+0x80202020,0x801e1e1e,0x801c1c1c,0x801a1a1a,0x80191919,0x80181818,
+0x80181818,0x80181818,0x801b1b1b,0x801d1d1d,0x801f1f1f,0x801f1f1f,
+0x801f1f1f,0x801d1d1d,0x801a1a1a,0x80181818,0x80191919,0x80171717,
+0x80171717,0x801b1b1b,0x801e1e1e,0x801d1d1d,0x801e1e1e,0x801f1f1f,
+0x801c1c1c,0x801b1b1b,0x80191919,0x80181818,0x80171717,0x80181818,
+0x801b1b1b,0x801d1d1d,0x801f1d1e,0x80211f20,0x80211f20,0x801e1e1e,
+0x801d1d1d,0x80121212,0x80030303,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80010101,0x80111111,0x801a1a1a,
+0x80191919,0x80191919,0x80181818,0x80181818,0x80919193,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8f91,0x808e8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8f91,0x80434343,0x80171717,0x80181818,
+0x801a1a1a,0x801b1b1b,0x801e1e1e,0x8020201e,0x801e1e1e,0x80202020,
+0x801e1e1e,0x80191919,0x80171717,0x80181818,0x80191919,0x80171717,
+0x801a1a1a,0x801f1f1f,0x80212121,0x801f1f1f,0x801d1d1d,0x801e1e1e,
+0x801b1b1b,0x80171717,0x80191919,0x80171717,0x80171717,0x801a1a1a,
+0x801e1e1e,0x801e1e1e,0x801f1f1f,0x80202020,0x801f1f1f,0x801b1b1b,
+0x80181818,0x80181818,0x80181818,0x80181818,0x801a1a1a,0x801c1c1c,
+0x801f1f1f,0x801e1e1e,0x801f1f1f,0x80202020,0x801d1d1d,0x80191919,
+0x80181818,0x80181818,0x80181818,0x80181818,0x801a1a1a,0x801e1e1e,
+0x801f1f1f,0x801d1d1d,0x801d1d1d,0x801f1f1f,0x80181818,0x80121212,
+0x80050505,0x800d0d0d,0x80030303,0x80191919,0x801f1f1f,0x801c1c1c,
+0x801e1e1e,0x801d1d1d,0x801f1f1f,0x801d1d1d,0x80181818,0x80090909,
+0x800c0c0c,0x80070707,0x800b0b0b,0x801d1d1d,0x801e1e1e,0x801f1f1f,
+0x801e1e1e,0x80202020,0x801d1d1d,0x80171717,0x80181818,0x80191919,
+0x80181818,0x80181818,0x801b1b1b,0x801f1f1f,0x80202020,0x801e1e1e,
+0x80202020,0x801c1c1c,0x80181818,0x80181818,0x80181818,0x80181818,
+0x80191919,0x801b1b1b,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x80202020,
+0x801e1e1e,0x801a1a1a,0x80181818,0x80181818,0x80191919,0x80171717,
+0x80191919,0x801e1e1e,0x80202020,0x801e1e1e,0x801d1d1d,0x801e1e1e,
+0x80191919,0x80191919,0x80181818,0x80161616,0x80171717,0x801a1a1a,
+0x801d1d1d,0x801e1e1e,0x801f1d1e,0x80222021,0x801e1c1d,0x801c1c1c,
+0x80181818,0x80080808,0x80000000,0x80010101,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80010101,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80050505,0x80171717,0x80181818,
+0x80171717,0x801a1a1a,0x80161616,0x801a1a1a,0x80909092,0x808f8e93,0x808f8e93,0x80908f94,0x80909092,0x808f9092,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x80909092,0x80444444,0x80181818,0x80191919,
+0x801c1c1c,0x801d1d1d,0x801f1f1f,0x801f1f1d,0x801f1f1f,0x801c1c1c,
+0x80191919,0x80191919,0x80181818,0x80161616,0x80181818,0x801b1b1b,
+0x801e1e1e,0x801d1d1d,0x801f1f1f,0x80202020,0x801e1e1e,0x801a1a1a,
+0x80181818,0x80191919,0x80171717,0x80181818,0x801a1a1a,0x801d1d1d,
+0x801f1f1f,0x801e1e1e,0x801e1e1e,0x80202020,0x801b1b1b,0x80191919,
+0x80181818,0x80181818,0x80171717,0x80181818,0x801c1c1c,0x801f1f1f,
+0x801d1d1d,0x80202020,0x80202020,0x801c1c1c,0x80191919,0x801a1a1a,
+0x80191919,0x80171717,0x80171717,0x801b1b1b,0x801e1e1e,0x801e1e1e,
+0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801b1b1b,0x80171717,0x80171717,
+0x80000000,0x80000000,0x80000000,0x801d1d1d,0x80212121,0x801c1c1c,
+0x801d1d1d,0x801f1f1f,0x801b1b1b,0x80171717,0x80181818,0x80050505,
+0x80010101,0x80000000,0x800e0e0e,0x801d1d1d,0x801e1e1e,0x80212121,
+0x801f1f1f,0x801c1c1c,0x80191919,0x80181818,0x80191919,0x80171717,
+0x80181818,0x801c1c1c,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801f1f1f,
+0x801c1c1c,0x801a1a1a,0x80181818,0x80171717,0x80171717,0x80181818,
+0x801b1b1b,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801f1f1f,0x801e1e1e,
+0x801b1b1b,0x80191919,0x80181818,0x80181818,0x80181818,0x801b1b1b,
+0x801e1e1e,0x801e1e1e,0x801f1f1f,0x80202020,0x801e1e1e,0x801a1a1a,
+0x80191919,0x80181818,0x80161616,0x80171717,0x801a1a1a,0x801e1e1e,
+0x801e1e1e,0x801d1d1d,0x801f1d1e,0x801f1d1e,0x801b191a,0x801a1a1a,
+0x80111111,0x80020202,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80010101,0x80010101,0x80000000,
+0x80000000,0x80000000,0x80000000,0x800a0a0a,0x80181818,0x80191919,
+0x80181818,0x80181818,0x80181818,0x801e1e1e,0x80909092,0x808f8e93,0x80908f94,0x80908f94,0x80909092,0x80909193,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x80909092,0x80454545,0x801a1a1a,0x801c1c1c,
+0x801f1f1f,0x801f1f1f,0x80202020,0x801e1e1c,0x801d1d1d,0x80191919,
+0x80171717,0x80181818,0x80181818,0x80181818,0x801a1a1a,0x801e1e1e,
+0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801e1e1e,0x801c1c1c,0x80171717,
+0x80171717,0x80191919,0x80171717,0x801b1b1b,0x801e1e1e,0x801f1f1f,
+0x801f1f1f,0x801f1f1f,0x801d1d1d,0x801c1c1c,0x80181818,0x80191919,
+0x80181818,0x80171717,0x80191919,0x801c1c1c,0x801e1e1e,0x801f1f1f,
+0x801e1e1e,0x801f1f1f,0x801d1d1d,0x80191919,0x80171717,0x80181818,
+0x80191919,0x80181818,0x801b1b1b,0x801e1e1e,0x801f1f1f,0x801e1e1e,
+0x801e1e1e,0x801e1e1e,0x801b1b1b,0x80171717,0x80181818,0x80151515,
+0x80030303,0x800a0a0a,0x80040404,0x80191919,0x801d1d1d,0x80202020,
+0x801f1f1f,0x801d1d1d,0x80171717,0x80151515,0x80191919,0x80070707,
+0x80050505,0x80070707,0x800e0e0e,0x801f1f1f,0x801f1f1f,0x801f1f1f,
+0x801c1c1c,0x80191919,0x80181818,0x80181818,0x80181818,0x80181818,
+0x801b1b1b,0x801f1f1f,0x80202020,0x801e1e1e,0x801d1d1d,0x801e1e1e,
+0x80191919,0x80191919,0x80181818,0x80171717,0x80181818,0x801b1b1b,
+0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801b1b1b,
+0x80191919,0x80181818,0x80181818,0x80181818,0x801a1a1a,0x801e1e1e,
+0x80202020,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801b1b1b,0x80181818,
+0x80191919,0x80171717,0x80171717,0x801a1a1a,0x801d1d1d,0x801f1f1f,
+0x801e1e1e,0x801e1e1e,0x801e1c1d,0x801d1b1c,0x801a1819,0x80161616,
+0x80090909,0x80000000,0x80020202,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80010101,0x80010101,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80121212,0x80181818,0x80181818,
+0x80191919,0x80191919,0x801e1e1e,0x801f1f1f,0x80909092,0x808f8e93,0x80908f94,0x808f8e93,0x808f8f91,0x808f9092,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8f91,0x80464646,0x801c1c1c,0x801e1e1e,
+0x80202020,0x80202020,0x801f1f1f,0x801c1c1a,0x80191919,0x80191919,
+0x80181818,0x80161616,0x80181818,0x801d1d1d,0x801f1f1f,0x801e1e1e,
+0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801a1a1a,0x80171717,0x80181818,
+0x80181818,0x80171717,0x801b1b1b,0x801d1d1d,0x801e1e1e,0x801e1e1e,
+0x801f1f1f,0x801f1f1f,0x801c1c1c,0x80181818,0x80171717,0x80181818,
+0x80181818,0x80181818,0x801c1c1c,0x80202020,0x80202020,0x801e1e1e,
+0x80202020,0x801c1c1c,0x80191919,0x801a1a1a,0x80181818,0x80161616,
+0x80181818,0x801c1c1c,0x801f1f1f,0x801d1d1d,0x801d1d1d,0x801f1f1f,
+0x801e1e1e,0x801a1a1a,0x80181818,0x80181818,0x80181818,0x80111111,
+0x80060606,0x80121212,0x80080808,0x801b1b1b,0x801f1f1f,0x801e1e1e,
+0x801c1c1c,0x80171717,0x80181818,0x801b1b1b,0x80191919,0x800a0a0a,
+0x800f0f0f,0x800e0e0e,0x800d0d0d,0x80212121,0x801f1f1f,0x801b1b1b,
+0x80181818,0x80191919,0x80191919,0x80181818,0x80171717,0x801c1c1c,
+0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801d1d1d,0x801a1a1a,
+0x80181818,0x80181818,0x80181818,0x80181818,0x801b1b1b,0x801f1f1f,
+0x80202020,0x801d1d1d,0x801e1e1e,0x801e1e1e,0x801c1c1c,0x80191919,
+0x80171717,0x80181818,0x80191919,0x80191919,0x801e1e1e,0x801d1d1d,
+0x801e1e1e,0x80202020,0x801e1e1e,0x80191919,0x80171717,0x80191919,
+0x80171717,0x80181818,0x801a1a1a,0x801e1e1e,0x801f1f1f,0x801e1e1e,
+0x801e1e1e,0x801f1f1f,0x801b191a,0x801b191a,0x80191718,0x80101010,
+0x80020202,0x80000000,0x80020202,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80040404,0x80191919,0x80191919,0x80171717,
+0x80191919,0x801c1c1c,0x80232323,0x801d1d1d,0x80909092,0x808f8e93,0x80908f94,0x808f8e93,0x808e8e90,0x808e8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8f91,0x80474747,0x801e1e1e,0x801f1f1f,
+0x80202020,0x801e1e1e,0x801d1d1d,0x80191917,0x80181818,0x80191919,
+0x80191919,0x80181818,0x801a1a1a,0x801f1f1f,0x801f1f1f,0x801e1e1e,
+0x801e1e1e,0x801e1e1e,0x801b1b1b,0x80181818,0x80171717,0x80181818,
+0x801a1a1a,0x801a1a1a,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801e1e1e,
+0x801d1d1d,0x801c1c1c,0x80191919,0x80171717,0x80181818,0x80191919,
+0x801a1a1a,0x801c1c1c,0x801e1e1e,0x80202020,0x80202020,0x801e1e1e,
+0x801e1e1e,0x80191919,0x80181818,0x80191919,0x80191919,0x80181818,
+0x801a1a1a,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801e1e1e,
+0x801b1b1b,0x80181818,0x80171717,0x80191919,0x801a1a1a,0x80151515,
+0x80030303,0x80060606,0x80000000,0x801c1c1c,0x80212121,0x801b1b1b,
+0x80181818,0x80151515,0x80181818,0x801a1a1a,0x80171717,0x80060606,
+0x80070707,0x80020202,0x800e0e0e,0x801f1f1f,0x801c1c1c,0x80191919,
+0x80181818,0x80181818,0x80181818,0x80191919,0x801b1b1b,0x801e1e1e,
+0x80202020,0x801e1e1e,0x801d1d1d,0x801d1d1d,0x801b1b1b,0x80171717,
+0x80181818,0x80181818,0x80191919,0x801b1b1b,0x801e1e1e,0x80202020,
+0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801b1b1b,0x80191919,0x80181818,
+0x80171717,0x80181818,0x801a1a1a,0x801c1c1c,0x801f1f1f,0x801e1e1e,
+0x801d1d1d,0x801e1e1e,0x801b1b1b,0x80171717,0x80171717,0x80191919,
+0x80181818,0x801b1b1b,0x801d1d1d,0x801e1e1e,0x801e1e1e,0x801e1e1e,
+0x801d1d1d,0x801c1c1c,0x801a1819,0x80191718,0x80141213,0x80060606,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80010101,0x80010101,0x800e0e0e,0x80191919,0x801a1a1a,0x80191919,
+0x801c1c1c,0x801e1e1e,0x80212121,0x801e1e1e,0x808f8f91,0x808f8e93,0x80908f94,0x808f8e93,0x808f8f91,0x808f9092,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x80919193,0x80494949,0x801f1f1f,0x801f1f1f,
+0x801f1f1f,0x801c1c1c,0x801a1a1a,0x80161614,0x80191919,0x80171717,
+0x80171717,0x801b1b1b,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801f1f1f,
+0x801f1f1f,0x801a1a1a,0x80171717,0x80191919,0x80191919,0x80171717,
+0x801a1a1a,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x80202020,0x80202020,
+0x801c1c1c,0x80181818,0x80171717,0x80191919,0x80191919,0x80191919,
+0x801c1c1c,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x80202020,
+0x80191919,0x80191919,0x80181818,0x80171717,0x80181818,0x801c1c1c,
+0x801f1f1f,0x801f1f1f,0x801d1d1d,0x801f1f1f,0x801f1f1f,0x801b1b1b,
+0x80171717,0x80181818,0x80191919,0x80181818,0x80181818,0x801b1b1b,
+0x80030303,0x80010101,0x80000000,0x80181818,0x80171717,0x80171717,
+0x80151515,0x80181818,0x80161616,0x80151515,0x801a1a1a,0x80090909,
+0x80030303,0x80000000,0x80101010,0x801c1c1c,0x80171717,0x80191919,
+0x801a1a1a,0x80171717,0x80161616,0x801b1b1b,0x80202020,0x801e1e1e,
+0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801a1a1a,0x80171717,0x80171717,
+0x80171717,0x80181818,0x801b1b1b,0x801e1e1e,0x801f1f1f,0x801d1d1d,
+0x801e1e1e,0x80202020,0x801d1d1d,0x80191919,0x80161616,0x80181818,
+0x80191919,0x80191919,0x801c1c1c,0x80202020,0x801d1d1d,0x801f1f1f,
+0x801e1e1e,0x801a1a1a,0x80181818,0x80191919,0x80191919,0x80181818,
+0x801a1a1a,0x801d1d1d,0x801e1e1e,0x801d1d1d,0x801e1e1e,0x801f1f1f,
+0x801c1c1c,0x80171717,0x80191718,0x80171516,0x800e0c0d,0x80000000,
+0x80000000,0x80020202,0x80000000,0x80010101,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80010101,0x80030303,0x80181818,0x80161616,0x80181818,0x801d1d1d,
+0x80202020,0x801e1e1e,0x801b1b1b,0x80202020,0x808f8f91,0x808f8e93,0x80908f94,0x808f8e93,0x808e8e90,0x808e8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x80919193,0x80484848,0x801e1e1e,0x801f1f1f,
+0x801d1d1d,0x80181818,0x80181818,0x80181816,0x80171717,0x80181818,
+0x801a1a1a,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801f1f1f,
+0x80181818,0x801a1a1a,0x80191919,0x80171717,0x80171717,0x801b1b1b,
+0x801e1e1e,0x801f1f1f,0x801d1d1d,0x801f1f1f,0x801f1f1f,0x801b1b1b,
+0x80181818,0x80171717,0x80181818,0x80191919,0x80181818,0x801d1d1d,
+0x801f1f1f,0x801d1d1d,0x801e1e1e,0x80202020,0x801e1e1e,0x80191919,
+0x80181818,0x80191919,0x80181818,0x80171717,0x801b1b1b,0x801f1f1f,
+0x801f1f1f,0x801d1d1d,0x80212121,0x801c1c1c,0x80191919,0x80191919,
+0x80191919,0x80171717,0x80181818,0x801a1a1a,0x80202020,0x801a1a1a,
+0x80060606,0x80121212,0x80010101,0x80030303,0x80030303,0x80010101,
+0x80030303,0x80010101,0x80040404,0x80030303,0x80030303,0x80020202,
+0x80111111,0x800c0c0c,0x800c0c0c,0x801a1a1a,0x80181818,0x80191919,
+0x80171717,0x80171717,0x801b1b1b,0x80212121,0x801d1d1d,0x80202020,
+0x80202020,0x801c1c1c,0x80191919,0x80181818,0x80181818,0x80171717,
+0x80161616,0x801b1b1b,0x801e1e1e,0x801d1d1d,0x801d1d1d,0x801f1f1f,
+0x801e1e1e,0x801b1b1b,0x80181818,0x80191919,0x80181818,0x80171717,
+0x801a1a1a,0x801e1e1e,0x801f1f1f,0x801d1d1d,0x801f1f1f,0x801f1f1f,
+0x801c1c1c,0x80181818,0x80161616,0x80171717,0x80191919,0x80191919,
+0x801f1f1f,0x80202020,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801c1c1c,
+0x80181818,0x80171717,0x801b1b1b,0x800d0d0d,0x80010101,0x80000000,
+0x80010101,0x80000000,0x80000000,0x80010101,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80020202,0x80000000,0x80010101,0x80000000,
+0x80000000,0x80111111,0x80151515,0x801b1b1b,0x801e1e1e,0x801e1e1e,
+0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801b1b1b,0x808f8f91,0x808f8e93,0x80908f94,0x808f8e93,0x808f8f91,0x808f9092,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8f91,0x80494949,0x801f1f1f,0x801c1c1c,
+0x801a1a1a,0x80191919,0x80191919,0x80161614,0x80181818,0x801c1c1c,
+0x801f1f1f,0x801d1d1d,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801a1a1a,
+0x801a1a1a,0x80181818,0x80171717,0x80181818,0x801b1b1b,0x801d1d1d,
+0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801d1d1d,0x801b1b1b,0x80191919,
+0x80191919,0x80181818,0x80191919,0x80191919,0x801d1d1d,0x801d1d1d,
+0x801e1e1e,0x80202020,0x801f1f1f,0x801c1c1c,0x80191919,0x80191919,
+0x80191919,0x80171717,0x80181818,0x801b1b1b,0x801e1e1e,0x801d1d1d,
+0x801e1e1e,0x801f1f1f,0x801c1c1c,0x801b1b1b,0x80191919,0x80181818,
+0x80171717,0x80181818,0x801b1b1b,0x801d1d1d,0x801d1d1d,0x80191919,
+0x80050505,0x80121212,0x80030303,0x80010101,0x80000000,0x80020202,
+0x80010101,0x80010101,0x80000000,0x80000000,0x80020202,0x80000000,
+0x80090909,0x80090909,0x800b0b0b,0x801b1b1b,0x80181818,0x80171717,
+0x80171717,0x801c1c1c,0x801f1f1f,0x801e1e1e,0x80202020,0x801e1e1e,
+0x801c1c1c,0x801a1a1a,0x80191919,0x80181818,0x80181818,0x80181818,
+0x801b1b1b,0x801c1c1c,0x801d1d1d,0x801e1e1e,0x801f1f1f,0x801e1e1e,
+0x801b1b1b,0x80181818,0x80191919,0x80171717,0x80171717,0x801b1b1b,
+0x801d1d1d,0x801d1d1d,0x801e1e1e,0x80202020,0x801f1f1f,0x801b1b1b,
+0x80181818,0x80191919,0x80191919,0x80171717,0x80191919,0x801e1e1e,
+0x801e1e1e,0x801d1d1d,0x801f1f1f,0x80202020,0x801b1b1b,0x80181818,
+0x80191919,0x80191919,0x80121212,0x80080808,0x80000000,0x80000000,
+0x80010101,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80010101,0x80000000,0x80010101,0x80010101,0x80000000,
+0x80060606,0x80151515,0x801b1b1b,0x801c1c1c,0x801e1e1e,0x801f1f1f,
+0x801f1f1f,0x801e1e1e,0x801b1b1b,0x80181818,0x808f8f91,0x808f8e93,0x80908f94,0x808f8e93,0x808f8f91,0x808f9092,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8f91,0x80494949,0x801e1e1e,0x801a1a1a,
+0x80181818,0x80181818,0x80191919,0x80171715,0x801a1a1a,0x801f1f1f,
+0x80212121,0x801f1f1f,0x801d1d1d,0x801e1e1e,0x801b1b1b,0x80171717,
+0x80191919,0x80171717,0x80171717,0x801a1a1a,0x801e1e1e,0x801e1e1e,
+0x801f1f1f,0x80202020,0x801f1f1f,0x801b1b1b,0x80181818,0x80181818,
+0x80181818,0x80181818,0x801a1a1a,0x801c1c1c,0x801f1f1f,0x801e1e1e,
+0x801f1f1f,0x80202020,0x801d1d1d,0x80191919,0x80181818,0x80181818,
+0x80181818,0x80181818,0x801a1a1a,0x801e1e1e,0x801f1f1f,0x801d1d1d,
+0x801d1d1d,0x801f1f1f,0x80191919,0x80191919,0x80181818,0x80161616,
+0x80171717,0x801a1a1a,0x801d1d1d,0x801e1e1e,0x80202020,0x801d1d1d,
+0x80000000,0x80020202,0x80000000,0x800f0f0f,0x80111111,0x80141414,
+0x80131313,0x80181818,0x80181818,0x80171717,0x801a1a1a,0x80080808,
+0x80020202,0x80000000,0x800b0b0b,0x801b1b1b,0x80181818,0x80181818,
+0x801a1a1a,0x801f1f1f,0x80202020,0x801d1d1d,0x80202020,0x801c1c1c,
+0x80181818,0x80181818,0x80181818,0x80181818,0x80191919,0x801b1b1b,
+0x801e1e1e,0x801d1d1d,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801b1b1b,
+0x80181818,0x80181818,0x80181818,0x80171717,0x80191919,0x801e1e1e,
+0x80202020,0x801f1f1f,0x801e1e1e,0x801f1f1f,0x801d1d1d,0x80191919,
+0x80171717,0x80181818,0x80191919,0x80191919,0x801c1c1c,0x80202020,
+0x801f1f1f,0x801c1c1c,0x801e1e1e,0x801d1d1d,0x80171717,0x80181818,
+0x801a1a1a,0x80151515,0x80060606,0x80020202,0x80000000,0x80000000,
+0x80010101,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80010101,0x80000000,0x80020202,0x80000000,0x80000000,
+0x80101010,0x801b1b1b,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x80202020,
+0x801f1f1f,0x801b1b1b,0x80181818,0x80171717,0x80909092,0x808f8e93,0x80908f94,0x808f8e93,0x808f8f91,0x808f9092,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x80909092,0x80454545,0x80191919,0x80191919,
+0x80191919,0x80161616,0x80191919,0x801b1b19,0x801e1e1e,0x801d1d1d,
+0x801f1f1f,0x80202020,0x801e1e1e,0x801a1a1a,0x80181818,0x80191919,
+0x80171717,0x80181818,0x801a1a1a,0x801d1d1d,0x801f1f1f,0x801e1e1e,
+0x801e1e1e,0x80202020,0x801b1b1b,0x80191919,0x80181818,0x80181818,
+0x80171717,0x80181818,0x801c1c1c,0x801f1f1f,0x801d1d1d,0x80202020,
+0x80202020,0x801c1c1c,0x80191919,0x801a1a1a,0x80191919,0x80171717,
+0x80171717,0x801b1b1b,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801f1f1f,
+0x801e1e1e,0x801b1b1b,0x80191919,0x80181818,0x80161616,0x80171717,
+0x801a1a1a,0x801e1e1e,0x801e1e1e,0x801d1d1d,0x801e1e1e,0x801c1c1c,
+0x80000000,0x80020202,0x80000000,0x80181818,0x801b1b1b,0x80181818,
+0x801c1c1c,0x80202020,0x801f1f1f,0x801e1e1e,0x801f1f1f,0x80090909,
+0x80020202,0x80000000,0x800c0c0c,0x80181818,0x80171717,0x801c1c1c,
+0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801f1f1f,0x801c1c1c,0x801a1a1a,
+0x80181818,0x80171717,0x80171717,0x80181818,0x801b1b1b,0x801e1e1e,
+0x801d1d1d,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801b1b1b,0x80181818,
+0x80181818,0x80191919,0x80171717,0x801b1b1b,0x801e1e1e,0x801e1e1e,
+0x801f1f1f,0x80202020,0x801f1f1f,0x801b1b1b,0x80191919,0x801a1a1a,
+0x80191919,0x80171717,0x80191919,0x801d1d1d,0x801f1f1f,0x801e1e1e,
+0x80202020,0x801e1e1e,0x801c1c1c,0x80181818,0x80171717,0x801b1b1b,
+0x80171717,0x800b0b0b,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80010101,0x80010101,0x80010101,0x80000000,0x80060606,
+0x80181818,0x801f1f1f,0x801e1e1e,0x801f1f1f,0x80202020,0x801f1f1f,
+0x801b1b1b,0x80181818,0x80171717,0x80191919,0x80909092,0x80908f94,0x80908f94,0x808f8e93,0x808e8e90,0x808e8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x80909092,0x80444444,0x80181818,0x80181818,
+0x80181818,0x80171717,0x801b1b1b,0x801e1e1c,0x801f1f1f,0x801e1e1e,
+0x801d1d1d,0x801e1e1e,0x801c1c1c,0x80171717,0x80171717,0x80191919,
+0x80171717,0x801b1b1b,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801f1f1f,
+0x801d1d1d,0x801c1c1c,0x80181818,0x80191919,0x80181818,0x80171717,
+0x80191919,0x801c1c1c,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801f1f1f,
+0x801d1d1d,0x80191919,0x80171717,0x80181818,0x80191919,0x80181818,
+0x801b1b1b,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801e1e1e,
+0x801b1b1b,0x80171717,0x80191919,0x80171717,0x80171717,0x801a1a1a,
+0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801d1d1d,0x80171717,
+0x80050505,0x800e0e0e,0x80050505,0x80141414,0x80181818,0x801a1a1a,
+0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801c1c1c,0x80090909,
+0x800a0a0a,0x800c0c0c,0x800b0b0b,0x80191919,0x801a1a1a,0x801f1f1f,
+0x80202020,0x801e1e1e,0x801d1d1d,0x801d1d1d,0x80191919,0x80191919,
+0x80181818,0x80171717,0x80181818,0x801b1b1b,0x801e1e1e,0x801f1f1f,
+0x801d1d1d,0x801f1f1f,0x801f1f1f,0x801b1b1b,0x80181818,0x80171717,
+0x80181818,0x80191919,0x801a1a1a,0x801d1d1d,0x80202020,0x801f1f1f,
+0x801f1f1f,0x801f1f1f,0x801c1c1c,0x80191919,0x80171717,0x80191919,
+0x801a1a1a,0x80191919,0x801b1b1b,0x801f1f1f,0x801f1f1f,0x801e1e1e,
+0x801f1f1f,0x801d1d1d,0x80191919,0x80181818,0x801a1a1a,0x80181818,
+0x800d0d0d,0x80020202,0x80000000,0x80000000,0x80010101,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80020202,0x80000000,0x80010101,0x80131313,
+0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801b1b1b,
+0x80181818,0x80171717,0x80181818,0x80191919,0x80919193,0x808f8e93,0x80908f94,0x808f8e93,0x808e8e90,0x808e8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808e8e90,0x80464646,0x80191919,0x80161616,
+0x80181818,0x801c1c1c,0x801f1f1f,0x801e1e1c,0x801f1f1f,0x801f1f1f,
+0x801e1e1e,0x801a1a1a,0x80171717,0x80181818,0x80181818,0x80171717,
+0x801b1b1b,0x801d1d1d,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801f1f1f,
+0x801c1c1c,0x80181818,0x80171717,0x80181818,0x80181818,0x80181818,
+0x801c1c1c,0x80202020,0x80202020,0x801e1e1e,0x80202020,0x801c1c1c,
+0x80191919,0x801a1a1a,0x80181818,0x80161616,0x80181818,0x801c1c1c,
+0x801f1f1f,0x801d1d1d,0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801a1a1a,
+0x80181818,0x80181818,0x80171717,0x80181818,0x801a1a1a,0x801e1e1e,
+0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801c1c1c,0x80151515,
+0x80020202,0x80080808,0x80000000,0x80171717,0x801f1f1f,0x80212121,
+0x801e1e1e,0x801d1d1d,0x801f1f1f,0x801f1f1f,0x801b1b1b,0x80060606,
+0x80050505,0x80020202,0x80090909,0x801d1d1d,0x801e1e1e,0x801e1e1e,
+0x801e1e1e,0x801e1e1e,0x801d1d1d,0x801a1a1a,0x80181818,0x80181818,
+0x80181818,0x80181818,0x801b1b1b,0x801f1f1f,0x80202020,0x801d1d1d,
+0x801f1f1f,0x801e1e1e,0x801b1b1b,0x80181818,0x80171717,0x80181818,
+0x80191919,0x80181818,0x801e1e1e,0x801d1d1d,0x801f1f1f,0x80202020,
+0x801f1f1f,0x801a1a1a,0x80181818,0x80191919,0x80181818,0x80171717,
+0x80191919,0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801f1f1f,
+0x801c1c1c,0x80191919,0x80181818,0x801b1b1b,0x801a1a1a,0x800e0e0e,
+0x80020202,0x80000000,0x80000000,0x80010101,0x80010101,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80010101,0x80000000,0x80000000,0x80000000,0x800b0b0b,0x801f1f1f,
+0x801f1f1f,0x801c1c1c,0x801f1f1f,0x801e1e1e,0x801b1b1b,0x80181818,
+0x80171717,0x80181818,0x80191919,0x80181818,0x80919193,0x808f8e93,0x80908f94,0x80908f94,0x808f8f91,0x808f9092,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808e8e90,0x80454545,0x80191919,0x80171717,
+0x801a1a1a,0x801e1e1e,0x80202020,0x801d1d1b,0x801e1e1e,0x801e1e1e,
+0x801b1b1b,0x80181818,0x80171717,0x80181818,0x801a1a1a,0x801a1a1a,
+0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801c1c1c,
+0x80191919,0x80171717,0x80181818,0x80191919,0x801a1a1a,0x801c1c1c,
+0x801e1e1e,0x80202020,0x80202020,0x801e1e1e,0x801e1e1e,0x80191919,
+0x80181818,0x80191919,0x80191919,0x80181818,0x801a1a1a,0x801f1f1f,
+0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801e1e1e,0x801b1b1b,0x80181818,
+0x80171717,0x80191919,0x80181818,0x801b1b1b,0x801d1d1d,0x801e1e1e,
+0x801e1e1e,0x801e1e1e,0x801d1d1d,0x801c1c1c,0x80171717,0x80151515,
+0x80000000,0x80010101,0x80000000,0x801c1c1c,0x80202020,0x801c1c1c,
+0x801f1f1f,0x801d1d1d,0x801c1c1c,0x801a1a1a,0x80191919,0x80050505,
+0x80020202,0x80000000,0x800c0c0c,0x801f1f1f,0x801f1f1f,0x801e1e1e,
+0x801d1d1d,0x801d1d1d,0x801b1b1b,0x80171717,0x80181818,0x80181818,
+0x80191919,0x801b1b1b,0x801e1e1e,0x80202020,0x801f1f1f,0x801e1e1e,
+0x801e1e1e,0x801b1b1b,0x80181818,0x80181818,0x80181818,0x80191919,
+0x801a1a1a,0x801b1b1b,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801f1f1f,
+0x801c1c1c,0x80181818,0x80171717,0x80191919,0x80181818,0x80191919,
+0x801c1c1c,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801e1e1e,
+0x80191919,0x80171717,0x80181818,0x80181818,0x800f0f0f,0x80030303,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80010101,0x80000000,0x80000000,0x80070707,0x80181818,0x80212121,
+0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801b1b1b,0x80181818,0x80171717,
+0x80181818,0x80191919,0x801b1b1b,0x801c1c1c,0x80919193,0x808f8e93,0x80908f94,0x80908f94,0x80909092,0x808f9092,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x80909092,0x80444444,0x80171717,0x801b1b1b,
+0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801e1e1c,0x801f1f1f,0x801a1a1a,
+0x80171717,0x80191919,0x80191919,0x80171717,0x801a1a1a,0x801e1e1e,
+0x801f1f1f,0x801f1f1f,0x80202020,0x80202020,0x801c1c1c,0x80181818,
+0x80171717,0x80191919,0x80191919,0x80191919,0x801c1c1c,0x801f1f1f,
+0x801f1f1f,0x801e1e1e,0x801e1e1e,0x80202020,0x80191919,0x80191919,
+0x80181818,0x80171717,0x80181818,0x801c1c1c,0x801f1f1f,0x801f1f1f,
+0x801d1d1d,0x801f1f1f,0x801f1f1f,0x801b1b1b,0x80171717,0x80181818,
+0x80191919,0x80181818,0x801a1a1a,0x801d1d1d,0x801e1e1e,0x801d1d1d,
+0x801e1e1e,0x801f1f1f,0x801c1c1c,0x80171717,0x80171717,0x80171717,
+0x80040404,0x80070707,0x80050505,0x801c1c1c,0x801c1c1c,0x80202020,
+0x801f1f1f,0x801e1e1e,0x80191919,0x80161616,0x80191919,0x80090909,
+0x80070707,0x80060606,0x80101010,0x801e1e1e,0x801d1d1d,0x80202020,
+0x801e1e1e,0x801a1a1a,0x80181818,0x80181818,0x80171717,0x80181818,
+0x801b1b1b,0x801e1e1e,0x801f1f1f,0x801d1d1d,0x801e1e1e,0x80202020,
+0x801b1b1b,0x80181818,0x80181818,0x80191919,0x80191919,0x80181818,
+0x801b1b1b,0x80202020,0x801d1d1d,0x80202020,0x801f1f1f,0x801b1b1b,
+0x80191919,0x80191919,0x80191919,0x80181818,0x80181818,0x801d1d1d,
+0x80202020,0x801e1e1e,0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801a1a1a,
+0x80181818,0x80181818,0x80181818,0x80111111,0x80020202,0x80000000,
+0x80010101,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80010101,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80020202,0x80000000,0x80111111,0x80212121,0x801d1d1d,
+0x801c1c1c,0x80212121,0x801b1b1b,0x80181818,0x80171717,0x80191919,
+0x80191919,0x80181818,0x801c1c1c,0x80212121,0x80919193,0x808f8e93,0x808f8e93,0x808f8e93,0x80909092,0x808e8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x80909092,0x80444444,0x801b1b1b,0x801e1e1e,
+0x801f1f1f,0x801d1d1d,0x801f1f1f,0x801e1e1c,0x80181818,0x801a1a1a,
+0x80191919,0x80171717,0x80171717,0x801b1b1b,0x801e1e1e,0x801f1f1f,
+0x801d1d1d,0x801f1f1f,0x801f1f1f,0x801b1b1b,0x80181818,0x80171717,
+0x80181818,0x80191919,0x80181818,0x801d1d1d,0x801f1f1f,0x801d1d1d,
+0x801e1e1e,0x80202020,0x801e1e1e,0x80191919,0x80181818,0x80191919,
+0x80181818,0x80171717,0x801b1b1b,0x801f1f1f,0x801f1f1f,0x801d1d1d,
+0x80212121,0x801c1c1c,0x80191919,0x80191919,0x80191919,0x80171717,
+0x80181818,0x801a1a1a,0x80202020,0x801e1e1e,0x801e1e1e,0x801f1f1f,
+0x801f1f1f,0x801c1c1c,0x80191919,0x80181818,0x80191919,0x80141414,
+0x80070707,0x80131313,0x80030303,0x801c1c1c,0x801e1e1e,0x80212121,
+0x801e1e1e,0x80181818,0x80171717,0x80181818,0x80181818,0x80090909,
+0x800e0e0e,0x800e0e0e,0x800d0d0d,0x801f1f1f,0x801f1f1f,0x801e1e1e,
+0x80191919,0x80171717,0x80181818,0x80191919,0x80161616,0x801b1b1b,
+0x801e1e1e,0x801d1d1d,0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801b1b1b,
+0x80181818,0x80191919,0x80181818,0x80171717,0x801a1a1a,0x801e1e1e,
+0x801f1f1f,0x801d1d1d,0x80202020,0x801f1f1f,0x801c1c1c,0x80191919,
+0x80171717,0x80171717,0x80181818,0x80171717,0x801c1c1c,0x801e1e1e,
+0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801d1d1d,0x801b1b1b,0x80171717,
+0x80181818,0x80181818,0x80101010,0x80030303,0x80000000,0x80000000,
+0x80010101,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80010101,0x80000000,0x80000000,
+0x80000000,0x80000000,0x800e0e0e,0x801d1d1d,0x801d1d1d,0x801d1d1d,
+0x801f1f1f,0x801b1b1b,0x80181818,0x80191919,0x80181818,0x80171717,
+0x801a1a1a,0x801e1e1e,0x801f1f1f,0x801d1d1d,0x80909092,0x808f8e93,0x808f8e93,0x808f8e93,0x80909092,0x808e8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8f91,0x80484848,0x801f1f1f,0x801e1e1e,
+0x801d1d1d,0x801e1e1e,0x801f1f1f,0x80191917,0x801a1a1a,0x80181818,
+0x80171717,0x80181818,0x801b1b1b,0x801d1d1d,0x801e1e1e,0x801f1f1f,
+0x801f1f1f,0x801d1d1d,0x801b1b1b,0x80191919,0x80191919,0x80181818,
+0x80191919,0x80191919,0x801d1d1d,0x801d1d1d,0x801e1e1e,0x80202020,
+0x801f1f1f,0x801c1c1c,0x80191919,0x80191919,0x80191919,0x80171717,
+0x80181818,0x801b1b1b,0x801e1e1e,0x801d1d1d,0x801e1e1e,0x801f1f1f,
+0x801c1c1c,0x801b1b1b,0x80191919,0x80181818,0x80171717,0x80181818,
+0x801b1b1b,0x801d1d1d,0x801e1e1e,0x801f1f1f,0x80202020,0x801e1e1e,
+0x801b1b1b,0x80191919,0x80181818,0x80181818,0x80181818,0x80181818,
+0x80000000,0x80010101,0x80000000,0x801e1e1e,0x801e1e1e,0x801c1c1c,
+0x80171717,0x801a1a1a,0x80191919,0x80181818,0x801a1a1a,0x80050505,
+0x80000000,0x80000000,0x80101010,0x801f1f1f,0x801c1c1c,0x801b1b1b,
+0x80191919,0x80181818,0x80181818,0x80181818,0x801b1b1b,0x801c1c1c,
+0x801d1d1d,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801b1b1b,0x80181818,
+0x80191919,0x80171717,0x80171717,0x801b1b1b,0x801d1d1d,0x801d1d1d,
+0x801e1e1e,0x80202020,0x801f1f1f,0x801a1a1a,0x80181818,0x80191919,
+0x80191919,0x80171717,0x80181818,0x801c1c1c,0x80222222,0x801e1e1e,
+0x801d1d1d,0x80202020,0x801f1f1f,0x801a1a1a,0x80161616,0x80171717,
+0x80171717,0x800c0c0c,0x80010101,0x80000000,0x80010101,0x80010101,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80010101,0x80000000,
+0x80000000,0x80010101,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80070707,0x80161616,0x801f1f1f,0x801f1f1f,0x801d1d1d,
+0x801c1c1c,0x80191919,0x80191919,0x80171717,0x80171717,0x801b1b1b,
+0x801d1d1d,0x801d1d1d,0x801e1e1e,0x80202020,0x80909092,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8f91,0x808e8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8f91,0x80494949,0x80202020,0x801f1f1f,
+0x801d1d1d,0x801d1d1d,0x801c1c1c,0x80171715,0x80191919,0x80171717,
+0x80171717,0x801a1a1a,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x80202020,
+0x801f1f1f,0x801b1b1b,0x80181818,0x80181818,0x80181818,0x80181818,
+0x801a1a1a,0x801c1c1c,0x801f1f1f,0x801e1e1e,0x801f1f1f,0x80202020,
+0x801d1d1d,0x80191919,0x80181818,0x80181818,0x80181818,0x80181818,
+0x801a1a1a,0x801e1e1e,0x801f1f1f,0x801d1d1d,0x801d1d1d,0x801f1f1f,
+0x80191919,0x80191919,0x80181818,0x80161616,0x80171717,0x801a1a1a,
+0x801d1d1d,0x801e1e1e,0x801e1e1e,0x80202020,0x801f1f1f,0x801b1b1b,
+0x80181818,0x80181818,0x80181818,0x80181818,0x80161616,0x801a1a1a,
+0x80030303,0x80040404,0x80020202,0x80121212,0x80131313,0x80121212,
+0x80101010,0x80121212,0x80111111,0x800f0f0f,0x80111111,0x80030303,
+0x80040404,0x80020202,0x800f0f0f,0x801d1d1d,0x80191919,0x80191919,
+0x80181818,0x80181818,0x80191919,0x80191919,0x801e1e1e,0x801d1d1d,
+0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801b1b1b,0x80181818,0x80181818,
+0x80181818,0x80171717,0x80191919,0x801e1e1e,0x80202020,0x801f1f1f,
+0x801e1e1e,0x801f1f1f,0x801c1c1c,0x80181818,0x80161616,0x80181818,
+0x80191919,0x80191919,0x801b1b1b,0x801f1f1f,0x801b1b1b,0x801f1f1f,
+0x80212121,0x801d1d1d,0x80191919,0x80181818,0x80181818,0x80171717,
+0x80090909,0x80010101,0x80000000,0x80010101,0x80030303,0x80000000,
+0x80000000,0x80010101,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80010101,0x80000000,
+0x80000000,0x80020202,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80030303,0x80141414,0x801f1f1f,0x80202020,0x801f1f1f,0x801c1c1c,
+0x80181818,0x80181818,0x80181818,0x80171717,0x80191919,0x801e1e1e,
+0x80202020,0x801f1f1f,0x801e1e1e,0x801f1f1f,0x808f8f91,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8f91,0x808e8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x80909092,0x80474747,0x801e1e1e,0x80202020,
+0x801e1e1e,0x80191919,0x80191919,0x80191917,0x80171717,0x80181818,
+0x801a1a1a,0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x80202020,
+0x801b1b1b,0x80191919,0x80181818,0x80181818,0x80171717,0x80181818,
+0x801c1c1c,0x801f1f1f,0x801d1d1d,0x80202020,0x80202020,0x801c1c1c,
+0x80191919,0x801a1a1a,0x80191919,0x80171717,0x80171717,0x801b1b1b,
+0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801b1b1b,
+0x80191919,0x80181818,0x80161616,0x80171717,0x801a1a1a,0x801e1e1e,
+0x801e1e1e,0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801b1b1b,0x80181818,
+0x80171717,0x80181818,0x80191919,0x80181818,0x801e1e1e,0x801a1a1a,
+0x800b0b0b,0x80141414,0x80050505,0x80000000,0x80010101,0x80020202,
+0x80030303,0x80000000,0x80000000,0x80000000,0x80010101,0x80010101,
+0x80111111,0x800e0e0e,0x800c0c0c,0x801a1a1a,0x80181818,0x80181818,
+0x80171717,0x80181818,0x801b1b1b,0x801e1e1e,0x801d1d1d,0x801e1e1e,
+0x801f1f1f,0x801f1f1f,0x801b1b1b,0x80181818,0x80181818,0x80191919,
+0x80171717,0x801b1b1b,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x80202020,
+0x801f1f1f,0x801b1b1b,0x80191919,0x80191919,0x80181818,0x80161616,
+0x80181818,0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801f1f1f,
+0x801c1c1c,0x80181818,0x80191919,0x801a1a1a,0x80121212,0x80060606,
+0x80000000,0x80000000,0x80020202,0x80020202,0x80000000,0x80000000,
+0x80000000,0x80010101,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80010101,0x80000000,0x80000000,0x80010101,0x80000000,0x80000000,
+0x800f0f0f,0x801d1d1d,0x80222222,0x801d1d1d,0x801b1b1b,0x80191919,
+0x80171717,0x80181818,0x80171717,0x801b1b1b,0x801e1e1e,0x801e1e1e,
+0x801f1f1f,0x80202020,0x801f1f1f,0x801b1b1b,0x808f8f91,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8f91,0x808e8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x80909092,0x80474747,0x801d1d1d,0x801e1e1e,
+0x801c1c1c,0x80171717,0x80171717,0x80191917,0x80171717,0x801b1b1b,
+0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801f1f1f,0x801d1d1d,0x801c1c1c,
+0x80181818,0x80191919,0x80181818,0x80171717,0x80191919,0x801c1c1c,
+0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801f1f1f,0x801d1d1d,0x80191919,
+0x80171717,0x80181818,0x80191919,0x80181818,0x801b1b1b,0x801e1e1e,
+0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801b1b1b,0x80171717,
+0x80191919,0x80171717,0x80171717,0x801a1a1a,0x801d1d1d,0x801f1f1f,
+0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801b1b1b,0x80181818,0x80171717,
+0x80171717,0x80181818,0x801a1a1a,0x801c1c1c,0x80202020,0x80161616,
+0x80010101,0x800a0a0a,0x80010101,0x80000000,0x80020202,0x80020202,
+0x80030303,0x80000000,0x80040404,0x80040404,0x80020202,0x80000000,
+0x80090909,0x80030303,0x800b0b0b,0x80191919,0x80161616,0x80181818,
+0x80181818,0x801a1a1a,0x801d1d1d,0x80202020,0x801d1d1d,0x801f1f1f,
+0x801f1f1f,0x801b1b1b,0x80181818,0x80171717,0x80181818,0x80191919,
+0x801a1a1a,0x801d1d1d,0x80202020,0x801f1f1f,0x801f1f1f,0x801f1f1f,
+0x801c1c1c,0x80191919,0x80171717,0x80191919,0x80191919,0x80181818,
+0x801b1b1b,0x801f1f1f,0x80202020,0x801e1e1e,0x80202020,0x801c1c1c,
+0x80191919,0x80191919,0x80171717,0x800e0e0e,0x80040404,0x80000000,
+0x80000000,0x80010101,0x80010101,0x80000000,0x80000000,0x80010101,
+0x80010101,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80010101,
+0x80000000,0x80000000,0x80010101,0x80000000,0x80000000,0x800b0b0b,
+0x801d1d1d,0x80202020,0x801f1f1f,0x801b1b1b,0x80181818,0x80171717,
+0x80171717,0x80181818,0x801a1a1a,0x801d1d1d,0x80202020,0x801f1f1f,
+0x801f1f1f,0x801f1f1f,0x801c1c1c,0x80191919,0x808f8f91,0x80908f94,0x808f8e93,0x808f8e93,0x808f8f91,0x808e8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8f91,0x804a4a4a,0x801d1d1d,0x80191919,
+0x80181818,0x80181818,0x80191919,0x80171715,0x801b1b1b,0x801d1d1d,
+0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801c1c1c,0x80181818,
+0x80171717,0x80181818,0x80181818,0x80181818,0x801c1c1c,0x80202020,
+0x80202020,0x801e1e1e,0x80202020,0x801c1c1c,0x80191919,0x801a1a1a,
+0x80181818,0x80161616,0x80181818,0x801c1c1c,0x801f1f1f,0x801d1d1d,
+0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801a1a1a,0x80181818,0x80181818,
+0x80171717,0x80181818,0x801a1a1a,0x801e1e1e,0x801f1f1f,0x801e1e1e,
+0x801e1e1e,0x801f1f1f,0x801c1c1c,0x80191919,0x80181818,0x80181818,
+0x80181818,0x80181818,0x801c1c1c,0x80202020,0x80202020,0x801d1d1d,
+0x80000000,0x80010101,0x80020202,0x80141414,0x80161616,0x80161616,
+0x80161616,0x801b1b1b,0x801d1d1d,0x801b1b1b,0x801b1b1b,0x80070707,
+0x80030303,0x80000000,0x800c0c0c,0x80181818,0x80161616,0x80191919,
+0x801b1b1b,0x801d1d1d,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801e1e1e,
+0x801b1b1b,0x80181818,0x80171717,0x80181818,0x80191919,0x80181818,
+0x801e1e1e,0x801d1d1d,0x801f1f1f,0x80202020,0x801f1f1f,0x801a1a1a,
+0x80181818,0x80191919,0x80171717,0x80171717,0x80191919,0x801d1d1d,
+0x801f1f1f,0x801f1f1f,0x801f1f1f,0x801f1f1f,0x801b1b1b,0x801b1b1b,
+0x80191919,0x80121212,0x80070707,0x80000000,0x80000000,0x80020202,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80010101,0x80000000,
+0x80000000,0x80010101,0x80010101,0x80000000,0x80060606,0x801b1b1b,
+0x80222222,0x801d1d1d,0x801b1b1b,0x801a1a1a,0x80181818,0x80171717,
+0x80181818,0x80191919,0x801e1e1e,0x801d1d1d,0x801f1f1f,0x80202020,
+0x801f1f1f,0x801a1a1a,0x80181818,0x80191919,0x808f8f91,0x80908f94,0x808f8e93,0x808f8e93,0x80909092,0x808f9092,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8f91,0x80494949,0x801c1c1c,0x80171717,
+0x80171717,0x80181818,0x801a1a1a,0x80191917,0x801e1e1e,0x801e1e1e,
+0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801c1c1c,0x80191919,0x80171717,
+0x80181818,0x80191919,0x801a1a1a,0x801c1c1c,0x801e1e1e,0x80202020,
+0x80202020,0x801e1e1e,0x801e1e1e,0x80191919,0x80181818,0x80191919,
+0x80191919,0x80181818,0x801a1a1a,0x801f1f1f,0x801f1f1f,0x801e1e1e,
+0x801d1d1d,0x801e1e1e,0x801b1b1b,0x80181818,0x80171717,0x80191919,
+0x80181818,0x801b1b1b,0x801d1d1d,0x801e1e1e,0x801e1e1e,0x801e1e1e,
+0x801d1d1d,0x801c1c1c,0x80191919,0x80181818,0x80181818,0x80191919,
+0x801a1a1a,0x801c1c1c,0x801e1e1e,0x80202020,0x801d1d1d,0x801d1d1d,
+0x80030303,0x80040404,0x80000000,0x80181818,0x80181818,0x80191919,
+0x801a1a1a,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801f1f1f,0x800a0a0a,
+0x80040404,0x80020202,0x800b0b0b,0x80191919,0x80171717,0x801c1c1c,
+0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801b1b1b,
+0x80181818,0x80181818,0x80181818,0x80191919,0x801a1a1a,0x801b1b1b,
+0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801c1c1c,0x80181818,
+0x80171717,0x80191919,0x80181818,0x80181818,0x801b1b1b,0x801f1f1f,
+0x80202020,0x801f1f1f,0x801d1d1d,0x801d1d1d,0x80191919,0x80151515,
+0x800c0c0c,0x80020202,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80020202,0x80010101,0x80000000,
+0x80000000,0x80010101,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80020202,0x80000000,
+0x80000000,0x80010101,0x80010101,0x80070707,0x80141414,0x80212121,
+0x801f1f1f,0x801b1b1b,0x80181818,0x80191919,0x80191919,0x80181818,
+0x80191919,0x801c1c1c,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801f1f1f,
+0x801c1c1c,0x80181818,0x80171717,0x80191919,0x808f8f91,0x80908f94,0x808f8e93,0x808f8e93,0x80909092,0x808f9092,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x80909092,0x80464646,0x80181818,0x80181818,
+0x801a1a1a,0x80171717,0x801a1a1a,0x801e1e1c,0x801f1f1f,0x801f1f1f,
+0x80202020,0x80202020,0x801c1c1c,0x80181818,0x80171717,0x80191919,
+0x80191919,0x80191919,0x801c1c1c,0x801f1f1f,0x801f1f1f,0x801e1e1e,
+0x801e1e1e,0x80202020,0x80191919,0x80191919,0x80181818,0x80171717,
+0x80181818,0x801c1c1c,0x801f1f1f,0x801f1f1f,0x801d1d1d,0x801f1f1f,
+0x801f1f1f,0x801b1b1b,0x80171717,0x80181818,0x80191919,0x80181818,
+0x801a1a1a,0x801d1d1d,0x801e1e1e,0x801d1d1d,0x801e1e1e,0x801f1f1f,
+0x801c1c1c,0x80171717,0x80181818,0x80181818,0x80181818,0x80181818,
+0x801c1c1c,0x80202020,0x80202020,0x801e1e1e,0x80202020,0x80171717,
+0x80060606,0x80131313,0x80020202,0x80181818,0x80181818,0x801b1b1b,
+0x80212121,0x801d1d1d,0x801e1e1e,0x80202020,0x801c1c1c,0x800a0a0a,
+0x800d0d0d,0x800b0b0b,0x80090909,0x80191919,0x801a1a1a,0x801f1f1f,
+0x801f1f1f,0x801e1e1e,0x801e1e1e,0x80202020,0x801b1b1b,0x80181818,
+0x80181818,0x80191919,0x80191919,0x80181818,0x801b1b1b,0x80202020,
+0x801d1d1d,0x80202020,0x801f1f1f,0x801b1b1b,0x80191919,0x80191919,
+0x80191919,0x80181818,0x80171717,0x801c1c1c,0x801f1f1f,0x801e1e1e,
+0x801e1e1e,0x801f1f1f,0x801d1d1d,0x80191919,0x800d0d0d,0x80030303,
+0x80000000,0x80000000,0x80020202,0x80000000,0x80000000,0x80010101,
+0x80010101,0x80010101,0x80000000,0x80000000,0x80000000,0x80020202,
+0x80020202,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80020202,0x80000000,0x80010101,0x80151515,0x80222222,0x801d1d1d,
+0x801b1b1b,0x801a1a1a,0x80171717,0x80171717,0x801a1a1a,0x80181818,
+0x801a1a1a,0x80212121,0x801d1d1d,0x80202020,0x801f1f1f,0x801b1b1b,
+0x80191919,0x80191919,0x80191919,0x80181818,0x808f8f91,0x808f8e93,0x80919095,0x808e8d92,0x808f8f91,0x808f9092,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808d8d8f,0x80454545,0x80191919,0x80171717,
+0x80181818,0x801a1a1a,0x801e1e1e,0x801e1e1c,0x801d1d1d,0x801f1f1f,
+0x801f1f1f,0x801b1b1b,0x80181818,0x80171717,0x80181818,0x80191919,
+0x80181818,0x801d1d1d,0x801f1f1f,0x801d1d1d,0x801e1e1e,0x80202020,
+0x801e1e1e,0x80191919,0x80181818,0x80191919,0x80181818,0x80171717,
+0x801b1b1b,0x801f1f1f,0x801f1f1f,0x801d1d1d,0x80212121,0x801c1c1c,
+0x80191919,0x80191919,0x80191919,0x80171717,0x80181818,0x801a1a1a,
+0x80202020,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801c1c1c,
+0x80191919,0x80181818,0x80181818,0x80171717,0x80191919,0x801e1e1e,
+0x80202020,0x801f1f1f,0x801e1e1e,0x80202020,0x801c1c1c,0x80161616,
+0x80000000,0x80050505,0x80010101,0x80161616,0x80191919,0x80202020,
+0x80202020,0x801f1f1f,0x801f1f1f,0x801f1f1f,0x801c1c1c,0x80060606,
+0x80030303,0x80020202,0x800a0a0a,0x801c1c1c,0x801c1c1c,0x801f1f1f,
+0x801f1f1f,0x80202020,0x801f1f1f,0x801a1a1a,0x80191718,0x80181617,
+0x80181617,0x80191718,0x801b191a,0x801e1c1d,0x80201e1f,0x80201e1f,
+0x80201e1f,0x801f1d1e,0x801d1b1c,0x801b191a,0x801a1819,0x80191718,
+0x80191718,0x80181617,0x801d1d1d,0x801e1e1e,0x801f1f1f,0x80212121,
+0x80202020,0x80181818,0x800d0d0d,0x80040404,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80010101,0x80000000,0x80010101,
+0x80000000,0x80030303,0x80141414,0x801f1f1f,0x801e1e1e,0x801c1c1c,
+0x80181818,0x80191919,0x80181818,0x80171717,0x801a1a1a,0x801e1e1e,
+0x801f1f1f,0x801d1d1d,0x801e1e1e,0x801e1e1e,0x801c1c1c,0x80181818,
+0x80181818,0x801a1a1a,0x80191919,0x80171717,0x808f8f91,0x808f8e93,0x80919095,0x808e8d92,0x808f8f91,0x808f9092,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x80909092,0x80444444,0x80171717,0x80181818,
+0x801b1b1b,0x801c1c1c,0x801e1e1e,0x801e1e1c,0x801f1f1f,0x801d1d1d,
+0x801b1b1b,0x80191919,0x80191919,0x80181818,0x80191919,0x80191919,
+0x801d1d1d,0x801d1d1d,0x801e1e1e,0x80202020,0x801f1f1f,0x801c1c1c,
+0x80191919,0x80191919,0x80191919,0x80171717,0x80181818,0x801b1b1b,
+0x801e1e1e,0x801d1d1d,0x801e1e1e,0x801f1f1f,0x801c1c1c,0x801b1b1b,
+0x80191919,0x80181818,0x80171717,0x80181818,0x801b1b1b,0x801d1d1d,
+0x801e1e1e,0x801f1f1f,0x80202020,0x801e1e1e,0x801b1b1b,0x80191919,
+0x80181818,0x80181818,0x80171717,0x801b1b1b,0x801d1d1d,0x801d1d1d,
+0x801f1f1f,0x80202020,0x801f1f1f,0x801c1c1c,0x80181818,0x80161616,
+0x80020202,0x80020202,0x80000000,0x801c1c1c,0x80212121,0x801f1f1f,
+0x801c1c1c,0x801e1e1e,0x801d1d1d,0x801a1a1a,0x80171717,0x80050505,
+0x80030303,0x80000000,0x800d0d0d,0x801e1e1e,0x801d1d1d,0x801f1f1f,
+0x801e1e1e,0x801d1d1d,0x801b1b1b,0x80191919,0x80191718,0x80191718,
+0x801a1819,0x801c1a1b,0x801e1c1d,0x80201e1f,0x80201e1f,0x80201e1f,
+0x801f1d1e,0x801d1b1c,0x80191718,0x80171516,0x80171516,0x80191718,
+0x801b191a,0x801c1a1b,0x801f1f1f,0x801f1f1f,0x801b1b1b,0x80131313,
+0x80080808,0x80010101,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80010101,0x80010101,0x80010101,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80010101,0x80000000,
+0x80030303,0x80111111,0x801e1e1e,0x80202020,0x801c1c1c,0x80191919,
+0x80191919,0x80171717,0x80171717,0x801b1b1b,0x801d1d1d,0x801d1d1d,
+0x801e1e1e,0x80202020,0x801e1e1e,0x801b1b1b,0x80191919,0x80191919,
+0x80191919,0x80171717,0x80181818,0x801b1b1b,0x80909092,0x808f8e93,0x80908f94,0x808f8e93,0x808f8f91,0x808f9092,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x80919193,0x80434343,0x80171717,0x801a1a1a,
+0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801f1f1d,0x801f1f1f,0x801b1b1b,
+0x80181818,0x80181818,0x80181818,0x80181818,0x801a1a1a,0x801c1c1c,
+0x801f1f1f,0x801e1e1e,0x801f1f1f,0x80202020,0x801d1d1d,0x80191919,
+0x80181818,0x80181818,0x80181818,0x80181818,0x801a1a1a,0x801e1e1e,
+0x801f1f1f,0x801d1d1d,0x801d1d1d,0x801f1f1f,0x80191919,0x80191919,
+0x80181818,0x80161616,0x80171717,0x801a1a1a,0x801d1d1d,0x801e1e1e,
+0x801e1e1e,0x80202020,0x801f1f1f,0x801b1b1b,0x80181818,0x80181818,
+0x80181818,0x80181818,0x80191919,0x801d1d1d,0x801f1f1f,0x801f1f1f,
+0x801e1e1e,0x801f1f1f,0x801c1c1c,0x80191919,0x80171717,0x80161616,
+0x80060606,0x800b0b0b,0x80030303,0x801a1a1a,0x801e1e1e,0x801d1d1d,
+0x80202020,0x801e1e1e,0x801b1b1b,0x80171717,0x80161616,0x80080808,
+0x800a0a0a,0x80090909,0x800d0d0d,0x801e1e1e,0x801f1f1f,0x80202020,
+0x801f1f1f,0x801b1b1b,0x80181818,0x80181818,0x80181617,0x80191718,
+0x801b191a,0x801d1b1c,0x80201e1f,0x80201e1f,0x801f1d1e,0x801e1c1d,
+0x801c1a1b,0x801b191a,0x801a1819,0x80191718,0x80191718,0x801a1819,
+0x801b191a,0x801b191a,0x80131313,0x800c0c0c,0x80040404,0x80000000,
+0x80010101,0x80010101,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80010101,0x80020202,0x80000000,
+0x80000000,0x80000000,0x80010101,0x80010101,0x80000000,0x80030303,
+0x80111111,0x801f1f1f,0x801f1f1f,0x801a1a1a,0x80181818,0x80181818,
+0x80181818,0x80171717,0x80191919,0x801e1e1e,0x80202020,0x801f1f1f,
+0x801e1e1e,0x801f1f1f,0x801c1c1c,0x80191919,0x80181818,0x80181818,
+0x80181818,0x80181818,0x801a1a1a,0x801e1e1e,0x80909092,0x808e8d92,0x80908f94,0x808f8e93,0x808f8f91,0x808f9092,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8f91,0x80454545,0x801a1a1a,0x801d1d1d,
+0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801f1f1d,0x801b1b1b,0x80191919,
+0x80181818,0x80181818,0x80171717,0x80181818,0x801c1c1c,0x801f1f1f,
+0x801d1d1d,0x80202020,0x80202020,0x801c1c1c,0x80191919,0x801a1a1a,
+0x80191919,0x80171717,0x80171717,0x801b1b1b,0x801e1e1e,0x801e1e1e,
+0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801b1b1b,0x80191919,0x80181818,
+0x80161616,0x80171717,0x801a1a1a,0x801e1e1e,0x801e1e1e,0x801d1d1d,
+0x801f1f1f,0x801e1e1e,0x801b1b1b,0x80181818,0x80171717,0x80181818,
+0x80191919,0x80181818,0x801e1e1e,0x801d1d1d,0x801f1f1f,0x80212121,
+0x801f1f1f,0x801a1a1a,0x80181818,0x80191919,0x80181818,0x80141414,
+0x80040404,0x800d0d0d,0x80050505,0x801a1a1a,0x801f1f1f,0x801e1e1e,
+0x801f1f1f,0x80191919,0x80171717,0x80191919,0x80191919,0x80070707,
+0x800a0a0a,0x800b0b0b,0x800c0c0c,0x801e1e1e,0x80202020,0x801c1c1c,
+0x801b1b1b,0x80191919,0x80181818,0x80181818,0x80191919,0x801a1a1a,
+0x801b1b1b,0x801d1d1d,0x801f1f1f,0x801f1f1f,0x801d1d1d,0x801c1c1c,
+0x80161616,0x80151515,0x80131313,0x80111111,0x800d0d0d,0x800a0a0a,
+0x80060606,0x80030303,0x80010101,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80010101,0x80020202,0x80010101,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80030303,0x80111111,
+0x801f1f1f,0x80202020,0x80191919,0x80161616,0x80171717,0x80181818,
+0x80171717,0x801b1b1b,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x80202020,
+0x801f1f1f,0x801b1b1b,0x80181818,0x80191919,0x80181818,0x80171717,
+0x80181818,0x801c1c1c,0x801f1f1f,0x801e1e1e,0x80909092,0x808e8d92,0x808f8e93,0x80908f94,0x808f8f91,0x808f9092,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808e8e90,0x80474747,0x801e1e1e,0x801e1e1e,
+0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801b1b19,0x80181818,0x80191919,
+0x80181818,0x80171717,0x80191919,0x801c1c1c,0x801e1e1e,0x801f1f1f,
+0x801e1e1e,0x801f1f1f,0x801d1d1d,0x80191919,0x80171717,0x80181818,
+0x80191919,0x80181818,0x801b1b1b,0x801e1e1e,0x801f1f1f,0x801e1e1e,
+0x801e1e1e,0x801e1e1e,0x801b1b1b,0x80171717,0x80191919,0x80171717,
+0x80171717,0x801a1a1a,0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801e1e1e,
+0x801f1f1f,0x801b1b1b,0x80181818,0x80171717,0x80171717,0x80181818,
+0x801a1a1a,0x801c1c1c,0x80202020,0x801f1f1f,0x801e1e1e,0x801f1f1f,
+0x801d1d1d,0x80191919,0x80171717,0x80181818,0x80171717,0x80141414,
+0x80000000,0x80040404,0x80000000,0x801b1b1b,0x80222222,0x801b1b1b,
+0x801a1a1a,0x80161616,0x80181818,0x801a1a1a,0x80181818,0x80040404,
+0x80020202,0x80000000,0x80111111,0x80202020,0x801b1b1b,0x80090909,
+0x80050505,0x80050505,0x80050505,0x80040404,0x80050505,0x80050505,
+0x80060606,0x80060606,0x80070707,0x80070707,0x80060606,0x80060606,
+0x80030303,0x80030303,0x80020202,0x80010101,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80010101,0x80020202,0x80010101,
+0x80000000,0x80000000,0x80000000,0x80010101,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80010101,0x80000000,0x80000000,0x80010101,
+0x80020202,0x80000000,0x80000000,0x80010101,0x80141414,0x801e1e1e,
+0x80202020,0x801a1a1a,0x80191919,0x80191919,0x80181818,0x80181818,
+0x801a1a1a,0x801d1d1d,0x80202020,0x801f1f1f,0x801f1f1f,0x801f1f1f,
+0x801c1c1c,0x80191919,0x80181818,0x80191919,0x80181818,0x80181818,
+0x801b1b1b,0x80202020,0x80202020,0x801e1e1e,0x80909092,0x808f8e93,0x808f8e93,0x80908f94,0x808f8f91,0x808e8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8f91,0x80484848,0x801e1e1e,0x801e1e1e,
+0x801f1f1f,0x801e1e1e,0x801c1c1c,0x80171715,0x80171717,0x80181818,
+0x80181818,0x80181818,0x801c1c1c,0x80202020,0x80202020,0x801e1e1e,
+0x80202020,0x801c1c1c,0x80191919,0x801a1a1a,0x80181818,0x80161616,
+0x80181818,0x801c1c1c,0x801f1f1f,0x801d1d1d,0x801d1d1d,0x801f1f1f,
+0x801e1e1e,0x801a1a1a,0x80181818,0x80181818,0x80171717,0x80181818,
+0x801a1a1a,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801f1f1f,
+0x801c1c1c,0x80191919,0x80181818,0x80181818,0x80181818,0x80181818,
+0x801c1c1c,0x80202020,0x801f1f1f,0x80202020,0x801f1f1f,0x801a1a1a,
+0x80191919,0x80191919,0x80191919,0x80171717,0x80181818,0x80171717,
+0x80040404,0x800b0b0b,0x80000000,0x800d0d0d,0x800f0f0f,0x800c0c0c,
+0x800c0c0c,0x800d0d0d,0x800e0e0e,0x800c0c0c,0x800c0c0c,0x80030303,
+0x80090909,0x80040404,0x800f0f0f,0x801e1e1e,0x80181818,0x80010101,
+0x80000000,0x80010101,0x80020202,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80020202,0x80000000,0x80000000,0x80000000,
+0x80010101,0x80020202,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80010101,0x80000000,
+0x80000000,0x80000000,0x80090909,0x80141414,0x801e1e1e,0x80202020,
+0x801b1b1b,0x80171717,0x801a1a1a,0x80191919,0x80161616,0x801a1a1a,
+0x801e1e1e,0x801d1d1d,0x801f1f1f,0x80202020,0x801f1f1f,0x801a1a1a,
+0x80181818,0x80191919,0x801a1a1a,0x80171717,0x80181818,0x801c1c1c,
+0x80202020,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x80909092,0x808f8e93,0x808e8d92,0x80908f94,0x808e8e90,0x808e8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x80909092,0x80484848,0x801e1e1e,0x801f1f1f,
+0x801e1e1e,0x801b1b1b,0x801a1a1a,0x80181816,0x80181818,0x80191919,
+0x801a1a1a,0x801c1c1c,0x801e1e1e,0x80202020,0x80202020,0x801e1e1e,
+0x801e1e1e,0x80191919,0x80181818,0x80191919,0x80191919,0x80181818,
+0x801a1a1a,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801e1e1e,
+0x801b1b1b,0x80181818,0x80171717,0x80191919,0x80181818,0x801b1b1b,
+0x801d1d1d,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801d1d1d,0x801c1c1c,
+0x80191919,0x80181818,0x80181818,0x80191919,0x801a1a1a,0x801c1c1c,
+0x801e1e1e,0x80202020,0x801e1e1e,0x801f1f1f,0x801c1c1c,0x80181818,
+0x80171717,0x80191919,0x80191919,0x80181818,0x801c1c1c,0x801a1a1a,
+0x80080808,0x80131313,0x80020202,0x80000000,0x80000000,0x80020202,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80020202,0x80020202,
+0x800f0f0f,0x800e0e0e,0x800c0c0c,0x801b1b1b,0x80161616,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80010101,0x80010101,0x80010101,0x80010101,0x80010101,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80010101,0x80010101,
+0x80010101,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80010101,0x80010101,0x80000000,
+0x80000000,0x80090909,0x80171717,0x80232323,0x801e1e1e,0x801c1c1c,
+0x80181818,0x80171717,0x80181818,0x80161616,0x80181818,0x801e1e1e,
+0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801c1c1c,0x80181818,
+0x80171717,0x80191919,0x80191919,0x80181818,0x801a1a1a,0x801f1f1f,
+0x80202020,0x801e1e1e,0x801d1d1d,0x801e1e1e,0x80909092,0x808f8e93,0x808e8d92,0x80908f94,0x808e8e90,0x808e8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x80909092,0x80484848,0x801f1f1f,0x80202020,
+0x801c1c1c,0x80171717,0x80181818,0x801a1a18,0x80191919,0x80191919,
+0x801c1c1c,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x80202020,
+0x80191919,0x80191919,0x80181818,0x80171717,0x80181818,0x801c1c1c,
+0x801f1f1f,0x801f1f1f,0x801d1d1d,0x801f1f1f,0x801f1f1f,0x801b1b1b,
+0x80171717,0x80181818,0x80191919,0x80181818,0x801a1a1a,0x801d1d1d,
+0x801e1e1e,0x801d1d1d,0x801e1e1e,0x801f1f1f,0x801c1c1c,0x80171717,
+0x80181818,0x80181818,0x80181818,0x80181818,0x801c1c1c,0x80202020,
+0x80202020,0x801e1e1e,0x80202020,0x801c1c1c,0x80191919,0x80191919,
+0x80181818,0x80171717,0x80181818,0x801a1a1a,0x801f1f1f,0x801a1a1a,
+0x80010101,0x80090909,0x80000000,0x80050505,0x80040404,0x80050505,
+0x80060606,0x80050505,0x80070707,0x80060606,0x80060606,0x80000000,
+0x80060606,0x80030303,0x800d0d0d,0x80191919,0x80141414,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80010101,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80010101,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80010101,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80010101,
+0x800d0d0d,0x801a1a1a,0x80202020,0x801e1e1e,0x801d1d1d,0x80191919,
+0x80171717,0x80171717,0x80181818,0x801a1a1a,0x801e1e1e,0x801f1f1f,
+0x801d1d1d,0x80202020,0x801f1f1f,0x801b1b1b,0x80191919,0x80191919,
+0x80191919,0x80181818,0x80171717,0x801b1b1b,0x801e1e1e,0x801e1e1e,
+0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801b1b1b,0x808f8f91,0x808f8e93,0x80908f94,0x80908f94,0x808f8f91,0x808f9092,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808e8e90,0x804b4b4b,0x801f1f1f,0x801a1a1a,
+0x80181818,0x80171717,0x80181818,0x80181816,0x80181818,0x801d1d1d,
+0x801f1f1f,0x801d1d1d,0x801e1e1e,0x80202020,0x801e1e1e,0x80191919,
+0x80181818,0x80191919,0x80181818,0x80171717,0x801b1b1b,0x801f1f1f,
+0x801f1f1f,0x801d1d1d,0x80212121,0x801c1c1c,0x80191919,0x80191919,
+0x80191919,0x80171717,0x80181818,0x801a1a1a,0x80202020,0x801e1e1e,
+0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801c1c1c,0x80191919,0x80181818,
+0x80181818,0x80171717,0x80191919,0x801e1e1e,0x80202020,0x801f1f1f,
+0x801e1e1e,0x80202020,0x80191919,0x80181818,0x80181818,0x80191919,
+0x80181818,0x80171717,0x801b1b1b,0x80202020,0x801c1c1c,0x801e1e1e,
+0x80020202,0x80000000,0x80020202,0x80151515,0x80191919,0x80181818,
+0x80171717,0x801c1c1c,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x80090909,
+0x80030303,0x80000000,0x800d0d0d,0x80171717,0x80161616,0x80000000,
+0x80000000,0x80000000,0x80010101,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80010101,0x80010101,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80010101,0x80000000,0x80030303,0x80121212,
+0x801e1e1e,0x801f1f1f,0x801d1d1d,0x801e1e1e,0x80191919,0x80191919,
+0x80181818,0x80171717,0x80191919,0x801d1d1d,0x801e1e1e,0x801d1d1d,
+0x801e1e1e,0x80202020,0x801c1c1c,0x80171717,0x80181818,0x80191919,
+0x80181818,0x80171717,0x801c1c1c,0x801e1e1e,0x80202020,0x801e1e1e,
+0x801d1d1d,0x801d1d1d,0x801b1b1b,0x80171717,0x808f8f91,0x808f8e93,0x80908f94,0x80908f94,0x808f8f91,0x808e8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x80909092,0x80484848,0x801b1b1b,0x80181818,
+0x80191919,0x80191919,0x80191919,0x80181816,0x801d1d1d,0x801d1d1d,
+0x801e1e1e,0x80202020,0x801f1f1f,0x801c1c1c,0x80191919,0x80191919,
+0x80191919,0x80171717,0x80181818,0x801b1b1b,0x801e1e1e,0x801d1d1d,
+0x801e1e1e,0x801f1f1f,0x801c1c1c,0x801b1b1b,0x80191919,0x80181818,
+0x80171717,0x80181818,0x801b1b1b,0x801d1d1d,0x801e1e1e,0x801f1f1f,
+0x80202020,0x801e1e1e,0x801b1b1b,0x80191919,0x80181818,0x80181818,
+0x80171717,0x801b1b1b,0x801d1d1d,0x801d1d1d,0x801f1f1f,0x80202020,
+0x801f1f1f,0x801c1c1c,0x80181818,0x80191919,0x80191919,0x80171717,
+0x80181818,0x801c1c1c,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801a1a1a,
+0x80010101,0x800c0c0c,0x80000000,0x80141414,0x80161616,0x80191919,
+0x801c1c1c,0x801d1d1d,0x801e1e1e,0x801e1e1e,0x801d1d1d,0x80070707,
+0x80040404,0x80040404,0x800b0b0b,0x80171717,0x80171717,0x80000000,
+0x80000000,0x80000000,0x80010101,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80010101,0x80010101,0x80010101,0x80010101,0x80010101,0x80000000,
+0x80000000,0x80000000,0x80000000,0x800a0a0a,0x80171717,0x801d1d1d,
+0x801f1f1f,0x801e1e1e,0x801c1c1c,0x801a1a1a,0x80191919,0x80181818,
+0x80171717,0x80191919,0x801c1c1c,0x801d1d1d,0x801e1e1e,0x801f1f1f,
+0x801e1e1e,0x801c1c1c,0x80191919,0x80191919,0x80191919,0x80171717,
+0x80171717,0x801b1b1b,0x801e1e1e,0x801d1d1d,0x801e1e1e,0x801f1f1f,
+0x801e1e1e,0x80191919,0x80171717,0x80181818,0x808f8f91,0x808f8e93,0x80908f94,0x80908f94,0x808f8f91,0x808e8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x80909092,0x80454545,0x80181818,0x80171717,
+0x801a1a1a,0x80191919,0x801a1a1a,0x801b1b19,0x801f1f1f,0x801e1e1e,
+0x801f1f1f,0x80202020,0x801d1d1d,0x80191919,0x80181818,0x80181818,
+0x80181818,0x80181818,0x801a1a1a,0x801e1e1e,0x801f1f1f,0x801d1d1d,
+0x801d1d1d,0x801f1f1f,0x80191919,0x80191919,0x80181818,0x80161616,
+0x80171717,0x801a1a1a,0x801d1d1d,0x801e1e1e,0x801e1e1e,0x80202020,
+0x801f1f1f,0x801b1b1b,0x80181818,0x80181818,0x80181818,0x80181818,
+0x80191919,0x801d1d1d,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801f1f1f,
+0x801c1c1c,0x80191919,0x80181818,0x80191919,0x80181818,0x80181818,
+0x801b1b1b,0x801f1f1f,0x80202020,0x801e1e1e,0x80202020,0x80181818,
+0x80050505,0x80151515,0x80050505,0x80171717,0x80181818,0x801a1a1a,
+0x801e1e1e,0x801e1e1e,0x801e1e1e,0x80202020,0x80202020,0x800b0b0b,
+0x800a0a0a,0x800c0c0c,0x800b0b0b,0x80171717,0x80171717,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80010101,0x80000000,0x80000000,0x80000000,0x80010101,0x80000000,
+0x80000000,0x80000000,0x800e0e0e,0x801a1a1a,0x80222222,0x80202020,
+0x801d1d1d,0x801d1d1d,0x801b1b1b,0x80161616,0x80191919,0x80171717,
+0x80181818,0x801b1b1b,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801f1f1f,
+0x801c1c1c,0x801a1a1a,0x80181818,0x80181818,0x80191919,0x80181818,
+0x801a1a1a,0x801f1f1f,0x80202020,0x801e1e1e,0x801d1d1d,0x801d1d1d,
+0x801b1b1b,0x80171717,0x80161616,0x80181818,0x808f8f91,0x808f8e93,0x80908f94,0x80908f94,0x808f8f91,0x808e8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808e8e90,0x80444444,0x80181818,0x80181818,
+0x80191919,0x80191919,0x801c1c1c,0x801e1e1c,0x801d1d1d,0x80202020,
+0x80202020,0x801c1c1c,0x80191919,0x801a1a1a,0x80191919,0x80171717,
+0x80171717,0x801b1b1b,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801f1f1f,
+0x801e1e1e,0x801b1b1b,0x80191919,0x80181818,0x80161616,0x80171717,
+0x801a1a1a,0x801e1e1e,0x801e1e1e,0x801d1d1d,0x801f1f1f,0x801e1e1e,
+0x801b1b1b,0x80181818,0x80171717,0x80181818,0x80191919,0x80181818,
+0x801e1e1e,0x801d1d1d,0x801f1f1f,0x80212121,0x801f1f1f,0x801a1a1a,
+0x80181818,0x80191919,0x80191919,0x80171717,0x80181818,0x801c1c1c,
+0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x80171717,
+0x80020202,0x80020202,0x80020202,0x80151515,0x801c1c1c,0x801e1e1e,
+0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801f1f1f,0x801d1d1d,0x80070707,
+0x80030303,0x80030303,0x800b0b0b,0x80191919,0x80191919,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80010101,0x80010101,0x80010101,0x80010101,
+0x80000000,0x80000000,0x80020202,0x80010101,0x80000000,0x80000000,
+0x80090909,0x80141414,0x801f1f1f,0x801f1f1f,0x801f1f1f,0x801d1d1d,
+0x801b1b1b,0x801a1a1a,0x80181818,0x80171717,0x80191919,0x80181818,
+0x801a1a1a,0x801d1d1d,0x80202020,0x801f1f1f,0x801e1e1e,0x801d1d1d,
+0x80181818,0x801a1a1a,0x80181818,0x80161616,0x80181818,0x801c1c1c,
+0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801d1d1d,0x80191919,
+0x80171717,0x80181818,0x80191919,0x80171717,0x80909092,0x808f8e93,0x80908f94,0x808f8e93,0x808f8f91,0x808f9092,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808e8e90,0x80454545,0x80191919,0x80181818,
+0x80191919,0x801c1c1c,0x80202020,0x801f1f1d,0x801e1e1e,0x801f1f1f,
+0x801d1d1d,0x80191919,0x80171717,0x80181818,0x80191919,0x80181818,
+0x801b1b1b,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801e1e1e,
+0x801b1b1b,0x80171717,0x80191919,0x80171717,0x80171717,0x801a1a1a,
+0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801b1b1b,
+0x80181818,0x80171717,0x80171717,0x80181818,0x801a1a1a,0x801c1c1c,
+0x80202020,0x801f1f1f,0x801e1e1e,0x801f1f1f,0x801d1d1d,0x80191919,
+0x80171717,0x80181818,0x80181818,0x80181818,0x801b1b1b,0x801f1f1f,
+0x80202020,0x801e1e1e,0x801d1d1d,0x801e1e1e,0x80191919,0x80141414,
+0x80020202,0x80000000,0x80000000,0x80161616,0x801e1e1e,0x801e1e1e,
+0x801f1f1f,0x80202020,0x801e1e1e,0x801b1b1b,0x80191919,0x80040404,
+0x80010101,0x80000000,0x800c0c0c,0x801c1c1c,0x801b1b1b,0x80010101,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80010101,0x80000000,0x80000000,0x80010101,0x80060606,0x800d0d0d,
+0x80181818,0x80212121,0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801c1c1c,
+0x801a1a1a,0x80171717,0x80181818,0x801a1a1a,0x80191919,0x801b1b1b,
+0x801d1d1d,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801d1d1d,0x801a1a1a,
+0x80181818,0x80181818,0x80181818,0x80181818,0x801b1b1b,0x80202020,
+0x80202020,0x801e1e1e,0x801d1d1d,0x801e1e1e,0x801b1b1b,0x80171717,
+0x80161616,0x80181818,0x801a1a1a,0x801a1a1a,0x80919193,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8f91,0x808f9092,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8f91,0x80454545,0x80191919,0x80191919,
+0x801c1c1c,0x801f1f1f,0x80212121,0x801e1e1c,0x80202020,0x801c1c1c,
+0x80191919,0x801a1a1a,0x80181818,0x80161616,0x80181818,0x801c1c1c,
+0x801f1f1f,0x801d1d1d,0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801a1a1a,
+0x80181818,0x80181818,0x80171717,0x80181818,0x801a1a1a,0x801e1e1e,
+0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801c1c1c,0x80191919,
+0x80181818,0x80181818,0x80181818,0x80181818,0x801c1c1c,0x80202020,
+0x801f1f1f,0x80202020,0x801f1f1f,0x801a1a1a,0x80191919,0x80191919,
+0x80191919,0x80171717,0x80171717,0x801c1c1c,0x801f1f1f,0x801f1f1f,
+0x801e1e1e,0x801e1e1e,0x801d1d1d,0x801a1a1a,0x80171717,0x80131313,
+0x80060606,0x80121212,0x80020202,0x801d1d1d,0x801f1f1f,0x801e1e1e,
+0x801f1f1f,0x801f1f1f,0x801b1b1b,0x80181818,0x80191919,0x800a0a0a,
+0x800a0a0a,0x800a0a0a,0x800e0e0e,0x801e1e1e,0x801b1b1b,0x80010101,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80020202,0x800a0a0a,0x80151515,0x801d1d1d,
+0x80202020,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801c1c1c,0x801a1a1a,
+0x80191919,0x80191919,0x80181818,0x80171717,0x801a1a1a,0x801d1d1d,
+0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801b1b1b,0x80171717,
+0x801a1a1a,0x80161616,0x80181818,0x801d1d1d,0x801f1f1f,0x801f1f1f,
+0x801f1f1f,0x801e1e1e,0x801d1d1d,0x80191919,0x80171717,0x80181818,
+0x80181818,0x80181818,0x801b1b1b,0x801e1e1e,0x80919193,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8f91,0x808f9092,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x80909092,0x80444444,0x801a1a1a,0x801c1c1c,
+0x801e1e1e,0x801f1f1f,0x80212121,0x801e1e1c,0x801e1e1e,0x80191919,
+0x80181818,0x80191919,0x80191919,0x80181818,0x801a1a1a,0x801f1f1f,
+0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801e1e1e,0x801b1b1b,0x80181818,
+0x80171717,0x80191919,0x80181818,0x801b1b1b,0x801d1d1d,0x801e1e1e,
+0x801e1e1e,0x801e1e1e,0x801d1d1d,0x801c1c1c,0x80191919,0x80181818,
+0x80181818,0x80191919,0x801a1a1a,0x801c1c1c,0x801e1e1e,0x80202020,
+0x801e1e1e,0x801f1f1f,0x801c1c1c,0x80181818,0x80171717,0x80191919,
+0x80191919,0x80181818,0x801b1b1b,0x801e1e1e,0x80202020,0x801e1e1e,
+0x801d1d1d,0x801d1d1d,0x801b1b1b,0x80171717,0x801a1a1a,0x80141414,
+0x80040404,0x800d0d0d,0x80000000,0x801c1c1c,0x801f1f1f,0x80212121,
+0x801d1d1d,0x801c1c1c,0x80181818,0x80171717,0x80191919,0x80080808,
+0x80080808,0x80070707,0x800e0e0e,0x801e1e1e,0x801b1b1b,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80010101,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80010101,0x80000000,0x80000000,0x80000000,0x80010101,0x80020202,
+0x80010101,0x800a0a0a,0x80141414,0x80191919,0x801b1b1b,0x801c1c1c,
+0x801e1e1e,0x801f1f1f,0x80202020,0x801e1e1e,0x801a1a1a,0x80171717,
+0x80171717,0x80191919,0x80191919,0x80181818,0x801d1d1d,0x801e1e1e,
+0x801f1f1f,0x801f1f1f,0x801d1d1d,0x801a1a1a,0x80191919,0x80181818,
+0x80191919,0x80171717,0x801a1a1a,0x801f1f1f,0x80202020,0x801e1e1e,
+0x801e1e1e,0x801d1d1d,0x801b1b1b,0x80171717,0x80161616,0x80191919,
+0x801a1a1a,0x801b1b1b,0x801c1c1c,0x801f1f1f,0x80919193,0x808f8e93,0x80908f94,0x80908f94,0x808f8f91,0x808e8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8f91,0x80444444,0x801b1b1b,0x801f1f1f,
+0x801f1f1f,0x801d1d1d,0x801f1f1f,0x801f1f1d,0x80191919,0x80191919,
+0x80181818,0x80171717,0x80181818,0x801c1c1c,0x801f1f1f,0x801f1f1f,
+0x801d1d1d,0x801f1f1f,0x801f1f1f,0x801b1b1b,0x80171717,0x80181818,
+0x80191919,0x80181818,0x801a1a1a,0x801d1d1d,0x801e1e1e,0x801d1d1d,
+0x801e1e1e,0x801f1f1f,0x801c1c1c,0x80171717,0x80181818,0x80181818,
+0x80181818,0x80181818,0x801c1c1c,0x80202020,0x80202020,0x801e1e1e,
+0x80202020,0x801c1c1c,0x80191919,0x80191919,0x80181818,0x80171717,
+0x80181818,0x801a1a1a,0x80202020,0x801e1e1e,0x801e1e1e,0x801f1f1f,
+0x801e1e1e,0x801a1a1a,0x80171717,0x80171717,0x80181818,0x80151515,
+0x80030303,0x80000000,0x80020202,0x801b1b1b,0x801e1e1e,0x801f1f1f,
+0x801b1b1b,0x80181818,0x80161616,0x80181818,0x801a1a1a,0x80050505,
+0x80010101,0x80000000,0x800e0e0e,0x801e1e1e,0x801a1a1a,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80010101,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80010101,
+0x80010101,0x80000000,0x80000000,0x80010101,0x80040404,0x80060606,
+0x80141414,0x80181818,0x801b1b1b,0x801b1b1b,0x801d1d1d,0x80212121,
+0x80202020,0x801d1d1d,0x801d1d1d,0x801a1a1a,0x80191919,0x80191919,
+0x80171717,0x80171717,0x801a1a1a,0x801f1f1f,0x801f1f1f,0x801e1e1e,
+0x801f1f1f,0x801f1f1f,0x801c1c1c,0x80181818,0x80171717,0x80191919,
+0x80171717,0x801a1a1a,0x801e1e1e,0x801f1f1f,0x801d1d1d,0x801e1e1e,
+0x801f1f1f,0x801b1b1b,0x80171717,0x80181818,0x80181818,0x80171717,
+0x801a1a1a,0x801e1e1e,0x801f1f1f,0x801d1d1d,0x80909193,0x808f9092,0x808d8e90,0x808c8d91,0x80909195,0x808f9094,
+0x808f9092,0x808f9092,0x808e8f91,0x808e8f91,0x808e8f91,0x808e8f91,
+0x808e8f91,0x808e8f91,0x808e8f91,0x808f9092,0x808f9092,0x808e8f91,
+0x808e8f91,0x808f9092,0x808f9092,0x808d8e90,0x808e8f91,0x808e8f91,
+0x808f9092,0x808e8f91,0x808e8f91,0x808e8f91,0x808e8f91,0x808f9092,
+0x808e8f91,0x808e8f91,0x808e8f91,0x808e8f91,0x808e8f91,0x808e8f91,
+0x808e8f91,0x808e8f91,0x80909092,0x80454545,0x801e1e1e,0x801e1e1e,
+0x80202020,0x80222222,0x801d1d1d,0x80181816,0x80181818,0x80191919,
+0x80181818,0x80171717,0x801b1b1b,0x801f1f1f,0x801f1f1f,0x801d1d1d,
+0x80212121,0x801c1c1c,0x80191919,0x80191919,0x80191919,0x80171717,
+0x80181818,0x801a1a1a,0x80202020,0x801e1e1e,0x801e1e1e,0x801f1f1f,
+0x801f1f1f,0x801c1c1c,0x80191919,0x80181818,0x80181818,0x80171717,
+0x80191919,0x801e1e1e,0x80202020,0x801f1f1f,0x801e1e1e,0x80202020,
+0x80191919,0x80181818,0x80181818,0x80191919,0x80181818,0x80171717,
+0x801b1b1b,0x80202020,0x801d1d1d,0x80202020,0x80202020,0x801c1c1c,
+0x80191919,0x80181818,0x80181818,0x80171717,0x80161616,0x80191919,
+0x80030303,0x800a0a0a,0x80000000,0x80080808,0x800e0e0e,0x800c0c0c,
+0x800b0b0b,0x800c0c0c,0x800c0c0c,0x800f0f0f,0x800a0a0a,0x80020202,
+0x800b0b0b,0x80040404,0x80101010,0x801f1f1f,0x80191919,0x80020202,
+0x80000000,0x80000000,0x80010101,0x80000000,0x80000100,0x80000100,
+0x80000100,0x80000100,0x80000100,0x80000100,0x80000100,0x80000201,
+0x80010101,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80010101,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80010101,0x80000000,
+0x80000000,0x80020202,0x80060606,0x800c0c0c,0x80141414,0x80191919,
+0x80161616,0x80191919,0x801c1c1c,0x801e1e1e,0x801f1f1f,0x801f1f1f,
+0x801e1e1e,0x801d1d1d,0x80181818,0x801a1a1a,0x80191919,0x80171717,
+0x80171717,0x801b1b1b,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801e1e1e,
+0x801d1d1d,0x801b1b1b,0x80181818,0x80171717,0x80171717,0x80171717,
+0x801a1a1a,0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801e1e1e,
+0x801b1b1b,0x80171717,0x80181818,0x80161616,0x80171717,0x801b1b1b,
+0x801f1f1f,0x801f1f1f,0x801f1f1f,0x801f1f1f,0x808d8d8f,0x808e8e90,0x80919193,0x808f8f91,0x80919095,0x808e8d92,
+0x80908f94,0x80908f94,0x80908f94,0x80908f94,0x80908f94,0x80908f94,
+0x80908f94,0x80908f94,0x808f8e93,0x80908f94,0x80908f94,0x808f8e93,
+0x80908f94,0x80919095,0x80919095,0x80908f94,0x80908f94,0x80908f94,
+0x80908f94,0x80908f94,0x808f8e93,0x808f8e93,0x80908f94,0x80908f94,
+0x808f8e93,0x808f8e93,0x80908f94,0x80908f94,0x80908f94,0x80908f94,
+0x80908f94,0x80908f94,0x80909092,0x80484848,0x80222222,0x80202020,
+0x801d1d1d,0x801c1c1c,0x801a1a1a,0x80191917,0x80191919,0x80171717,
+0x80181818,0x801b1b1b,0x801e1e1e,0x801d1d1d,0x801e1e1e,0x801f1f1f,
+0x801c1c1c,0x801b1b1b,0x80191919,0x80181818,0x80171717,0x80181818,
+0x801b1b1b,0x801d1d1d,0x801e1e1e,0x801f1f1f,0x80202020,0x801e1e1e,
+0x801b1b1b,0x80191919,0x80181818,0x80181818,0x80171717,0x801b1b1b,
+0x801d1d1d,0x801d1d1d,0x801f1f1f,0x80202020,0x801f1f1f,0x801c1c1c,
+0x80181818,0x80191919,0x80191919,0x80171717,0x80181818,0x801c1c1c,
+0x801e1e1e,0x801e1e1e,0x80202020,0x801e1e1e,0x801c1c1c,0x801a1a1a,
+0x80191919,0x80181818,0x80181818,0x80181818,0x801c1c1c,0x80181818,
+0x80070707,0x801b1b1b,0x80010101,0x80010101,0x80000000,0x80020202,
+0x80000000,0x80030303,0x80000000,0x80000000,0x80000000,0x80020202,
+0x80111111,0x800d0d0d,0x80111111,0x801b1b1b,0x80151515,0x80010101,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80010101,
+0x80000000,0x80000000,0x80000000,0x80010101,0x80000000,0x80040404,
+0x800c0c0c,0x80131313,0x80181818,0x80191919,0x80191919,0x80181818,
+0x80191919,0x801c1c1c,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801e1e1e,
+0x801c1c1c,0x801a1a1a,0x801a1a1a,0x80181818,0x80171717,0x80181818,
+0x801b1b1b,0x801d1d1d,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801d1d1d,
+0x801b1b1b,0x80191919,0x80181818,0x80181818,0x80191919,0x80191919,
+0x801d1d1d,0x801d1d1d,0x801e1e1e,0x80202020,0x801e1e1e,0x801a1a1a,
+0x80171717,0x80181818,0x80161616,0x80191919,0x801b1b1b,0x801d1d1d,
+0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x808f8f91,0x808f8f91,0x80909092,0x808d8d8f,0x80909092,0x80908f94,
+0x808e8d92,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x80908f94,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808e8d92,0x80908f94,0x808f8e93,
+0x808f8e93,0x808e8d92,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808e8d92,0x808f8e93,0x808f8e93,0x808f8e93,0x80908f94,0x808f8e93,
+0x808f8e93,0x808f8e93,0x80909092,0x80464646,0x801e1e1e,0x801d1d1d,
+0x801a1a1a,0x80191919,0x80191919,0x80181816,0x80181818,0x80181818,
+0x801a1a1a,0x801e1e1e,0x801f1f1f,0x801d1d1d,0x801d1d1d,0x801f1f1f,
+0x80191919,0x80191919,0x80181818,0x80161616,0x80171717,0x801a1a1a,
+0x801d1d1d,0x801e1e1e,0x801e1e1e,0x80202020,0x801f1f1f,0x801b1b1b,
+0x80181818,0x80181818,0x80181818,0x80181818,0x80191919,0x801d1d1d,
+0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801f1f1f,0x801c1c1c,0x80191919,
+0x80181818,0x80191919,0x80181818,0x80181818,0x801b1b1b,0x801f1f1f,
+0x80202020,0x801e1e1e,0x80202020,0x801c1c1c,0x80181818,0x80181818,
+0x80181818,0x80181818,0x80191919,0x801b1b1b,0x801e1e1e,0x801b1b1b,
+0x80020202,0x80020202,0x80020202,0x80060606,0x800a0a0a,0x800c0c0c,
+0x800a0a0a,0x800c0c0c,0x800c0c0c,0x80111111,0x800f0f0f,0x80010101,
+0x80040404,0x80010101,0x800e0e0e,0x80191919,0x80131313,0x80000000,
+0x80010101,0x80000000,0x80000000,0x80010101,0x80000000,0x80000000,
+0x80000000,0x80010101,0x80010101,0x80010101,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80010101,0x80010101,0x80000000,
+0x80000000,0x80000000,0x80010101,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80020202,0x80050505,0x80080808,0x80191919,0x801a1a1a,
+0x801a1a1a,0x80191919,0x80181818,0x80171717,0x80171717,0x80181818,
+0x801c1c1c,0x801e1e1e,0x80202020,0x801f1f1f,0x801e1e1e,0x801c1c1c,
+0x801a1a1a,0x80191919,0x80191919,0x80171717,0x80171717,0x801b1b1b,
+0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801d1d1d,0x801b1b1b,
+0x80191919,0x80171717,0x80171717,0x80191919,0x801b1b1b,0x801c1c1c,
+0x801e1e1e,0x801e1e1e,0x801f1f1f,0x80202020,0x801c1c1c,0x80171717,
+0x80161616,0x80181818,0x80171717,0x801b1b1b,0x801e1e1e,0x801e1e1e,
+0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801b1b1b,0x808e8e90,0x808e8e90,0x808e8e90,0x80909092,0x80909092,0x808f8f91,
+0x808f8e93,0x808f8e93,0x80908f94,0x80908f94,0x80908f94,0x808f8e93,
+0x808f8e93,0x808f8e93,0x80908f94,0x80908f94,0x80908f94,0x80908f94,
+0x80908f94,0x80908f94,0x808f8e93,0x808f8e93,0x80908f94,0x80908f94,
+0x808f8e93,0x808f8e93,0x80908f94,0x80908f94,0x80908f94,0x808f8e93,
+0x80908f94,0x80908f94,0x80908f94,0x80908f94,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8f91,0x80484848,0x80212121,0x801f1f1f,
+0x801b1b1b,0x80181818,0x80191919,0x801a1a18,0x80171717,0x801b1b1b,
+0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801b1b1b,
+0x80191919,0x80181818,0x80161616,0x80171717,0x801a1a1a,0x801e1e1e,
+0x801e1e1e,0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801b1b1b,0x80181818,
+0x80171717,0x80181818,0x80191919,0x80181818,0x801e1e1e,0x801d1d1d,
+0x801f1f1f,0x80212121,0x801f1f1f,0x801a1a1a,0x80181818,0x80191919,
+0x80191919,0x80171717,0x80181818,0x801c1c1c,0x801f1f1f,0x801f1f1f,
+0x801e1e1e,0x801f1f1f,0x801c1c1c,0x801a1a1a,0x80181818,0x80171717,
+0x80171717,0x80181818,0x801b1b1b,0x801e1e1e,0x801d1d1d,0x801e1e1e,
+0x80020202,0x80000000,0x80030303,0x80161616,0x801a1a1a,0x80161616,
+0x80191919,0x801a1a1a,0x801b1b1b,0x80222222,0x801e1e1e,0x80070707,
+0x80020202,0x80010101,0x800b0b0b,0x801b1b1b,0x80161616,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80010101,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,
+0x80000000,0x80010101,0x80000000,0x80010101,0x80040404,0x80090909,
+0x800f0f0f,0x80161616,0x801c1c1c,0x80202020,0x801f1f1f,0x801e1e1e,
+0x801b1b1b,0x80181818,0x80171717,0x80181818,0x801b1b1b,0x801d1d1d,
+0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801b1b1b,
+0x80191919,0x80181818,0x80171717,0x80181818,0x801b1b1b,0x801e1e1e,
+0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801e1e1e,0x801b1b1b,0x80191919,
+0x80171717,0x80171717,0x80181818,0x801b1b1b,0x801d1d1d,0x801e1e1e,
+0x801d1d1d,0x801f1f1f,0x801f1f1f,0x801b1b1b,0x80181818,0x80181818,
+0x80191919,0x80181818,0x801b1b1b,0x801d1d1d,0x801e1e1e,0x801f1f1f,
+0x80202020,0x801f1f1f,0x801c1c1c,0x80181818,0x808e8e8e,0x80939395,0x808f8f91,0x80929294,0x808d8d8f,0x808f8f91,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x80908f94,
+0x80908f94,0x80908f94,0x808f8e93,0x80908f94,0x80908f94,0x808f8e93,
+0x808f8e93,0x808f8e93,0x80908f94,0x80908f94,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808e8d92,0x808f8e93,
+0x808f8e93,0x808f8e93,0x80909092,0x80494949,0x801b1b1b,0x80181818,
+0x80181818,0x80171717,0x80181818,0x80181816,0x801b1b1b,0x801e1e1e,
+0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801b1b1b,0x80171717,
+0x80191919,0x80171717,0x80171717,0x801a1a1a,0x801d1d1d,0x801f1f1f,
+0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801b1b1b,0x80181818,0x80171717,
+0x80171717,0x80181818,0x801a1a1a,0x801c1c1c,0x80202020,0x801f1f1f,
+0x801e1e1e,0x801f1f1f,0x801d1d1d,0x80191919,0x80171717,0x80181818,
+0x80181818,0x80181818,0x801b1b1b,0x801f1f1f,0x80202020,0x801e1e1e,
+0x801d1d1d,0x801e1e1e,0x80191919,0x80191919,0x80181818,0x80171717,
+0x80181818,0x801b1b1b,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801a1a1a,
+0x80050505,0x80161616,0x80000000,0x80191919,0x80171717,0x80181818,
+0x80191919,0x801e1e1e,0x801e1e1e,0x801d1d1d,0x801b1b1b,0x800e0e0e,
+0x800b0b0b,0x80090909,0x800a0a0a,0x80181818,0x80141414,0x80010101,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80010101,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80010101,
+0x80000000,0x80000000,0x80010101,0x80020202,0x80040404,0x80050505,
+0x80070707,0x80090909,0x800f0f0f,0x80121212,0x80171717,0x801b1b1b,
+0x801e1e1e,0x80202020,0x80202020,0x80202020,0x801a1a1a,0x801a1a1a,
+0x80191919,0x80191919,0x80191919,0x801a1a1a,0x801b1b1b,0x801d1d1d,
+0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801b1b1b,0x80191919,
+0x80181818,0x80181818,0x80171717,0x801b1b1b,0x801e1e1e,0x801f1f1f,
+0x801f1f1f,0x801e1e1e,0x801c1c1c,0x801a1a1a,0x80181818,0x80181818,
+0x80171717,0x80181818,0x801a1a1a,0x801c1c1c,0x801e1e1e,0x801f1f1f,
+0x801e1e1e,0x801f1f1f,0x801c1c1c,0x80181818,0x80171717,0x80191919,
+0x801a1a1a,0x80191919,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x80202020,
+0x801f1f1f,0x801c1c1c,0x80191919,0x80171717,0x806a6a6a,0x806d6d6d,0x8068686a,0x806e6e70,0x806b6b6d,0x806f6f71,
+0x806b6b6d,0x806a6a6c,0x806a6a6c,0x806a6a6c,0x806b6b6d,0x806c6c6e,
+0x806c6c6e,0x806c6c6e,0x806e6e70,0x806d6d6f,0x806c6c6e,0x806b6b6d,
+0x806a6a6c,0x8069696b,0x8069696b,0x806a6a6c,0x806c6c6e,0x806c6c6e,
+0x806c6c6e,0x806c6c6e,0x806c6c6e,0x806b6b6d,0x806a6a6c,0x806a6a6c,
+0x8069696b,0x8069696b,0x806a6a6c,0x806a6a6c,0x806b6b6d,0x806c6c6e,
+0x806d6d6f,0x806d6d6f,0x806e6e70,0x803c3c3c,0x801a1a1a,0x80181818,
+0x80191919,0x80181818,0x80191919,0x80191917,0x801f1f1f,0x801d1d1d,
+0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801a1a1a,0x80181818,0x80181818,
+0x80171717,0x80181818,0x801a1a1a,0x801e1e1e,0x801f1f1f,0x801e1e1e,
+0x801e1e1e,0x801f1f1f,0x801c1c1c,0x80191919,0x80181818,0x80181818,
+0x80181818,0x80181818,0x801c1c1c,0x80202020,0x801f1f1f,0x80202020,
+0x801f1f1f,0x801a1a1a,0x80191919,0x80191919,0x80191919,0x80171717,
+0x80171717,0x801c1c1c,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801e1e1e,
+0x801d1d1d,0x801a1a1a,0x80181818,0x80181818,0x80181818,0x80181818,
+0x801b1b1b,0x801f1f1f,0x80202020,0x801d1d1d,0x801e1e1e,0x801a1a1a,
+0x800c0c0c,0x801a1a1a,0x80050505,0x80171717,0x80151515,0x801b1b1b,
+0x801c1c1c,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801d1d1d,0x80121212,
+0x800f0f0f,0x800f0f0f,0x80121212,0x80151515,0x80141414,0x800d0d0d,
+0x800f0f0f,0x800d0d0d,0x800d0d0d,0x800e0e0e,0x800c0c0c,0x800b0b0b,
+0x800a0a0a,0x800a0a0a,0x800a0a0a,0x800b0b0b,0x800d0d0d,0x800e0e0e,
+0x80131112,0x80141213,0x80161415,0x80171516,0x80181617,0x80181617,
+0x80191718,0x80191718,0x80181617,0x801b191a,0x801f1d1e,0x80211f20,
+0x80211f20,0x80201e1f,0x801e1c1d,0x801c1a1b,0x80191919,0x80181818,
+0x80171717,0x80171717,0x80191919,0x801c1c1c,0x801f1f1f,0x80212121,
+0x801f1f1f,0x801e1e1e,0x801c1c1c,0x801b1b1b,0x80191919,0x80171717,
+0x80171717,0x80181818,0x801b1b1b,0x801d1d1d,0x801e1e1e,0x801e1e1e,
+0x801e1e1e,0x801e1e1e,0x801b1b1b,0x80171717,0x80171717,0x80181818,
+0x80191919,0x801b1b1b,0x801c1c1c,0x801d1d1d,0x801e1e1e,0x801e1e1e,
+0x80202020,0x801c1c1c,0x80181818,0x80191919,0x80191919,0x80181818,
+0x80191919,0x801c1c1c,0x801f1f1f,0x801e1e1e,0x801f1f1f,0x801f1f1f,
+0x801c1c1c,0x80181818,0x80171717,0x80181818,0x80232323,0x801e1e1e,0x801e1e1e,0x80212123,0x801b1b1d,0x8018181a,
+0x80191919,0x80191919,0x80191919,0x801a1a1a,0x801c1c1c,0x801e1e1e,
+0x801e1e1e,0x801e1e1e,0x80202020,0x801d1d1d,0x801b1b1b,0x80191919,
+0x80181818,0x80171717,0x80181818,0x801a1a1a,0x801d1d1d,0x801e1e1e,
+0x801e1e1e,0x801e1e1e,0x801d1d1d,0x801b1b1b,0x80191919,0x80181818,
+0x80181818,0x80191919,0x801b1b1b,0x801c1c1c,0x801d1d1d,0x801e1e1e,
+0x801e1e1e,0x801e1e1e,0x801f1f21,0x80181818,0x80171717,0x801a1a1a,
+0x80181818,0x80181818,0x801d1d1d,0x8021211f,0x801f1f1f,0x801e1e1e,
+0x801d1d1d,0x801e1e1e,0x801b1b1b,0x80181818,0x80171717,0x80191919,
+0x80181818,0x801b1b1b,0x801d1d1d,0x801e1e1e,0x801e1e1e,0x801e1e1e,
+0x801d1d1d,0x801c1c1c,0x80191919,0x80181818,0x80181818,0x80191919,
+0x801a1a1a,0x801c1c1c,0x801e1e1e,0x80202020,0x801e1e1e,0x801f1f1f,
+0x801c1c1c,0x80181818,0x80171717,0x80191919,0x80191919,0x80181818,
+0x801b1b1b,0x801e1e1e,0x80202020,0x801e1e1e,0x801d1d1d,0x801d1d1d,
+0x801b1b1b,0x80171717,0x80181818,0x80181818,0x80191919,0x801b1b1b,
+0x801e1e1e,0x80202020,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801e1e1e,
+0x80191919,0x80151515,0x80191919,0x801a1a1a,0x80191919,0x801d1d1d,
+0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x80161616,
+0x80181818,0x801b1b1b,0x801a1a1a,0x801a1a1a,0x801d1d1d,0x801d1d1d,
+0x80202020,0x801e1e1e,0x801f1f1f,0x801d1d1d,0x80191919,0x80191919,
+0x80181818,0x80181818,0x80191919,0x801b1b1b,0x801d1d1d,0x801e1e1e,
+0x80211f20,0x80211f20,0x80201e1f,0x801e1c1d,0x801b191a,0x80191718,
+0x80181617,0x80181617,0x801d1b1c,0x801f1d1e,0x80201e1f,0x80201e1f,
+0x801f1d1e,0x801e1c1d,0x801d1b1c,0x801c1a1b,0x80191919,0x80191919,
+0x80191919,0x801a1a1a,0x801d1d1d,0x801e1e1e,0x801e1e1e,0x801e1e1e,
+0x801e1e1e,0x801c1c1c,0x801a1a1a,0x80191919,0x80181818,0x80171717,
+0x80191919,0x801b1b1b,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801d1d1d,
+0x801c1c1c,0x801b1b1b,0x80191919,0x80171717,0x80171717,0x80191919,
+0x801b1b1b,0x801d1d1d,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801e1e1e,
+0x801d1d1d,0x80191919,0x80171717,0x80181818,0x80191919,0x80191919,
+0x801b1b1b,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801c1c1c,
+0x80191919,0x80171717,0x80171717,0x80191919,0x801d1b1c,0x801f1d1e,0x80222021,0x801d1b1e,0x801b191c,0x8019171a,
+0x80191816,0x80181715,0x80191816,0x801b1a18,0x801e1d1b,0x80201f1d,
+0x80201f1d,0x801f1e1c,0x801e1d1b,0x801b1a18,0x80191816,0x80181715,
+0x80181715,0x80181715,0x801b1a18,0x801e1d1b,0x801f1e1c,0x80201f1d,
+0x80201f1d,0x80201f1d,0x801e1d1b,0x801b1a18,0x80191816,0x80181715,
+0x80191816,0x801a1917,0x801d1c1a,0x801f1e1c,0x80201f1d,0x80201f1d,
+0x801f1e1c,0x801f1e1c,0x80171719,0x80191919,0x80191919,0x80181818,
+0x80181818,0x801b1b1b,0x801e1e1e,0x801d1d1b,0x801d1d1d,0x801f1f1f,
+0x801f1f1f,0x801b1b1b,0x80171717,0x80181818,0x80191919,0x80181818,
+0x801a1a1a,0x801d1d1d,0x801e1e1e,0x801d1d1d,0x801e1e1e,0x801f1f1f,
+0x801c1c1c,0x80171717,0x80181818,0x80181818,0x80181818,0x80181818,
+0x801c1c1c,0x80202020,0x80202020,0x801e1e1e,0x80202020,0x801c1c1c,
+0x80191919,0x80191919,0x80181818,0x80171717,0x80181818,0x801a1a1a,
+0x80202020,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801a1a1a,
+0x80171717,0x80171717,0x80171717,0x80181818,0x801b1b1b,0x801e1e1e,
+0x801f1f1f,0x801d1d1d,0x801e1e1e,0x80202020,0x801b1b1b,0x80161616,
+0x80181818,0x80191919,0x80181818,0x80191919,0x801c1c1c,0x80202020,
+0x801d1d1d,0x80212121,0x80212121,0x801a1a1a,0x80191919,0x80181818,
+0x801b1b1b,0x80171717,0x80171717,0x801a1a1a,0x80202020,0x801e1e1e,
+0x801e1e1e,0x801e1e1e,0x801f1f1f,0x80191919,0x80191718,0x80191718,
+0x80181617,0x80191718,0x801a1819,0x801d1b1c,0x801f1d1e,0x80211f20,
+0x801e1c1d,0x801e1c1d,0x801c1a1b,0x80191718,0x80171516,0x80171516,
+0x80191718,0x801b191a,0x801e1c1d,0x80201e1f,0x80211f20,0x80201e1f,
+0x801e1c1d,0x801d1b1c,0x801a1819,0x80181617,0x80181818,0x80181818,
+0x80191919,0x801b1b1b,0x801f1f1f,0x80202020,0x801f1f1f,0x801d1d1d,
+0x801d1d1d,0x801a1a1a,0x80191919,0x80181818,0x80181818,0x80181818,
+0x801b1b1b,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801f1f1f,0x801e1e1e,
+0x801a1a1a,0x80171717,0x80171717,0x801a1a1a,0x80171717,0x80191919,
+0x801c1c1c,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801d1d1d,
+0x80171717,0x80191919,0x80191919,0x80171717,0x80181818,0x801c1c1c,
+0x801f1f1f,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801b1b1b,0x80181818,
+0x80171717,0x80181818,0x80191919,0x80181818,0x801e1e1e,0x801f1f1f,0x801d1d1d,0x80191919,0x80181818,0x80191919,
+0x80171717,0x80181818,0x801a1a1a,0x801e1e1e,0x801f1f1f,0x801f1f1f,
+0x801e1e1e,0x801f1f1f,0x80181818,0x801a1a1a,0x80191919,0x80171717,
+0x80171717,0x801b1b1b,0x801e1e1e,0x801f1f1f,0x801d1d1d,0x801f1f1f,
+0x801f1f1f,0x801b1b1b,0x80181818,0x80171717,0x80181818,0x80191919,
+0x80181818,0x801d1d1d,0x801f1f1f,0x801d1d1d,0x801e1e1e,0x80202020,
+0x801e1e1e,0x80191919,0x80181818,0x80191919,0x80181818,0x80171717,
+0x801b1b1b,0x801f1f1f,0x801f1f1f,0x801d1d1d,0x80212121,0x801c1c1c,
+0x80191919,0x80191919,0x80191919,0x80171717,0x80181818,0x801a1a1a,
+0x80202020,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801c1c1c,
+0x80191919,0x80181818,0x80181818,0x80171717,0x80191919,0x801e1e1e,
+0x80202020,0x801f1f1f,0x801e1e1e,0x80202020,0x80191919,0x80181818,
+0x80181818,0x80191919,0x80181818,0x80171717,0x801b1b1b,0x80202020,
+0x801d1d1d,0x80202020,0x80202020,0x801c1c1c,0x80191919,0x80181818,
+0x80181818,0x80171717,0x80161616,0x801b1b1b,0x801e1e1e,0x801d1d1d,
+0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801b1b1b,0x80181818,0x80191919,
+0x80181818,0x80171717,0x801a1a1a,0x801e1e1e,0x801f1f1f,0x801d1d1d,
+0x801e1e1e,0x801e1e1e,0x801c1c1c,0x80181818,0x80181818,0x801a1a1a,
+0x80191919,0x80171717,0x801c1c1c,0x801e1e1e,0x80202020,0x801e1e1e,
+0x801d1d1d,0x801d1d1d,0x801b1b1b,0x80171717,0x801a1a1a,0x80171717,
+0x80171717,0x801a1a1a,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801f1f1f,
+0x801d1d1d,0x801a1a1a,0x80181818,0x80171717,0x80181818,0x80181818,
+0x801a1a1a,0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801f1f1f,
+0x801c1c1c,0x80181818,0x80181818,0x801a1a1a,0x80161616,0x80191919,
+0x801c1c1c,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801d1d1d,
+0x80181818,0x801a1a1a,0x80191919,0x80171717,0x80171717,0x801b1b1b,
+0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801b1b1b,
+0x80181818,0x80171717,0x80171717,0x80171717,0x80191919,0x801d1d1d,
+0x801e1e1e,0x801e1e1e,0x801f1f1f,0x80202020,0x801d1d1d,0x80171717,
+0x80181818,0x80191919,0x80191919,0x80191919,0x801b1b1b,0x801f1f1f,
+0x80202020,0x801d1d1d,0x80202020,0x801c1c1c,0x80191919,0x80191919,
+0x80191919,0x80171717,0x80191919,0x801d1d1d,0x80202020,0x801c1c1c,0x80191919,0x80191919,0x80191919,0x80171717,
+0x80181818,0x801c1c1c,0x801f1f1f,0x801d1d1d,0x801e1e1e,0x801f1f1f,
+0x801e1e1e,0x801a1a1a,0x801a1a1a,0x80181818,0x80171717,0x80181818,
+0x801b1b1b,0x801d1d1d,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801d1d1d,
+0x801b1b1b,0x80191919,0x80191919,0x80181818,0x80191919,0x80191919,
+0x801d1d1d,0x801d1d1d,0x801e1e1e,0x80202020,0x801f1f1f,0x801c1c1c,
+0x80191919,0x80191919,0x80191919,0x80171717,0x80181818,0x801b1b1b,
+0x801e1e1e,0x801d1d1d,0x801e1e1e,0x801f1f1f,0x801c1c1c,0x801b1b1b,
+0x80191919,0x80181818,0x80171717,0x80181818,0x801b1b1b,0x801d1d1d,
+0x801e1e1e,0x801f1f1f,0x80202020,0x801e1e1e,0x801b1b1b,0x80191919,
+0x80181818,0x80181818,0x80171717,0x801b1b1b,0x801d1d1d,0x801d1d1d,
+0x801f1f1f,0x80202020,0x801f1f1f,0x801c1c1c,0x80181818,0x80191919,
+0x80191919,0x80171717,0x80181818,0x801c1c1c,0x801e1e1e,0x801e1e1e,
+0x80202020,0x801e1e1e,0x801c1c1c,0x801a1a1a,0x80191919,0x80181818,
+0x80181818,0x80181818,0x801b1b1b,0x801c1c1c,0x801d1d1d,0x801e1e1e,
+0x801f1f1f,0x801e1e1e,0x801b1b1b,0x80181818,0x80191919,0x80171717,
+0x80171717,0x801b1b1b,0x801d1d1d,0x801d1d1d,0x801e1e1e,0x80202020,
+0x801e1e1e,0x801b1b1b,0x80191919,0x80191919,0x80191919,0x80171717,
+0x80181818,0x801b1b1b,0x801e1e1e,0x801d1d1d,0x801e1e1e,0x801f1f1f,
+0x801e1e1e,0x80191919,0x80171717,0x80181818,0x80171717,0x80191919,
+0x801b1b1b,0x801c1c1c,0x801d1d1d,0x801e1e1e,0x801e1e1e,0x801e1e1e,
+0x801a1a1a,0x80181818,0x80171717,0x80171717,0x80191919,0x801a1a1a,
+0x801c1c1c,0x801e1e1e,0x801e1e1e,0x80202020,0x801f1f1f,0x801b1b1b,
+0x80191919,0x80191919,0x80191919,0x80181818,0x80191919,0x801c1c1c,
+0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801c1c1c,0x801a1a1a,
+0x801a1a1a,0x80181818,0x80171717,0x80181818,0x801b1b1b,0x801d1d1d,
+0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801b1b1b,0x80191919,
+0x80181818,0x80181818,0x80191919,0x80191919,0x801d1d1d,0x801d1d1d,
+0x801f1f1f,0x80202020,0x801f1f1f,0x801b1b1b,0x80191919,0x80191919,
+0x80191919,0x80171717,0x80181818,0x801c1c1c,0x801f1f1f,0x801e1e1e,
+0x801e1e1e,0x801f1f1f,0x801c1c1c,0x801a1a1a,0x80181818,0x80171717,
+0x80181818,0x801a1a1a,0x801c1c1c,0x801e1e1e,0x801e1e1e,0x80191919,0x80171717,0x80181818,0x80191919,0x80171717,
+0x801a1a1a,0x801f1f1f,0x80212121,0x801f1f1f,0x801d1d1d,0x801e1e1e,
+0x801b1b1b,0x80171717,0x80191919,0x80171717,0x80171717,0x801a1a1a,
+0x801e1e1e,0x801e1e1e,0x801f1f1f,0x80202020,0x801f1f1f,0x801b1b1b,
+0x80181818,0x80181818,0x80181818,0x80181818,0x801a1a1a,0x801c1c1c,
+0x801f1f1f,0x801e1e1e,0x801f1f1f,0x80202020,0x801d1d1d,0x80191919,
+0x80181818,0x80181818,0x80181818,0x80181818,0x801a1a1a,0x801e1e1e,
+0x801f1f1f,0x801d1d1d,0x801d1d1d,0x801f1f1f,0x80191919,0x80191919,
+0x80181818,0x80161616,0x80171717,0x801a1a1a,0x801d1d1d,0x801e1e1e,
+0x801e1e1e,0x80202020,0x801f1f1f,0x801b1b1b,0x80181818,0x80181818,
+0x80181818,0x80181818,0x80191919,0x801d1d1d,0x801f1f1f,0x801f1f1f,
+0x801e1e1e,0x801f1f1f,0x801c1c1c,0x80191919,0x80181818,0x80191919,
+0x80181818,0x80181818,0x801b1b1b,0x801f1f1f,0x80202020,0x801e1e1e,
+0x80202020,0x801c1c1c,0x80181818,0x80181818,0x80181818,0x80181818,
+0x80191919,0x801b1b1b,0x801e1e1e,0x801d1d1d,0x801e1e1e,0x801f1f1f,
+0x801f1f1f,0x801b1b1b,0x80181818,0x80181818,0x80181818,0x80171717,
+0x80191919,0x801e1e1e,0x80202020,0x801f1f1f,0x801e1e1e,0x801f1f1f,
+0x801c1c1c,0x80191919,0x80181818,0x80181818,0x80181818,0x80181818,
+0x801a1a1a,0x801e1e1e,0x80202020,0x801e1e1e,0x801d1d1d,0x801d1d1d,
+0x801b1b1b,0x80171717,0x80161616,0x80181818,0x80171717,0x801b1b1b,
+0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801d1d1d,0x801b1b1b,
+0x80181818,0x80171717,0x80171717,0x80191919,0x801b1b1b,0x801c1c1c,
+0x801e1e1e,0x80202020,0x801e1e1e,0x801f1f1f,0x801d1d1d,0x80191919,
+0x80171717,0x80181818,0x80191919,0x80181818,0x801c1c1c,0x801e1e1e,
+0x80202020,0x801f1f1f,0x801e1e1e,0x801c1c1c,0x801a1a1a,0x80191919,
+0x80191919,0x80171717,0x80171717,0x801b1b1b,0x801e1e1e,0x801e1e1e,
+0x801e1e1e,0x801f1f1f,0x801d1d1d,0x801b1b1b,0x80191919,0x80171717,
+0x80171717,0x80191919,0x801b1b1b,0x801c1c1c,0x801e1e1e,0x801f1f1f,
+0x80202020,0x80202020,0x801d1d1d,0x80181818,0x80171717,0x80191919,
+0x80191919,0x80181818,0x801a1a1a,0x801f1f1f,0x80202020,0x801f1f1f,
+0x801d1d1d,0x801e1e1e,0x80191919,0x80191919,0x80181818,0x80171717,
+0x80181818,0x801c1c1c,0x801f1f1f,0x801f1f1f,0x80191919,0x80191919,0x80181818,0x80161616,0x80181818,0x801b1b1b,
+0x801e1e1e,0x801d1d1d,0x801f1f1f,0x80202020,0x801e1e1e,0x801a1a1a,
+0x80181818,0x80191919,0x80171717,0x80181818,0x801a1a1a,0x801d1d1d,
+0x801f1f1f,0x801e1e1e,0x801e1e1e,0x80202020,0x801b1b1b,0x80191919,
+0x80181818,0x80181818,0x80171717,0x80181818,0x801c1c1c,0x801f1f1f,
+0x801d1d1d,0x80202020,0x80202020,0x801c1c1c,0x80191919,0x801a1a1a,
+0x80191919,0x80171717,0x80171717,0x801b1b1b,0x801e1e1e,0x801e1e1e,
+0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801b1b1b,0x80191919,0x80181818,
+0x80161616,0x80171717,0x801a1a1a,0x801e1e1e,0x801e1e1e,0x801d1d1d,
+0x801f1f1f,0x801e1e1e,0x801b1b1b,0x80181818,0x80171717,0x80181818,
+0x80191919,0x80181818,0x801e1e1e,0x801d1d1d,0x801f1f1f,0x80212121,
+0x801f1f1f,0x801a1a1a,0x80181818,0x80191919,0x80191919,0x80171717,
+0x80181818,0x801c1c1c,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801f1f1f,
+0x801c1c1c,0x801a1a1a,0x80181818,0x80171717,0x80171717,0x80181818,
+0x801b1b1b,0x801e1e1e,0x801d1d1d,0x801e1e1e,0x801f1f1f,0x801f1f1f,
+0x801b1b1b,0x80181818,0x80181818,0x80191919,0x80171717,0x801b1b1b,
+0x801e1e1e,0x801e1e1e,0x801f1f1f,0x80202020,0x801f1f1f,0x801b1b1b,
+0x80181818,0x80191919,0x80181818,0x80171717,0x80181818,0x801c1c1c,
+0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801d1d1d,0x80191919,
+0x80171717,0x80181818,0x80191919,0x80171717,0x801a1a1a,0x801c1c1c,
+0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801b1b1b,0x80171717,
+0x80171717,0x80171717,0x80191919,0x801b1b1b,0x801d1d1d,0x801e1e1e,
+0x801f1f1f,0x801f1f1f,0x801f1f1f,0x801b1b1b,0x80191919,0x80191919,
+0x80181818,0x80171717,0x80191919,0x801c1c1c,0x801e1e1e,0x801f1f1f,
+0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801b1b1b,0x80191919,0x80181818,
+0x80171717,0x80181818,0x801b1b1b,0x801e1e1e,0x801f1f1f,0x801e1e1e,
+0x801d1d1d,0x801e1e1e,0x801b1b1b,0x80191919,0x80171717,0x80171717,
+0x80181818,0x801b1b1b,0x801d1d1d,0x801e1e1e,0x801e1e1e,0x80202020,
+0x80202020,0x801b1b1b,0x80181818,0x80191919,0x80191919,0x80181818,
+0x80191919,0x801c1c1c,0x801f1f1f,0x801f1f1f,0x801f1f1f,0x80202020,
+0x801d1d1d,0x801a1a1a,0x80181818,0x80181818,0x80181818,0x80181818,
+0x801b1b1b,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x80171717,0x80181818,0x80181818,0x80181818,0x801a1a1a,0x801e1e1e,
+0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801e1e1e,0x801c1c1c,0x80171717,
+0x80171717,0x80191919,0x80171717,0x801b1b1b,0x801e1e1e,0x801f1f1f,
+0x801f1f1f,0x801f1f1f,0x801d1d1d,0x801c1c1c,0x80181818,0x80191919,
+0x80181818,0x80171717,0x80191919,0x801c1c1c,0x801e1e1e,0x801f1f1f,
+0x801e1e1e,0x801f1f1f,0x801d1d1d,0x80191919,0x80171717,0x80181818,
+0x80191919,0x80181818,0x801b1b1b,0x801e1e1e,0x801f1f1f,0x801e1e1e,
+0x801e1e1e,0x801e1e1e,0x801b1b1b,0x80171717,0x80191919,0x80171717,
+0x80171717,0x801a1a1a,0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801e1e1e,
+0x801f1f1f,0x801b1b1b,0x80181818,0x80171717,0x80171717,0x80181818,
+0x801a1a1a,0x801c1c1c,0x80202020,0x801f1f1f,0x801e1e1e,0x801f1f1f,
+0x801d1d1d,0x80191919,0x80171717,0x80181818,0x80181818,0x80181818,
+0x801b1b1b,0x801f1f1f,0x80202020,0x801e1e1e,0x801d1d1d,0x801e1e1e,
+0x80191919,0x80191919,0x80181818,0x80171717,0x80181818,0x801b1b1b,
+0x801e1e1e,0x801f1f1f,0x801d1d1d,0x801f1f1f,0x801f1f1f,0x801b1b1b,
+0x80181818,0x80171717,0x80181818,0x80191919,0x801a1a1a,0x801d1d1d,
+0x80202020,0x801f1f1f,0x801f1f1f,0x801f1f1f,0x801c1c1c,0x80191919,
+0x80181818,0x80191919,0x80181818,0x80181818,0x801b1b1b,0x80202020,
+0x80202020,0x801e1e1e,0x801d1d1d,0x801e1e1e,0x801b1b1b,0x80171717,
+0x80161616,0x80181818,0x801a1a1a,0x801a1a1a,0x801e1e1e,0x801d1d1d,
+0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801b1b1b,0x80181818,0x80171717,
+0x80181818,0x80191919,0x801b1b1b,0x801d1d1d,0x801e1e1e,0x801f1f1f,
+0x801f1f1f,0x801e1e1e,0x801c1c1c,0x80191919,0x80171717,0x80181818,
+0x80191919,0x80191919,0x801b1b1b,0x801f1f1f,0x801f1f1f,0x801f1f1f,
+0x801e1e1e,0x801d1d1d,0x801b1b1b,0x80191919,0x80181818,0x80181818,
+0x80171717,0x801b1b1b,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801e1e1e,
+0x801c1c1c,0x801a1a1a,0x80181818,0x80181818,0x80171717,0x80181818,
+0x801a1a1a,0x801c1c1c,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801f1f1f,
+0x801d1d1d,0x80181818,0x80171717,0x80181818,0x80191919,0x80191919,
+0x801b1b1b,0x801f1f1f,0x80202020,0x801f1f1f,0x801e1e1e,0x801e1e1e,
+0x801b1b1b,0x80171717,0x80181818,0x80181818,0x80191919,0x801c1c1c,
+0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x80181818,0x80161616,0x80181818,0x801d1d1d,0x801f1f1f,0x801e1e1e,
+0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801a1a1a,0x80171717,0x80181818,
+0x80181818,0x80171717,0x801b1b1b,0x801d1d1d,0x801e1e1e,0x801e1e1e,
+0x801f1f1f,0x801f1f1f,0x801c1c1c,0x80181818,0x80171717,0x80181818,
+0x80181818,0x80181818,0x801c1c1c,0x80202020,0x80202020,0x801e1e1e,
+0x80202020,0x801c1c1c,0x80191919,0x801a1a1a,0x80181818,0x80161616,
+0x80181818,0x801c1c1c,0x801f1f1f,0x801d1d1d,0x801d1d1d,0x801f1f1f,
+0x801e1e1e,0x801a1a1a,0x80181818,0x80181818,0x80171717,0x80181818,
+0x801a1a1a,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801f1f1f,
+0x801c1c1c,0x80191919,0x80181818,0x80181818,0x80181818,0x80181818,
+0x801c1c1c,0x80202020,0x801f1f1f,0x80202020,0x801f1f1f,0x801a1a1a,
+0x80191919,0x80191919,0x80191919,0x80171717,0x80171717,0x801c1c1c,
+0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801d1d1d,0x801a1a1a,
+0x80181818,0x80181818,0x80181818,0x80181818,0x801b1b1b,0x801f1f1f,
+0x80202020,0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801b1b1b,0x80181818,
+0x80171717,0x80181818,0x80191919,0x80181818,0x801e1e1e,0x801d1d1d,
+0x801f1f1f,0x80202020,0x801f1f1f,0x801a1a1a,0x80181818,0x80191919,
+0x801a1a1a,0x80171717,0x80181818,0x801c1c1c,0x80202020,0x801f1f1f,
+0x801e1e1e,0x801e1e1e,0x801d1d1d,0x80191919,0x80171717,0x80181818,
+0x80181818,0x80181818,0x801b1b1b,0x801e1e1e,0x801f1f1f,0x801e1e1e,
+0x801e1e1e,0x801e1e1e,0x801b1b1b,0x80171717,0x80171717,0x80191919,
+0x80181818,0x801a1a1a,0x801c1c1c,0x801e1e1e,0x801f1f1f,0x80202020,
+0x801f1f1f,0x801d1d1d,0x80181818,0x80191919,0x80181818,0x80171717,
+0x80191919,0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801f1f1f,0x801e1e1e,
+0x801c1c1c,0x801b1b1b,0x80191919,0x80171717,0x80171717,0x80181818,
+0x801b1b1b,0x801d1d1d,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801e1e1e,
+0x801b1b1b,0x80171717,0x80171717,0x80181818,0x80191919,0x801b1b1b,
+0x801c1c1c,0x801d1d1d,0x801e1e1e,0x801e1e1e,0x80202020,0x801b1b1b,
+0x80181818,0x80191919,0x80181818,0x80171717,0x80181818,0x801c1c1c,
+0x801f1f1f,0x801e1e1e,0x801f1f1f,0x80202020,0x801e1e1e,0x80191919,
+0x80171717,0x80181818,0x80181818,0x80181818,0x801a1a1a,0x801e1e1e,
+0x80202020,0x801f1f1f,0x801d1d1d,0x801d1d1d,0x80191919,0x80181818,0x801a1a1a,0x801f1f1f,0x801f1f1f,0x801e1e1e,
+0x801e1e1e,0x801e1e1e,0x801b1b1b,0x80181818,0x80171717,0x80181818,
+0x801a1a1a,0x801a1a1a,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801e1e1e,
+0x801d1d1d,0x801c1c1c,0x80191919,0x80171717,0x80181818,0x80191919,
+0x801a1a1a,0x801c1c1c,0x801e1e1e,0x80202020,0x80202020,0x801e1e1e,
+0x801e1e1e,0x80191919,0x80181818,0x80191919,0x80191919,0x80181818,
+0x801a1a1a,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801e1e1e,
+0x801b1b1b,0x80181818,0x80171717,0x80191919,0x80181818,0x801b1b1b,
+0x801d1d1d,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801d1d1d,0x801c1c1c,
+0x80191919,0x80181818,0x80181818,0x80191919,0x801a1a1a,0x801c1c1c,
+0x801e1e1e,0x80202020,0x801e1e1e,0x801f1f1f,0x801c1c1c,0x80181818,
+0x80171717,0x80191919,0x80191919,0x80181818,0x801b1b1b,0x801e1e1e,
+0x80202020,0x801e1e1e,0x801d1d1d,0x801d1d1d,0x801b1b1b,0x80171717,
+0x80181818,0x80181818,0x80191919,0x801b1b1b,0x801e1e1e,0x80202020,
+0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801b1b1b,0x80181818,0x80181818,
+0x80181818,0x80191919,0x801a1a1a,0x801b1b1b,0x801f1f1f,0x801e1e1e,
+0x801e1e1e,0x801f1f1f,0x801c1c1c,0x80181818,0x80171717,0x80191919,
+0x80191919,0x80181818,0x801a1a1a,0x801f1f1f,0x80202020,0x801e1e1e,
+0x801d1d1d,0x801e1e1e,0x801b1b1b,0x80171717,0x80161616,0x80191919,
+0x801a1a1a,0x801b1b1b,0x801c1c1c,0x801f1f1f,0x801f1f1f,0x801e1e1e,
+0x801d1d1d,0x801b1b1b,0x80181818,0x80171717,0x80181818,0x801a1a1a,
+0x801a1a1a,0x801c1c1c,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801f1f1f,
+0x801c1c1c,0x801a1a1a,0x80181818,0x80191919,0x80191919,0x80191919,
+0x801b1b1b,0x801f1f1f,0x80202020,0x801e1e1e,0x801e1e1e,0x801c1c1c,
+0x801a1a1a,0x80191919,0x80181818,0x80171717,0x80191919,0x801b1b1b,
+0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801d1d1d,0x801c1c1c,0x801b1b1b,
+0x80191919,0x80171717,0x80171717,0x80191919,0x801b1b1b,0x801d1d1d,
+0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801d1d1d,0x80191919,
+0x80171717,0x80191919,0x80191919,0x80181818,0x801a1a1a,0x801f1f1f,
+0x80202020,0x801e1e1e,0x801d1d1d,0x801d1d1d,0x801b1b1b,0x80171717,
+0x80171717,0x80191919,0x80191919,0x801b1b1b,0x801d1d1d,0x801f1f1f,
+0x801f1f1f,0x801e1e1e,0x801c1c1c,0x80191919,0x80171717,0x801b1b1b,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801f1f1f,
+0x801f1f1f,0x801a1a1a,0x80171717,0x80191919,0x80191919,0x80171717,
+0x801a1a1a,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x80202020,0x80202020,
+0x801c1c1c,0x80181818,0x80171717,0x80191919,0x80191919,0x80191919,
+0x801c1c1c,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x80202020,
+0x80191919,0x80191919,0x80181818,0x80171717,0x80181818,0x801c1c1c,
+0x801f1f1f,0x801f1f1f,0x801d1d1d,0x801f1f1f,0x801f1f1f,0x801b1b1b,
+0x80171717,0x80181818,0x80191919,0x80181818,0x801a1a1a,0x801d1d1d,
+0x801e1e1e,0x801d1d1d,0x801e1e1e,0x801f1f1f,0x801c1c1c,0x80171717,
+0x80181818,0x80181818,0x80181818,0x80181818,0x801c1c1c,0x80202020,
+0x80202020,0x801e1e1e,0x80202020,0x801c1c1c,0x80191919,0x80191919,
+0x80181818,0x80171717,0x80181818,0x801a1a1a,0x80202020,0x801e1e1e,
+0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801a1a1a,0x80171717,0x80171717,
+0x80171717,0x80181818,0x801b1b1b,0x801e1e1e,0x801f1f1f,0x801d1d1d,
+0x801e1e1e,0x80202020,0x801b1b1b,0x80181818,0x80181818,0x80191919,
+0x80191919,0x80181818,0x801b1b1b,0x80202020,0x801d1d1d,0x80202020,
+0x801f1f1f,0x801b1b1b,0x80191919,0x80191919,0x80191919,0x80181818,
+0x80171717,0x801b1b1b,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801e1e1e,
+0x801e1e1e,0x801b1b1b,0x80171717,0x80181818,0x80181818,0x80171717,
+0x801a1a1a,0x801e1e1e,0x801f1f1f,0x801d1d1d,0x801f1f1f,0x801e1e1e,
+0x801b1b1b,0x80171717,0x80171717,0x80191919,0x801a1a1a,0x80181818,
+0x801d1d1d,0x801e1e1e,0x80202020,0x801f1f1f,0x801e1e1e,0x801d1d1d,
+0x801a1a1a,0x80161616,0x801a1a1a,0x80181818,0x80181818,0x801c1c1c,
+0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801d1d1d,0x801a1a1a,
+0x80191919,0x80181818,0x80181818,0x80181818,0x801b1b1b,0x801e1e1e,
+0x801f1f1f,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801a1a1a,0x80171717,
+0x80171717,0x801a1a1a,0x80171717,0x80191919,0x801c1c1c,0x801e1e1e,
+0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801d1d1d,0x80171717,0x80191919,
+0x80191919,0x80181818,0x80191919,0x801c1c1c,0x801f1f1f,0x80202020,
+0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801a1a1a,0x80171717,0x80181818,
+0x80191919,0x80181818,0x801a1a1a,0x801e1e1e,0x80202020,0x801e1e1e,
+0x801d1d1d,0x801d1d1d,0x801a1a1a,0x80161616,0x801a1a1a,0x80202020,0x801e1e1e,0x801d1d1d,0x801f1f1f,0x801c1c1c,
+0x80181818,0x80191919,0x80191919,0x80171717,0x80171717,0x801a1a1a,
+0x801e1e1e,0x801f1f1f,0x801d1d1d,0x80212121,0x801f1f1f,0x801b1b1b,
+0x80171717,0x80191919,0x801a1a1a,0x80181818,0x80171717,0x801d1d1d,
+0x80202020,0x801f1f1f,0x801f1f1f,0x801f1f1f,0x801d1d1d,0x80181818,
+0x80161616,0x801a1a1a,0x80191919,0x80171717,0x801a1a1a,0x801f1f1f,
+0x801f1f1f,0x801f1f1f,0x80212121,0x801c1c1c,0x80191919,0x80191919,
+0x80191919,0x80171717,0x80181818,0x801a1a1a,0x801e1e1e,0x80202020,
+0x80202020,0x801f1f1f,0x801d1d1d,0x801c1c1c,0x80191919,0x80161616,
+0x80181818,0x80171717,0x80191919,0x801e1e1e,0x80202020,0x801f1f1f,
+0x801e1e1e,0x80202020,0x80191919,0x80181818,0x80181818,0x80191919,
+0x80181818,0x80171717,0x801b1b1b,0x80202020,0x801d1d1d,0x801f1f1f,
+0x801f1f1f,0x801d1d1d,0x801b1b1b,0x80181818,0x80181818,0x80191919,
+0x80151515,0x801b1b1b,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801f1f1f,
+0x801e1e1e,0x801c1c1c,0x80181818,0x80191919,0x80181818,0x80171717,
+0x801a1a1a,0x801e1e1e,0x801f1f1f,0x801d1d1d,0x801f1f1f,0x801e1e1e,
+0x801b1b1b,0x80191919,0x80191919,0x80191919,0x80181818,0x80191919,
+0x801d1d1d,0x801d1d1d,0x801d1d1d,0x801e1e1e,0x80202020,0x801d1d1d,
+0x80181818,0x80181818,0x80171717,0x801a1a1a,0x80181818,0x80191919,
+0x80212121,0x80202020,0x801c1c1c,0x801f1f1f,0x801e1e1e,0x801a1a1a,
+0x80161616,0x80191919,0x80171717,0x801a1a1a,0x80191919,0x801d1d1d,
+0x80202020,0x801c1c1c,0x801e1e1e,0x80212121,0x801c1c1c,0x80191919,
+0x80181818,0x80171717,0x80181818,0x801a1a1a,0x801d1d1d,0x801e1e1e,
+0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801d1d1d,0x80191919,0x80191919,
+0x80181818,0x80171717,0x80181818,0x801c1c1c,0x801e1e1e,0x801e1e1e,
+0x801e1e1e,0x80202020,0x801e1e1e,0x801a1a1a,0x80171717,0x80171717,
+0x80191919,0x80171717,0x801a1a1a,0x801e1e1e,0x801c1c1c,0x801e1e1e,
+0x80202020,0x801c1c1c,0x801a1a1a,0x80191919,0x80171717,0x80191919,
+0x80191919,0x80181818,0x801c1c1c,0x801f1f1f,0x80202020,0x801e1e1e,
+0x80212121,0x801c1c1c,0x80181818,0x80191919,0x80191919,0x80171717,
+0x80181818,0x801b1b1b,0x801f1f1f,0x801e1e1e,0x801f1f1f,0x801f1f1f,
+0x801c1c1c,0x801a1a1a,0x80181818,0x80171717,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801b1b1b,
+0x801a1a1a,0x80181818,0x80171717,0x80181818,0x801a1a1a,0x801d1d1d,
+0x801e1e1e,0x801f1f1f,0x80212121,0x801e1e1e,0x801a1a1a,0x80181818,
+0x80181818,0x80191919,0x80181818,0x80171717,0x801e1e1e,0x801c1c1c,
+0x801b1b1b,0x801e1e1e,0x801f1f1f,0x801d1d1d,0x801a1a1a,0x80191919,
+0x801a1a1a,0x80181818,0x80161616,0x801a1a1a,0x801f1f1f,0x80202020,
+0x801e1e1e,0x801f1f1f,0x801c1c1c,0x801b1b1b,0x80191919,0x80181818,
+0x80171717,0x80181818,0x801b1b1b,0x801d1d1d,0x801f1f1f,0x801d1d1d,
+0x801d1d1d,0x801f1f1f,0x801c1c1c,0x80161616,0x80161616,0x801a1a1a,
+0x80171717,0x801b1b1b,0x801d1d1d,0x801d1d1d,0x801f1f1f,0x80202020,
+0x801f1f1f,0x801c1c1c,0x80181818,0x80191919,0x80191919,0x80171717,
+0x80181818,0x801c1c1c,0x801e1e1e,0x801e1e1e,0x80202020,0x801f1f1f,
+0x801d1d1d,0x801a1a1a,0x80161616,0x80151515,0x80161616,0x80191919,
+0x801c1c1c,0x801d1d1d,0x801e1e1e,0x801f1f1f,0x80202020,0x801f1f1f,
+0x801b1b1b,0x80171717,0x80191919,0x80171717,0x80171717,0x801b1b1b,
+0x801d1d1d,0x801d1d1d,0x801e1e1e,0x80202020,0x801f1f1f,0x801d1d1d,
+0x80191919,0x80181818,0x80171717,0x80171717,0x80191919,0x80191919,
+0x801e1e1e,0x80212121,0x80222222,0x80202020,0x801d1d1d,0x801a1a1a,
+0x80181818,0x80181818,0x80191919,0x80161616,0x801a1a1a,0x801e1e1e,
+0x801c1c1c,0x801d1d1d,0x801f1f1f,0x801f1f1f,0x801a1a1a,0x801a1a1a,
+0x80181818,0x801a1a1a,0x80171717,0x801a1a1a,0x801c1c1c,0x80202020,
+0x801c1c1c,0x80202020,0x80202020,0x801c1c1c,0x80181818,0x80181818,
+0x80181818,0x80191919,0x80181818,0x801c1c1c,0x801f1f1f,0x801e1e1e,
+0x801d1d1d,0x801d1d1d,0x801c1c1c,0x801a1a1a,0x80191919,0x80171717,
+0x80161616,0x80181818,0x801b1b1b,0x801e1e1e,0x801e1e1e,0x801e1e1e,
+0x80202020,0x801e1e1e,0x801a1a1a,0x80181818,0x80181818,0x80181818,
+0x80181818,0x801a1a1a,0x801e1e1e,0x801e1e1e,0x801c1c1c,0x801f1f1f,
+0x80202020,0x801e1e1e,0x801c1c1c,0x80171717,0x801a1a1a,0x80171717,
+0x80181818,0x801b1b1b,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801e1e1e,
+0x801c1c1c,0x801b1b1b,0x80191919,0x80181818,0x80181818,0x80181818,
+0x801b1b1b,0x801e1e1e,0x801c1c1c,0x801f1f1f,0x801f1f1f,0x801e1e1e,
+0x801c1c1c,0x80191919,0x80181818,0x801b1b1b,0x80202020,0x801e1e1e,0x801e1e1e,0x801d1d1d,0x80191919,0x80171717,
+0x801a1a1a,0x80171717,0x80171717,0x801b1b1b,0x801e1e1e,0x801e1e1e,
+0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801b1b1b,0x80191919,0x80191919,
+0x80181818,0x80161616,0x80181818,0x801d1d1d,0x80202020,0x801f1f1f,
+0x80202020,0x80212121,0x801e1e1e,0x80181818,0x80171717,0x80191919,
+0x80161616,0x80171717,0x801b1b1b,0x801f1f1f,0x80222222,0x801e1e1e,
+0x801c1c1c,0x801e1e1e,0x80191919,0x80191919,0x80181818,0x80161616,
+0x80171717,0x801a1a1a,0x801d1d1d,0x801e1e1e,0x801d1d1d,0x801f1f1f,
+0x801f1f1f,0x801d1d1d,0x801a1a1a,0x80191919,0x80181818,0x80171717,
+0x80191919,0x801d1d1d,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801f1f1f,
+0x801c1c1c,0x80191919,0x80181818,0x80191919,0x80181818,0x80181818,
+0x801b1b1b,0x801f1f1f,0x80202020,0x801e1e1e,0x80202020,0x801c1c1c,
+0x80191919,0x80181818,0x80181818,0x80191919,0x80191919,0x801a1a1a,
+0x801f1f1f,0x801d1d1d,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801b1b1b,
+0x80181818,0x80161616,0x80181818,0x80171717,0x80191919,0x801e1e1e,
+0x80202020,0x801f1f1f,0x801e1e1e,0x801f1f1f,0x80181818,0x801a1a1a,
+0x80181818,0x80181818,0x80171717,0x80171717,0x801e1e1e,0x80202020,
+0x801e1e1e,0x80202020,0x80202020,0x801d1d1d,0x80191919,0x80181818,
+0x80191919,0x80171717,0x80171717,0x801a1a1a,0x80202020,0x80212121,
+0x801e1e1e,0x80202020,0x80202020,0x80181818,0x80161616,0x80171717,
+0x80151515,0x80171717,0x80181818,0x801d1d1d,0x801e1e1e,0x801f1f1f,
+0x801e1e1e,0x80212121,0x801c1c1c,0x80161616,0x80181818,0x80191919,
+0x80181818,0x80181818,0x801d1d1d,0x801f1f1f,0x80202020,0x801f1f1f,
+0x801f1f1f,0x801e1e1e,0x801b1b1b,0x80161616,0x80181818,0x80161616,
+0x80171717,0x801b1b1b,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801f1f1f,
+0x801d1d1d,0x801a1a1a,0x80181818,0x80181818,0x80181818,0x80171717,
+0x80181818,0x801c1c1c,0x801f1f1f,0x80202020,0x80202020,0x801f1f1f,
+0x801b1b1b,0x80181818,0x80191919,0x80171717,0x80181818,0x80191919,
+0x801c1c1c,0x801f1f1f,0x80202020,0x801f1f1f,0x801f1f1f,0x80202020,
+0x80181818,0x80191919,0x80191919,0x80171717,0x80181818,0x801b1b1b,
+0x801e1e1e,0x801f1f1f,0x80202020,0x80202020,0x801c1c1c,0x80191919,
+0x80191919,0x80181818,0x80161616,0x80181818,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801b1b1b,0x80181818,0x80191919,
+0x80181818,0x80181818,0x801b1b1b,0x801e1e1e,0x801f1f1f,0x801e1e1e,
+0x801e1e1e,0x801f1f1f,0x801d1d1d,0x80171717,0x80171717,0x80171717,
+0x801a1a1a,0x801a1a1a,0x801c1c1c,0x801f1f1f,0x801b1b1b,0x801e1e1e,
+0x80202020,0x801c1c1c,0x80181818,0x80171717,0x80171717,0x80181818,
+0x80191919,0x801d1d1d,0x80202020,0x801d1d1d,0x801e1e1e,0x801e1e1e,
+0x801f1f1f,0x801d1d1d,0x80191919,0x80181818,0x80161616,0x80171717,
+0x801a1a1a,0x801e1e1e,0x801e1e1e,0x801d1d1d,0x80212121,0x801f1f1f,
+0x801b1b1b,0x80161616,0x80161616,0x80191919,0x80191919,0x80171717,
+0x801e1e1e,0x801d1d1d,0x801f1f1f,0x80212121,0x801f1f1f,0x801a1a1a,
+0x80181818,0x80191919,0x80191919,0x80171717,0x80181818,0x801c1c1c,
+0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801f1f1f,0x801d1d1d,0x801a1a1a,
+0x80181818,0x80181818,0x80171717,0x80181818,0x801a1a1a,0x801b1b1b,
+0x801e1e1e,0x801f1f1f,0x80202020,0x801f1f1f,0x801b1b1b,0x80171717,
+0x80181818,0x801a1a1a,0x80171717,0x801b1b1b,0x801e1e1e,0x801e1e1e,
+0x801f1f1f,0x80202020,0x801f1f1f,0x801b1b1b,0x801b1b1b,0x801a1a1a,
+0x80151515,0x80181818,0x801b1b1b,0x801c1c1c,0x80202020,0x801d1d1d,
+0x80202020,0x801e1e1e,0x801b1b1b,0x80191919,0x80171717,0x80181818,
+0x801a1a1a,0x80171717,0x801b1b1b,0x801e1e1e,0x801d1d1d,0x801c1c1c,
+0x801f1f1f,0x801e1e1e,0x801a1a1a,0x80171717,0x80191919,0x80191919,
+0x80181818,0x801a1a1a,0x801c1c1c,0x80202020,0x801f1f1f,0x801d1d1d,
+0x801f1f1f,0x801c1c1c,0x80181818,0x80171717,0x80191919,0x80191919,
+0x80181818,0x801b1b1b,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801d1d1d,
+0x801d1d1d,0x801b1b1b,0x801a1a1a,0x80181818,0x80171717,0x80181818,
+0x801b1b1b,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801f1f1f,
+0x801c1c1c,0x80181818,0x801a1a1a,0x801a1a1a,0x80181818,0x80191919,
+0x801d1d1d,0x80202020,0x801d1d1d,0x80202020,0x801f1f1f,0x801c1c1c,
+0x80181818,0x80161616,0x80181818,0x801a1a1a,0x80181818,0x801d1d1d,
+0x801e1e1e,0x801f1f1f,0x801d1d1d,0x80202020,0x801c1c1c,0x80181818,
+0x80191919,0x80181818,0x80171717,0x80181818,0x801b1b1b,0x801e1e1e,
+0x801f1f1f,0x801d1d1d,0x801e1e1e,0x801f1f1f,0x801d1d1d,0x80191919,
+0x80161616,0x80161616,0x801a1a1a,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801a1a1a,0x80171717,0x80171717,0x80171717,
+0x80171717,0x801b1b1b,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801f1f1f,
+0x801d1d1d,0x801b1b1b,0x80171717,0x80161616,0x801a1a1a,0x80171717,
+0x801a1a1a,0x801b1b1b,0x801d1d1d,0x80212121,0x80212121,0x80202020,
+0x801c1c1c,0x80181818,0x80171717,0x80191919,0x80191919,0x80171717,
+0x801c1c1c,0x801d1d1d,0x801f1f1f,0x801b1b1b,0x801e1e1e,0x801d1d1d,
+0x801c1c1c,0x80151515,0x80191919,0x80171717,0x80171717,0x801a1a1a,
+0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x80212121,0x801a1a1a,
+0x80171717,0x801a1a1a,0x801a1a1a,0x80171717,0x80181818,0x801d1d1d,
+0x80202020,0x801f1f1f,0x801e1e1e,0x801f1f1f,0x801d1d1d,0x80191919,
+0x80171717,0x80181818,0x80181818,0x80181818,0x801b1b1b,0x801f1f1f,
+0x80202020,0x801e1e1e,0x801d1d1d,0x801e1e1e,0x80191919,0x80181818,
+0x80191919,0x80191919,0x80161616,0x80191919,0x801f1f1f,0x80232323,
+0x801d1d1d,0x801e1e1e,0x801e1e1e,0x801b1b1b,0x80181818,0x80171717,
+0x80171717,0x80181818,0x801a1a1a,0x801d1d1d,0x80202020,0x801f1f1f,
+0x801f1f1f,0x801f1f1f,0x801c1c1c,0x80191919,0x80181818,0x80191919,
+0x80181818,0x80191919,0x801d1d1d,0x801d1d1d,0x801e1e1e,0x801e1e1e,
+0x80212121,0x801e1e1e,0x80191919,0x80181818,0x80181818,0x80171717,
+0x801a1a1a,0x80191919,0x801f1f1f,0x801e1e1e,0x801c1c1c,0x801f1f1f,
+0x80212121,0x801a1a1a,0x80151515,0x801a1a1a,0x80171717,0x80181818,
+0x801b1b1b,0x801d1d1d,0x801f1f1f,0x801e1e1e,0x80202020,0x80202020,
+0x801b1b1b,0x80191919,0x801a1a1a,0x801a1a1a,0x80171717,0x80181818,
+0x801d1d1d,0x80202020,0x80202020,0x80202020,0x801f1f1f,0x801d1d1d,
+0x80191919,0x80151515,0x80171717,0x801b1b1b,0x80181818,0x801b1b1b,
+0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801f1f1f,0x801d1d1d,0x801c1c1c,
+0x801b1b1b,0x80141414,0x80171717,0x80171717,0x80161616,0x801c1c1c,
+0x801f1f1f,0x801e1e1e,0x801f1f1f,0x80212121,0x801c1c1c,0x80181818,
+0x801a1a1a,0x801a1a1a,0x80171717,0x80191919,0x801d1d1d,0x801f1f1f,
+0x801d1d1d,0x801f1f1f,0x801e1e1e,0x80212121,0x801b1b1b,0x80161616,
+0x80191919,0x80181818,0x80181818,0x801b1b1b,0x801f1f1f,0x801f1f1f,
+0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801a1a1a,0x80181818,0x80181818,
+0x80161616,0x80181818,0x801c1c1c,0x801c1c1c,0x80202020,0x801a1a1a,0x80131313,0x80141414,0x80171717,0x80151515,
+0x801a1a1a,0x801c1c1c,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801f1f1f,
+0x801b1b1b,0x80171717,0x80191919,0x80141414,0x80171717,0x80131313,
+0x801c1c1c,0x801f1f1f,0x801d1d1d,0x80191919,0x80191919,0x80191919,
+0x801a1a1a,0x801a1a1a,0x80191919,0x80171717,0x80181818,0x801b1b1b,
+0x80202020,0x801f1f1f,0x80212121,0x801b1b1b,0x80191919,0x80141414,
+0x80181818,0x80171717,0x80171717,0x80181818,0x801a1a1a,0x801e1e1e,
+0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x80191919,0x80181818,
+0x80161616,0x80141414,0x80131313,0x80161616,0x801b1b1b,0x801f1f1f,
+0x801f1f1f,0x80202020,0x801f1f1f,0x801a1a1a,0x80191919,0x80191919,
+0x80191919,0x80171717,0x80171717,0x801c1c1c,0x801f1f1f,0x801f1f1f,
+0x801e1e1e,0x801e1e1e,0x801d1d1d,0x801a1a1a,0x80181818,0x80161616,
+0x80181818,0x801a1a1a,0x801b1b1b,0x801e1e1e,0x801d1d1d,0x80171717,
+0x801b1b1b,0x801a1a1a,0x80171717,0x80161616,0x80171717,0x80191919,
+0x80191919,0x80161616,0x801e1e1e,0x801d1d1d,0x801f1f1f,0x80202020,
+0x801f1f1f,0x801a1a1a,0x80181818,0x80191919,0x80181818,0x80161616,
+0x80161616,0x80151515,0x801d1d1d,0x80202020,0x80191919,0x801b1b1b,
+0x80161616,0x801b1b1b,0x80171717,0x80181818,0x80181818,0x80171717,
+0x801c1c1c,0x801d1d1d,0x801d1d1d,0x801f1f1f,0x801e1e1e,0x80181818,
+0x80111111,0x80141414,0x80191919,0x80191919,0x801b1b1b,0x80151515,
+0x80161616,0x801b1b1b,0x80222222,0x801f1f1f,0x801d1d1d,0x801c1c1c,
+0x80191919,0x80191919,0x801a1a1a,0x80181818,0x80171717,0x801d1d1d,
+0x80202020,0x801a1a1a,0x80151515,0x80131313,0x80131313,0x80171717,
+0x80191919,0x80181818,0x80171717,0x80171717,0x801c1c1c,0x801e1e1e,
+0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801b1b1b,0x80171717,
+0x80151515,0x800f0f0f,0x80121212,0x80161616,0x801e1e1e,0x80232323,
+0x801a1a1a,0x80131313,0x80151515,0x801a1a1a,0x801b1b1b,0x80171717,
+0x80191919,0x80191919,0x80171717,0x801b1b1b,0x801e1e1e,0x801f1f1f,
+0x801e1e1e,0x80212121,0x80171717,0x80141414,0x80131313,0x801b1b1b,
+0x80171717,0x80181818,0x801b1b1b,0x801e1e1e,0x801f1f1f,0x801e1e1e,
+0x801e1e1e,0x801f1f1f,0x801c1c1c,0x80171717,0x80161616,0x80181818,
+0x80161616,0x80161616,0x801a1a1a,0x801d1d1d,0x80171717,0x800a0a0a,0x80030303,0x80020202,0x80010101,0x80000000,
+0x801c1c1c,0x801d1d1d,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801c1c1c,
+0x80191919,0x80161616,0x80191919,0x80040404,0x80000000,0x80000000,
+0x80181818,0x801f1f1f,0x80121212,0x80000000,0x80020202,0x800c0c0c,
+0x80161616,0x801a1a1a,0x80171717,0x80161616,0x801b1b1b,0x801f1f1f,
+0x801f1f1f,0x801d1d1d,0x801c1c1c,0x800a0a0a,0x80020202,0x80010101,
+0x80121212,0x801a1a1a,0x80181818,0x801b1b1b,0x801d1d1d,0x801e1e1e,
+0x801e1e1e,0x801e1e1e,0x801d1d1d,0x801c1c1c,0x80161616,0x80191919,
+0x800f0f0f,0x80000000,0x80000000,0x80101010,0x801e1e1e,0x801f1f1f,
+0x801e1e1e,0x801f1f1f,0x801c1c1c,0x80181818,0x80171717,0x80191919,
+0x80191919,0x80181818,0x801b1b1b,0x801e1e1e,0x80202020,0x801e1e1e,
+0x801d1d1d,0x801d1d1d,0x801b1b1b,0x80171717,0x80191919,0x80161616,
+0x80171717,0x801a1a1a,0x801d1d1d,0x801e1e1e,0x80121212,0x80000000,
+0x80000000,0x80000000,0x80000000,0x80040404,0x800b0b0b,0x80131313,
+0x801b1b1b,0x80202020,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801f1f1f,
+0x801c1c1c,0x80181818,0x80171717,0x80191919,0x80191919,0x800a0a0a,
+0x80000000,0x80000000,0x80151515,0x801c1c1c,0x80050505,0x80000000,
+0x80090909,0x80171717,0x80171717,0x80161616,0x80191919,0x80191919,
+0x801e1e1e,0x801f1f1f,0x801d1d1d,0x80202020,0x80161616,0x80020202,
+0x80000000,0x80060606,0x80131313,0x80181818,0x800e0e0e,0x80000000,
+0x80000000,0x800c0c0c,0x801e1e1e,0x801e1e1e,0x801b1b1b,0x80181818,
+0x80191919,0x80181818,0x80171717,0x80181818,0x801d1d1d,0x801f1f1f,
+0x80171717,0x800a0a0a,0x80010101,0x80000000,0x80000000,0x80060606,
+0x80111111,0x80191919,0x801b1b1b,0x80181818,0x801e1e1e,0x801e1e1e,
+0x801e1e1e,0x801e1e1e,0x801d1d1d,0x801b1b1b,0x80181818,0x80151515,
+0x80050505,0x80020202,0x80030303,0x800b0b0b,0x801c1c1c,0x801c1c1c,
+0x80070707,0x80010101,0x80030303,0x800a0a0a,0x80171717,0x80191919,
+0x80161616,0x801a1a1a,0x801d1d1d,0x80212121,0x801d1d1d,0x80202020,
+0x801f1f1f,0x801c1c1c,0x80070707,0x80000000,0x80040404,0x80151515,
+0x80181818,0x801b1b1b,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801e1e1e,
+0x801d1d1d,0x801c1c1c,0x80171717,0x80181818,0x80141414,0x800c0c0c,
+0x80030303,0x80000000,0x80020202,0x80121212,0x80090909,0x80000000,0x80000000,0x80000000,0x80000000,0x80020202,
+0x801c1c1c,0x801d1d1d,0x801f1f1f,0x801f1f1f,0x801c1c1c,0x80171717,
+0x80171717,0x80191919,0x80191919,0x80040404,0x80000000,0x80010101,
+0x80191919,0x801e1e1e,0x80111111,0x80020202,0x80000000,0x800d0d0d,
+0x80181818,0x80181818,0x80171717,0x801c1c1c,0x801f1f1f,0x801e1e1e,
+0x801d1d1d,0x80202020,0x801e1e1e,0x80060606,0x80000000,0x80010101,
+0x80131313,0x80161616,0x801a1a1a,0x801d1d1d,0x801e1e1e,0x801d1d1d,
+0x801e1e1e,0x801f1f1f,0x801c1c1c,0x80171717,0x80191919,0x80181818,
+0x800e0e0e,0x80000000,0x80010101,0x80101010,0x801c1c1c,0x801e1e1e,
+0x80202020,0x801c1c1c,0x80191919,0x80191919,0x80181818,0x80171717,
+0x80181818,0x801a1a1a,0x80202020,0x801e1e1e,0x801e1e1e,0x801f1f1f,
+0x801e1e1e,0x801a1a1a,0x80171717,0x80171717,0x80171717,0x80181818,
+0x801b1b1b,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x80131313,0x80010101,
+0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80040404,
+0x80121212,0x801f1f1f,0x801d1d1d,0x80202020,0x801f1f1f,0x801b1b1b,
+0x80191919,0x80191919,0x80191919,0x80181818,0x80191919,0x800b0b0b,
+0x80020202,0x80000000,0x80131313,0x801b1b1b,0x80010101,0x80000000,
+0x80040404,0x80181818,0x80191919,0x80171717,0x801c1c1c,0x801d1d1d,
+0x801f1f1f,0x801d1d1d,0x801f1f1f,0x801f1f1f,0x800f0f0f,0x80020202,
+0x80020202,0x80000000,0x80060606,0x80191919,0x80121212,0x80010101,
+0x80000000,0x800d0d0d,0x801f1f1f,0x801c1c1c,0x801a1a1a,0x80181818,
+0x80171717,0x80181818,0x80181818,0x801c1c1c,0x80212121,0x80191919,
+0x80090909,0x80000000,0x80000000,0x80020202,0x80000000,0x80000000,
+0x80040404,0x80111111,0x801c1c1c,0x801f1f1f,0x801e1e1e,0x801e1e1e,
+0x801f1f1f,0x801f1f1f,0x801c1c1c,0x80171717,0x80151515,0x80161616,
+0x80010101,0x80000000,0x80000000,0x80040404,0x801b1b1b,0x80181818,
+0x80000000,0x80000000,0x80000000,0x80040404,0x80161616,0x801c1c1c,
+0x80171717,0x801c1c1c,0x80202020,0x801d1d1d,0x801d1d1d,0x80212121,
+0x801c1c1c,0x80161616,0x80010101,0x80000000,0x80040404,0x80141414,
+0x801b1b1b,0x801e1e1e,0x801f1f1f,0x801d1d1d,0x801e1e1e,0x801f1f1f,
+0x801c1c1c,0x80171717,0x80181818,0x80131313,0x80030303,0x80000000,
+0x80020202,0x80000000,0x80010101,0x80121212,0x80000000,0x80000000,0x80000000,0x80090909,0x800a0a0a,0x800c0c0c,
+0x801c1c1c,0x801f1f1f,0x801f1f1f,0x801a1a1a,0x80171717,0x80181818,
+0x80191919,0x80181818,0x80191919,0x80050505,0x80010101,0x80010101,
+0x801a1a1a,0x801f1f1f,0x800e0e0e,0x80010101,0x80000000,0x800d0d0d,
+0x80181818,0x80171717,0x801a1a1a,0x801f1f1f,0x801e1e1e,0x801f1f1f,
+0x80202020,0x801d1d1d,0x80191919,0x80070707,0x80000000,0x80020202,
+0x80121212,0x801c1c1c,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x80202020,
+0x801f1f1f,0x801c1c1c,0x80181818,0x80171717,0x80171717,0x80181818,
+0x800e0e0e,0x80000000,0x80000000,0x800e0e0e,0x80202020,0x801f1f1f,
+0x801c1c1c,0x80171717,0x80191919,0x801a1a1a,0x80161616,0x80161616,
+0x801c1c1c,0x80202020,0x801d1d1d,0x80202020,0x80202020,0x801c1c1c,
+0x80191919,0x80181818,0x80181818,0x80171717,0x80171717,0x801b1b1b,
+0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801f1f1f,0x80141414,0x80010101,
+0x80010101,0x80020202,0x80090909,0x80000000,0x80000000,0x80010101,
+0x80030303,0x801a1a1a,0x801e1e1e,0x801e1e1e,0x801c1c1c,0x80181818,
+0x80181818,0x801a1a1a,0x80191919,0x80171717,0x801d1d1d,0x800c0c0c,
+0x80000000,0x80000000,0x80131313,0x801d1d1d,0x80030303,0x80000000,
+0x80070707,0x80161616,0x80171717,0x801a1a1a,0x80202020,0x801e1e1e,
+0x801f1f1f,0x801e1e1e,0x80202020,0x80191919,0x800e0e0e,0x80010101,
+0x80000000,0x80010101,0x80020202,0x80171717,0x80161616,0x80010101,
+0x80010101,0x800d0d0d,0x801b1b1b,0x801b191a,0x80191718,0x801a1819,
+0x80181818,0x80191919,0x801d1d1d,0x801f1f1f,0x801f1f1f,0x80121212,
+0x80010101,0x80000000,0x80040404,0x800d0d0d,0x80080808,0x80000000,
+0x80000000,0x800f0f0f,0x801f1f1f,0x801d1d1d,0x801e1e1e,0x801f1f1f,
+0x80202020,0x80191919,0x80181818,0x80181818,0x801a1a1a,0x80121212,
+0x80000000,0x80010101,0x80000000,0x80000000,0x801a1a1a,0x80111111,
+0x80020202,0x80000000,0x80020202,0x80000000,0x80141414,0x801a1a1a,
+0x801d1d1d,0x801f1f1f,0x80202020,0x801e1e1e,0x80202020,0x801e1e1e,
+0x801a1a1a,0x80171717,0x80020202,0x80000000,0x80020202,0x80191919,
+0x801d1d1d,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801c1c1c,0x801a1a1a,
+0x80191919,0x80181818,0x80181818,0x80040404,0x80000000,0x80010101,
+0x80000000,0x80080808,0x800c0c0c,0x80161616,0x80020202,0x80020202,0x80090909,0x801c1c1c,0x801f1f1f,0x80202020,
+0x801f1f1f,0x801e1e1e,0x801b1b1b,0x80191919,0x80181818,0x80191919,
+0x80191919,0x80181818,0x801d1d1d,0x80060606,0x80010101,0x80010101,
+0x80191919,0x801e1e1e,0x800e0e0e,0x80000000,0x80000000,0x800a0a0a,
+0x80181818,0x801d1d1d,0x801e1e1e,0x801f1f1f,0x801d1d1d,0x80202020,
+0x801e1e1e,0x801c1c1c,0x80181818,0x80060606,0x80000000,0x80000000,
+0x80141414,0x801c1c1c,0x801d1d1d,0x801f1f1f,0x80202020,0x801e1e1e,
+0x801b1b1b,0x80181818,0x80181818,0x80191919,0x80191919,0x801b1b1b,
+0x80111111,0x80000000,0x80010101,0x800e0e0e,0x801d1d1d,0x801b1b1b,
+0x80191919,0x801a1a1a,0x80191919,0x80161616,0x80181818,0x801e1e1e,
+0x80202020,0x801e1e1e,0x80202020,0x801e1e1e,0x801c1c1c,0x801a1a1a,
+0x80191919,0x80181818,0x80181818,0x80181818,0x801b1b1b,0x801c1c1c,
+0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x80121212,0x80000000,
+0x80000000,0x800b0b0b,0x80161616,0x80121212,0x80080808,0x80000000,
+0x80000000,0x80101010,0x801e1e1e,0x801b1b1b,0x80191919,0x80191919,
+0x80191919,0x80171717,0x80181818,0x801b1b1b,0x80202020,0x800e0e0e,
+0x80000000,0x80030303,0x80121212,0x80161616,0x80020202,0x80020202,
+0x80040404,0x80171717,0x801c1c1c,0x801d1d1d,0x801f1f1f,0x801d1d1d,
+0x801f1f1f,0x801e1e1e,0x801a1a1a,0x801a1a1a,0x800f0f0f,0x80000000,
+0x80000000,0x80010101,0x80000000,0x800c0c0c,0x80151515,0x80010101,
+0x80000000,0x800b0b0b,0x80191919,0x801b191a,0x80191718,0x80191718,
+0x801a1a1a,0x801b1b1b,0x801e1e1e,0x801f1f1f,0x801f1f1f,0x80121212,
+0x80010101,0x80000000,0x800a0a0a,0x80181818,0x800e0e0e,0x80000000,
+0x80000000,0x800e0e0e,0x801d1d1d,0x801f1f1f,0x80202020,0x801d1d1d,
+0x801b1b1b,0x80181818,0x80191919,0x80181818,0x80191919,0x800f0f0f,
+0x80000000,0x80020202,0x80040404,0x80000000,0x80161616,0x800e0e0e,
+0x80010101,0x80040404,0x80000000,0x80000000,0x80151515,0x801c1c1c,
+0x801d1d1d,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801b1b1b,
+0x80181818,0x80161616,0x80020202,0x80010101,0x80030303,0x801b1b1b,
+0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801b1b1b,0x80191919,
+0x80181818,0x80181818,0x800f0f0f,0x80010101,0x80000000,0x80050505,
+0x80151515,0x80212121,0x801e1e1e,0x801b1b1b,0x80010101,0x80000000,0x80010101,0x800e0e0e,0x800e0e0e,0x800e0e0e,
+0x801e1e1e,0x801b1b1b,0x80181818,0x80181818,0x80181818,0x80181818,
+0x80191919,0x801b1b1b,0x801f1f1f,0x80070707,0x80010101,0x80020202,
+0x80151515,0x801b1b1b,0x800d0d0d,0x80000000,0x80010101,0x800b0b0b,
+0x801a1a1a,0x80202020,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801f1f1f,
+0x80191919,0x80181818,0x80181818,0x80060606,0x80010101,0x80000000,
+0x801a1a1a,0x80202020,0x801d1d1d,0x801f1f1f,0x801f1f1f,0x801b1b1b,
+0x80181818,0x80171717,0x80181818,0x80191919,0x80181818,0x801c1c1c,
+0x80121212,0x80000000,0x80010101,0x800e0e0e,0x801d1d1d,0x801a1a1a,
+0x80171717,0x801b1b1b,0x80191919,0x80171717,0x801b1b1b,0x80202020,
+0x80202020,0x801d1d1d,0x80202020,0x801c1c1c,0x80181818,0x80181818,
+0x80181818,0x80181818,0x80191919,0x801b1b1b,0x801f1f1f,0x801d1d1d,
+0x801f1f1f,0x80202020,0x801e1e1e,0x801b1b1b,0x800f0f0f,0x80000000,
+0x80000000,0x800d0d0d,0x801a1a1a,0x801d1d1d,0x80111111,0x80010101,
+0x80000000,0x80070707,0x801c1c1c,0x80191919,0x80181818,0x80181818,
+0x80181818,0x80181818,0x801a1a1a,0x801e1e1e,0x801e1e1e,0x800f0f0f,
+0x80000000,0x80000000,0x800a0a0a,0x800c0c0c,0x80000000,0x80010101,
+0x80050505,0x801a1a1a,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801c1c1c,
+0x801e1e1e,0x801c1c1c,0x80171717,0x80191919,0x80101010,0x80000000,
+0x80000000,0x80020202,0x80000000,0x80030303,0x800d0d0d,0x80000000,
+0x80000000,0x800a0a0a,0x80171717,0x801a1819,0x80191718,0x80191718,
+0x801c1c1c,0x801d1d1d,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x80111111,
+0x80010101,0x80000000,0x800b0b0b,0x80131313,0x800b0b0b,0x80000000,
+0x80000000,0x800c0c0c,0x801d1d1d,0x80202020,0x801f1f1f,0x801a1a1a,
+0x80171717,0x80171717,0x80191919,0x80191919,0x80191919,0x800e0e0e,
+0x80000000,0x80030303,0x800b0b0b,0x80000000,0x800e0e0e,0x80080808,
+0x80000000,0x800a0a0a,0x80000000,0x80000000,0x80151515,0x801e1e1e,
+0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801d1d1d,0x801a1a1a,0x80181818,
+0x80171717,0x80171717,0x80020202,0x80000000,0x80040404,0x801c1c1c,
+0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801b1b1b,0x80191919,0x80171717,
+0x80171717,0x80181818,0x800d0d0d,0x80030303,0x80010101,0x80080808,
+0x801d1d1d,0x801e1e1e,0x801a1a1a,0x80151515,0x80010101,0x80010101,0x80000000,0x80010101,0x80000000,0x80020202,
+0x80181818,0x80181818,0x80181818,0x80181818,0x80181818,0x80191919,
+0x801c1c1c,0x801f1f1f,0x801e1e1e,0x80070707,0x80010101,0x80030303,
+0x80131313,0x80191919,0x800e0e0e,0x80000000,0x80000000,0x80101010,
+0x801e1e1e,0x801f1f1f,0x801c1c1c,0x801f1f1f,0x801f1f1f,0x801a1a1a,
+0x80181818,0x80171717,0x80191919,0x80060606,0x80000000,0x80000000,
+0x80191919,0x801c1c1c,0x80202020,0x801e1e1e,0x801b1b1b,0x80191919,
+0x80181818,0x80181818,0x80181818,0x80191919,0x801c1c1c,0x801f1f1f,
+0x80131313,0x80000000,0x80000000,0x800c0c0c,0x801a1a1a,0x80171717,
+0x80181818,0x80181818,0x80181818,0x801c1c1c,0x801e1e1e,0x801d1d1d,
+0x801e1e1e,0x801f1f1f,0x801c1c1c,0x801a1a1a,0x80181818,0x80171717,
+0x80171717,0x80181818,0x801b1b1b,0x801e1e1e,0x801e1e1e,0x801e1e1e,
+0x80202020,0x801f1f1f,0x801b1b1b,0x80181818,0x800f0f0f,0x80010101,
+0x80000000,0x800c0c0c,0x801b1b1b,0x80202020,0x80151515,0x80050505,
+0x80010101,0x80050505,0x80181818,0x80191919,0x80181818,0x80171717,
+0x80181818,0x801c1c1c,0x801f1f1f,0x801e1e1e,0x801d1d1d,0x80141414,
+0x80010101,0x80000000,0x80000000,0x80030303,0x80000000,0x80000000,
+0x800f0f0f,0x801c1c1c,0x801f1f1f,0x801f1f1f,0x801f1f1f,0x801d1d1d,
+0x801b1b1b,0x80181818,0x801a1a1a,0x80181818,0x800f0f0f,0x80010101,
+0x80020202,0x80050505,0x80040404,0x80000000,0x80030303,0x80000000,
+0x80020202,0x800b0b0b,0x80171717,0x80191718,0x801b191a,0x801d1b1c,
+0x801f1f1f,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801c1c1c,0x800f0f0f,
+0x80000000,0x80000000,0x80070707,0x80010101,0x80000000,0x80020202,
+0x80000000,0x800b0b0b,0x80202020,0x801d1d1d,0x801a1a1a,0x80191919,
+0x80171717,0x80171717,0x80191919,0x80191919,0x801b1b1b,0x800d0d0d,
+0x80010101,0x80040404,0x80111111,0x80000000,0x80070707,0x80040404,
+0x80000000,0x800f0f0f,0x80000000,0x80000000,0x80121212,0x801f1f1f,
+0x80202020,0x801f1f1f,0x801d1d1d,0x80191919,0x80191919,0x80171717,
+0x80171717,0x80181818,0x80020202,0x80000000,0x80030303,0x801c1c1c,
+0x801e1e1e,0x801d1d1d,0x801b1b1b,0x80181818,0x80171717,0x80171717,
+0x80181818,0x801a1a1a,0x800c0c0c,0x80000000,0x80020202,0x800e0e0e,
+0x80212121,0x80181818,0x80191919,0x801a1a1a,0x80010101,0x80000000,0x80000000,0x80030303,0x80000000,0x80030303,
+0x80151515,0x80171717,0x80181818,0x80181818,0x80191919,0x801c1c1c,
+0x801f1f1f,0x80202020,0x801e1e1e,0x80070707,0x80000000,0x80030303,
+0x80131313,0x80191919,0x800e0e0e,0x80010101,0x80000000,0x80111111,
+0x801e1e1e,0x801f1f1f,0x801c1c1c,0x801d1d1d,0x801c1c1c,0x80171717,
+0x80191919,0x80181818,0x801a1a1a,0x80070707,0x80000000,0x80000000,
+0x801b1b1b,0x801e1e1e,0x80212121,0x801c1c1c,0x80181818,0x80181818,
+0x80191919,0x80181818,0x80191919,0x801c1c1c,0x801e1e1e,0x80202020,
+0x80121212,0x80000000,0x80000000,0x800b0b0b,0x80191919,0x80191919,
+0x80181818,0x80181818,0x801a1a1a,0x80202020,0x801f1f1f,0x801c1c1c,
+0x801f1f1f,0x801e1e1e,0x80191919,0x80191919,0x80181818,0x80171717,
+0x80181818,0x801b1b1b,0x801e1e1e,0x801f1f1f,0x801e1e1e,0x801e1e1e,
+0x801f1f1f,0x801c1c1c,0x80181818,0x80171717,0x800f0f0f,0x80000000,
+0x80000000,0x800d0d0d,0x80222222,0x80222222,0x80121212,0x80030303,
+0x80000000,0x80070707,0x80181818,0x80191919,0x80181818,0x80181818,
+0x801b1b1b,0x80202020,0x80202020,0x801e1e1e,0x80212121,0x801c1c1c,
+0x800c0c0c,0x80040404,0x80000000,0x80000000,0x80030303,0x80080808,
+0x801a1a1a,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801b1b1b,
+0x80181818,0x80171717,0x801b1b1b,0x80181818,0x80101010,0x80010101,
+0x80010101,0x800b0b0b,0x80101010,0x80000000,0x80000000,0x80000000,
+0x80020202,0x800a0a0a,0x80181818,0x801b191a,0x801d1b1c,0x80201e1f,
+0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801c1c1c,0x801b1b1b,0x800e0e0e,
+0x80000000,0x80000000,0x80060606,0x80010101,0x80000000,0x80010101,
+0x80000000,0x800c0c0c,0x801e1e1e,0x801b1b1b,0x80171717,0x80191919,
+0x80181818,0x80181818,0x801a1a1a,0x801c1c1c,0x801d1d1d,0x800a0a0a,
+0x80020202,0x80040404,0x80151515,0x80010101,0x80020202,0x80010101,
+0x80030303,0x80141414,0x80010101,0x80010101,0x80101010,0x801f1f1f,
+0x801f1f1f,0x801e1e1e,0x801b1b1b,0x80171717,0x80191919,0x80171717,
+0x80191919,0x801a1a1a,0x80030303,0x80000000,0x80040404,0x801b1b1b,
+0x801c1c1c,0x801b1b1b,0x80191919,0x80171717,0x80161616,0x80181818,
+0x801b1b1b,0x801d1d1d,0x80101010,0x80000000,0x80000000,0x800b0b0b,
+0x801e1e1e,0x80161616,0x80191919,0x80151515,0x80030303,0x80000000,0x80070707,0x80161616,0x80141414,0x80131313,
+0x80171717,0x80181818,0x80181818,0x80191919,0x801c1c1c,0x801f1f1f,
+0x801f1f1f,0x801d1d1d,0x801e1e1e,0x80090909,0x80000000,0x80020202,
+0x80111111,0x80171717,0x800c0c0c,0x80000000,0x80000000,0x80101010,
+0x801c1c1c,0x80202020,0x801e1e1e,0x80191919,0x80181818,0x80181818,
+0x80181818,0x80181818,0x80191919,0x80080808,0x80000000,0x80030303,
+0x80171717,0x801e1e1e,0x80191919,0x80181818,0x80171717,0x80181818,
+0x80181818,0x80181818,0x801c1c1c,0x80202020,0x801d1d1d,0x801e1e1e,
+0x80111111,0x80000000,0x80010101,0x800a0a0a,0x80161616,0x80171717,
+0x80161616,0x801d1d1d,0x801e1e1e,0x80202020,0x801f1f1f,0x801e1e1e,
+0x801f1f1f,0x80181818,0x80181818,0x80181818,0x80181818,0x80181818,
+0x801b1b1b,0x801f1f1f,0x80202020,0x801d1d1d,0x801f1f1f,0x801d1d1d,
+0x801b1b1b,0x80181818,0x80171717,0x80181818,0x800f0f0f,0x80000000,
+0x80010101,0x800d0d0d,0x801e1e1e,0x80171717,0x80090909,0x80000000,
+0x80000000,0x800b0b0b,0x801a1a1a,0x80171717,0x80181818,0x801c1c1c,
+0x80202020,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801c1c1c,
+0x80141414,0x800e0e0e,0x80010101,0x80000000,0x80090909,0x801b1b1b,
+0x801f1f1f,0x80202020,0x801f1f1f,0x801d1d1d,0x801b1b1b,0x80181818,
+0x80171717,0x80191919,0x80181818,0x801a1a1a,0x80131313,0x80000000,
+0x80000000,0x80101010,0x801a1a1a,0x80020202,0x80010101,0x80000000,
+0x80000000,0x80080808,0x801a1a1a,0x801d1b1c,0x801f1d1e,0x80201e1f,
+0x801f1f1f,0x801e1e1e,0x801c1c1c,0x801a1a1a,0x80191919,0x800e0e0e,
+0x80000000,0x80000000,0x800c0c0c,0x80161616,0x800c0c0c,0x80000000,
+0x80010101,0x800d0d0d,0x80191919,0x80191919,0x80171717,0x80191919,
+0x80181818,0x80191919,0x801d1d1d,0x80202020,0x801f1f1f,0x80060606,
+0x80020202,0x80040404,0x80171717,0x80030303,0x80000000,0x80010101,
+0x80080808,0x80181818,0x80010101,0x80010101,0x800f0f0f,0x801f1f1f,
+0x801c1c1c,0x801a1a1a,0x80191919,0x80181818,0x80181818,0x80181818,
+0x801c1c1c,0x801b1b1b,0x80030303,0x80010101,0x80050505,0x801b1b1b,
+0x801a1a1a,0x80191919,0x80171717,0x80171717,0x80181818,0x801b1b1b,
+0x801e1e1e,0x801f1f1f,0x80151515,0x80030303,0x80000000,0x80040404,
+0x80131313,0x80161616,0x801a1a1a,0x80171717,0x80030303,0x80000000,0x80080808,0x801a1a1a,0x80191919,0x80171717,
+0x80191919,0x80181818,0x80191919,0x801c1c1c,0x801f1f1f,0x801f1f1f,
+0x801f1f1f,0x801e1e1e,0x801d1d1d,0x800c0c0c,0x80000000,0x80000000,
+0x80090909,0x800c0c0c,0x80040404,0x80000000,0x80010101,0x80141414,
+0x801d1d1d,0x801e1e1e,0x801d1d1d,0x80171717,0x80171717,0x80181818,
+0x80181818,0x801a1a1a,0x801b1b1b,0x800b0b0b,0x80000000,0x80000000,
+0x80060606,0x800c0c0c,0x800b0b0b,0x80111111,0x80171717,0x80191919,
+0x80191919,0x801b1b1b,0x801e1e1e,0x80212121,0x801f1f1f,0x80202020,
+0x80121212,0x80010101,0x80010101,0x80030303,0x800a0a0a,0x800a0a0a,
+0x800e0e0e,0x80202020,0x80202020,0x801e1e1e,0x801f1f1f,0x801c1c1c,
+0x801a1a1a,0x80161616,0x80181818,0x80181818,0x80191919,0x801b1b1b,
+0x801e1e1e,0x80202020,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801a1a1a,
+0x80181818,0x80181818,0x80191919,0x80191919,0x800f0f0f,0x80000000,
+0x80020202,0x800c0c0c,0x800d0d0d,0x80060606,0x80010101,0x80000000,
+0x80060606,0x80121212,0x80191919,0x80181818,0x801a1a1a,0x801f1f1f,
+0x80202020,0x801e1e1e,0x801d1d1d,0x801e1e1e,0x80181818,0x80181818,
+0x80171717,0x80111111,0x80010101,0x80000000,0x800c0c0c,0x80222222,
+0x801f1f1f,0x801f1f1f,0x801d1d1d,0x801a1a1a,0x80181818,0x80171717,
+0x80171717,0x801a1a1a,0x80191919,0x801e1e1e,0x80141414,0x80000000,
+0x80000000,0x800e0e0e,0x801c1c1c,0x800b0b0b,0x80020202,0x80010101,
+0x80000000,0x80090909,0x801d1d1d,0x801f1d1e,0x801f1d1e,0x801f1d1e,
+0x801f1f1f,0x801c1c1c,0x801a1a1a,0x80191919,0x80191919,0x800e0e0e,
+0x80000000,0x80000000,0x800f0f0f,0x80212121,0x80141414,0x80000000,
+0x80000000,0x800b0b0b,0x80171717,0x80191919,0x80171717,0x801a1a1a,
+0x801a1a1a,0x801c1c1c,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x80030303,
+0x80010101,0x80050505,0x80181818,0x80050505,0x80000000,0x80010101,
+0x800d0d0d,0x801c1c1c,0x80020202,0x80010101,0x800c0c0c,0x801d1d1d,
+0x80191919,0x80181818,0x80181818,0x80181818,0x80191919,0x801b1b1b,
+0x801e1e1e,0x801c1c1c,0x80020202,0x80000000,0x80040404,0x80181818,
+0x80191919,0x80181818,0x80171717,0x80181818,0x801b1b1b,0x801e1e1e,
+0x801f1f1f,0x801f1f1f,0x801a1a1a,0x800a0a0a,0x80000000,0x80000000,
+0x80010101,0x80070707,0x800a0a0a,0x80131313,0x80000000,0x80000000,0x80070707,0x80171717,0x80171717,0x80191919,
+0x80191919,0x80181818,0x801a1a1a,0x801f1f1f,0x80202020,0x801e1e1e,
+0x801e1e1e,0x80212121,0x80191919,0x800f0f0f,0x80020202,0x80000000,
+0x80010101,0x80010101,0x80000000,0x80000000,0x80030303,0x801a1a1a,
+0x801f1f1f,0x80191919,0x80181818,0x80171717,0x80181818,0x80181818,
+0x801a1a1a,0x801e1e1e,0x80212121,0x80121212,0x80000000,0x80020202,
+0x80000000,0x80010101,0x80000000,0x800c0c0c,0x80171717,0x801a1a1a,
+0x801c1c1c,0x80202020,0x80202020,0x801d1d1d,0x801d1d1d,0x801e1e1e,
+0x80121212,0x80020202,0x80000000,0x80000000,0x80010101,0x80000000,
+0x80030303,0x801d1d1d,0x801e1e1e,0x801c1c1c,0x80202020,0x80191919,
+0x80171717,0x801a1a1a,0x80171717,0x80181818,0x801b1b1b,0x801e1e1e,
+0x801f1f1f,0x801d1d1d,0x801e1e1e,0x80202020,0x801c1c1c,0x80171717,
+0x80171717,0x80191919,0x801a1a1a,0x80181818,0x80101010,0x80030303,
+0x80000000,0x800c0c0c,0x80050505,0x80000000,0x80000000,0x80000000,
+0x800e0e0e,0x80191919,0x80171717,0x801b1b1b,0x801e1e1e,0x801e1e1e,
+0x801e1e1e,0x801e1e1e,0x801e1e1e,0x801b1b1b,0x80171717,0x80191919,
+0x80191919,0x800f0f0f,0x80000000,0x80010101,0x800c0c0c,0x801c1c1c,
+0x801e1e1e,0x801e1e1e,0x801b1b1b,0x80171717,0x80171717,0x80191919,
+0x80191919,0x80191919,0x801d1d1d,0x80202020,0x80121212,0x80000000,
+0x80030303,0x80090909,0x801a1a1a,0x80151515,0x80000000,0x80010101,
+0x80010101,0x800c0c0c,0x801f1f1f,0x801f1d1e,0x801f1d1e,0x801f1d1e,
+0x801e1e1e,0x801c1c1c,0x80191919,0x80181818,0x80191919,0x800e0e0e,
+0x80000000,0x80000000,0x800e0e0e,0x801c1c1c,0x80131313,0x80010101,
+0x80000000,0x800a0a0a,0x80181818,0x80191919,0x80171717,0x801a1a1a,
+0x801c1c1c,0x80202020,0x801f1f1f,0x801c1c1c,0x801c1c1c,0x80030303,
+0x80000000,0x80060606,0x801a1a1a,0x80080808,0x80000000,0x80010101,
+0x80111111,0x801f1f1f,0x80040404,0x80000000,0x80080808,0x801a1a1a,
+0x80181818,0x80191919,0x80181818,0x80171717,0x801b1b1b,0x801d1d1d,
+0x80212121,0x801d1d1d,0x80010101,0x80000000,0x80030303,0x80151515,
+0x80181818,0x80181818,0x80181818,0x801a1a1a,0x801d1d1d,0x801f1f1f,
+0x801f1f1f,0x801e1e1e,0x80202020,0x80111111,0x80050505,0x80000000,
+0x80000000,0x80010101,0x80000000,0x80121212,0x80000000,0x80000000,0x80070707,0x80151515,0x80191919,0x80181818,
+0x80191816,0x801d1c1a,0x80201f1d,0x80201f1d,0x80201f1d,0x80201f1d,
+0x801d1c1a,0x80191816,0x80191816,0x80171614,0x80100f0d,0x80060503,
+0x80010000,0x80010000,0x80030200,0x80050402,0x801d1c1a,0x801d1c1a,
+0x801c1b19,0x801a1917,0x80181715,0x80181715,0x801a1917,0x801b1a18,
+0x801f1e1c,0x801f1e1c,0x80201f1d,0x801d1c1a,0x8011100e,0x80030200,
+0x80010000,0x80010000,0x80020100,0x800d0c0a,0x80191816,0x801e1d1b,
+0x801f1e1c,0x80201f1d,0x80201f1d,0x80201f1d,0x801d1c1a,0x801c1b19,
+0x80181715,0x80100f0d,0x80070604,0x80010000,0x80010000,0x80010000,
+0x80090806,0x801d1c1a,0x80232220,0x801b1a18,0x801a1917,0x801a1917,
+0x80181715,0x801a1917,0x80171614,0x801c1b19,0x801f1e1c,0x801f1e1c,
+0x801f1e1c,0x80201f1d,0x801f1e1c,0x801d1c1a,0x80171614,0x801b1a18,
+0x801a1917,0x80171614,0x801b1a18,0x801e1d1b,0x80131210,0x80030200,
+0x80020100,0x800c0b09,0x80080705,0x80010000,0x80090806,0x80141311,
+0x80171614,0x801a1917,0x801e1d1b,0x801e1d1b,0x801e1d1b,0x80201f1d,
+0x80201f1d,0x801e1d1b,0x801b1a18,0x80171614,0x801a1917,0x80191816,
+0x80181715,0x8011100e,0x80040301,0x80010000,0x800c0b09,0x801e1d1b,
+0x801f1e1c,0x801c1b19,0x80191816,0x80191816,0x80191816,0x80191816,
+0x801c1b19,0x801f1e1c,0x80201f1d,0x80201f1d,0x80141311,0x80030200,
+0x80010000,0x800d0c0a,0x80191816,0x801b1a18,0x800c0b09,0x80010000,
+0x80030200,0x80141311,0x801f1e1c,0x80201f1d,0x801f1e1c,0x801f1e1c,
+0x801a1917,0x801c1b19,0x80191816,0x80181715,0x80191816,0x800f0e0c,
+0x80030200,0x80010000,0x800e0d0b,0x801e1d1b,0x80171614,0x80010000,
+0x80010000,0x800d0c0a,0x80171614,0x801a1917,0x80181715,0x801f1e1c,
+0x80201f1d,0x801d1c1a,0x801f1e1c,0x8022211f,0x80161513,0x80040301,
+0x80010000,0x80090806,0x80161513,0x8012110f,0x80010000,0x80040301,
+0x80171614,0x80201f1d,0x80050402,0x80010000,0x80090806,0x80171614,
+0x801b1a18,0x80171614,0x80191816,0x801e1d1b,0x801e1d1b,0x801f1e1c,
+0x801f1e1c,0x801e1d1b,0x80050402,0x80010000,0x80070604,0x80161513,
+0x801a1917,0x80181715,0x801a1917,0x80201f1d,0x8022211f,0x801f1e1c,
+0x801f1e1c,0x8022211f,0x801b1a18,0x801a1917,0x80141311,0x80080705,
+0x80010000,0x80010000,0x80020100,0x80151412,0x80131313,0x80141414,0x80111111,0x801b1b1b,0x80181818,0x80181818,
+0x801d1c1a,0x801f1e1c,0x80201f1d,0x80201f1d,0x801f1e1c,0x801d1c1a,
+0x801b1a18,0x80191816,0x801a1a18,0x80181816,0x80171715,0x80161614,
+0x80151513,0x80131311,0x80161614,0x801b1b19,0x801d1c1a,0x801c1b19,
+0x801a1917,0x80181715,0x80181715,0x80191816,0x801c1b19,0x801e1d1b,
+0x801c1c1a,0x801e1e1c,0x8020201e,0x8020201e,0x801b1b19,0x80151513,
+0x80131311,0x80141412,0x8012110f,0x80181715,0x801e1d1b,0x80201f1d,
+0x801f1e1c,0x801f1e1c,0x801e1d1b,0x801c1b19,0x80191816,0x80191816,
+0x80191816,0x80181715,0x80171614,0x80171614,0x80191816,0x801a1917,
+0x80161513,0x801f1e1c,0x801f1e1c,0x80191816,0x801a1917,0x80191816,
+0x80171614,0x80191816,0x801c1b19,0x801e1d1b,0x801f1e1c,0x801f1e1c,
+0x80201f1d,0x80201f1d,0x801d1c1a,0x80191816,0x801a1917,0x80181715,
+0x80171614,0x801b1a18,0x801f1e1c,0x801f1e1c,0x801c1b19,0x80181715,
+0x80161513,0x80181715,0x80161513,0x80151412,0x80191816,0x80191816,
+0x80181715,0x801d1c1a,0x801f1e1c,0x801f1e1c,0x801f1e1c,0x801f1e1c,
+0x801d1c1a,0x801b1a18,0x80191816,0x80181715,0x80181715,0x801b1a18,
+0x801d1c1a,0x801d1c1a,0x80191816,0x80171614,0x801b1a18,0x80201f1d,
+0x801b1a18,0x801a1917,0x80191816,0x80181715,0x80191816,0x801b1a18,
+0x801e1d1b,0x801f1e1c,0x801e1e1c,0x801f1f1d,0x801b1b19,0x80141412,
+0x8011110f,0x80141412,0x80171715,0x80171715,0x801b1a18,0x80141311,
+0x80151412,0x801d1c1a,0x8021201e,0x801f1e1c,0x801c1b19,0x80191816,
+0x80191816,0x80191816,0x80181715,0x80191816,0x801d1c1a,0x801b1a18,
+0x80181715,0x80181715,0x801a1917,0x801e1d1b,0x80191816,0x8011100e,
+0x8012110f,0x80141311,0x80161513,0x801b1a18,0x80201f1d,0x801f1e1c,
+0x801f1e1c,0x80201f1d,0x80201f1d,0x801e1d1b,0x80181715,0x80131210,
+0x80131311,0x80151513,0x801b1b19,0x801b1b19,0x80131311,0x80171715,
+0x8020201e,0x801f1f1d,0x80181715,0x80131210,0x80141311,0x80191816,
+0x801a1917,0x80191816,0x801c1b19,0x80201f1d,0x801f1e1c,0x801f1e1c,
+0x801e1d1b,0x80201f1d,0x8011100e,0x8011100e,0x80131210,0x80191816,
+0x80171614,0x801b1a18,0x801e1d1b,0x801e1d1b,0x801f1e1c,0x8021201e,
+0x801f1e1c,0x801c1b19,0x801a1917,0x80181715,0x801b1a18,0x80181715,
+0x80151412,0x80171614,0x80171614,0x80191816,0x80191919,0x801a1a1a,0x80151515,0x80191919,0x8018181a,0x801a1a1c,
+0x80211f20,0x80201e1f,0x80201e1f,0x80201e1f,0x801e1c1d,0x801b191a,
+0x80191718,0x80191718,0x80181818,0x80181818,0x801b1b1b,0x801f1f1f,
+0x80202020,0x801e1e1e,0x801e1e1e,0x80212121,0x801c1a1b,0x801b191a,
+0x80191718,0x80181617,0x80191718,0x801b191a,0x801f1d1e,0x80211f20,
+0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801c1c1c,0x801a1a1a,0x80181818,
+0x80171717,0x80161616,0x801a1819,0x801d1b1c,0x801f1d1e,0x801f1d1e,
+0x80201e1f,0x80201e1f,0x801e1c1d,0x801b191a,0x80191718,0x80181617,
+0x80191718,0x801a1819,0x801d1b1c,0x801f1d1e,0x80201e1f,0x801f1d1e,
+0x80211f20,0x801f1d1e,0x801b191a,0x80191718,0x80191718,0x80181617,
+0x80191718,0x801c1a1b,0x801f1d1e,0x80201e1f,0x80201e1f,0x80201e1f,
+0x801f1d1e,0x801c1a1b,0x80191718,0x80171516,0x801b191a,0x80181617,
+0x80191718,0x801e1c1d,0x80211f20,0x801f1d1e,0x80201e1f,0x80222021,
+0x801e1c1d,0x801b191a,0x80181617,0x801a1819,0x801c1a1b,0x801a1819,
+0x801a1819,0x801f1d1e,0x80201e1f,0x80201e1f,0x80201e1f,0x801d1b1c,
+0x801a1819,0x80181617,0x80181617,0x80191718,0x80191718,0x801c1a1b,
+0x801e1c1d,0x801f1d1e,0x80201e1f,0x80211f20,0x801f1d1e,0x801b191a,
+0x80181617,0x80191718,0x80191718,0x80191718,0x801b191a,0x801f1d1e,
+0x80201e1f,0x801f1d1e,0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801c1c1c,
+0x801a1a1a,0x80181818,0x80181818,0x80191919,0x801f1d1e,0x801e1c1d,
+0x80201e1f,0x80211f20,0x80201e1f,0x801e1c1d,0x801c1a1b,0x80191718,
+0x80191718,0x80181617,0x80191718,0x801b191a,0x801d1b1c,0x801f1d1e,
+0x801f1d1e,0x80201e1f,0x80211f20,0x801c1a1b,0x80181617,0x80191718,
+0x801b191a,0x80191718,0x80191718,0x801e1c1d,0x80211f20,0x801f1d1e,
+0x801f1d1e,0x80201e1f,0x801f1d1e,0x801b191a,0x80191718,0x801a1819,
+0x80181818,0x80191919,0x801e1e1e,0x801f1f1f,0x801d1d1d,0x801f1f1f,
+0x80202020,0x801d1d1d,0x801c1a1b,0x80191718,0x80181617,0x80191718,
+0x80191718,0x801b191a,0x801e1c1d,0x801e1c1d,0x80201e1f,0x80211f20,
+0x801c1a1b,0x801e1c1d,0x80191718,0x801c1a1b,0x80191718,0x80191718,
+0x801a1819,0x801f1d1e,0x80211f20,0x801f1d1e,0x801f1d1e,0x80201e1f,
+0x801d1b1c,0x80171516,0x80191718,0x80161415,0x801a1819,0x801d1b1c,
+0x801e1c1d,0x80201e1f,0x80211f20,0x801f1d1e,0x80161616,0x80171717,0x801b1b1b,0x8018181a,0x801e1e20,0x80202022,
+0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801c1c1c,0x801a1a1a,0x80181818,
+0x80181818,0x80181818,0x80191919,0x801c1c1c,0x801f1f1f,0x801f1f1f,
+0x801f1f1f,0x801f1f1f,0x801d1d1d,0x80191919,0x80171717,0x80171717,
+0x80171717,0x80181818,0x801b1b1b,0x801d1d1d,0x801f1f1f,0x801f1f1f,
+0x80212121,0x801e1e1e,0x801a1a1a,0x80171717,0x80161616,0x80171717,
+0x80181818,0x80181818,0x801d1d1d,0x801f1f1f,0x801f1f1f,0x801e1e1e,
+0x801d1d1d,0x801c1c1c,0x80191919,0x80161616,0x80181818,0x80171717,
+0x80181818,0x801a1a1a,0x801d1d1d,0x801f1f1f,0x801e1e1e,0x801d1d1d,
+0x801f1f1f,0x801a1a1a,0x80181818,0x80181818,0x80171717,0x80171717,
+0x801b1b1b,0x801f1f1f,0x801e1e1e,0x801e1e1e,0x801f1f1f,0x801f1f1f,
+0x801b1b1b,0x80171717,0x80161616,0x80181818,0x80181818,0x801b1b1b,
+0x801e1e1e,0x801f1f1f,0x801f1f1f,0x801f1f1f,0x801d1d1d,0x801c1c1c,
+0x801a1a1a,0x80191919,0x80171717,0x80161616,0x80181818,0x801c1c1c,
+0x801f1f1f,0x80202020,0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801a1a1a,
+0x80171717,0x80161616,0x80171717,0x80181818,0x801c1c1c,0x801f1f1f,
+0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801e1e1e,0x801b1b1b,0x80161616,
+0x80171717,0x80181818,0x80191919,0x801a1a1a,0x801c1c1c,0x801f1f1f,
+0x80202020,0x801f1f1f,0x801f1f1f,0x801b1b1b,0x80181818,0x80181818,
+0x80181818,0x80171717,0x801a1a1a,0x801e1e1e,0x801e1e1e,0x801f1f1f,
+0x80202020,0x801f1f1f,0x801c1c1c,0x801a1a1a,0x80181818,0x80171717,
+0x80181818,0x80181818,0x801b1b1b,0x801e1e1e,0x801e1e1e,0x801f1f1f,
+0x801f1f1f,0x801e1e1e,0x801b1b1b,0x80191919,0x80171717,0x80171717,
+0x80181818,0x801a1a1a,0x801d1d1d,0x801f1f1f,0x801d1d1d,0x801e1e1e,
+0x801e1e1e,0x801b1b1b,0x80181818,0x80181818,0x80181818,0x80171717,
+0x80171717,0x801b1b1b,0x801f1f1f,0x80202020,0x801f1f1f,0x801e1e1e,
+0x801d1d1d,0x801b1b1b,0x80181818,0x80171717,0x80181818,0x801a1a1a,
+0x801c1c1c,0x801f1f1f,0x801f1f1f,0x801e1e1e,0x801d1d1d,0x801f1f1f,
+0x80191919,0x80181818,0x80171717,0x801a1a1a,0x80171717,0x80191919,
+0x801e1e1e,0x801e1e1e,0x801f1f1f,0x80202020,0x801f1f1f,0x801b1b1b,
+0x80181818,0x80171717,0x80191919,0x801a1a1a,0x80191919,0x801b1b1b,
+0x80202020,0x801c1c1c,0x801f1f1f,0x80212121,0x802b2b2b,0x802a2a2a,0x802b2b2d,0x80272729,0x802d2d2f,0x802e2e30,
+0x802b2b2d,0x802d2d2f,0x802c2c2e,0x8028282a,0x80262628,0x80272729,
+0x8028282a,0x80272729,0x8029292b,0x802c2c2e,0x802d2d2f,0x802b2b2d,
+0x802b2b2d,0x802c2c2e,0x802a2a2c,0x80272729,0x80262628,0x80262628,
+0x80272729,0x8028282a,0x802a2a2c,0x802c2c2e,0x802c2c2e,0x802c2c2e,
+0x802d2d2f,0x802a2a2c,0x80272729,0x80272729,0x80272729,0x80272729,
+0x8029292b,0x802c2c2e,0x802d2d2f,0x802e2e30,0x802e2e30,0x802c2c2e,
+0x802a2a2c,0x8029292b,0x80262628,0x80242426,0x80262628,0x80272729,
+0x8028282a,0x802b2b2d,0x802c2c2e,0x802d2d2f,0x802d2d2f,0x802d2d2f,
+0x8029292b,0x80272729,0x80272729,0x8028282a,0x80272729,0x80272729,
+0x802b2b2d,0x802d2d2f,0x802b2b2d,0x802b2b2d,0x802b2b2d,0x802b2b2d,
+0x8028282a,0x80252527,0x80252527,0x8028282a,0x80262628,0x802b2b2d,
+0x802d2d2f,0x802d2d2f,0x802d2d2f,0x802d2d2f,0x802c2c2e,0x8028282a,
+0x80272729,0x8028282a,0x8029292b,0x8028282a,0x8029292b,0x802d2d2f,
+0x802e2e30,0x802b2b2d,0x802c2c2e,0x802b2b2d,0x8029292b,0x8028282a,
+0x80272729,0x80272729,0x80272729,0x80272729,0x802b2b2d,0x802d2d2f,
+0x802e2e30,0x802d2d2f,0x802c2c2e,0x802a2a2c,0x8028282a,0x80272729,
+0x8028282a,0x80272729,0x80272729,0x802a2a2c,0x802c2c2e,0x802c2c2e,
+0x802c2c2e,0x802c2c2e,0x802b2b2d,0x8028282a,0x80272729,0x80272729,
+0x80272729,0x8028282a,0x802a2a2c,0x802c2c2e,0x802c2c2e,0x802c2c2e,
+0x802c2c2e,0x802b2b2d,0x8029292b,0x80272729,0x80262628,0x80272729,
+0x80272729,0x80272729,0x802c2c2e,0x802e2e30,0x802c2c2e,0x802c2c2e,
+0x802d2d2f,0x8029292b,0x80252527,0x80272729,0x8028282a,0x80272729,
+0x80272729,0x802b2b2d,0x802d2d2f,0x802b2b2d,0x802d2d2f,0x802d2d2f,
+0x802b2b2d,0x80262628,0x80252527,0x80272729,0x8028282a,0x80272729,
+0x802b2b2d,0x802d2d2f,0x802c2c2e,0x802c2c2e,0x802e2e30,0x802c2c2e,
+0x8028282a,0x80262628,0x8029292b,0x80272729,0x80272729,0x8029292b,
+0x802b2b2d,0x802c2c2e,0x802d2d2f,0x802e2e30,0x802a2a2c,0x802b2b2d,
+0x80272729,0x80262628,0x80262628,0x8028282a,0x80272729,0x802c2c2e,
+0x802e2e30,0x802b2b2d,0x802b2b2d,0x802d2d2f,0x802c2c2e,0x80272729,
+0x80252527,0x80272729,0x80242426,0x8028282a,0x8028282a,0x802b2b2d,
+0x80303032,0x802d2d2f,0x802e2e30,0x801f1f21,0x80777777,0x80878789,0x80878789,0x808b8b8d,0x8089898b,0x80878789,
+0x80878789,0x808a8a8c,0x8089898b,0x80868688,0x80858587,0x80878789,
+0x8088888a,0x80868688,0x8088888a,0x80868688,0x80868688,0x8088888a,
+0x8089898b,0x80878789,0x80878789,0x8088888a,0x8088888a,0x8088888a,
+0x80878789,0x80878789,0x8088888a,0x8088888a,0x8089898b,0x8088888a,
+0x8088888a,0x80878789,0x80868688,0x8088888a,0x80878789,0x80858587,
+0x80868688,0x8088888a,0x80878789,0x8088888a,0x8088888a,0x80878789,
+0x80868688,0x80868688,0x80878789,0x8088888a,0x80868688,0x80878789,
+0x8088888a,0x8088888a,0x8088888a,0x80878789,0x80878789,0x80878789,
+0x80878789,0x80868688,0x80878789,0x80878789,0x80878789,0x8088888a,
+0x8088888a,0x80878789,0x8089898b,0x8088888a,0x80878789,0x80878789,
+0x80878789,0x80868688,0x80868688,0x80878789,0x8088888a,0x80878789,
+0x80878789,0x8088888a,0x8088888a,0x8088888a,0x8088888a,0x8088888a,
+0x80868688,0x80858587,0x80878789,0x8088888a,0x8088888a,0x80878789,
+0x80878789,0x80878789,0x8089898b,0x8088888a,0x80868688,0x80868688,
+0x80878789,0x8088888a,0x80878789,0x80878789,0x8088888a,0x80878789,
+0x80878789,0x8088888a,0x80878789,0x80878789,0x80868688,0x80868688,
+0x8088888a,0x80868688,0x80868688,0x8089898b,0x808a8a8c,0x8088888a,
+0x8088888a,0x8089898b,0x80878789,0x80878789,0x8088888a,0x8088888a,
+0x8088888a,0x8088888a,0x8088888a,0x80878789,0x8088888a,0x8088888a,
+0x80878789,0x8088888a,0x8088888a,0x80878789,0x80868688,0x8089898b,
+0x80878789,0x80878789,0x8088888a,0x8088888a,0x80868688,0x80878789,
+0x8088888a,0x80868688,0x80878789,0x80868688,0x80878789,0x80878789,
+0x8088888a,0x8088888a,0x8088888a,0x80878789,0x808a8a8c,0x8088888a,
+0x80878789,0x80878789,0x80878789,0x80868688,0x80868688,0x80878789,
+0x8088888a,0x8089898b,0x80878789,0x80878789,0x8088888a,0x8088888a,
+0x80858587,0x80858587,0x80878789,0x80868688,0x80858587,0x80878789,
+0x8088888a,0x80878789,0x80868688,0x8088888a,0x8088888a,0x8088888a,
+0x80868688,0x80868688,0x8088888a,0x80878789,0x80868688,0x808a8a8c,
+0x8088888a,0x8088888a,0x8088888a,0x80878789,0x80878789,0x80878789,
+0x80878789,0x80878789,0x8088888a,0x8089898b,0x808a8a8c,0x8089898b,
+0x80878789,0x8089898b,0x80868688,0x80555557,0x80868688,0x80929294,0x808d8d8f,0x80909092,0x808e8e90,0x808f8f91,
+0x808f8f91,0x80909092,0x80909092,0x808f8f91,0x808f8f91,0x80909092,
+0x80909092,0x808f8f91,0x80919193,0x808f8f91,0x808e8e90,0x80909092,
+0x80919193,0x808f8f91,0x808f8f91,0x80919193,0x80919193,0x80919193,
+0x80909092,0x80909092,0x80909092,0x80909092,0x80909092,0x80909092,
+0x808f8f91,0x808f8f91,0x80909092,0x80909092,0x80909092,0x80909092,
+0x808f8f91,0x808f8f91,0x80909092,0x808f8f91,0x808f8f91,0x808e8e90,
+0x808e8e90,0x808e8e90,0x808f8f91,0x80909092,0x808f8f91,0x80909092,
+0x80909092,0x80909092,0x80909092,0x80909092,0x808f8f91,0x808f8f91,
+0x80909092,0x80909092,0x808f8f91,0x808f8f91,0x80909092,0x80919193,
+0x808f8f91,0x808e8e90,0x80919193,0x80909092,0x808f8f91,0x808f8f91,
+0x80909092,0x80909092,0x80909092,0x808f8f91,0x80919193,0x808f8f91,
+0x808e8e90,0x808f8f91,0x808f8f91,0x808e8e90,0x808e8e90,0x80909092,
+0x80909092,0x808f8f91,0x808f8f91,0x80909092,0x80909092,0x808f8f91,
+0x808f8f91,0x80919193,0x80909092,0x80909092,0x808f8f91,0x808f8f91,
+0x80909092,0x80909092,0x80909092,0x80909092,0x80919193,0x80909092,
+0x808e8e90,0x808e8e90,0x808f8f91,0x808f8f91,0x80909092,0x80909092,
+0x80909092,0x808f8f91,0x808f8f91,0x80909092,0x80909092,0x808f8f91,
+0x808f8f91,0x808f8f91,0x808f8f91,0x80909092,0x80909092,0x80909092,
+0x80909092,0x80909092,0x808f8f91,0x808f8f91,0x80909092,0x80909092,
+0x808f8f91,0x808f8f91,0x80909092,0x808f8f91,0x808e8e90,0x80909092,
+0x80909092,0x80909092,0x80909092,0x808f8f91,0x808e8e90,0x80909092,
+0x80929294,0x80929294,0x80929294,0x80909092,0x808e8e90,0x808f8f91,
+0x80909092,0x808e8e90,0x808e8e90,0x80909092,0x808f8f91,0x808d8d8f,
+0x808e8e90,0x80919193,0x80929294,0x808f8f91,0x808e8e90,0x808f8f91,
+0x808e8e90,0x80909092,0x80919193,0x80909092,0x808f8f91,0x808e8e90,
+0x808f8f91,0x80919193,0x808f8f91,0x80909092,0x80909092,0x80909092,
+0x80929294,0x80909092,0x808f8f91,0x80909092,0x80909092,0x808f8f91,
+0x808f8f91,0x808f8f91,0x80919193,0x808f8f91,0x808e8e90,0x808e8e90,
+0x808e8e90,0x80909092,0x80909092,0x808e8e90,0x808e8e90,0x80909092,
+0x80909092,0x808f8f91,0x808f8f91,0x808e8e90,0x80909092,0x808f8f91,
+0x808d8d8f,0x80929294,0x80919193,0x80535355,0x80828284,0x80909092,0x80919193,0x808f8f91,0x80909092,0x80919193,
+0x808f8f91,0x808e8e90,0x808f8f91,0x80909092,0x80909092,0x808f8f91,
+0x808f8f91,0x808f8f91,0x808d8e90,0x808f9092,0x808f9092,0x808d8e90,
+0x808e8f91,0x808f9092,0x808f9092,0x808c8d8f,0x808e8e90,0x808f8f91,
+0x808f8f91,0x80909092,0x80909092,0x808f8f91,0x808f8f91,0x808e8e90,
+0x808e8f91,0x808f9092,0x808e8f91,0x808c8d8f,0x808d8e90,0x808f9092,
+0x808f9092,0x808c8d8f,0x80909092,0x80909092,0x808f8f91,0x80909092,
+0x80909092,0x80909092,0x80909092,0x80909092,0x808f8f91,0x808f8f91,
+0x808e8e90,0x808f8f91,0x808f8f91,0x808f8f91,0x808f8f91,0x808e8e90,
+0x808e8e90,0x80909092,0x808f8f91,0x808f8f91,0x80909092,0x808f8f91,
+0x808e8e90,0x80919193,0x808e8e90,0x80909092,0x80909092,0x80909092,
+0x808f8f91,0x808f8f91,0x808f8f91,0x808f8f91,0x808d8d8f,0x80909092,
+0x80919193,0x80909092,0x80909092,0x80919193,0x80919193,0x808f8f91,
+0x808d8d8f,0x80919193,0x80909092,0x808e8e90,0x808f8f91,0x808f8f91,
+0x808f8f91,0x808f8f91,0x808f8f91,0x808f8f91,0x808f8f91,0x808f8f91,
+0x808f8f91,0x808f8f91,0x808f8f91,0x808f8f91,0x808d8d8f,0x808f8f91,
+0x80909092,0x808f8f91,0x80909092,0x80919193,0x80909092,0x808e8e90,
+0x808e8e90,0x80909092,0x80909092,0x808e8e90,0x808e8e90,0x808f8f91,
+0x80909092,0x808e8e90,0x808e8f91,0x808e8f91,0x808e8f91,0x808f9092,
+0x808e8f91,0x808e8f91,0x808e8f91,0x808f9092,0x808e8e90,0x80909092,
+0x80909092,0x808e8e90,0x80909092,0x80909092,0x808f8f91,0x80919193,
+0x808f8f91,0x80909092,0x80909092,0x808f8f91,0x808f8f91,0x808f8f91,
+0x808f8f91,0x808f8f91,0x808e8e90,0x80909092,0x80909092,0x808f8f91,
+0x80909092,0x808f8f91,0x808e8e90,0x80909092,0x808f8f91,0x80909092,
+0x80909092,0x808f8f91,0x808f8f91,0x808f8f91,0x80909092,0x80909092,
+0x808f9092,0x808f9092,0x808e8f91,0x808e8f91,0x808f9092,0x808e8f91,
+0x808d8e90,0x808d8e90,0x808f8f91,0x80919193,0x808f8f91,0x808d8d8f,
+0x808f8f91,0x808f8f91,0x808f8f91,0x80909092,0x808f8f91,0x808f8f91,
+0x80909092,0x808f8f91,0x808f8f91,0x808f8f91,0x80909092,0x808f8f91,
+0x80909092,0x808f8f91,0x808f8f91,0x80909092,0x80909092,0x808f8f91,
+0x808e8e90,0x808f8f91,0x808e8e90,0x80909092,0x808f8f91,0x808f8f91,
+0x808f8f91,0x808e8e90,0x808e8e90,0x80575759,0x80868688,0x80908f94,0x808f8e93,0x808e8e90,0x808e8e8e,0x808d8d8d,
+0x808f8e93,0x808e8e90,0x80909092,0x808d8d8d,0x8089898b,0x80909092,
+0x808d8c91,0x80919096,0x808e8d92,0x80919095,0x808e8e90,0x808e8e90,
+0x80949496,0x8088888a,0x808c8c8e,0x808f8f91,0x808e8e8e,0x808d8d8d,
+0x808a8a8a,0x808c8c8e,0x80919193,0x80939395,0x808e8e90,0x808f8f91,
+0x80908f94,0x808f8f91,0x808d8d8f,0x808e8e8e,0x808c8c8c,0x808e8e90,
+0x80909092,0x808e8d92,0x808f8e93,0x808f8e93,0x80919193,0x808e8e90,
+0x808b8b8d,0x808e8e90,0x808b8b8d,0x808e8e90,0x808d8d8f,0x8088888a,
+0x8089898b,0x80909092,0x808e8e90,0x80909092,0x808f8f91,0x80909092,
+0x80919095,0x808e8e90,0x808f8f91,0x808b8b8b,0x808e8e8e,0x808f8f91,
+0x808b8b8d,0x80919095,0x808f8e94,0x80908f94,0x808e8e90,0x808c8c8e,
+0x80909090,0x8089898b,0x808e8e90,0x80919095,0x808e8e90,0x808e8e90,
+0x808a8a8c,0x808e8e90,0x808f8f91,0x808e8e90,0x808e8d92,0x80919095,
+0x80909092,0x808d8d8f,0x80909092,0x808b8b8d,0x808e8e90,0x808d8d8f,
+0x808f8f91,0x808d8d8f,0x808d8d8f,0x808b8b8d,0x80929294,0x808f8e93,
+0x808a898e,0x80939297,0x80919095,0x808f8e93,0x80909090,0x808b8b8b,
+0x808b8b8b,0x808b8b8d,0x808e8e90,0x808c8c8e,0x808e8e90,0x80919193,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x80908f94,0x80909092,0x808d8d8f,0x808e8e8e,
+0x808e8e8e,0x808d8d8f,0x808c8c8e,0x80919095,0x80919095,0x808e8d92,
+0x80939395,0x808f8f91,0x808e8e90,0x808e8e90,0x808f8f91,0x808b8b8d,
+0x808d8d8f,0x808f8f91,0x80908f94,0x808f8e93,0x808f8e93,0x80929294,
+0x80898989,0x808f8f8f,0x80909092,0x8089898b,0x808e8e90,0x80909092,
+0x808a8a8c,0x80909092,0x808c8c8e,0x808d8d8f,0x808f8e93,0x80908f94,
+0x80909092,0x80909092,0x808e8e90,0x80909092,0x808c8c8e,0x808c8c8e,
+0x808f8e93,0x808f8e93,0x808f8f91,0x808f8f91,0x808d8d8f,0x808e8e90,
+0x808b8b8d,0x808e8e90,0x808c8c8e,0x8089898b,0x808f8f91,0x808a8a8c,
+0x80909092,0x80919193,0x80908f94,0x808e8d92,0x80909092,0x808e8e90,
+0x808d8d8f,0x8088888a,0x808e8e90,0x808c8b90,0x808e8d92,0x808e8d92,
+0x808e8d92,0x80929196,0x808d8d8f,0x808d8d8d,0x808c8c8c,0x808f8f8f,
+0x8088888a,0x808c8c8e,0x808c8c8e,0x808e8e90,0x808e8e90,0x80908f94,
+0x80908f94,0x80908f94,0x808f8e93,0x8057565b,0x80828284,0x80908f94,0x808b8a8f,0x80a5a5a7,0x80d4d4d4,0x80d7d7d7,
+0x80bcbcbe,0x8088888a,0x80a6a6a8,0x80d8d8d8,0x80d8d8d8,0x80b9b9bb,
+0x808e8d92,0x808e8d93,0x80919095,0x808c8b90,0x80909092,0x80909092,
+0x80878789,0x80a7a7a9,0x80ccccce,0x80e1e1e3,0x80e2e2e2,0x80d2d2d2,
+0x80ababab,0x80949496,0x808e8e90,0x808c8c8e,0x808e8e90,0x80929294,
+0x808e8d92,0x808c8c8e,0x80b5b5b7,0x80d8d8d8,0x80d4d4d4,0x80aaaaac,
+0x808b8b8d,0x80908f94,0x80908f94,0x808e8d92,0x80909092,0x808c8c8e,
+0x80a2a2a4,0x80d4d4d6,0x80d7d7d9,0x80d5d5d7,0x80c8c8ca,0x80c4c4c6,
+0x80a8a8aa,0x80909092,0x8088888a,0x80959597,0x808e8e90,0x808e8e90,
+0x808e8d92,0x808d8d8f,0x809e9ea0,0x80d1d1d1,0x80d6d6d6,0x80c3c3c5,
+0x80929294,0x808d8c91,0x80929197,0x8088878c,0x80979799,0x80cccccc,
+0x80e0e0e0,0x80c7c7c9,0x80919193,0x808a8a8c,0x80a2a2a4,0x80d5d5d7,
+0x80d9d9db,0x80bbbbbd,0x80909092,0x80909092,0x80939297,0x808d8c91,
+0x808d8d8f,0x808f8f91,0x808c8c8e,0x80a8a8aa,0x80c9c9cb,0x80e4e4e6,
+0x80e2e2e4,0x80d1d1d3,0x80b1b1b3,0x80979799,0x80878789,0x80919193,
+0x80959499,0x808e8d92,0x808c8b90,0x808f8e93,0x808a8a8a,0x80a5a5a5,
+0x80c3c3c3,0x80dadadc,0x80d1d1d3,0x80d8d8da,0x80a9a9ab,0x8089898b,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808e8e90,0x808f8f91,0x80bdbdbd,
+0x80d4d4d4,0x80d4d4d6,0x80a4a4a6,0x808c8b90,0x808d8c91,0x808e8d92,
+0x808f8f91,0x808e8e90,0x808f8f91,0x80a7a7a9,0x80d2d2d4,0x80d7d7d9,
+0x80bebec0,0x808c8c8e,0x808d8c91,0x80949398,0x80908f94,0x8088888a,
+0x80b5b5b5,0x80dddddd,0x80e1e1e3,0x80b2b2b4,0x808c8c8e,0x808b8b8d,
+0x80b3b3b5,0x80e0e0e2,0x80dedee0,0x80afafb1,0x808c8b90,0x808e8d92,
+0x80909092,0x808d8d8f,0x80909092,0x80bababc,0x80d2d2d4,0x80d5d5d7,
+0x809b9a9f,0x808f8e93,0x808f8f91,0x808f8f91,0x80c0c0c2,0x80d6d6d8,
+0x80d4d4d6,0x80d5d5d7,0x80d6d6d8,0x80d7d7d9,0x80d5d5d7,0x80aaaaac,
+0x808b8b8d,0x808d8d8f,0x80929196,0x80908f94,0x808e8e90,0x808c8c8e,
+0x80ababad,0x80c7c7c9,0x80d8d8da,0x80cacacc,0x809c9ba0,0x808e8d92,
+0x80908f94,0x808b8a8f,0x809f9fa1,0x80d3d3d3,0x80d5d5d5,0x80d5d5d5,
+0x80ccccce,0x80bbbbbd,0x80a1a1a3,0x808d8d8f,0x808e8e90,0x808e8e90,
+0x808e8d92,0x80929196,0x808d8c91,0x8057565b,0x80838385,0x80919095,0x8089888d,0x80b1b1b3,0x80ffffff,0x80ffffff,
+0x80dedee0,0x8088888a,0x80b4b4b4,0x80fcfcfc,0x80ffffff,0x80d4d4d6,
+0x808c8b90,0x80908f94,0x80908f94,0x808e8d92,0x80909092,0x80909092,
+0x80c8c8ca,0x80fcfcfe,0x80fcfcfe,0x80ffffff,0x80ffffff,0x80ffffff,
+0x80fdfdfd,0x80d7d7d9,0x80939395,0x808b8b8d,0x808f8f91,0x808d8d8f,
+0x808e8d92,0x808b8b8d,0x80d1d1d3,0x80ffffff,0x80fefefe,0x80bdbdbf,
+0x8089898b,0x80908f94,0x80908f94,0x808f8e93,0x80919193,0x8089898b,
+0x80a7a7a9,0x80fcfcfe,0x80ffffff,0x80ffffff,0x80ffffff,0x80fdfdff,
+0x80fafafc,0x80d4d4d6,0x809b9b9d,0x80868688,0x80909092,0x80929294,
+0x808f8e93,0x808c8c8e,0x80a1a1a3,0x80ffffff,0x80ffffff,0x80e5e5e7,
+0x80949496,0x808e8d92,0x80919095,0x808c8b90,0x80b5b5b7,0x80ffffff,
+0x80ffffff,0x80f9f9f9,0x80bcbcbe,0x80838385,0x80afafb1,0x80fefeff,
+0x80ffffff,0x80d8d8da,0x808f8f91,0x808c8c8e,0x80919095,0x808d8c91,
+0x808e8e90,0x80919193,0x80cdcdcf,0x80fdfdff,0x80ffffff,0x80fefeff,
+0x80ffffff,0x80ffffff,0x80fefeff,0x80e9e9eb,0x80adadaf,0x808b8b8d,
+0x808d8c91,0x808f8e93,0x80919095,0x808a898e,0x80b8b8b8,0x80fcfcfc,
+0x80ffffff,0x80fdfdff,0x80fdfdff,0x80ffffff,0x80b6b6b8,0x808c8c8e,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808e8d92,0x808d8d8f,0x808d8d8f,0x80dcdcdc,
+0x80ffffff,0x80ffffff,0x80b0b0b2,0x808a898e,0x808f8e93,0x80929196,
+0x808f8f91,0x80909092,0x808c8c8e,0x80b3b3b5,0x80fefeff,0x80ffffff,
+0x80dbdbdd,0x808c8c8e,0x80908f94,0x808c8b90,0x808d8c91,0x8099999b,
+0x80ececec,0x80ffffff,0x80fdfdff,0x80f7f7f9,0x80979799,0x8098989a,
+0x80f3f3f5,0x80ffffff,0x80ffffff,0x80e8e8ea,0x80929196,0x808e8d92,
+0x80909092,0x808e8e90,0x808e8e90,0x80d7d7d9,0x80ffffff,0x80ffffff,
+0x80a4a3a8,0x808e8d92,0x80919193,0x808e8e90,0x80dfdfe1,0x80fdfdff,
+0x80fdfdff,0x80ffffff,0x80fefeff,0x80ffffff,0x80fefeff,0x80bfbfc1,
+0x808a8a8c,0x808d8d8f,0x808f8e93,0x808c8b90,0x8098989a,0x80e1e1e3,
+0x80ffffff,0x80fdfdff,0x80fdfdff,0x80fdfdff,0x809a9a9c,0x808b8a8f,
+0x80929196,0x8088878c,0x80a7a7a9,0x80ffffff,0x80fcfcfc,0x80fdfdfd,
+0x80ffffff,0x80ffffff,0x80f9f9fb,0x80d5d5d7,0x808f8f91,0x808f8f91,
+0x80908f94,0x808d8c91,0x808f8e93,0x805b5a5f,0x80838385,0x808f8e93,0x808b8a8f,0x80b1b1b3,0x80ffffff,0x80fefefe,
+0x80dedee0,0x807f7f81,0x80b3b3b3,0x80ffffff,0x80ffffff,0x80d3d3d5,
+0x8089888d,0x808d8c91,0x808d8c91,0x80929196,0x80878789,0x80bfbfc1,
+0x80fdfdff,0x80fefeff,0x80fdfdff,0x80ffffff,0x80fefefe,0x80ffffff,
+0x80ffffff,0x80ffffff,0x80d7d7d9,0x80939395,0x808d8d8f,0x80929294,
+0x80908f94,0x8089898b,0x80d2d2d4,0x80fcfcfc,0x80fefefe,0x80bcbcbe,
+0x8089898b,0x808f8e93,0x808f8e93,0x80908f94,0x80939395,0x808c8c8e,
+0x80a4a4a6,0x80fefeff,0x80ffffff,0x80fdfdff,0x80fefeff,0x80ffffff,
+0x80ffffff,0x80ffffff,0x80e6e6e8,0x80969698,0x808e8e90,0x808e8e90,
+0x80908f94,0x808c8c8e,0x809d9d9f,0x80ffffff,0x80fdfdfd,0x80e4e4e6,
+0x80909092,0x80908f94,0x808c8b90,0x808a898e,0x80bdbdbf,0x80ffffff,
+0x80fcfcfc,0x80ffffff,0x80ededef,0x808a8a8c,0x80ababad,0x80ffffff,
+0x80fbfbfd,0x80dcdcde,0x808f8f91,0x808d8d8f,0x808f8e93,0x80908f94,
+0x808a8a8c,0x80ccccce,0x80ffffff,0x80ffffff,0x80fcfcfe,0x80fdfdff,
+0x80f6f6f8,0x80ffffff,0x80ffffff,0x80fefeff,0x80bebec0,0x808e8e90,
+0x808f8f91,0x80919095,0x80908f94,0x80919095,0x80eeeeee,0x80fefefe,
+0x80ffffff,0x80fbfbfd,0x80ffffff,0x80fefeff,0x80bcbcbe,0x8089898b,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808e8e90,0x808a8a8c,0x80dcdcdc,
+0x80fefefe,0x80ffffff,0x80acacae,0x808b8a8f,0x808e8d92,0x80919095,
+0x808f8f91,0x80909092,0x8089898b,0x80b2b2b4,0x80ffffff,0x80ffffff,
+0x80dadadc,0x80878789,0x80939297,0x808e8d92,0x808d8c91,0x80a3a3a5,
+0x80fdfdfd,0x80ffffff,0x80ffffff,0x80fcfcfc,0x80a7a7a7,0x80aeaeae,
+0x80fbfbfb,0x80fdfdfd,0x80ffffff,0x80fcfcfc,0x80a09fa4,0x808d8c91,
+0x808f8f91,0x80919193,0x808b8b8d,0x80d9d9db,0x80ffffff,0x80fdfdff,
+0x80a7a6ab,0x8087868b,0x8089898b,0x80909092,0x80e4e4e6,0x80fefeff,
+0x80ffffff,0x80ffffff,0x80ffffff,0x80fdfdff,0x80fcfcfe,0x80bbbbbd,
+0x8088888a,0x80939395,0x808d8c91,0x80908f94,0x80e2e2e2,0x80fcfcfc,
+0x80ffffff,0x80ffffff,0x80fefeff,0x80f9f9fb,0x809c9c9e,0x808d8d8f,
+0x808c8b90,0x808e8d92,0x80a4a4a6,0x80fbfbfb,0x80ffffff,0x80ffffff,
+0x80f9f9fb,0x80ffffff,0x80ffffff,0x80ffffff,0x80dfdfe1,0x80979799,
+0x808b8b8d,0x80908f94,0x80949398,0x8056555a,0x80828284,0x808c8b90,0x808b8a8f,0x80b2b2b4,0x80fefefe,0x80ffffff,
+0x80d4d4d6,0x807e7e80,0x80b1b1b1,0x80ffffff,0x80fefefe,0x80d0d0d2,
+0x808f8f91,0x80929196,0x80919095,0x808a898e,0x80a3a3a5,0x80fbfbfd,
+0x80fefeff,0x80ffffff,0x80e2e2e4,0x80afafb1,0x80adadad,0x80d2d2d2,
+0x80fdfdfd,0x80ffffff,0x80ffffff,0x80b1b1b3,0x808d8d8f,0x808d8d8f,
+0x80919095,0x8088888a,0x80cfcfd1,0x80fefefe,0x80ffffff,0x80b9b9bb,
+0x8088888a,0x808f8e93,0x80908f94,0x80908f94,0x808e8e90,0x808e8e90,
+0x80a7a7a9,0x80ffffff,0x80fdfdff,0x80ececee,0x80b1b1b3,0x80d2d2d4,
+0x80fcfcfe,0x80ffffff,0x80ffffff,0x80cacacc,0x808d8d8f,0x808c8c8e,
+0x808e8d92,0x808c8c8e,0x80a0a0a2,0x80ffffff,0x80fdfdfd,0x80e2e2e4,
+0x80919193,0x808d8c91,0x808f8e93,0x808c8c8e,0x80bbbbbd,0x80ffffff,
+0x80fefefe,0x80ffffff,0x80fcfcfe,0x80b8b8ba,0x80a4a4a6,0x80ffffff,
+0x80fefeff,0x80dbdbdd,0x808d8d8f,0x80909092,0x808f8e93,0x808c8b90,
+0x80a9a9ab,0x80fcfcfe,0x80ffffff,0x80ffffff,0x80ceced0,0x80a3a3a5,
+0x80939395,0x80b5b5b7,0x80e9e9eb,0x80bbbbbd,0x80878789,0x80878789,
+0x80929294,0x808c8c8e,0x8088888a,0x80a3a2a7,0x80f6f6f6,0x80ffffff,
+0x80f8f8f8,0x80b5b5b7,0x809d9d9f,0x80a5a5a7,0x809a9a9c,0x808e8e90,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x80908f94,0x808f8f91,0x808c8c8e,0x80d8d8d8,
+0x80ffffff,0x80fefeff,0x80adadaf,0x808b8a8f,0x808f8e93,0x808f8e93,
+0x808f8f91,0x808f8f91,0x8089898b,0x80b3b3b5,0x80fefeff,0x80fdfdff,
+0x80dadadc,0x8088888a,0x808e8d92,0x808f8e93,0x808b8a8f,0x80ababad,
+0x80fdfdfd,0x80fafafa,0x80f9f9f9,0x80ffffff,0x80b2b2b2,0x80b9b9b9,
+0x80ffffff,0x80fefefe,0x80fbfbfb,0x80ffffff,0x80a9a8ad,0x808b8a8f,
+0x808d8d8f,0x80919193,0x808b8b8d,0x80d8d8da,0x80fdfdff,0x80fcfcfe,
+0x80a4a3a8,0x808d8c91,0x80919193,0x808e8e90,0x80a5a5a7,0x80afafb1,
+0x80dbdbdd,0x80ffffff,0x80fdfdff,0x80c4c4c6,0x80b2b2b4,0x809c9c9e,
+0x808b8b8d,0x80909092,0x808a898e,0x80b5b4b9,0x80fbfbfb,0x80ffffff,
+0x80fafafa,0x80bfbfc1,0x80a5a5a7,0x809e9ea0,0x80929294,0x808e8e90,
+0x80908f94,0x808d8c91,0x80a4a4a6,0x80ffffff,0x80ffffff,0x80e4e4e4,
+0x80b6b6b8,0x80d7d7d9,0x80fefeff,0x80fdfdff,0x80ffffff,0x80bfbfc1,
+0x808e8e90,0x80909092,0x808e8e90,0x805a595e,0x80858587,0x80908f94,0x8089888d,0x80b0b0b2,0x80ffffff,0x80ffffff,
+0x80f5f5f7,0x80d0d0d0,0x80e3e3e3,0x80ffffff,0x80ffffff,0x80d1d1d1,
+0x808a8a8c,0x808d8c91,0x808f8e93,0x8089888d,0x80c5c5c7,0x80fefeff,
+0x80ffffff,0x80e3e3e5,0x80929294,0x808b8b8d,0x80888888,0x808f8f8f,
+0x80cfcfcf,0x80fdfdff,0x80fefeff,0x80dadadc,0x808d8d8f,0x808d8d8f,
+0x808f8e93,0x808b8b8d,0x80d0d0d2,0x80ffffff,0x80ffffff,0x80b9b9bb,
+0x808a8a8c,0x80908f94,0x80908f94,0x80908f94,0x808c8c8e,0x808b8b8d,
+0x80a6a6a8,0x80fefeff,0x80fdfdff,0x80e0e0e2,0x8089898b,0x80868688,
+0x80c2c2c4,0x80fcfcfe,0x80fefeff,0x80f1f1f3,0x80919193,0x80909092,
+0x80908f94,0x808a8a8c,0x80a0a0a2,0x80ffffff,0x80ffffff,0x80e3e3e5,
+0x80939395,0x808d8c91,0x808e8d92,0x808a8a8c,0x80bdbdbd,0x80ffffff,
+0x80fefefe,0x80ffffff,0x80fdfdfd,0x80e6e6e8,0x80b0b0b2,0x80fefeff,
+0x80ffffff,0x80d8d8da,0x808b8b8d,0x808f8f91,0x808f8e93,0x808a898e,
+0x80cbcbcb,0x80ffffff,0x80fefefe,0x80d6d6d6,0x80919191,0x80949494,
+0x80b4b4b4,0x80b2b2b2,0x80bebebe,0x80b9b9b9,0x80b8b8ba,0x80b2b2b4,
+0x808d8d8f,0x80929294,0x808f8f91,0x80939395,0x80f2f2f2,0x80ffffff,
+0x80ffffff,0x80dedee0,0x809f9fa1,0x80858587,0x80909092,0x808c8c8e,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808e8e90,0x808e8e90,0x80d7d7d7,
+0x80ffffff,0x80ffffff,0x80afafb1,0x808b8a8f,0x80919095,0x808f8e93,
+0x80909092,0x808f8f91,0x8089898b,0x80b3b3b5,0x80fdfdff,0x80ffffff,
+0x80d7d7d9,0x808c8c8e,0x808e8d92,0x808e8d92,0x8088878c,0x80b9b9bb,
+0x80ffffff,0x80f7f7f7,0x80e4e4e4,0x80ffffff,0x80c0c0c0,0x80cacaca,
+0x80fefefe,0x80e6e6e6,0x80f5f5f5,0x80fdfdfd,0x80afaeb3,0x808a898e,
+0x808f8f91,0x808f8f91,0x808a8a8c,0x80d8d8da,0x80ffffff,0x80ffffff,
+0x80a3a2a7,0x808b8a8f,0x80909092,0x80919193,0x808a8a8c,0x808a8a8c,
+0x80cacacc,0x80fcfcfe,0x80ffffff,0x80a3a3a5,0x80818183,0x808d8d8f,
+0x80939395,0x808d8d8f,0x8089888d,0x80dddce1,0x80ffffff,0x80ffffff,
+0x80dbdbdb,0x80a1a1a1,0x80a6a6a8,0x80a5a5a7,0x80919193,0x80909092,
+0x808f8e93,0x808d8c91,0x80a5a5a7,0x80fbfbfb,0x80ffffff,0x80e2e2e2,
+0x80878789,0x80848486,0x80c4c4c4,0x80ffffff,0x80fdfdff,0x80ebebed,
+0x808f8f91,0x808b8b8d,0x808e8e90,0x805b5b5d,0x80848486,0x80929196,0x808b8a8f,0x80afafb1,0x80ffffff,0x80fdfdfd,
+0x80fcfcfe,0x80ffffff,0x80ffffff,0x80fcfcfa,0x80ffffff,0x80d5d5d5,
+0x808a8a8c,0x808e8d92,0x80929196,0x8086858a,0x80d6d6d8,0x80ffffff,
+0x80ffffff,0x80bcbcbe,0x80858587,0x808e8e90,0x808f8f8f,0x80898989,
+0x809f9f9f,0x80fefeff,0x80fefeff,0x80ededef,0x80909092,0x808e8e90,
+0x808e8d92,0x808c8c8e,0x80cfcfd1,0x80fcfcfc,0x80fbfbfb,0x80bbbbbd,
+0x808a8a8c,0x80908f94,0x808f8e93,0x808f8e93,0x80909092,0x808a8a8c,
+0x80a4a4a6,0x80fdfdff,0x80ffffff,0x80e2e2e4,0x80909092,0x8088888a,
+0x80939395,0x80f3f3f5,0x80ffffff,0x80fdfdff,0x80a2a2a4,0x808d8d8f,
+0x80919095,0x808a8a8c,0x809d9d9f,0x80fcfcfc,0x80ffffff,0x80e2e2e4,
+0x80939395,0x808f8e93,0x80919095,0x8089898b,0x80bdbdbd,0x80ffffff,
+0x80fffffd,0x80f7f7f7,0x80fdfdfd,0x80fcfcfe,0x80d9d9db,0x80fcfcfe,
+0x80fdfdff,0x80d7d7d9,0x808e8e90,0x808e8e90,0x80919095,0x808d8c91,
+0x80e6e6e6,0x80fdfdfd,0x80ffffff,0x80b3b3b3,0x80828282,0x80a9a9a9,
+0x80fdfdfd,0x80ffffff,0x80ffffff,0x80ffffff,0x80ffffff,0x80e8e8ea,
+0x80919193,0x808e8e90,0x808c8c8e,0x808b8b8d,0x80b9b9b9,0x80fdfdfd,
+0x80ffffff,0x80ffffff,0x80f8f8fa,0x80bcbcbe,0x8088888a,0x80939395,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808e8e90,0x808c8c8e,0x80d8d8d8,
+0x80ffffff,0x80fefeff,0x80aeaeb0,0x808a898e,0x808e8d92,0x808f8e93,
+0x808f8f91,0x80909092,0x8089898b,0x80b2b2b4,0x80fefeff,0x80ffffff,
+0x80d6d6d8,0x8089898b,0x80908f94,0x80949398,0x808a898e,0x80bcbcbe,
+0x80fdfdfd,0x80f8f8f8,0x80d1d1d1,0x80fdfdfd,0x80dadada,0x80d7d7d7,
+0x80fefefe,0x80cecece,0x80ededed,0x80ffffff,0x80bab9be,0x808a898e,
+0x80919193,0x808e8e90,0x808b8b8d,0x80d6d6d8,0x80fefeff,0x80fdfdff,
+0x80a7a6ab,0x808a898e,0x808d8d8f,0x808f8f91,0x808d8d8f,0x808b8b8d,
+0x80cfcfd1,0x80ffffff,0x80fdfdff,0x80aeaeb0,0x808d8d8f,0x808e8e90,
+0x808e8e90,0x808e8e90,0x80908f94,0x80ebeaef,0x80ffffff,0x80ffffff,
+0x80fafafa,0x80ffffff,0x80ffffff,0x80f5f5f7,0x809d9d9f,0x808b8b8d,
+0x808f8e93,0x8089888d,0x80a7a7a9,0x80fcfcfc,0x80ffffff,0x80e6e6e6,
+0x80909092,0x808c8c8e,0x809a9a9a,0x80f8f8f8,0x80ffffff,0x80f7f7f9,
+0x809c9c9e,0x808e8e90,0x808f8f91,0x8059595b,0x80808082,0x808e8d92,0x808d8c91,0x80aeaeb0,0x80ffffff,0x80ffffff,
+0x80ffffff,0x80fbfbfb,0x80fefefe,0x80fffffd,0x80ffffff,0x80cfcfcf,
+0x808b8b8d,0x80919095,0x80908f94,0x808a898e,0x80d8d8da,0x80fefeff,
+0x80fefeff,0x80b8b8ba,0x808a8a8c,0x80909092,0x808f8f8f,0x808b8b8b,
+0x809e9e9e,0x80f9f9fb,0x80ffffff,0x80eeeef0,0x80939395,0x808e8e90,
+0x80908f94,0x8088888a,0x80cfcfd1,0x80ffffff,0x80ffffff,0x80bebec0,
+0x80868688,0x80908f94,0x80919095,0x808c8b90,0x80939395,0x808a8a8c,
+0x80a5a5a7,0x80fdfdff,0x80fefeff,0x80e3e3e5,0x808e8e90,0x808d8d8f,
+0x80939395,0x80ededef,0x80fdfdff,0x80ffffff,0x80a2a2a4,0x808b8b8d,
+0x808f8e93,0x808d8d8f,0x80a1a1a3,0x80ffffff,0x80fefefe,0x80e2e2e4,
+0x80929294,0x808e8d92,0x808f8e93,0x808a8a8c,0x80bfbfbf,0x80fefefe,
+0x80fffffd,0x80cecece,0x80e3e3e3,0x80ffffff,0x80fefeff,0x80ffffff,
+0x80fefeff,0x80d7d7d9,0x808f8f91,0x808c8c8e,0x80908f94,0x8088878c,
+0x80e7e7e7,0x80ffffff,0x80ffffff,0x80b4b4b4,0x80888888,0x80aaaaaa,
+0x80ffffff,0x80fdfdfd,0x80fdfdfd,0x80ffffff,0x80fcfcfc,0x80e8e8ea,
+0x808f8f91,0x808f8f91,0x808e8e90,0x808f8f91,0x80888888,0x80bbbbbb,
+0x80f8f8f8,0x80fdfdff,0x80ffffff,0x80ffffff,0x80bcbcbe,0x808a8a8c,
+0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,0x808f8e93,
+0x808f8e93,0x808f8e93,0x80908f94,0x808f8f91,0x808a8a8c,0x80dcdcdc,
+0x80ffffff,0x80ffffff,0x80acacae,0x8089888d,0x808f8e93,0x80908f94,
+0x808f8f91,0x80929294,0x8089898b,0x80b1b1b3,0x80ffffff,0x80fefeff,
+0x80dcdcde,0x8088888a,0x808e8d92,0x808e8d92,0x808b8a8f,0x80c8c8ca,
+0x80ffffff,0x80ececec,0x80b5b5b5,0x80fefefe,0x80ececec,0x80eaeaea,
+0x80ffffff,0x80b6b6b6,0x80f7f7f7,0x80fdfdfd,0x80c6c5ca,0x8089888d,
+0x80919193,0x808f8f91,0x808d8d8f,0x80d6d6d8,0x80ffffff,0x80fcfcfe,
+0x80a5a4a9,0x808a898e,0x80939395,0x808e8e90,0x80919193,0x808b8b8d,
+0x80cdcdcf,0x80ffffff,0x80ffffff,0x80adadaf,0x8089898b,0x808f8f91,
+0x80909092,0x808f8f91,0x80919095,0x80eeedf2,0x80fefefe,0x80ffffff,
+0x80ffffff,0x80ffffff,0x80fbfbfb,0x80fdfdff,0x809e9ea0,0x808e8e90,
+0x80908f94,0x8089888d,0x80a6a6a8,0x80fcfcfc,0x80fefefe,0x80e1e1e1,
+0x80909092,0x808c8c8e,0x80959595,0x80efefef,0x80fefefe,0x80ffffff,
+0x80979799,0x808d8d8f,0x808f8f91,0x8059595b,0x80858585,0x80909092,0x808b8b8d,0x80b0b0b2,0x80ffffff,0x80fdfffe,
+0x80e3e3e5,0x809c9c9e,0x80c4c4c6,0x80ffffff,0x80fdfdff,0x80d3d3d5,
+0x808a8a8c,0x808e8e90,0x808c8c8e,0x808c8c8e,0x80c7c7c9,0x80ffffff,
+0x80fefeff,0x80d9d9d9,0x80888888,0x808b8b8b,0x808b8b8b,0x80868686,
+0x80c2c2c2,0x80ffffff,0x80ffffff,0x80e0e0e2,0x808c8c8e,0x80909092,
+0x808f8f91,0x808b8b8d,0x80cdcdcf,0x80fefeff,0x80ffffff,0x80b5b5b5,
+0x80868686,0x808c8c8c,0x808d8c91,0x808d8c91,0x80939395,0x808c8c8e,
+0x80a5a5a5,0x80fefefe,0x80fefefc,0x80e4e4e2,0x808d8d8d,0x80858585,
+0x80ababab,0x80fbfbfd,0x80ffffff,0x80fbfbfd,0x80979799,0x808d8d8f,
+0x80909092,0x808b8b8d,0x809f9f9f,0x80ffffff,0x80fdfdfd,0x80e3e3e3,
+0x808f8f91,0x80919193,0x80919193,0x8088888a,0x80bcbcbe,0x80ffffff,
+0x80fafafc,0x80cacacc,0x80afafb1,0x80ffffff,0x80fefefc,0x80fffffd,
+0x80ffffff,0x80d4d4d4,0x808e8e90,0x808e8e90,0x80908f94,0x8089888d,
+0x80d4d4d4,0x80ffffff,0x80ffffff,0x80d7d7d7,0x80878787,0x80959595,
+0x80b2b2b2,0x80adadad,0x80e2e2e0,0x80fefefc,0x80ffffff,0x80d6d6d6,
+0x808b8b8d,0x808f8f91,0x808e8d92,0x808f8e93,0x808c8c8c,0x80898989,
+0x80a2a2a2,0x80e1e1e1,0x80ffffff,0x80fdfdfd,0x80f7f7f7,0x80989898,
+0x808d8c91,0x808e8d92,0x80908f94,0x80908f94,0x808f8e93,0x808f8e93,
+0x808f8e93,0x80908f94,0x80909092,0x808f8f91,0x808c8c8e,0x80d9d9db,
+0x80ffffff,0x80ffffff,0x80a9a9a9,0x80898989,0x808b8b8b,0x808e8e8e,
+0x808e8e90,0x80939395,0x808a8a8c,0x80b1b1b3,0x80ffffff,0x80fdfdfd,
+0x80d8d8da,0x808a8a8c,0x80929294,0x80909092,0x808a8a8c,0x80d6d6d6,
+0x80ffffff,0x80efefef,0x80a9a9a9,0x80f4f4f4,0x80ffffff,0x80fbfbfb,
+0x80f3f3f3,0x80a3a3a3,0x80f4f4f4,0x80ffffff,0x80d1d1d3,0x8089898b,
+0x80909092,0x80909092,0x808c8c8e,0x80d6d6d6,0x80ffffff,0x80fcfcfc,
+0x80a5a4a9,0x808d8c91,0x808d8d8f,0x80919193,0x808f8f91,0x808c8c8e,
+0x80cdcdcf,0x80ffffff,0x80fefdff,0x80adacb1,0x8087868b,0x80929196,
+0x80929196,0x808d8c91,0x808a898e,0x80e4e3e8,0x80ffffff,0x80fdfdfd,
+0x80e3e3e3,0x80b6b6b8,0x80c0c0c2,0x80bebec0,0x80969698,0x808e8e90,
+0x80919193,0x808b8b8d,0x80a6a6a8,0x80fcfcfe,0x80ffffff,0x80e3e3e3,
+0x808c8c8c,0x80868686,0x80b4b4b2,0x80fffffd,0x80ffffff,0x80f1f1f1,
+0x80939395,0x808f8f91,0x80908f94,0x80555459,0x80828282,0x808d8d8f,0x808c8c8e,0x80b0b0b2,0x80ffffff,0x80feffff,
+0x80dbdbdd,0x80858587,0x80adadaf,0x80fefeff,0x80ffffff,0x80d3d3d5,
+0x808d8d8f,0x808f8f91,0x80949496,0x8089898b,0x80a4a4a6,0x80ffffff,
+0x80ffffff,0x80fafafa,0x80d2d2d2,0x809e9e9e,0x809e9e9e,0x80c5c5c5,
+0x80fafafa,0x80fdfdff,0x80fefeff,0x80bdbdbf,0x808a8a8c,0x808e8e90,
+0x808f8f91,0x8089898b,0x80d3d3d5,0x80fefeff,0x80fdfdff,0x80d2d2d2,
+0x809c9c9c,0x80a3a3a3,0x809d9ca1,0x80908f94,0x80909092,0x80868688,
+0x80a5a5a5,0x80ffffff,0x80ffffff,0x80e0e0de,0x80999999,0x80b4b4b4,
+0x80efefef,0x80ffffff,0x80ffffff,0x80d9d9db,0x808b8b8d,0x808e8e90,
+0x80908f94,0x8088888a,0x80a1a1a1,0x80fcfcfc,0x80ffffff,0x80e3e3e3,
+0x80939395,0x808d8c91,0x808f8f91,0x808b8b8d,0x80bbbbbd,0x80ffffff,
+0x80ffffff,0x80c3c3c5,0x808d8d8f,0x80eaeaec,0x80fffffd,0x80fdfdfd,
+0x80fefefe,0x80d9d9d9,0x808b8b8d,0x808e8e90,0x80919095,0x808d8c91,
+0x80afafaf,0x80ffffff,0x80ffffff,0x80f8f8f8,0x80c7c7c7,0x80929292,
+0x808d8d8d,0x80b2b2b2,0x80f6f6f4,0x80fefefe,0x80ffffff,0x80b0b0b0,
+0x808e8e90,0x808d8d8f,0x808f8e93,0x80908f94,0x80989898,0x80949494,
+0x808d8d8d,0x80acacac,0x80fcfcfc,0x80fefefe,0x80ffffff,0x80a2a2a2,
+0x808d8c91,0x808e8d92,0x80908f94,0x80908f94,0x808f8e93,0x808f8e93,
+0x808f8e93,0x80908f94,0x808e8e90,0x80919193,0x808c8c8e,0x80dadadc,
+0x80fcfcfe,0x80ffffff,0x80cacaca,0x80989898,0x80a2a2a2,0x809a9a9a,
+0x808c8c8e,0x80908f94,0x808a898e,0x80b2b2b4,0x80fefefe,0x80ffffff,
+0x80d9d9db,0x808d8d8f,0x808e8e90,0x808f8f91,0x80909092,0x80dddddd,
+0x80ffffff,0x80efefef,0x809a9a9a,0x80e7e7e7,0x80fefefe,0x80fefefe,
+0x80e7e7e7,0x80989898,0x80f5f5f5,0x80fefefe,0x80dddddf,0x808c8c8e,
+0x808f8f91,0x808d8d8f,0x808f8f91,0x80dadada,0x80fcfcfc,0x80fefefe,
+0x80a4a3a8,0x808d8c91,0x80909092,0x808f8f91,0x808c8c8e,0x808a8a8c,
+0x80ceced0,0x80ffffff,0x80fffeff,0x80afaeb3,0x808b8a8f,0x808e8d92,
+0x808c8b90,0x80919095,0x808d8c91,0x80c0bfc4,0x80fcfcfc,0x80ffffff,
+0x80e6e6e6,0x80acacae,0x80919193,0x808d8d8f,0x808f8f91,0x80919193,
+0x808c8c8e,0x808c8c8e,0x80a6a6a8,0x80fefeff,0x80ffffff,0x80dddddd,
+0x809e9e9e,0x80b5b5b5,0x80f5f5f3,0x80ffffff,0x80ffffff,0x80cfcfcf,
+0x80909092,0x808e8e90,0x808f8e93,0x805b5a5f,0x80838383,0x808f8f91,0x808b8b8d,0x80b0b0b2,0x80fefeff,0x80fdfffe,
+0x80dadadc,0x80818183,0x80b6b6b8,0x80ffffff,0x80fefeff,0x80d1d1d3,
+0x808b8b8d,0x808e8e90,0x808c8c8e,0x80919193,0x80909092,0x80ccccce,
+0x80ffffff,0x80ffffff,0x80ffffff,0x80f9f9f9,0x80f6f6f6,0x80ffffff,
+0x80fdfdff,0x80ffffff,0x80e8e8ea,0x80959597,0x808d8d8f,0x80919193,
+0x808d8d8f,0x808b8b8d,0x80c2c2c4,0x80ffffff,0x80ffffff,0x80ffffff,
+0x80f8f8f8,0x80fafafa,0x80d8d7dc,0x808a898e,0x808d8d8f,0x80909092,
+0x80a7a7a9,0x80fafafa,0x80ffffff,0x80e0e0e0,0x80d6d6d6,0x80fcfcfc,
+0x80fefeff,0x80ffffff,0x80f4f4f6,0x80aaaaac,0x808c8c8e,0x808f8f91,
+0x80908f94,0x808a8a8c,0x80a5a5a5,0x80fdfdfd,0x80ffffff,0x80dedede,
+0x80929294,0x808e8d92,0x808e8e90,0x808b8b8d,0x80c1c1c3,0x80fafafc,
+0x80ffffff,0x80cbcbcd,0x80838385,0x80b3b3b5,0x80fefefe,0x80ffffff,
+0x80fdfdfd,0x80dcdcde,0x808e8e90,0x808e8e90,0x808d8c91,0x80929196,
+0x808d8d8d,0x80dbdbdb,0x80fdfdfd,0x80ffffff,0x80ffffff,0x80f5f5f5,
+0x80ebebeb,0x80ffffff,0x80fefefe,0x80ffffff,0x80e0e0e0,0x808c8c8e,
+0x808b8b8d,0x80949496,0x808d8c91,0x80949398,0x80e2e2e2,0x80f1f1f1,
+0x80f5f5f5,0x80f4f4f4,0x80ffffff,0x80ffffff,0x80f5f5f5,0x809c9c9c,
+0x808d8c91,0x808e8d92,0x80908f94,0x80908f94,0x808f8e93,0x808f8e93,
+0x808f8e93,0x80908f94,0x80909092,0x808d8d8f,0x808a8a8c,0x80c4c4c6,
+0x80ffffff,0x80ffffff,0x80ffffff,0x80fbfbfb,0x80fafafa,0x80cdcdcd,
+0x808f8f91,0x808e8d92,0x808a898e,0x80b3b3b5,0x80fefefe,0x80fdfdfd,
+0x80dadadc,0x808a8a8c,0x808f8f91,0x808d8d8f,0x80919193,0x80eaeaec,
+0x80fdfdfd,0x80e9e9e9,0x808a8a8a,0x80dbdbdb,0x80fefefe,0x80ffffff,
+0x80d5d5d5,0x808a8a8a,0x80eeeeee,0x80ffffff,0x80e9e9eb,0x80868688,
+0x80929294,0x80939395,0x8088888a,0x80d6d6d8,0x80ffffff,0x80fdfdfd,
+0x80a5a4a9,0x808a898e,0x808e8e90,0x80909092,0x80929294,0x808e8e90,
+0x80cfcfd1,0x80fdfdff,0x80fffeff,0x80aaa9ae,0x808b8a8f,0x808f8e93,
+0x808d8c91,0x80929196,0x808c8b90,0x80939297,0x80ededed,0x80ffffff,
+0x80fefeff,0x80fdfdff,0x80f3f3f5,0x80ebebed,0x8099999b,0x808c8c8e,
+0x808f8f91,0x808d8d8f,0x80a3a3a5,0x80fcfcfe,0x80ffffff,0x80e4e4e6,
+0x80d1d1d1,0x80ffffff,0x80ffffff,0x80ffffff,0x80f3f3f3,0x80a4a4a6,
+0x808a8a8c,0x80909092,0x808b8a8f,0x8056555a,0x80868688,0x808f8f91,0x8088878c,0x80b3b3b5,0x80ffffff,0x80feffff,
+0x80dfdfe1,0x80838385,0x80b8b8ba,0x80fcfcfe,0x80fcfcfe,0x80d7d7d9,
+0x808c8c8e,0x808e8e90,0x80908f94,0x80909092,0x8088888a,0x80949496,
+0x80dadadc,0x80fdfdff,0x80ffffff,0x80ffffff,0x80ffffff,0x80fefeff,
+0x80fefeff,0x80e8e8ea,0x809e9ea0,0x808a8a8c,0x80939395,0x808e8d92,
+0x80939297,0x808b8b8d,0x809d9d9f,0x80ececee,0x80ffffff,0x80fcfcfe,
+0x80ffffff,0x80fdfdff,0x80e5e4e9,0x808a898e,0x80909092,0x8088888a,
+0x80a7a7a9,0x80ffffff,0x80fefefe,0x80e4e4e4,0x80dedee0,0x80ffffff,
+0x80ffffff,0x80f2f2f4,0x80b2b2b4,0x808c8c8e,0x80909092,0x808f8e93,
+0x80919095,0x808a8a8c,0x809e9ea0,0x80ffffff,0x80ffffff,0x80e6e6e8,
+0x80949496,0x808d8c91,0x80929294,0x80848486,0x80c0c0c2,0x80ffffff,
+0x80ffffff,0x80ceced0,0x80858587,0x808f8f91,0x80e6e6e6,0x80fefefe,
+0x80ffffff,0x80d3d3d5,0x808c8c8e,0x80909092,0x80929196,0x808c8b90,
+0x808b8b8d,0x809b9b9d,0x80dedee0,0x80ffffff,0x80fafafc,0x80fcfcfe,
+0x80ffffff,0x80fdfdff,0x80ffffff,0x80e7e7e7,0x8099999b,0x808e8e90,
+0x80939395,0x808c8c8e,0x808f8e93,0x80939297,0x80f5f5f7,0x80ffffff,
+0x80fdfdff,0x80fefeff,0x80fdfdff,0x80ffffff,0x80ccccce,0x808d8d8f,
+0x808e8d92,0x808f8e93,0x80908f94,0x80908f94,0x808f8e93,0x808f8e93,
+0x808f8e93,0x80908f94,0x80908f94,0x808f8f91,0x808d8d8f,0x80a2a2a4,
+0x80f1f1f3,0x80ffffff,0x80ffffff,0x80ffffff,0x80ffffff,0x80d2d2d4,
+0x808a8a8c,0x80919095,0x808a898e,0x80b0b0b2,0x80ffffff,0x80fefefe,
+0x80dbdadf,0x808a8a8c,0x80959597,0x808c8c8e,0x80939395,0x80f8f8fa,
+0x80ffffff,0x80ededef,0x808b8b8d,0x80c6c6c8,0x80ffffff,0x80ffffff,
+0x80bfbfc1,0x808c8c8e,0x80ededef,0x80ffffff,0x80f3f2f7,0x80949496,
+0x808e8e90,0x808f8f91,0x80919193,0x80dadadc,0x80ffffff,0x80fefeff,
+0x80a6a5aa,0x808a898e,0x80919193,0x80909092,0x808e8e90,0x8088888a,
+0x80cdcdcf,0x80ffffff,0x80fffeff,0x80abaaaf,0x808a898e,0x80908f94,
+0x80919095,0x808f8e93,0x808e8d92,0x808d8c91,0x80a5a5a7,0x80ececee,
+0x80ffffff,0x80ffffff,0x80fcfcfe,0x80ffffff,0x80a1a1a3,0x808d8c91,
+0x808f8e93,0x808b8b8d,0x80a7a7a9,0x80fefeff,0x80fdfdff,0x80e2e2e4,
+0x80dddddf,0x80ffffff,0x80ffffff,0x80ebebeb,0x80acacae,0x8088888a,
+0x808f8f91,0x808d8d8f,0x80949398,0x8057565b,0x80838385,0x808c8b90,0x808c8b90,0x80adadaf,0x80eaeaec,0x80ebecee,
+0x80ccccce,0x80878789,0x80aeaeb0,0x80ececee,0x80efeff1,0x80c7c7c9,
+0x808c8c8e,0x80919193,0x808c8b90,0x80919095,0x80929196,0x808c8c8e,
+0x808f8f91,0x80b8b8ba,0x80e1e1e3,0x80f4f4f6,0x80f0f0f2,0x80e8e8ea,
+0x80c5c5c7,0x80979799,0x8088888a,0x80929196,0x808b8a8f,0x80908f94,
+0x808c8b90,0x80929196,0x8089888d,0x80a0a0a2,0x80c8c8ca,0x80e1e1e3,
+0x80ececee,0x80eeeef0,0x80d1d0d5,0x8089888d,0x80919193,0x808b8b8d,
+0x80a1a1a3,0x80eaeaec,0x80f1f1f3,0x80d1d1d3,0x80ceced0,0x80dbdbdd,
+0x80c3c3c5,0x8099999b,0x808b8b8d,0x808f8e93,0x808b8a8f,0x80929196,
+0x80919095,0x808b8a8f,0x809e9ea0,0x80eeeeee,0x80ededed,0x80d2d2d4,
+0x80919095,0x80908f94,0x808d8d8f,0x808c8c8e,0x80b9b9bb,0x80ececee,
+0x80ededef,0x80c0c0c2,0x8089898b,0x808b8b8d,0x80a2a2a4,0x80ececee,
+0x80ececee,0x80a6a6a8,0x808b8b8d,0x80909092,0x808c8b90,0x80929196,
+0x80929294,0x8088888a,0x80929294,0x80bbbbbd,0x80ebebed,0x80f3f3f5,
+0x80f1f1f3,0x80e9e9eb,0x80c1c1c3,0x80959597,0x80868688,0x80909092,
+0x808e8e90,0x80909092,0x808e8d92,0x80949398,0x80dfdfe1,0x80ececee,
+0x80f2f2f4,0x80e5e5e7,0x80d7d7d9,0x80bababc,0x80929294,0x808d8d8f,
+0x808f8e93,0x808f8e93,0x80908f94,0x80908f94,0x808f8e93,0x808f8e93,
+0x808f8e93,0x80908f94,0x808e8d92,0x80929196,0x808e8d92,0x8088888a,
+0x809e9ea0,0x80cdcdcf,0x80dfdfe1,0x80ececee,0x80ececec,0x80c8c8ca,
+0x808c8b90,0x808e8d92,0x808b8a8f,0x80aeadb2,0x80e9e9eb,0x80ededed,
+0x80cccbd0,0x808d8c91,0x808c8b90,0x808b8b8d,0x809b9b9d,0x80e9e9eb,
+0x80eaeaec,0x80d7d7d9,0x80878789,0x809c9c9e,0x80ebebed,0x80ececee,
+0x809b9b9d,0x8089898b,0x80e0e0e2,0x80ececee,0x80dedde2,0x8097969b,
+0x808d8c91,0x808f8f91,0x808b8b8d,0x80c6c6c8,0x80efeff1,0x80ececee,
+0x80a3a2a7,0x808c8b90,0x80909092,0x808e8e90,0x808f8f91,0x808f8f91,
+0x80c5c5c7,0x80ececee,0x80ecebf0,0x80acabb0,0x808b8a8f,0x808c8b90,
+0x80929196,0x808f8e93,0x80908f94,0x808e8d92,0x808a8a8c,0x80979799,
+0x80c6c6c8,0x80dadadc,0x80ededef,0x80e7e6eb,0x809b9a9f,0x808a898e,
+0x808f8e93,0x808b8a8f,0x80a3a2a7,0x80ececee,0x80ededef,0x80d1d1d3,
+0x80cbcbcd,0x80dcdcde,0x80c0c0c2,0x809b9b9d,0x808a8a8c,0x808b8b8d,
+0x80919193,0x80959597,0x808b8a8f,0x8059585d,0x80858587,0x80919095,0x80908f94,0x8089888d,0x80909092,0x808d8e90,
+0x80939395,0x808a8a8c,0x808d8d8f,0x808f8f91,0x808d8d8f,0x80919193,
+0x80919193,0x808d8d8f,0x80929196,0x808d8c91,0x808f8e93,0x808e8d92,
+0x808d8d8f,0x808a8a8c,0x808e8e90,0x80949496,0x809b9b9d,0x808f8f91,
+0x80858587,0x808f8f91,0x80929196,0x808e8d92,0x80919095,0x80908f94,
+0x80919095,0x80919095,0x808f8e93,0x808a898e,0x808f8f91,0x808c8c8e,
+0x808c8c8e,0x808e8e90,0x80929294,0x808b8b8d,0x80909092,0x808f8f91,
+0x808f8f91,0x808d8d8f,0x808a8a8c,0x80909092,0x808f8f91,0x808d8d8f,
+0x8089898b,0x808c8c8e,0x80908f94,0x80908f94,0x80919095,0x808d8c91,
+0x808c8b90,0x80919095,0x808f8f91,0x808d8d8f,0x808a8a8c,0x80949496,
+0x808f8e93,0x808e8d92,0x808f8f91,0x808f8f91,0x808e8e90,0x808d8d8f,
+0x808e8e90,0x808f8f91,0x808d8d8f,0x80909092,0x808d8d8f,0x80939395,
+0x80969698,0x808c8c8e,0x80929294,0x808e8e90,0x808f8f91,0x80909092,
+0x808c8c8e,0x80909092,0x80929294,0x8088888a,0x808d8d8f,0x80959597,
+0x80979799,0x80909092,0x808a8a8c,0x808c8c8e,0x80919193,0x80959597,
+0x808e8e90,0x808f8f91,0x80949496,0x808e8e90,0x808d8d8f,0x808a8a8c,
+0x808d8d8f,0x808d8d8f,0x80909092,0x8088888a,0x808f8f91,0x808f8f91,
+0x808f8e93,0x808f8e93,0x80908f94,0x80908f94,0x808f8e93,0x808f8e93,
+0x808f8e93,0x80908f94,0x808f8e93,0x808e8d92,0x80908f94,0x80949398,
+0x808a8a8c,0x808f8f91,0x808d8d8f,0x808b8b8d,0x808b8b8d,0x80919193,
+0x80908f94,0x80939297,0x808d8c91,0x808e8d92,0x808c8c8e,0x80909092,
+0x80908f94,0x808c8b90,0x80919095,0x80929196,0x808a8a8c,0x80909092,
+0x808f8f91,0x808d8d8f,0x80929294,0x808b8b8d,0x80939395,0x808e8e90,
+0x80919193,0x808f8f91,0x808d8d8f,0x808c8c8e,0x808f8e93,0x808e8d92,
+0x808f8e93,0x80908f94,0x808f8f91,0x80929294,0x808c8c8e,0x808d8d8f,
+0x80929196,0x808a898e,0x808f8f91,0x80909092,0x80919193,0x808b8b8d,
+0x80909092,0x808e8e90,0x808e8d92,0x808d8c91,0x80919095,0x80939297,
+0x80908f94,0x808c8b90,0x808e8d92,0x80929196,0x80929294,0x808c8c8e,
+0x808a8a8c,0x808f8f91,0x80908f94,0x808b8a8f,0x80908f94,0x80919095,
+0x808e8d92,0x80959499,0x808c8b90,0x808e8d92,0x808c8c8e,0x80909092,
+0x80909092,0x808e8e90,0x8089898b,0x808d8d8f,0x80919193,0x80929294,
+0x808f8f91,0x808a8a8c,0x80919193,0x8059595b,0x80828284,0x808e8d92,0x80929196,0x808f8e93,0x808d8d8f,0x80909193,
+0x808d8c91,0x80939297,0x80908f94,0x80919095,0x80908f94,0x808d8c91,
+0x80919095,0x808f8e93,0x808d8c91,0x808e8d92,0x8096959a,0x808c8b90,
+0x80949496,0x80909092,0x80919193,0x808e8e90,0x808b8b8d,0x808c8c8e,
+0x80939395,0x80929294,0x8089888d,0x80908f94,0x80908f94,0x808f8e93,
+0x808f8e93,0x808d8c91,0x808f8e93,0x80929196,0x808d8d8f,0x808e8e90,
+0x80949496,0x808a8a8c,0x808e8e90,0x80919193,0x808d8d8f,0x80929196,
+0x80919095,0x808f8e93,0x80908f94,0x808f8e93,0x808c8c8e,0x808f8f91,
+0x80909092,0x80939395,0x808d8c91,0x808f8e93,0x808c8b90,0x80919095,
+0x80919095,0x808c8b90,0x80909092,0x808e8e90,0x80939395,0x808e8e90,
+0x808f8e93,0x80908f94,0x80919095,0x80908f94,0x808f8e93,0x808f8e93,
+0x808d8c91,0x808f8e93,0x80939297,0x808e8d92,0x808e8d92,0x808d8c91,
+0x808e8d92,0x808d8c91,0x808e8d92,0x808e8e90,0x80919193,0x808e8e90,
+0x80959597,0x808b8b8d,0x80919193,0x808f8f91,0x80909092,0x80909092,
+0x808b8b8d,0x80919193,0x808f8e93,0x80929196,0x808c8b90,0x808d8c91,
+0x80908f94,0x80919193,0x808b8b8d,0x80909092,0x808f8f91,0x80939395,
+0x808e8e90,0x808f8f91,0x808e8e90,0x808f8f91,0x80929294,0x808c8c8e,
+0x80908f94,0x80908f94,0x808f8e93,0x808f8e93,0x80908f94,0x80908f94,
+0x80908f94,0x808f8e93,0x808f8e93,0x80908f94,0x808f8e93,0x808e8d92,
+0x80909092,0x808d8d8f,0x808f8f91,0x808f8f91,0x80909092,0x80909092,
+0x808f8e93,0x808b8a8f,0x80908f94,0x80949398,0x808c8c8e,0x808f8f91,
+0x808f8e93,0x80929196,0x808e8d92,0x80908f94,0x80929294,0x808a8a8c,
+0x80909092,0x80929294,0x80909092,0x808f8f91,0x80919193,0x808e8e90,
+0x808e8e90,0x80909092,0x808e8e90,0x808f8f91,0x80908f94,0x80929196,
+0x808e8d92,0x808f8e93,0x808e8e90,0x80909092,0x808e8e90,0x808f8f91,
+0x808f8e93,0x80908f94,0x80919193,0x80909092,0x808d8d8f,0x808f8f91,
+0x808f8f91,0x808d8d8f,0x808f8e93,0x80919095,0x808e8d92,0x808d8c91,
+0x808e8d92,0x80929196,0x80908f94,0x808e8d92,0x808d8d8f,0x80929294,
+0x808e8e90,0x808f8f91,0x808d8c91,0x80919095,0x808f8e93,0x80908f94,
+0x80908f94,0x808f8e93,0x808e8d92,0x80919095,0x80929294,0x808f8f91,
+0x808b8b8d,0x80919193,0x808f8e93,0x80919095,0x808e8d92,0x808c8b90,
+0x80929196,0x80909092,0x808e8e90,0x8059595b,0x80878789,0x808f8e93,0x808c8b90,0x80908f94,0x80919193,0x808d8e90,
+0x80908f94,0x808f8e93,0x808f8e93,0x808c8b90,0x80908f94,0x80908f94,
+0x808d8c91,0x80929196,0x808e8d92,0x80939297,0x808b8a8f,0x80929196,
+0x808e8d92,0x808e8e90,0x80919193,0x808f8f91,0x80919193,0x80909092,
+0x808d8d8f,0x808c8b90,0x80959499,0x808e8d92,0x808f8e93,0x808f8e93,
+0x80908f94,0x80939297,0x808d8c91,0x80908f94,0x80908f94,0x80909092,
+0x808b8b8d,0x80919193,0x808f8f91,0x80909092,0x80909092,0x808f8e93,
+0x808c8b90,0x80939297,0x808e8d92,0x808f8e93,0x80919193,0x808f8f91,
+0x808e8e90,0x808f8e93,0x80919095,0x808f8e93,0x80929196,0x808e8d92,
+0x808f8e93,0x808f8e93,0x80909092,0x808f8f91,0x808e8e90,0x80909092,
+0x80908f94,0x80908f94,0x808e8d92,0x80908f94,0x808f8e93,0x808f8e93,
+0x80919095,0x808c8b90,0x808d8c91,0x80908f94,0x80908f94,0x80919095,
+0x808d8c91,0x80919095,0x808f8e93,0x80909092,0x808e8e90,0x808f8f91,
+0x808d8d8f,0x80919193,0x80909092,0x80929294,0x808f8f91,0x808d8d8f,
+0x80919193,0x808d8d8f,0x80919095,0x808e8d92,0x80919095,0x80919095,
+0x80929196,0x808d8d8f,0x80939395,0x808e8e90,0x80909092,0x808b8b8d,
+0x80919193,0x80909092,0x80909092,0x80909092,0x808f8f91,0x80929294,
+0x80908f94,0x80908f94,0x808f8e93,0x808f8e93,0x80908f94,0x80908f94,
+0x80908f94,0x808f8e93,0x80908f94,0x808f8e93,0x808f8e93,0x80929196,
+0x808d8c91,0x80929294,0x808b8b8d,0x80929294,0x80909092,0x80909092,
+0x80908f94,0x80908f94,0x808f8e93,0x808c8b90,0x80949496,0x808e8e90,
+0x808f8e93,0x808d8c91,0x80919095,0x808d8c91,0x80929196,0x808f8f91,
+0x80929294,0x808d8d8f,0x808e8e90,0x80939395,0x808e8e90,0x80919193,
+0x808e8e90,0x808f8f91,0x80929294,0x808d8d8f,0x808d8c91,0x80908f94,
+0x808f8e93,0x80908f94,0x808e8d92,0x80909092,0x808e8e90,0x808f8f91,
+0x80908f94,0x80919095,0x808e8e90,0x80909092,0x808d8d8f,0x80919193,
+0x808e8e90,0x80919193,0x80908f94,0x808f8e93,0x808e8d92,0x80939297,
+0x808f8e93,0x808f8e93,0x808d8c91,0x80919095,0x80919193,0x808e8e90,
+0x80919193,0x808e8d92,0x80929196,0x808c8b90,0x80929196,0x808f8e93,
+0x80908f94,0x808d8c91,0x80949398,0x808e8d92,0x808c8b90,0x80919193,
+0x80919193,0x808e8e90,0x808e8d92,0x80908f94,0x808e8d92,0x80949398,
+0x808c8b90,0x80919193,0x80929294,0x8059595b,0x80828284,0x80919193,0x808b8b8d,0x80929294,0x808b8b8d,0x80919193,
+0x80909092,0x808f8f91,0x808f8f91,0x80919193,0x80919193,0x808f8f91,
+0x808e8e90,0x808f8f91,0x808f8f91,0x808e8e90,0x808e8e90,0x80909092,
+0x80909092,0x808e8e90,0x808e8e90,0x80909092,0x80919193,0x808f8f91,
+0x808f8f91,0x80909092,0x808f8f91,0x808d8d8f,0x808e8e90,0x80919193,
+0x808e8e90,0x80909092,0x80919193,0x808f8f91,0x808f8f91,0x80909092,
+0x80909092,0x808f8f91,0x808d8d8f,0x80909092,0x80919193,0x808f8f91,
+0x808f8f91,0x80919193,0x80909092,0x808e8e90,0x80919193,0x80909092,
+0x808f8f91,0x808f8f91,0x80909092,0x80919193,0x80909092,0x80909092,
+0x80909092,0x80909092,0x808f8f91,0x808f8f91,0x808f8f91,0x80909092,
+0x808f8f91,0x808d8d8f,0x808f8f91,0x808e8e90,0x808e8e90,0x80909092,
+0x80909092,0x808e8e90,0x808e8e90,0x808f8f91,0x80909092,0x808f8f91,
+0x808e8e90,0x80909092,0x80909092,0x808e8e90,0x808e8e90,0x808f8f91,
+0x80909092,0x80909092,0x808f8f91,0x808f8f91,0x808f8f91,0x808f8f91,
+0x80909092,0x80909092,0x808f8f91,0x808e8e90,0x808f8f91,0x80919193,
+0x80909092,0x808d8d8f,0x808e8e90,0x80919193,0x808e8e90,0x80909092,
+0x80909092,0x808f8f91,0x808f8f91,0x808f8f91,0x808f8f91,0x808e8e90,
+0x808e8e90,0x80909092,0x80919193,0x808f8f91,0x808e8e90,0x808f8f91,
+0x80909092,0x808f8f91,0x808f8f91,0x808f8f91,0x808f8f91,0x80909092,
+0x80909092,0x80909092,0x80909092,0x808f8f91,0x808e8e90,0x80909092,
+0x80909092,0x808e8e90,0x808e8e90,0x80909092,0x80909092,0x808d8d8f,
+0x808f8f91,0x808f8f91,0x808f8f91,0x808f8f91,0x80909092,0x80909092,
+0x80909092,0x808f8f91,0x80919193,0x808f8f91,0x808f8f91,0x80909092,
+0x80909092,0x808f8f91,0x808f8f91,0x808f8f91,0x808f8f91,0x808f8f91,
+0x808f8f91,0x808f8f91,0x80909092,0x80909092,0x808f8f91,0x808f8f91,
+0x80909092,0x808f8f91,0x808f8f91,0x80909092,0x808f8f91,0x808e8e90,
+0x808f8f91,0x80909092,0x80909092,0x808f8f91,0x808f8f91,0x80909092,
+0x80909092,0x808f8f91,0x808f8f91,0x808f8f91,0x808f8f91,0x80919193,
+0x80919193,0x808f8f91,0x808e8e90,0x808f8f91,0x80909092,0x808f8f91,
+0x808f8f91,0x808f8f91,0x808f8f91,0x808e8e90,0x808f8f91,0x80909092,
+0x80909092,0x808f8f91,0x80919193,0x808f8f91,0x808b8b8d,0x80949496,
+0x808e8e90,0x80909092,0x808f8f91,0x805b5b5d,
+};
+/****************************************************************/
+static  void smit_480cfg_logo_init()
+{
+
+#if (COLORTYPE==ARGB8888)
+	stsys_WRITEREGDEV32LE(GDP1_NODE_TOP_ADDRESS + 0x00 , 0x80000005);
+#else
+	stsys_WRITEREGDEV32LE(GDP1_NODE_TOP_ADDRESS + 0x00 , 0x80000000);
+#endif
+	stsys_WRITEREGDEV32LE(GDP1_NODE_TOP_ADDRESS + 0x04 , 0x00808080);
+	stsys_WRITEREGDEV32LE(GDP1_NODE_TOP_ADDRESS + 0x08 , 0x00000100);
+	stsys_WRITEREGDEV32LE(GDP1_NODE_TOP_ADDRESS + 0x0c , /*0x0007007a*/0x0025007a);
+
+	stsys_WRITEREGDEV32LE(GDP1_NODE_TOP_ADDRESS + 0x10 , /*0x01e60349*/0x02040349);
+	stsys_WRITEREGDEV32LE(GDP1_NODE_TOP_ADDRESS + 0x14 , HD_PIC_LAOD_PHY_ADDRESS);
+#if (COLORTYPE==ARGB8888)
+	stsys_WRITEREGDEV32LE(GDP1_NODE_TOP_ADDRESS + 0x18 , 0x00000b40);
+#else
+	stsys_WRITEREGDEV32LE(GDP1_NODE_TOP_ADDRESS + 0x18 , 0x000005a0);//GR Test adeed
+#endif
+	stsys_WRITEREGDEV32LE(GDP1_NODE_TOP_ADDRESS + 0x1c , 0x01E002d0);
+
+	stsys_WRITEREGDEV32LE(GDP1_NODE_TOP_ADDRESS + 0x20 , 0x00000100);
+	stsys_WRITEREGDEV32LE(GDP1_NODE_TOP_ADDRESS + 0x24 , GDP1_NODE_TOP_PHY_ADDRESS);
+	stsys_WRITEREGDEV32LE(GDP1_NODE_TOP_ADDRESS + 0x28 , 0x00000000);
+	stsys_WRITEREGDEV32LE(GDP1_NODE_TOP_ADDRESS + 0x2c , 0x00000000);
+
+	stsys_WRITEREGDEV32LE(GDP1_NODE_TOP_ADDRESS + 0x30 , 0x48000fc0);
+	stsys_WRITEREGDEV32LE(GDP1_NODE_TOP_ADDRESS + 0x34 , 0x00000000);
+	stsys_WRITEREGDEV32LE(GDP1_NODE_TOP_ADDRESS + 0x38 , 0x480011a0);
+	stsys_WRITEREGDEV32LE(GDP1_NODE_TOP_ADDRESS + 0x3c , 0x8092226c);
+
+
+#if (COLORTYPE==ARGB8888)
+	stsys_WRITEREGDEV32LE(GDP3_NODE_TOP_ADDRESS + 0x00 , 0x80000005);
+#else
+	stsys_WRITEREGDEV32LE(GDP3_NODE_TOP_ADDRESS + 0x00 , 0x80000000);//GR Test added
+#endif
+	stsys_WRITEREGDEV32LE(GDP3_NODE_TOP_ADDRESS + 0x04 , 0x00808080);
+	stsys_WRITEREGDEV32LE(GDP3_NODE_TOP_ADDRESS + 0x08 , 0x00000000);
+	stsys_WRITEREGDEV32LE(GDP3_NODE_TOP_ADDRESS + 0x0c , /*0x0007007b*/0x00250078);
+
+	stsys_WRITEREGDEV32LE(GDP3_NODE_TOP_ADDRESS + 0x10 , /*0x01e5034a*/0x02030347);
+	stsys_WRITEREGDEV32LE(GDP3_NODE_TOP_ADDRESS + 0x14 , SD_PIC_LAOD_PHY_ADDRESS);
+#if (COLORTYPE==ARGB8888)
+	stsys_WRITEREGDEV32LE(GDP3_NODE_TOP_ADDRESS + 0x18 , 0x00001680);
+#else
+	stsys_WRITEREGDEV32LE(GDP3_NODE_TOP_ADDRESS + 0x18 , 0x00000b40);//GR Test adeed
+#endif
+	stsys_WRITEREGDEV32LE(GDP3_NODE_TOP_ADDRESS + 0x1c , 0x01e002d0);
+
+	stsys_WRITEREGDEV32LE(GDP3_NODE_TOP_ADDRESS + 0x20 , 0x00000000);
+	stsys_WRITEREGDEV32LE(GDP3_NODE_TOP_ADDRESS + 0x24 , GDP3_NODE_BOTTOM_PHY_ADDRESS);
+	stsys_WRITEREGDEV32LE(GDP3_NODE_TOP_ADDRESS + 0x28 , 0x00000000);
+	stsys_WRITEREGDEV32LE(GDP3_NODE_TOP_ADDRESS + 0x2c , 0x00000000);
+
+
+	stsys_WRITEREGDEV32LE(GDP3_NODE_TOP_ADDRESS + 0x30 , 0x00000000);
+	stsys_WRITEREGDEV32LE(GDP3_NODE_TOP_ADDRESS + 0x34 , 0x00000000);
+	stsys_WRITEREGDEV32LE(GDP3_NODE_TOP_ADDRESS + 0x38 , 0x00000000);
+	stsys_WRITEREGDEV32LE(GDP3_NODE_TOP_ADDRESS + 0x3c , 0x00000000);
+
+
+#if (COLORTYPE==ARGB8888)
+	stsys_WRITEREGDEV32LE(GDP3_NODE_BOTTOM_ADDRESS + 0x00 , 0x80000005);
+#else
+	stsys_WRITEREGDEV32LE(GDP3_NODE_BOTTOM_ADDRESS + 0x00 , 0x80000000);//GR Tst added
+#endif
+	stsys_WRITEREGDEV32LE(GDP3_NODE_BOTTOM_ADDRESS + 0x04 , 0x00808080);
+	stsys_WRITEREGDEV32LE(GDP3_NODE_BOTTOM_ADDRESS + 0x08 , 0x01000100);
+	stsys_WRITEREGDEV32LE(GDP3_NODE_BOTTOM_ADDRESS + 0x0c , /*0x0007007b*/0x00260078);
+
+	stsys_WRITEREGDEV32LE(GDP3_NODE_BOTTOM_ADDRESS + 0x10 , /*0x01e6034a*/0x02040347);
+#if (COLORTYPE==ARGB8888)
+	stsys_WRITEREGDEV32LE(GDP3_NODE_BOTTOM_ADDRESS + 0x14 , SD_PIC_LAOD_PHY_ADDRESS+0xb40);
+#else
+	stsys_WRITEREGDEV32LE(GDP3_NODE_BOTTOM_ADDRESS + 0x14 , SD_PIC_LAOD_PHY_ADDRESS+0x5a0);//GR
+#endif
+
+#if (COLORTYPE==ARGB8888)
+	stsys_WRITEREGDEV32LE(GDP3_NODE_BOTTOM_ADDRESS + 0x18 , 0x00001680);
+#else
+	stsys_WRITEREGDEV32LE(GDP3_NODE_BOTTOM_ADDRESS + 0x18 , 0x00000b40);//GR Test added
+#endif
+
+	stsys_WRITEREGDEV32LE(GDP3_NODE_BOTTOM_ADDRESS + 0x1c , 0x01e002d0);
+
+	stsys_WRITEREGDEV32LE(GDP3_NODE_BOTTOM_ADDRESS + 0x20 , 0x00000100);
+	stsys_WRITEREGDEV32LE(GDP3_NODE_BOTTOM_ADDRESS + 0x24 , GDP3_NODE_TOP_PHY_ADDRESS);
+	stsys_WRITEREGDEV32LE(GDP3_NODE_BOTTOM_ADDRESS + 0x28 , 0x00000000);
+	stsys_WRITEREGDEV32LE(GDP3_NODE_BOTTOM_ADDRESS + 0x2c , 0x00000000);
+
+
+	stsys_WRITEREGDEV32LE(GDP3_NODE_BOTTOM_ADDRESS + 0x30 , 0x00000000);
+	stsys_WRITEREGDEV32LE(GDP3_NODE_BOTTOM_ADDRESS + 0x34 , 0x00000000);
+	stsys_WRITEREGDEV32LE(GDP3_NODE_BOTTOM_ADDRESS + 0x38 , 0x00000000);
+	stsys_WRITEREGDEV32LE(GDP3_NODE_BOTTOM_ADDRESS + 0x3c , 0x00000000);
+
+	WriteRegister((volatile ULONG *)0xfe000010,0x0000c0de);
+	WriteRegister((volatile ULONG *)0xfe0000b8,0x00000001);
+	WriteRegister((volatile ULONG *)0xfe030810,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe20ac34,0x00003aa1);
+	WriteRegister((volatile ULONG *)0xfe20ad34,0x0000002a);
+	WriteRegister((volatile ULONG *)0xfe20a1fc,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe20a1ec,0x00000006);
+	WriteRegister((volatile ULONG *)0xfe20a1f0,0x00000005);
+	WriteRegister((volatile ULONG *)0xfe20a1f4,0x00000003);
+	WriteRegister((volatile ULONG *)0xfe20a1f8,0x00000003);
+	WriteRegister((volatile ULONG *)0xfe20a1fc,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe20a2fc,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe20a2ec,0x00000006);
+	WriteRegister((volatile ULONG *)0xfe20a2f0,0x00000005);
+	WriteRegister((volatile ULONG *)0xfe20a2f4,0x00000003);
+	WriteRegister((volatile ULONG *)0xfe20a2f8,0x00000003);
+	WriteRegister((volatile ULONG *)0xfe20a2fc,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe20a3fc,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe20a3ec,0x00000006);
+	WriteRegister((volatile ULONG *)0xfe20a3f0,0x00000005);
+	WriteRegister((volatile ULONG *)0xfe20a3f4,0x00000003);
+	WriteRegister((volatile ULONG *)0xfe20a3f8,0x00000003);
+	WriteRegister((volatile ULONG *)0xfe20a3fc,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe002000,0x00000001);
+	WriteRegister((volatile ULONG *)0xfe002100,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe0020b0,0x000000a3);
+	WriteRegister((volatile ULONG *)0xfe00212c,0x478abc10);
+	WriteRegister((volatile ULONG *)0xfe002130,0x41fdbb70);
+	WriteRegister((volatile ULONG *)0xfe002230,0x20201004);
+	WriteRegister((volatile ULONG *)0xfe002238,0x000101c4);
+	WriteRegister((volatile ULONG *)0xfe002240,0x478abe08);
+	WriteRegister((volatile ULONG *)0xfe00224c,0x00000100);
+	WriteRegister((volatile ULONG *)0xfe002250,0x00000100);
+	WriteRegister((volatile ULONG *)0xfe002228,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe002208,0x00004000);
+	WriteRegister((volatile ULONG *)0xfe002208,0x00004000);
+	WriteRegister((volatile ULONG *)0xfe002220,0x4767e408);
+	WriteRegister((volatile ULONG *)0xfe002208,0x00004010);
+	WriteRegister((volatile ULONG *)0xfe002208,0x00004010);
+	WriteRegister((volatile ULONG *)0xfe002228,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe002208,0x00004000);
+	WriteRegister((volatile ULONG *)0xfe002220,0x4767e408);
+	WriteRegister((volatile ULONG *)0xfe002208,0x00004010);
+	WriteRegister((volatile ULONG *)0xfe00222c,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe002234,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe00222c,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe002238,0x000101c4);
+	WriteRegister((volatile ULONG *)0xfe00223c,0x00000001);
+	WriteRegister((volatile ULONG *)0xfe002200,0x00000001);
+	WriteRegister((volatile ULONG *)0xfe003000,0x00000001);
+	WriteRegister((volatile ULONG *)0xfe003100,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe00312c,0x478ab810);
+	WriteRegister((volatile ULONG *)0xfe003130,0x41fdbd70);
+	WriteRegister((volatile ULONG *)0xfe20a0ec,0x00000006);
+	WriteRegister((volatile ULONG *)0xfe20a0f0,0x00000005);
+	WriteRegister((volatile ULONG *)0xfe20a0f4,0x00000003);
+	WriteRegister((volatile ULONG *)0xfe20a0f8,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe20a0fc,0x00000003);
+	WriteRegister((volatile ULONG *)0xfe030800,0x00000048);
+	WriteRegister((volatile ULONG *)0xfe030400,0x00000870);
+	WriteRegister((volatile ULONG *)0xfe030408,0x00000260);
+	WriteRegister((volatile ULONG *)0xfd104e08,0x00000039);
+	WriteRegister((volatile ULONG *)0xfd104e00,0x00000a50);
+	WriteRegister((volatile ULONG *)0xfd104e40,0x00000002);
+	WriteRegister((volatile ULONG *)0xfd104e00,0x00000a50);
+	WriteRegister((volatile ULONG *)0xfd104000,0x00000000);
+	WriteRegister((volatile ULONG *)0xfd10400c,0xffffffff);
+	WriteRegister((volatile ULONG *)0xfd104110,0x00000000);
+	WriteRegister((volatile ULONG *)0xfd104114,0x00000000);
+	WriteRegister((volatile ULONG *)0xfd104118,0x00000060);
+	WriteRegister((volatile ULONG *)0xfe001108,0x0c000000);
+	WriteRegister((volatile ULONG *)0xfe210000,0x00007ff6);
+	WriteRegister((volatile ULONG *)0xfe21001c,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe210018,0x00000004);
+	WriteRegister((volatile ULONG *)0xfe210010,0x000000f3);
+	WriteRegister((volatile ULONG *)0xfe210014,0x00003c00);
+	WriteRegister((volatile ULONG *)0xfe21001c,0x00000001);
+	WriteRegister((volatile ULONG *)0xfe210000,0x00007ffe);
+	WriteRegister((volatile ULONG *)0xfe21002c,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe210028,0x00000004);
+	WriteRegister((volatile ULONG *)0xfe210020,0x000000f3);
+	WriteRegister((volatile ULONG *)0xfe210024,0x00003c00);
+	WriteRegister((volatile ULONG *)0xfe21002c,0x00000001);
+	WriteRegister((volatile ULONG *)0xfe210000,0x00007ffe);
+	WriteRegister((volatile ULONG *)0xfe21003c,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe210038,0x00000004);
+	WriteRegister((volatile ULONG *)0xfe210030,0x000000f3);
+	WriteRegister((volatile ULONG *)0xfe210034,0x00003c00);
+	WriteRegister((volatile ULONG *)0xfe21003c,0x00000001);
+	WriteRegister((volatile ULONG *)0xfd104200,0x00001002);
+	WriteRegister((volatile ULONG *)0xfd104004,0x00000011);
+	WriteRegister((volatile ULONG *)0xfe030900,0x00000649);
+	WriteRegister((volatile ULONG *)0xfd104004,0x00000011);
+	WriteRegister((volatile ULONG *)0xfd104000,0x00000000);
+	WriteRegister((volatile ULONG *)0xfd104200,0x003d1002);
+	WriteRegister((volatile ULONG *)0xfd104244,0x0000000f);
+	WriteRegister((volatile ULONG *)0xfe00110c,0x32644000);
+	WriteRegister((volatile ULONG *)0xfe001108,0x0c000000);
+	WriteRegister((volatile ULONG *)0xfd104200,0x003d1002);
+	WriteRegister((volatile ULONG *)0xfd104244,0x0000000f);
+	WriteRegister((volatile ULONG *)0xfd104400,0x00001800);
+	WriteRegister((volatile ULONG *)0xfe030900,0x00000448);
+	WriteRegister((volatile ULONG *)0xfd104020,0x00004807);
+	WriteRegister((volatile ULONG *)0xfd104200,0x003d1002);
+	WriteRegister((volatile ULONG *)0xfd104244,0x0000000f);
+	WriteRegister((volatile ULONG *)0xfd104020,0x00004807);
+	WriteRegister((volatile ULONG *)0xfd104200,0x003d1002);
+	WriteRegister((volatile ULONG *)0xfd104020,0x00004807);
+	WriteRegister((volatile ULONG *)0xfe030980,0x00000448);
+	WriteRegister((volatile ULONG *)0xfe20ba00,0x80000000);
+	WriteRegister((volatile ULONG *)0xfe20ba00,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe20bb04,0x00000005);
+	WriteRegister((volatile ULONG *)0xfe20bb08,0x00000003);
+	WriteRegister((volatile ULONG *)0xfe20bb0c,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe20bb10,0x00000002);
+	WriteRegister((volatile ULONG *)0xfe20bb24,0x00000005);
+	WriteRegister((volatile ULONG *)0xfe20bb28,0x00000003);
+	WriteRegister((volatile ULONG *)0xfe20bb2c,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe20bb30,0x00000002);
+	WriteRegister((volatile ULONG *)0xfe20bb44,0x00000005);
+	WriteRegister((volatile ULONG *)0xfe20bb48,0x00000003);
+	WriteRegister((volatile ULONG *)0xfe20bb4c,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe20bb50,0x00000002);
+	WriteRegister((volatile ULONG *)0xfe20bb84,0x00000005);
+	WriteRegister((volatile ULONG *)0xfe20bb88,0x00000003);
+	WriteRegister((volatile ULONG *)0xfe20bb8c,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe20bb90,0x00000002);
+	WriteRegister((volatile ULONG *)0xfe20ba60,0x80c00003);
+	WriteRegister((volatile ULONG *)0xfe20ba64,0x41085000);
+	WriteRegister((volatile ULONG *)0xfe20ba70,0x80c00002);
+	WriteRegister((volatile ULONG *)0xfe20ba74,0x410b5000);
+	WriteRegister((volatile ULONG *)0xfe20ba80,0x80c00001);
+	WriteRegister((volatile ULONG *)0xfe20ba84,0x410e5000);
+	WriteRegister((volatile ULONG *)0xfe030980,0x00000148);
+	WriteRegister((volatile ULONG *)0xfe030900,0x00000148);
+	WriteRegister((volatile ULONG *)0xfe030900,0x00000148);
+	WriteRegister((volatile ULONG *)0xfe030980,0x00000148);
+	WriteRegister((volatile ULONG *)0xfe20ac04,0x00101060);
+	WriteRegister((volatile ULONG *)0xfe20ac00,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe20ac28,0x0007007a);
+	WriteRegister((volatile ULONG *)0xfe20ac2c,0x02040349);
+	WriteRegister((volatile ULONG *)0xfe20ac04,0x00101060);
+	WriteRegister((volatile ULONG *)0xfe20ac0c,0x0025007a);
+	WriteRegister((volatile ULONG *)0xfe20ac10,0x02040349);
+	WriteRegister((volatile ULONG *)0xfe20ac00,0x00000001);
+	WriteRegister((volatile ULONG *)0xfe20ac38,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe000010,0x0000c0de);
+	WriteRegister((volatile ULONG *)0xfe0000a4,0x00003411);
+	WriteRegister((volatile ULONG *)0xfe030404,0x0000008a);
+	WriteRegister((volatile ULONG *)0xfe030800,0x00000048);
+	WriteRegister((volatile ULONG *)0xfe030b00,0x00000903);
+	WriteRegister((volatile ULONG *)0xfe030b04,0x00000f1a);
+	WriteRegister((volatile ULONG *)0xfe030b08,0x0000013a);
+	WriteRegister((volatile ULONG *)0xfe030b0c,0x00001805);
+	WriteRegister((volatile ULONG *)0xfe030b10,0x00000903);
+	WriteRegister((volatile ULONG *)0xfe030b14,0x00000c3c);
+	WriteRegister((volatile ULONG *)0xfe030b18,0x0000003a);
+	WriteRegister((volatile ULONG *)0xfe030b1c,0x00001a06);
+	WriteRegister((volatile ULONG *)0xfe030b20,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030b24,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030b28,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030b2c,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030b30,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030b34,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030b38,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030b3c,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030b40,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030b44,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030b48,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030b4c,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030b50,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030b54,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030b58,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030b5c,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030b60,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030b64,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030b68,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030b6c,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030b70,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030b74,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030b78,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030b7c,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030b80,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030b84,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030b88,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030b8c,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030b90,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030b94,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030b98,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030b9c,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030ba0,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030ba4,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030ba8,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030bac,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030bb0,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030bb4,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030bb8,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030bbc,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030bc0,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030bc4,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030bc8,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030bcc,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030bd0,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030bd4,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030bd8,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030bdc,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030be0,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030be4,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030be8,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030bec,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030bf0,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030bf4,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030bf8,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030bfc,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030800,0x68000048);
+	WriteRegister((volatile ULONG *)0xfe000020,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe000024,0x00000001);
+	WriteRegister((volatile ULONG *)0xfe000018,0xfffffff1);
+	WriteRegister((volatile ULONG *)0xfe00001c,0x00001c72);
+	WriteRegister((volatile ULONG *)0xfe000020,0x00000001);
+	WriteRegister((volatile ULONG *)0xfe030324,0x00000200);
+	WriteRegister((volatile ULONG *)0xfe030328,0x0000035a);
+	WriteRegister((volatile ULONG *)0xfe030340,0x0000041a);
+	WriteRegister((volatile ULONG *)0xfe03032c,0x00360352);
+	WriteRegister((volatile ULONG *)0xfe030330,0x0006020d);
+	WriteRegister((volatile ULONG *)0xfe030334,0x0006020d);
+	WriteRegister((volatile ULONG *)0xfe030338,0x03520352);
+	WriteRegister((volatile ULONG *)0xfe03033c,0x03520352);
+	WriteRegister((volatile ULONG *)0xfe03035c,0x003e0000);
+	WriteRegister((volatile ULONG *)0xfe030360,0x00070001);
+	WriteRegister((volatile ULONG *)0xfe030364,0x00070001);
+	WriteRegister((volatile ULONG *)0xfe030368,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe03036c,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe03037c,0x00060044);
+	WriteRegister((volatile ULONG *)0xfe030380,0x00010007);
+	WriteRegister((volatile ULONG *)0xfe030384,0x00010007);
+	WriteRegister((volatile ULONG *)0xfe030388,0x00060006);
+	WriteRegister((volatile ULONG *)0xfe03038c,0x00060006);
+	WriteRegister((volatile ULONG *)0xfe030324,0x00000200);
+	WriteRegister((volatile ULONG *)0xfe030398,0x00000018);
+	WriteRegister((volatile ULONG *)0xfe030324,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe030348,0x00000001);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe0000a4,0x00003411);
+	WriteRegister((volatile ULONG *)0xfd104e08,0x00000939);
+	WriteRegister((volatile ULONG *)0xfe030408,0x00000260);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfd104e04,0x0000003b);
+	WriteRegister((volatile ULONG *)0xfe030814,0x01ed0005);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe030840,0x01ed0005);
+	WriteRegister((volatile ULONG *)0xfe030818,0x00fc827f);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe03081c,0x008fe20b);
+	WriteRegister((volatile ULONG *)0xfe030820,0x00f684fc);
+	WriteRegister((volatile ULONG *)0xfe030824,0x050f7c24);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe030828,0x00f4857c);
+	WriteRegister((volatile ULONG *)0xfe03082c,0x0a1f402e);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe030830,0x00fa027f);
+	WriteRegister((volatile ULONG *)0xfe030834,0x0e076e1d);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe030844,0x00fc827f);
+	WriteRegister((volatile ULONG *)0xfe030848,0x008fe20b);
+	WriteRegister((volatile ULONG *)0xfe03084c,0x00f684fc);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe030850,0x050f7c24);
+	WriteRegister((volatile ULONG *)0xfe030854,0x00f4857c);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe030858,0x0a1f402e);
+	WriteRegister((volatile ULONG *)0xfe03085c,0x00fa027f);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe030860,0x0e076e1d);
+	WriteRegister((volatile ULONG *)0xfe030800,0x68000048);
+	WriteRegister((volatile ULONG *)0xfe030808,0x00d20278);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe03080c,0x00d20278);
+	WriteRegister((volatile ULONG *)0xfe030838,0x00d20278);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe030800,0x68000349);
+	WriteRegister((volatile ULONG *)0xfe00110c,0x32644000);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe030400,0x00000070);
+	WriteRegister((volatile ULONG *)0xfe030900,0x00000349);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe20a124,GDP1_NODE_TOP_PHY_ADDRESS);
+	WriteRegister((volatile ULONG *)0xfe20ac00,0x00000009);
+	WriteRegister((volatile ULONG *)0xfe20ac38,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe20ad04,0x00101060);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfd104004,0x00000011);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfd104000,0x00000000);
+	WriteRegister((volatile ULONG *)0xfd104200,0x003d1002);
+	WriteRegister((volatile ULONG *)0xfe000010,0x0000c0de);
+	WriteRegister((volatile ULONG *)0xfe0000a4,0x00001611);
+	WriteRegister((volatile ULONG *)0xfe000068,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfd104244,0x0000000f);
+	WriteRegister((volatile ULONG *)0xfe00006c,0x00000001);
+	WriteRegister((volatile ULONG *)0xfe000060,0xfffffff1);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe000064,0x00001c72);
+	WriteRegister((volatile ULONG *)0xfe000068,0x00000001);
+	WriteRegister((volatile ULONG *)0xfe00110c,0x32644000);
+	WriteRegister((volatile ULONG *)0xfe001108,0x0c000000);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe0000a8,0x00000006);
+	WriteRegister((volatile ULONG *)0xfd104e04,0x00000011);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe030800,0x68000349);
+	WriteByteRegister((volatile UCHAR *)0xfe0301a8,0x1d);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteByteRegister((volatile UCHAR *)0xfe030044,0x75);
+	WriteByteRegister((volatile UCHAR *)0xfe030048,0xd8);
+	WriteRegister((volatile ULONG *)0xfd104004,0x00000011);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteByteRegister((volatile UCHAR *)0xfe030048,0xd7);
+	WriteByteRegister((volatile UCHAR *)0xfe03004c,0x9e);
+	WriteByteRegister((volatile UCHAR *)0xfe0301ac,0x1e);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteByteRegister((volatile UCHAR *)0xfe03017c,0x17);
+	WriteRegister((volatile ULONG *)0xfd104000,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe20ad00,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe20ad28,0x00050077);
+	WriteRegister((volatile ULONG *)0xfe20ad2c,0x02050346);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfd104200,0x003d1002);
+	WriteRegister((volatile ULONG *)0xfe20ad04,0x00101060);
+	WriteRegister((volatile ULONG *)0xfe20ad0c,0x00260077);
+	WriteRegister((volatile ULONG *)0xfe20ad10,0x02050346);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfd104244,0x0000000f);
+	WriteRegister((volatile ULONG *)0xfe20ad00,0x00000001);
+	WriteRegister((volatile ULONG *)0xfe20ad38,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe000068,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe00006c,0x00000001);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe000060,0xfffffff1);
+	WriteRegister((volatile ULONG *)0xfe000064,0x00001c72);
+	WriteRegister((volatile ULONG *)0xfe000068,0x00000001);
+	WriteRegister((volatile ULONG *)0xfe00110c,0x32644000);
+	WriteRegister((volatile ULONG *)0xfe001108,0x0c000000);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe001104,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe001108,0x08060000);
+	WriteRegister((volatile ULONG *)0xfe00110c,0x32644000);
+	WriteRegister((volatile ULONG *)0xfe030224,0x00000200);
+	WriteRegister((volatile ULONG *)0xfe030228,0x0000035a);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe030240,0x0000020d);
+	WriteRegister((volatile ULONG *)0xfe03022c,0x003a0356);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe030230,0x0107ffff);
+	WriteRegister((volatile ULONG *)0xfe030234,0xffff0106);
+	WriteRegister((volatile ULONG *)0xfe030238,0x01a9ffff);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe03023c,0xffff0356);
+	WriteRegister((volatile ULONG *)0xfe03025c,0x0000003e);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe00110c,0x32645000);
+	WriteRegister((volatile ULONG *)0xfe00110c,0x32645800);
+	WriteRegister((volatile ULONG *)0xfe030260,0x00010004);
+	WriteRegister((volatile ULONG *)0xfe030264,0x00000003);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe030268,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe03026c,0x01ad01ad);
+	WriteRegister((volatile ULONG *)0xfe03027c,0x003e0000);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfd104014,0x00000002);
+	WriteRegister((volatile ULONG *)0xfd104018,0x00000032);
+	WriteRegister((volatile ULONG *)0xfe030280,0x00040001);
+	WriteRegister((volatile ULONG *)0xfe030284,0x00030000);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfd104100,0x0000007b);
+	WriteRegister((volatile ULONG *)0xfd104104,0x0000034a);
+	WriteRegister((volatile ULONG *)0xfd104108,0x00000025);
+	WriteRegister((volatile ULONG *)0xfe030288,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe03028c,0x01ad01ad);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe030224,0x00000200);
+	WriteRegister((volatile ULONG *)0xfe030298,0x00000018);
+	WriteRegister((volatile ULONG *)0xfe030224,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe030248,0x00000001);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteByteRegister((volatile UCHAR *)0xfe03001c,0x00);
+	WriteByteRegister((volatile UCHAR *)0xfe030000,0x96);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000008);
+	WriteByteRegister((volatile UCHAR *)0xfe030004,0x46);
+	WriteRegister((volatile ULONG *)0xfd10410c,0x00000204);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000008);
+	WriteByteRegister((volatile UCHAR *)0xfe030008,0x60);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfd10400c,0xffffffff);
+	WriteRegister((volatile ULONG *)0xfd104004,0x000001df);
+	WriteRegister((volatile ULONG *)0xfd104000,0x00000c1b);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteByteRegister((volatile UCHAR *)0xfe03000c,0x08);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfd10400c,0x00000041);
+	WriteRegister((volatile ULONG *)0xfd104000,0x80000c1b);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteByteRegister((volatile UCHAR *)0xfe030010,0x08);
+	WriteByteRegister((volatile UCHAR *)0xfe030014,0x00);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000010);
+	WriteByteRegister((volatile UCHAR *)0xfe030020,0x24);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteByteRegister((volatile UCHAR *)0xfe030018,0x91);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteByteRegister((volatile UCHAR *)0xfe030170,0x48);
+	WriteByteRegister((volatile UCHAR *)0xfe030174,0x38);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000008);
+	WriteByteRegister((volatile UCHAR *)0xfe030178,0x08);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfd10400c,0x00000041);
+	WriteRegister((volatile ULONG *)0xfd10400c,0x00000003);
+	WriteRegister((volatile ULONG *)0xfd104000,0x00000c1b);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteByteRegister((volatile UCHAR *)0xfe030020,0x24);
+	WriteByteRegister((volatile UCHAR *)0xfe030100,0x10);
+	WriteRegister((volatile ULONG *)0xfd10400c,0x00000041);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000008);
+	WriteByteRegister((volatile UCHAR *)0xfe030104,0x09);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000010);
+	WriteByteRegister((volatile UCHAR *)0xfe030088,0x40);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteByteRegister((volatile UCHAR *)0xfe03008c,0x00);
+	WriteByteRegister((volatile UCHAR *)0xfe030090,0x00);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000010);
+	WriteByteRegister((volatile UCHAR *)0xfe030094,0x00);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000008);
+	WriteByteRegister((volatile UCHAR *)0xfe030098,0x00);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteByteRegister((volatile UCHAR *)0xfe03009c,0x00);
+	WriteByteRegister((volatile UCHAR *)0xfe0300a0,0x00);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000008);
+	WriteByteRegister((volatile UCHAR *)0xfe0300a4,0x00);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteByteRegister((volatile UCHAR *)0xfe0300a8,0x00);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteByteRegister((volatile UCHAR *)0xfe030144,0x32);
+	WriteByteRegister((volatile UCHAR *)0xfe030120,0x20);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000010);
+	WriteByteRegister((volatile UCHAR *)0xfe030114,0x80);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteByteRegister((volatile UCHAR *)0xfe03011c,0x80);
+	WriteByteRegister((volatile UCHAR *)0xfe030118,0x00);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000010);
+	WriteByteRegister((volatile UCHAR *)0xfe0301a4,0x80);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000008);
+	WriteByteRegister((volatile UCHAR *)0xfe030034,0x35);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteByteRegister((volatile UCHAR *)0xfe0301a8,0x1d);
+	WriteByteRegister((volatile UCHAR *)0xfe030044,0x75);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000008);
+	WriteByteRegister((volatile UCHAR *)0xfe030048,0xd8);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000010);
+	WriteByteRegister((volatile UCHAR *)0xfe030048,0xd7);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteByteRegister((volatile UCHAR *)0xfe03004c,0x9e);
+	WriteByteRegister((volatile UCHAR *)0xfe0301ac,0x1e);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000010);
+	WriteByteRegister((volatile UCHAR *)0xfe03017c,0x17);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000008);
+	WriteByteRegister((volatile UCHAR *)0xfe030018,0x10);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteByteRegister((volatile UCHAR *)0xfe0301a8,0x1d);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000008);
+	WriteByteRegister((volatile UCHAR *)0xfe03007c,0x00);
+	WriteByteRegister((volatile UCHAR *)0xfe030080,0x00);
+	WriteByteRegister((volatile UCHAR *)0xfe030084,0x18);
+	WriteByteRegister((volatile UCHAR *)0xfe03000c,0x28);
+	WriteRegister((volatile ULONG *)0xfd10400c,0x00000041);
+	WriteRegister((volatile ULONG *)0xfd104210,0x000d0282);
+	WriteRegister((volatile ULONG *)0xfd104214,0x40080024);
+	WriteRegister((volatile ULONG *)0xfd104218,0x00000003);
+	WriteRegister((volatile ULONG *)0xfd10421c,0x00000000);
+	WriteRegister((volatile ULONG *)0xfd104220,0x00000000);
+	WriteRegister((volatile ULONG *)0xfd104224,0x00000000);
+	WriteRegister((volatile ULONG *)0xfd104228,0x00000000);
+	WriteRegister((volatile ULONG *)0xfd10422c,0x00000000);
+	WriteRegister((volatile ULONG *)0xfd104230,0x00000001);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000018);
+	WriteRegister((volatile ULONG *)0xfd10400c,0x00000045);
+	WriteRegister((volatile ULONG *)0xfd104210,0x000d0282);
+	WriteRegister((volatile ULONG *)0xfd104214,0x40080024);
+	WriteRegister((volatile ULONG *)0xfd104218,0x00000003);
+	WriteRegister((volatile ULONG *)0xfd10421c,0x00000000);
+	WriteRegister((volatile ULONG *)0xfd104220,0x00000000);
+	WriteRegister((volatile ULONG *)0xfd104224,0x00000000);
+	WriteRegister((volatile ULONG *)0xfd104228,0x00000000);
+	WriteRegister((volatile ULONG *)0xfd10422c,0x00000000);
+	WriteRegister((volatile ULONG *)0xfd104230,0x00000001);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000010);
+	WriteByteRegister((volatile UCHAR *)0xfe0300a4,0x01);
+	WriteByteRegister((volatile UCHAR *)0xfe0300a8,0x08);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000010);
+	WriteByteRegister((volatile UCHAR *)0xfe0300a4,0x00);
+	WriteByteRegister((volatile UCHAR *)0xfe0300a8,0x40);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000010);
+	WriteByteRegister((volatile UCHAR *)0xfe0300a4,0x8f);
+	WriteByteRegister((volatile UCHAR *)0xfe0300a8,0x00);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000008);
+	WriteByteRegister((volatile UCHAR *)0xfe030044,0x75);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000010);
+	WriteByteRegister((volatile UCHAR *)0xfe0300a4,0x01);
+	WriteByteRegister((volatile UCHAR *)0xfe0300a8,0x08);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000008);
+	WriteByteRegister((volatile UCHAR *)0xfe030048,0xd7);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000010);
+	WriteByteRegister((volatile UCHAR *)0xfe0300a4,0x00);
+	WriteByteRegister((volatile UCHAR *)0xfe0300a8,0x40);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000008);
+	WriteByteRegister((volatile UCHAR *)0xfe030048,0xd7);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000010);
+	WriteByteRegister((volatile UCHAR *)0xfe0300a4,0x8f);
+	WriteByteRegister((volatile UCHAR *)0xfe0300a8,0x00);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000010);
+	WriteByteRegister((volatile UCHAR *)0xfe0300a4,0x01);
+	WriteByteRegister((volatile UCHAR *)0xfe0300a8,0x08);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000008);
+	WriteByteRegister((volatile UCHAR *)0xfe03004c,0x9e);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000010);
+	WriteByteRegister((volatile UCHAR *)0xfe0300a4,0x00);
+	WriteByteRegister((volatile UCHAR *)0xfe0300a8,0x40);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000008);
+	WriteByteRegister((volatile UCHAR *)0xfe0301ac,0x1e);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000010);
+	WriteByteRegister((volatile UCHAR *)0xfe0300a4,0x8f);
+	WriteByteRegister((volatile UCHAR *)0xfe0300a8,0x00);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000010);
+	WriteByteRegister((volatile UCHAR *)0xfe0300a4,0x01);
+	WriteByteRegister((volatile UCHAR *)0xfe0300a8,0x08);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000008);
+	WriteByteRegister((volatile UCHAR *)0xfe03017c,0x17);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000010);
+	WriteByteRegister((volatile UCHAR *)0xfe0300a4,0x00);
+	WriteByteRegister((volatile UCHAR *)0xfe0300a8,0x40);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe00110c,0x32644000);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000010);
+	WriteByteRegister((volatile UCHAR *)0xfe0300a4,0x8f);
+	WriteByteRegister((volatile UCHAR *)0xfe0300a8,0x00);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfd104e00,0x00000850);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000010);
+	WriteByteRegister((volatile UCHAR *)0xfe0300a4,0x01);
+	WriteByteRegister((volatile UCHAR *)0xfe0300a8,0x08);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000010);
+	WriteByteRegister((volatile UCHAR *)0xfe0300a4,0x00);
+	WriteByteRegister((volatile UCHAR *)0xfe0300a8,0x40);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000010);
+	WriteByteRegister((volatile UCHAR *)0xfe0300a4,0x8f);
+	WriteByteRegister((volatile UCHAR *)0xfe0300a8,0x00);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe20a324,GDP3_NODE_TOP_PHY_ADDRESS);
+	WriteRegister((volatile ULONG *)0xfe0000a8,0x00000007);
+	WriteRegister((volatile ULONG *)0xfe20ad00,0x00000021);
+	WriteRegister((volatile ULONG *)0xfe20ad38,0x00000000);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000018);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000010);
+	WriteByteRegister((volatile UCHAR *)0xfe0300a4,0x01);
+	WriteByteRegister((volatile UCHAR *)0xfe0300a8,0x08);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000010);
+	WriteByteRegister((volatile UCHAR *)0xfe0300a4,0x00);
+	WriteByteRegister((volatile UCHAR *)0xfe0300a8,0x40);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000018);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000018);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000010);
+	WriteByteRegister((volatile UCHAR *)0xfe0300a4,0x8f);
+	WriteByteRegister((volatile UCHAR *)0xfe0300a8,0x00);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000010);
+	WriteByteRegister((volatile UCHAR *)0xfe0300a4,0x01);
+	WriteByteRegister((volatile UCHAR *)0xfe0300a8,0x08);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000010);
+	WriteByteRegister((volatile UCHAR *)0xfe0300a4,0x00);
+	WriteByteRegister((volatile UCHAR *)0xfe0300a8,0x40);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe03029c,0x00000010);
+	WriteByteRegister((volatile UCHAR *)0xfe0300a4,0x8f);
+	WriteByteRegister((volatile UCHAR *)0xfe0300a8,0x00);
+
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000008);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+
+	WriteRegister((volatile ULONG *)0xfe00110c,0x32644000);
+	WriteRegister((volatile ULONG *)0xfe001108,0x0c000000);
+	WriteRegister((volatile ULONG *)0xfe001108,0x08060000);
+	WriteRegister((volatile ULONG *)0xfe00110c,0x32644000);
+	WriteRegister((volatile ULONG *)0xfe00110c,0x32645000);
+	WriteRegister((volatile ULONG *)0xfe00110c,0x32645800);
+
+	WriteRegister((volatile ULONG *)0xfd104014,0x00000002);
+	WriteRegister((volatile ULONG *)0xfd104018,0x00000032);
+	WriteRegister((volatile ULONG *)0xfd104100,0x0000007b);
+	WriteRegister((volatile ULONG *)0xfd104104,0x0000034a);
+	WriteRegister((volatile ULONG *)0xfd104108,0x00000025);
+	WriteRegister((volatile ULONG *)0xfd10410c,0x00000204);
+	WriteRegister((volatile ULONG *)0xfd10400c,0xffffffff);
+	WriteRegister((volatile ULONG *)0xfd104004,0x000001db);
+	WriteRegister((volatile ULONG *)0xfd104000,0x00000c1b);
+	WriteRegister((volatile ULONG *)0xfd104000,0x80000c1b);
+	WriteRegister((volatile ULONG *)0xfd10400c,0x00000003);
+	WriteRegister((volatile ULONG *)0xfd104000,0x00000c1b);
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfd10400c,0x00000041);
+
+	WriteRegister((volatile ULONG *)0xfe03039c,0x00000010);
+	WriteRegister((volatile ULONG *)0xfd10400c,0x00000041);
+
+	// HDMI HAL_SetOutputSize VGA
+
+	WriteRegister((volatile ULONG *)0xfd104000,0x00000c11);
+	WriteRegister((volatile ULONG *)0xfd104100,0x0000007b);
+	WriteRegister((volatile ULONG *)0xfd104104,0x0000034a);
+	WriteRegister((volatile ULONG *)0xfd104108,0x00000025);
+	WriteRegister((volatile ULONG *)0xfd10410c,0x00000204);
+
+	return 0;
+}
+
+static unsigned short smitGetCrc16(unsigned char *data_blk_ptr,unsigned int data_blk_size)
+{
+	unsigned short		crc_return;
+	unsigned char		CRC16Lo = INI_VECTORLo;
+	unsigned char		CRC16Hi = INI_VECTORHi;
+	unsigned char		SaveHi, SaveLo;
+	register unsigned int	i, j;
+	for (i = 0; i < data_blk_size; i++)
+	{
+		CRC16Lo = CRC16Lo ^ *data_blk_ptr++;
+		for ( j = 0; j < 8; j++ )
+		{
+			SaveHi = CRC16Hi;
+			SaveLo = CRC16Lo;
+			CRC16Hi = CRC16Hi >> 1;
+			CRC16Lo = CRC16Lo >> 1;
+			if ((SaveHi & 0x1) == 0x1)
+			{
+				CRC16Lo = CRC16Lo | 0x80;
+			}
+			if ((SaveLo & 0x1) == 0x1)
+			{
+				CRC16Hi = CRC16Hi ^ POLYNOMIALHi;
+				CRC16Lo = CRC16Lo ^ POLYNOMIALLo;
+			}
+		}
+	}
+	crc_return = CRC16Hi * 0xff + CRC16Lo;
+	return crc_return;
+}
+
+/*
+* do some operation concerning usb.
+* like start, stop usb device, or look usb
+* information.
+* $ FAILURE_RET, have some error when copy
+* $ SUCCESS_RET, success return
+*/
+extern int usb_operate(usb_operation_et oper_type)
+{
+	char *usb_command[3];
+	int i;
+	int ret = -1;
+
+	for (i = 0; i < ARRAY_SIZE(usb_command); i++) {
+		usb_command[i] = malloc(COMMAND_SIZE);
+		if (NULL == usb_command[i]) {
+			goto fail_return;
+		}
+		memset(usb_command[i], '\0', COMMAND_SIZE);
+	}
+	strncpy(usb_command[0], "usb", COMMAND_SIZE);
+	switch (oper_type) {
+	case USB_START:
+		strncpy(usb_command[1], "start", COMMAND_SIZE);
+		break;
+	case USB_STOP:
+		strncpy(usb_command[1], "stop", COMMAND_SIZE);
+		break;
+	default:
+		goto fail_return;
+		break;
+	}
+	ret = do_usb(NULL, 0, 2, usb_command);
+	if (0 != ret) {
+		goto fail_return;
+	}
+	for (i = 0; i < ARRAY_SIZE(usb_command); i++) {
+		if (usb_command[i]) {
+			free(usb_command[i]);
+			usb_command[i] = NULL;
+		}
+	}
+	return SUCCESS_RET;
+fail_return:
+	for (i = 0; i < ARRAY_SIZE(usb_command); i++) {
+		if (usb_command[i]) {
+			free(usb_command[i]);
+			usb_command[i] = NULL;
+		}
+	}
+	return FAILURE_RET;
+}
+
+/*
+* copy data from USB device to ram.
+* @ char *file_name, appoint to the file name which will be copy
+* $ FAILURE_RET, have some error when copy
+* $ SUCCESS_RET, success return
+*/
+int usb_ext2load(char *file_name,int partition)
+{
+	char *ext2load_command[7];
+	int i;
+	int ret = FAILURE_RET;
+
+	for (i = 0; i < ARRAY_SIZE(ext2load_command); i++) {
+		ext2load_command[i] = malloc(COMMAND_SIZE);
+		if (NULL == ext2load_command[i]) {
+			goto fail_return;
+		}
+		memset(ext2load_command[i], '\0', COMMAND_SIZE);
+	}
+
+	strncpy(ext2load_command[0], "ext2load", COMMAND_SIZE);
+	strncpy(ext2load_command[1], "usb", COMMAND_SIZE);
+	if(partition == INT_USB_PARTITION_BACKUP)
+	{
+		strncpy(ext2load_command[2], "0:1", COMMAND_SIZE);
+	}
+	else if(partition == INT_USB_PARTITION_RUNNING)
+	{
+		strncpy(ext2load_command[2], "0:2", COMMAND_SIZE);
+	}
+	strncpy(ext2load_command[3], "80000000", COMMAND_SIZE);
+	strncpy(ext2load_command[4], file_name, COMMAND_SIZE);
+
+	ret = do_ext2load(NULL, 0, 6, ext2load_command);
+
+	if (0 != ret)
+	{
+		goto fail_return;
+	}
+	for (i = 0; i < ARRAY_SIZE(ext2load_command); i++) {
+		if (ext2load_command[i]) {
+			free(ext2load_command[i]);
+			ext2load_command[i] = NULL;
+		}
+	}
+	return SUCCESS_RET;
+fail_return:
+	for (i = 0; i < ARRAY_SIZE(ext2load_command); i++) {
+		if (ext2load_command[i]) {
+			free(ext2load_command[i]);
+			ext2load_command[i] = NULL;
+		}
+	}
+	return FAILURE_RET;
+}
+/*
+* copy data from USB device to ram.
+* @ char *file_name, appoint to the file name which will be copy
+* $ FAILURE_RET, have some error when copy
+* $ SUCCESS_RET, success return
+*/
+static int usb_fatload(char *file_name,unsigned int LoadSize)
+{
+	char *fatload_command[7];
+	int i;
+	int ret = FAILURE_RET;
+
+	for (i = 0; i < ARRAY_SIZE(fatload_command); i++) {
+		fatload_command[i] = malloc(COMMAND_SIZE);
+		if (NULL == fatload_command[i]) {
+			goto fail_return;
+		}
+		memset(fatload_command[i], '\0', COMMAND_SIZE);
+	}
+
+	strncpy(fatload_command[0], "fatload", COMMAND_SIZE);
+	strncpy(fatload_command[1], "usb", COMMAND_SIZE);
+	strncpy(fatload_command[2], "0", COMMAND_SIZE);
+	strncpy(fatload_command[3], "80000000", COMMAND_SIZE);
+	strncpy(fatload_command[4], file_name, COMMAND_SIZE);
+
+	if(LoadSize != 0)
+	{
+		sprintf(fatload_command[5], "%x", LoadSize);
+		ret = do_fat_fsload(NULL, 0, 6, fatload_command);
+	}
+	else
+	{
+		ret = do_fat_fsload(NULL, 0, 5, fatload_command);
+	}
+
+	if (0 != ret) {
+		goto fail_return;
+	}
+	for (i = 0; i < ARRAY_SIZE(fatload_command); i++) {
+		if (fatload_command[i]) {
+			free(fatload_command[i]);
+			fatload_command[i] = NULL;
+		}
+	}
+	return SUCCESS_RET;
+fail_return:
+	for (i = 0; i < ARRAY_SIZE(fatload_command); i++) {
+		if (fatload_command[i]) {
+			free(fatload_command[i]);
+			fatload_command[i] = NULL;
+		}
+	}
+	return FAILURE_RET;
+}
+
+/*
+return value:
+0 ----equal
+-1 ---not equal
+*/
+static int CompareSHA1Value(unsigned char *buffer1, unsigned char *buffer2)
+{
+	int i;
+
+	for(i = 0; i < 20; i++)
+	{
+		if(buffer1[i] != buffer2[i])
+		{
+			break;
+		}
+	}
+
+	if(i == 20)
+	{
+		return 0;
+	}
+	else
+	{
+		printf("CompareSHA1Value error!!!\n");
+		return -1;
+	}
+}
+
+static void SHA1ValueAdd(unsigned char *Sum, unsigned char *AddValue)
+{
+	int i;
+
+	for(i = 0; i < 20; i++)
+	{
+		Sum[i] = (Sum[i] + AddValue[i]) % 256;
+	}
+
+}
+
+/**********************************************************************
+Function   :check_update_sw_header
+Descriptor :
+SUCCESS_RET ----need update
+FAILURE_RET ---Don't need update
+Notice     :
+**********************************************************************/
+static int check_update_sw_header(ImageFileHeader_T *pFileHeader, SPISoftWareInfo_T *pSPISWInfo)
+{
+	int ret;
+
+	ret =FAILURE_RET;
+
+	if( ((pFileHeader->FactoryID == pSPISWInfo->FactoryID) || (0xffffffff == pSPISWInfo->FactoryID))
+		&&((pFileHeader->DeviceID == pSPISWInfo->DeviceID) || (0xffffffff == pSPISWInfo->DeviceID))
+		&&(pFileHeader->UpdateUbootFlag == 0xabcd6789)
+		&&(pFileHeader->UBOOT_Ver != pSPISWInfo->UBOOT_Ver) )
+	{
+		ret = SUCCESS_RET;
+	}
+	return  ret;
+}
+
+
+
+static void smit_restartST40(void)
+{
+	volatile unsigned short *ST40_CPG1_WTCNT  = 0xFFC00000 + 0x08;
+	volatile unsigned short *ST40_CPG1_WTCSR  = 0xFFC00000 + 0x0C;
+	volatile unsigned short *ST40_CPG1_WTCSR2 = 0xFFC00000 + 0x1C;
+
+	*ST40_CPG1_WTCNT  = 0x5AF0;
+	*ST40_CPG1_WTCSR  = 0xA547;
+	*ST40_CPG1_WTCSR2 = 0xAA00;
+	*ST40_CPG1_WTCSR  = 0xA5C7;
+
+	for(;;)
+		printf("waiting for restar\n");
+}
+
+/* init PIO of led and key config */
+static void init_pio(void)
+{
+	/*init led&key*/
+	PIO0_CLEAR_C0 = 0x32;
+	PIO0_CLEAR_C1 = 0x32;
+	PIO0_CLEAR_C2 = 0x32;
+	PIO0_SET_C0 = 0x02;
+	PIO0_SET_C1 = 0x30;
+	PIO0_SET_C2 = 0x02;
+
+	udelay(1000);
+}
+
+static void set_led_green(int v)
+{
+	STPIO_SET_PIN(PIO0_BASSADDRESS,4,v);
+}
+
+static void set_led_red(int v)
+{
+	STPIO_SET_PIN(PIO0_BASSADDRESS,5,v);
+}
+
+static void init_led(void)
+{
+	set_led_green(0x01);   //close
+	set_led_red(0x00);     //open
+}
+
+/**********************************************************************
+Function   :check_key_press
+Descriptor :check if key is down 3 second
+Input      :
+Output     :
+return     : KEY_DOWN:   success
+KEY_UP:     failed   ( < 3 second )
+Notice     :
+**********************************************************************/
+static int check_key_press(void)
+{
+	int count,cur_key,next_key,led;
+
+	led = 0x00;
+	count = 7;
+	cur_key = STPIO_GET_PIN(PIO0_BASSADDRESS, 1);
+
+	if(cur_key == KEY_DOWN)
+	{
+		while(count--)
+		{
+			udelay(500000);
+			next_key = STPIO_GET_PIN(PIO0_BASSADDRESS, 1);
+			if(next_key != cur_key)
+			{
+				return KEY_UP;
+			}
+			cur_key = next_key;
+
+			set_led_green(led);
+			led = !led;
+		}
+		if(!count)
+		{
+			return KEY_DOWN;
+		}
+	}
+
+	return cur_key;
+}
+
+/**********************************************************************
+Function   :set_led_flash
+Descriptor :the board have two led,red and green;
+Input      :
+Output     :
+return     :
+Notice     :
+**********************************************************************/
+static void set_led_flash(led_gb620_et led,unsigned int nsec,led_flash_et ntype)
+{
+	int nswitch,ncnt,ntime;
+
+	nswitch = 1;
+	ntime = nsec;
+
+	do
+	{
+		for(ncnt = 0; ncnt < 5; ncnt++)
+		{
+			udelay(200000);
+			if(led == GB620_RED_LED)
+			{
+				set_led_red(nswitch);
+			}
+			if(led == GB620_GREEN_LED)
+			{
+				set_led_green(nswitch);
+			}
+			nswitch = !nswitch;
+		}
+		ntime --;
+	}while( (GB620_LED_FLASH_ALL == ntype) || (ntime > 0) );
+
+}
+
+/**********************************************************************
+Function   :usb_config_start
+Descriptor :*USB config and start*;
+Input      :
+Output     :
+return     : SUCCESS_RET:   success
+FAILURE_RET:   failed
+Notice     :
+**********************************************************************/
+static int usb_config_start(unsigned int cfg)
+{
+	int ncnt = 0;
+	int nret = FAILURE_RET;
+	cfg_7105_usb_ohci_regs = cfg;
+
+	nret = usb_operate(USB_START);
+
+	/*waiting, until usb device found, timeout is 2s */
+	while((dev_index != 2) && (ncnt < 2) && (GetStorageDevicesNum() != 1) )
+	{
+		udelay(1000000);
+		nret = usb_operate(USB_START);
+		ncnt++;
+	}
+	return nret;
+}
+
+/*----------------------------------------------------------------------------
+ * FuncName   :  smit_logo_init
+ * Description:  display logo, default 480p@NTSC 3.58, default bmp size 190*220
+ 				 support HD/SD photo
+ * Parameters :  @
+                 @
+ * FuncReturn :  NULL
+ * Information:
+              110-12,2010    jgong    Write/Modify
+------------------------------------------------------------------------------*/
+static int smit_logo_init(void)
+{
+	unsigned int  *L1_p, *L2_p;
+	unsigned int  i, j, x, y, h, w, w_screen, h_screen;
+	unsigned int logo_size, display_sd, color;
+
+	color = 0x80000000;   /* backgrand color: black*/
+
+	L1_p = (unsigned int *)HD_PIC_LAOD_ADDRESS;   /* HD PHOTO */
+	L2_p = (unsigned int *)SD_PIC_LAOD_ADDRESS;   /* SD PHOTO */
+
+	smit_480cfg_logo_init();
+
+	w_screen = 720;
+	h_screen = 480;
+	w = 190;
+	h = 220;
+	x = (w_screen - w)/2;
+	y = (h_screen - h)/2;
+	for (i = 0; i < w_screen; i++)
+	{
+		for (j = 0; j < h_screen; j++)
+		{
+			/* background */
+			*(L1_p + i + j*w_screen) = color;
+			*(L2_p + i + j*w_screen) = color;
+		}
+	}
+	for(i = y; i < y+h; i++)
+	{
+		for(j = x; j < x+w; j++)
+		{
+			*(L1_p + w_screen*i + j) = image_data[(i-y)*w+j-x];
+			*(L2_p + w_screen*i + j) = image_data[(i-y)*w+j-x];
+		}
+	}
+	return 0;
+}
+
+/**********************************************************************
+Function   :setenv_start
+Descriptor :set env to start kernel and FS;
+start kernel about take 20s,start FS about 8s
+Input      :
+partition :usb partition (inside usb has 3 partition,extern usb only has 1 partition)
+flag: spi update flag
+Output     :
+return     : SUCCESS_RET:   success
+FAILURE_RET:   failed
+Notice     :
+**********************************************************************/
+int setenv_start(int partition,unsigned char flag)
+{
+	/* factory mode */
+	if (flag == EXT_EXT2_USB)
+	{
+		setenv("bootargs", "console=ttyAS0,115200 root=/dev/sdb1  rootfstype=ext3 rw  nwhwconf=device:eth0,hwaddr:10:08:E2:12:06:BD phyaddr:0,watchdog:5000 mem=120M bigphysarea=2048");
+		setenv("bootcmd", "ext2load usb 0:1 80000000 vmlinux.ub; bootm 80000000");
+
+	}
+	/* inside usb start ;setenv by partition: 1 or 2*/
+	else
+	{
+		if(partition == INT_USB_PARTITION_BACKUP)
+		{
+			setenv("bootargs", "console=ttyAS0,115200 root=8:1  rootfstype=ext3 rw rootflags=data=journal nwhwconf=device:eth0,hwaddr:10:08:E2:12:06:BD phyaddr:0,watchdog:5000 mem=120M bigphysarea=2048");
+			setenv("bootcmd", "ext2load usb 0:1 80000000 vmlinux.ub; bootm 80000000");
+		}
+		else if(partition == INT_USB_PARTITION_RUNNING)
+		{
+			setenv("bootargs", "console=ttyAS0,115200 root=8:2  rootfstype=ext3 rw rootflags=data=journal nwhwconf=device:eth0,hwaddr:10:08:E2:12:06:BD phyaddr:0,watchdog:5000 mem=120M bigphysarea=2048");
+			setenv("bootcmd", "ext2load usb 0:2 80000000 vmlinux.ub; bootm 80000000");
+		}
+	}
+	return SUCCESS_RET;
+}
+/**********************************************************************
+Function   :uboot_update
+Descriptor :
+Input      :none
+Output     :none
+return     : SUCCESS_RET:   success
+FAILURE_RET:   failed
+Notice     :
+**********************************************************************/
+int uboot_update(unsigned char flag)
+{
+	ImageFileHeader_T *pImgFileHeader = NULL;
+	unsigned char     *pUbootHeader = NULL;
+	unsigned short    CRCValue;
+	SPISoftWareInfo_T SPISoftWareInfo = {0};
+	unsigned char     SHA1TempResult[20] = {0};
+
+	if(GetStorageDevicesNum() < 1)
+	{
+		return FAILURE_RET;
+	}
+	/* load uboot sw to ddr */
+	if(SUCCESS_RET  == usb_fatload("iptvubootupdate.bin", sizeof(ImageFileHeader_T)+MAX_IMAGE_SECTION/2)	)
+	{
+		/* read spi from addr 0x91000, get sw version info */
+		ReadSPIFlashDataToBuffer(SPI_UBOOT_UPDATE_INFO, (unsigned char *)(&SPISoftWareInfo), sizeof(SPISoftWareInfo_T));
+		pImgFileHeader = (ImageFileHeader_T *)(SWLOADADDR);
+		pUbootHeader = (unsigned char *)(SWLOADADDR+sizeof(ImageFileHeader_T));
+		CRCValue = smitGetCrc16(pImgFileHeader, sizeof(ImageFileHeader_T)-2);
+
+		if(CRCValue != pImgFileHeader->CRC_Header)
+		{
+			set_led_flash(GB620_RED_LED,UBOOT_UPDATE_TIME_SEC,GB620_LED_FLASH_SEC);
+			return ABNORMITY_RET;
+		}
+
+		/* check sw update info */
+		if(0 == check_update_sw_header(pImgFileHeader, &SPISoftWareInfo))
+		{
+			/* count uboot sw data sha1 */
+			soft_sha_1(pUbootHeader, MAX_IMAGE_SECTION/2, SHA1TempResult);
+
+			/* check uboot data valid */
+			if(0 == CompareSHA1Value(pImgFileHeader->SHA1_Uboot, SHA1TempResult))
+			{
+				/* write uboot to spi flash */
+				if(SUCCESS_RET == do_auto_update_uboot_to_spi(NULL, pImgFileHeader->UbootSize, \
+					sizeof(ImageFileHeader_T), NULL))
+				{
+					SPISoftWareInfo.UBOOT_Ver = pImgFileHeader->UBOOT_Ver;
+					SPISoftWareInfo.DeviceID = pImgFileHeader->DeviceID;
+					SPISoftWareInfo.FactoryID = pImgFileHeader->FactoryID;
+					strncpy(SPISoftWareInfo.Date, pImgFileHeader->Date,10);
+
+					WriteSPIFlashDataFromBuffer(SPI_UBOOT_UPDATE_INFO, (unsigned char *)(&SPISoftWareInfo), \
+						sizeof(SPISoftWareInfo_T));
+
+					if(flag != NORMAL_START)
+					{
+						WriteSPIFlashDataByChar(IPTV_FLAG_ADDR,NORMAL_START);
+					}
+					set_led_flash(GB620_GREEN_LED,UBOOT_UPDATE_TIME_SEC,GB620_LED_FLASH_SEC);
+					smit_restartST40();
+				}
+				else
+				{
+					set_led_flash(GB620_RED_LED,UBOOT_UPDATE_TIME_SEC,GB620_LED_FLASH_SEC);
+					return ABNORMITY_RET;
+				}
+			}
+		}
+		else
+		{
+			set_led_flash(GB620_RED_LED,UBOOT_UPDATE_TIME_SEC,GB620_LED_FLASH_SEC);
+			return ABNORMITY_RET;
+		}
+	}
+	return FAILURE_RET;
+
+}
+
+/**********************************************************************
+Function   :update_process
+Descriptor :start by flag and key
+Input      :none
+Output     :none
+return     : SUCCESS_RET:   success
+FAILURE_RET:   failed
+Notice     :
+**********************************************************************/
+int update_process(void)
+{
+	unsigned char flag;
+	unsigned int partition,key,ext2_fs;
+	int uboot_update_flag;
+	Loader_Info_t loader_info = {0};
+	unsigned char spi_loaderinfo_ini[8] = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};
+
+	init_pio();
+	init_led();
+
+	flag = ReadSPIFlashDataByChar(IPTV_FLAG_ADDR);
+
+	/* press down the key more than 3s; green led flash 3 times */
+	key = check_key_press();
+
+	/* let led flash normal */
+	init_led();
+	smit_logo_init();
+
+	/* key has been pressed more than 3s */
+	if(KEY_DOWN == key )
+	{
+
+		/* USB config and start */
+		if(FAILURE_RET == usb_config_start(USB_EXT_REGS))
+		{
+			return FAILURE_RET;
+		}
+
+		/* check extern usb type,ext2 or not */
+		ext2_fs = check_ext2_usb(EXT_USB_PARTITION);
+
+		if(NOT_EXT2_FS == ext2_fs)
+		{
+			/*
+			* if usb filesystem is fat,
+			* check if the uboot update file exsit,
+			* if file exsit, do uboot updating, or recovering
+			*/
+			uboot_update_flag = uboot_update(flag);
+			if(ABNORMITY_RET == uboot_update_flag)
+			{
+				if(NORMAL_START != flag)
+				{
+					WriteSPIFlashDataByChar(IPTV_FLAG_ADDR,NORMAL_START);
+				}
+				smit_restartST40();
+			}
+
+			/* uboot update fail, file or crc error */
+			else if(FAILURE_RET == uboot_update_flag)
+			{
+				if(FAILURE_RET == usb_config_start(USB_INT_REGS))
+				{
+					return FAILURE_RET;
+				}
+				ext2_fs = check_ext2_usb(INT_USB_PARTITION_BACKUP);
+				if(ext2_fs == RIGHT_EXT2_FS)
+				{
+					if(ONEKEY_RECOVER != flag)
+					{
+						WriteSPIFlashDataByChar(IPTV_FLAG_ADDR,ONEKEY_RECOVER);
+						flag = ONEKEY_RECOVER;
+					}
+					partition = INT_USB_PARTITION_BACKUP;
+				}
+
+				/* load failed, not ext2 or ext2 file wrong */
+				else
+				{
+					set_led_flash(GB620_RED_LED,ALL_WARING_TIME_SEC,GB620_LED_FLASH_ALL);
+				}
+			}
+		}
+
+		/* ext2 filesystem */
+		else
+		{
+			if(RIGHT_EXT2_FS == ext2_fs)
+			{
+				if(EXT_EXT2_USB != flag)
+				{
+					WriteSPIFlashDataByChar(IPTV_FLAG_ADDR,EXT_EXT2_USB);
+					flag = EXT_EXT2_USB;
+				}
+				partition = EXT_USB_PARTITION;
+			}
+
+			/* ext2 filesystem, but the file is wrong or not exist */
+			else if(WRONG_EXT2_FS == ext2_fs)
+			{
+				set_led_flash(GB620_RED_LED,ALL_WARING_TIME_SEC,GB620_LED_FLASH_ALL);
+			}
+		}
+	}
+
+	/* if no key pressed, check flag(flag:1,4,255) */
+	else
+	{
+		if(cfg_7105_usb_ohci_regs != USB_INT_REGS)
+		{
+			if(FAILURE_RET == usb_config_start(USB_INT_REGS))
+			{
+				return FAILURE_RET;
+			}
+		}
+
+		/* for nfs, only used by designer */
+		if(100 == flag)
+		{
+			setenv("bootcmd", "ext2load usb 0:2 80000000 vmlinux.ub; bootm 80000000");
+			return FAILURE_RET;
+		}
+
+		/* if find abnormal flag, change to normal */
+		if((NORMAL_START != flag) && (ONEKEY_RECOVER != flag) && (EXT_EXT2_USB != flag) && (NET_UPGRADE_RUNNING != flag))
+		{
+			WriteSPIFlashDataByChar(IPTV_FLAG_ADDR,NORMAL_START);
+			flag = NORMAL_START;
+		}
+
+		/* start normal */
+		if(NORMAL_START == flag)
+		{
+			/* check running patition of inside usb */
+			ext2_fs = check_ext2_usb(INT_USB_PARTITION_RUNNING);
+
+			/* load Kernel&FS of inside usb succeed */
+			if(RIGHT_EXT2_FS == ext2_fs)
+			{
+				partition = INT_USB_PARTITION_RUNNING;
+			}
+			else
+			{
+				set_led_flash(GB620_RED_LED,ALL_WARING_TIME_SEC,GB620_LED_FLASH_ALL);
+			}
+		}
+
+		/* factory mode */
+		if(EXT_EXT2_USB == flag)
+		{
+			if(FAILURE_RET == usb_config_start(USB_EXT_REGS))
+			{
+				return FAILURE_RET;
+			}
+			ext2_fs = check_ext2_usb(EXT_USB_PARTITION);
+
+			/* if you insert a right extern usb, goto extern usb system */
+			if(RIGHT_EXT2_FS == ext2_fs)
+			{
+				partition = EXT_USB_PARTITION;
+			}
+
+			/* if no extern usb, switch to inside usb system */
+			else
+			{
+				if(FAILURE_RET == usb_config_start(USB_INT_REGS))
+				{
+					return FAILURE_RET;
+				}
+
+				/* check the running and backup partion of inside usb */
+				ext2_fs = check_ext2_usb(INT_USB_PARTITION_RUNNING);
+				if(RIGHT_EXT2_FS == ext2_fs)
+				{
+					ext2_fs = check_ext2_usb(INT_USB_PARTITION_BACKUP);
+				}
+				if(RIGHT_EXT2_FS == ext2_fs)
+				{
+					/*
+					* read the address of 0x95000 of spi flash,
+					* the address is used to save the loader info,
+					* which is writed on the end of factory updating
+					*/
+					memset((void*)(&loader_info),0,sizeof(loader_info));
+					ReadSPIFlashDataToBuffer(SPI_LOADER_INFO, (unsigned char *)(&loader_info), sizeof(loader_info));
+					if((memcpy(loader_info.aAppVer,spi_loaderinfo_ini,8)==0)
+						&&(memcpy(loader_info.aLoaderVer,spi_loaderinfo_ini,8)==0))
+					{
+						set_led_flash(GB620_RED_LED,ALL_WARING_TIME_SEC,GB620_LED_FLASH_ALL);
+					}
+					else
+					{
+						WriteSPIFlashDataByChar(IPTV_FLAG_ADDR,NORMAL_START);
+						flag = NORMAL_START;
+						partition = INT_USB_PARTITION_RUNNING;
+					}
+				}
+
+				/* this mode maybe worker forget to connect extern ext3 usb */
+				else
+				{
+					set_led_flash(GB620_RED_LED,ALL_WARING_TIME_SEC,GB620_LED_FLASH_ALL);
+				}
+			}
+		}
+
+		/* net_update mode: when flag value is 4 or 2, start from inside usb backup partition */
+		if( (NET_UPGRADE_RUNNING == flag) || (ONEKEY_RECOVER == flag) )
+		{
+			ext2_fs = check_ext2_usb(INT_USB_PARTITION_BACKUP);
+			if(RIGHT_EXT2_FS == ext2_fs)
+			{
+				partition = INT_USB_PARTITION_BACKUP;
+			}
+
+			/* load failed, not ext2 or ext2 file is wrong */
+			else
+			{
+				WriteSPIFlashDataByChar(IPTV_FLAG_ADDR,NORMAL_START);
+				set_led_flash(GB620_RED_LED,ALL_WARING_TIME_SEC,GB620_LED_FLASH_ALL);
+			}
+		}
+	}
+	/* end else */
+	if((partition != 1) && (partition != 2))
+	{
+		return FAILURE_RET;
+	}
+
+	setenv_start(partition,flag);
+
+	return SUCCESS_RET;
+}
+
+U_BOOT_CMD(
+	logo,    1,    0,    smit_logo_init,
+	"logo	- show logo\n",""
+	);
+
diff --git a/board/st/pdk7105/swUpdate.h b/board/st/pdk7105/swUpdate.h
new file mode 100644
index 0000000000..79c12de1c6
--- /dev/null
+++ b/board/st/pdk7105/swUpdate.h
@@ -0,0 +1,106 @@
+#ifndef _SW_UPDATE_T_
+#define _SW_UPDATE_T_
+
+#define SUCCESS_RET     0
+#define FAILURE_RET     -1
+#define ABNORMITY_RET   -2
+
+#define RIGHT_EXT2_FS             0
+#define NOT_EXT2_FS               1
+#define WRONG_EXT2_FS             2
+#define UBOOT_UPDATE_TIME_SEC     3
+#define EXTUSB_WARING_TIME_SEC    10
+#define INTUSB_WARING_TIME_SEC    60
+#define ALL_WARING_TIME_SEC       100
+
+#define INI_VECTORLo     0x00
+#define INI_VECTORHi     0x00
+#define POLYNOMIALHi     0x80
+#define POLYNOMIALLo     0x05
+
+/* led */
+#define PIO0_BASSADDRESS  0xFD020000
+#define PIO0_CLEAR_C0     *(volatile unsigned char *)(PIO0_BASSADDRESS+0x28)
+#define PIO0_CLEAR_C1     *(volatile unsigned char *)(PIO0_BASSADDRESS+0x38)
+#define PIO0_CLEAR_C2     *(volatile unsigned char *)(PIO0_BASSADDRESS+0x48)
+#define PIO0_SET_C0       *(volatile unsigned char *)(PIO0_BASSADDRESS+0x24)
+#define PIO0_SET_C1       *(volatile unsigned char *)(PIO0_BASSADDRESS+0x34)
+#define PIO0_SET_C2       *(volatile unsigned char *)(PIO0_BASSADDRESS+0x44)
+
+
+typedef enum USB_OPER
+{
+	USB_START = 1,
+	USB_STOP
+} usb_operation_et;
+
+typedef enum USB_PARTITION
+{
+	EXT_USB_PARTITION = 1,
+	INT_USB_PARTITION_BACKUP = 1,
+	INT_USB_PARTITION_RUNNING
+} usb_partion_et;
+
+typedef enum UPDATE_KEY
+{
+	KEY_DOWN,    //
+	KEY_UP       //
+} update_key_et;
+
+typedef enum LED_GB620
+{
+	GB620_RED_LED,
+	GB620_GREEN_LED
+} led_gb620_et;
+
+typedef enum LED_FLASH_TYPE
+{
+	GB620_LED_FLASH_ALL,
+	GB620_LED_FLASH_SEC
+} led_flash_et;
+
+typedef enum IPTV_LOADER
+{
+	NORMAL_START = 1,           //
+	ONEKEY_RECOVER,             //ext2-U
+	NET_UPGRADE_OSP,            //OSP
+	NET_UPGRADE_RUNNING,        //RUNNING
+	EXT_EXT2_USB = 255          //ext2 U
+} iptv_loader_et;
+
+/* uboot update */
+typedef struct _ImageFileHeader
+{
+	unsigned int   UpdateUbootFlag; /*update uboot flag*/
+	unsigned int   UBOOT_Ver;       /*u-boot version: */
+	unsigned int   SW_Ver;
+	unsigned char  HW_Ver[16];
+	unsigned int   FactoryID;
+	unsigned int   DeviceID;        /*620*/
+	unsigned int   UbootSize;       /*uboot size*/
+	unsigned char  Date[10];        /*eg:20100522*/
+	unsigned char  SHA1_Uboot[20];  /*uboot section sha1*/
+	unsigned short CRC_Header;      /*header crc value*/
+} ImageFileHeader_T;
+
+typedef struct _SPISoftWareInfo
+{
+	unsigned int   SW_Ver;
+	unsigned int   HW_Ver;
+	unsigned int   UBOOT_Ver;       /*u-boot version: */
+	unsigned int   FactoryID;
+	unsigned int   DeviceID;        /*620*/
+	unsigned short Reserved;
+	unsigned char  Date[10];        /*20100522*/
+} SPISoftWareInfo_T;
+
+typedef struct Loader_Info_s
+{
+	unsigned char   aLoaderVer[8];
+	unsigned char   aAppVer[8];
+}Loader_Info_t;
+
+static void SHA1ValueAdd(unsigned char *Sum, unsigned char *AddValue);
+static int CompareSHA1Value(unsigned char *buffer1, unsigned char *buffer2);
+
+#endif
diff --git a/common/cmd_bdinfo.c b/common/cmd_bdinfo.c
index d05998366b..3bc8c6274f 100644
--- a/common/cmd_bdinfo.c
+++ b/common/cmd_bdinfo.c
@@ -2,6 +2,9 @@
  * (C) Copyright 2003
  * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
  *
+ * (C) Copyright 2009 STMicroelectronics.
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
  * See file CREDITS for list of people who contributed to this
  * project.
  *
@@ -31,6 +34,10 @@
 DECLARE_GLOBAL_DATA_PTR;
 
 static void print_num(const char *, ulong);
+#if defined(CONFIG_SH4)
+static void print_mem(const char *, ulong);
+static void print_mhz(const char *name, ulong value);
+#endif
 
 #ifndef CONFIG_ARM	/* PowerPC and other */
 
@@ -271,7 +278,131 @@ int do_bdinfo ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 	return 0;
 }
 
-#else /* ! PPC, which leaves MIPS */
+#elif defined(CONFIG_SH4)
+
+#include "asm/socregs.h"
+
+int do_bdinfo ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	DECLARE_GLOBAL_DATA_PTR;
+#if defined(CONFIG_CMD_BDI_DUMP_EMI_BANKS)
+	#define MAX_EMI_BANKS	6	/* Maximum of 6 EMI Banks */
+	const u32 emi_base = 0xa0000000u;
+	u32 base[MAX_EMI_BANKS+1];	/* Base address for each bank */
+	u32 enabled;			/* number of enabled EMI banks */
+#endif	/* CONFIG_CMD_BDI_DUMP_EMI_BANKS */
+#if defined(CONFIG_CMD_NET) || defined(CONFIG_CMD_BDI_DUMP_EMI_BANKS)
+	unsigned int i;
+#endif
+	bd_t *bd = gd->bd;
+
+	print_num ("boot_params",	(ulong)bd->bi_boot_params);
+	print_num ("memstart",		(ulong)bd->bi_memstart);
+	print_mem ("memsize",		(ulong)bd->bi_memsize);
+#ifndef CFG_NO_FLASH
+	print_num ("flashstart",	(ulong)bd->bi_flashstart);
+	print_mem ("flashsize",		(ulong)bd->bi_flashsize);
+	print_num ("flashoffset",	(ulong)bd->bi_flashoffset);
+#endif /* CFG_NO_FLASH */
+
+#if defined(CONFIG_CMD_NET)
+	puts ("ethaddr     =");
+	for (i=0; i<6; ++i) {
+		printf ("%c%02X", i ? ':' : ' ', bd->bi_enetaddr[i]);
+	}
+	puts ("\nip_addr     = ");
+	print_IPaddr (bd->bi_ip_addr);
+#endif
+	printf ("\nbaudrate    = %d bps\n", bd->bi_baudrate);
+
+#if defined(CONFIG_SH_STB7100)
+	if (STB7100_DEVICEID_7109(bd->bi_devid))
+		printf ("\nSTb7109 version %ld.x", STB7100_DEVICEID_CUT(bd->bi_devid));
+	else if (STB7100_DEVICEID_7100(bd->bi_devid))
+		printf ("\nSTb7100 version %ld.x", STB7100_DEVICEID_CUT(bd->bi_devid));
+#elif defined(CONFIG_SH_STX5197)
+	if (STX5197_DEVICEID_5197(bd->bi_devid))
+		printf ("\nSTx5197 version %ld.x", STX5197_DEVICEID_CUT(bd->bi_devid));
+#elif defined(CONFIG_SH_STX7105)
+	if (STX7105_DEVICEID_7105(bd->bi_devid))
+		printf ("\nSTx7105 version %ld.x", STX7105_DEVICEID_CUT(bd->bi_devid));
+#elif defined(CONFIG_SH_STX7111)
+	if (STX7111_DEVICEID_7111(bd->bi_devid))
+		printf ("\nSTx7111 version %ld.x", STX7111_DEVICEID_CUT(bd->bi_devid));
+#elif defined(CONFIG_SH_STX7141)
+	if (STX7141_DEVICEID_7141(bd->bi_devid))
+		printf ("\nSTx7141 version %ld.x", STX7141_DEVICEID_CUT(bd->bi_devid));
+#elif defined(CONFIG_SH_STX7200)
+	if (STX7200_DEVICEID_7200(bd->bi_devid))
+		printf ("\nSTx7200 version %ld.x", STX7200_DEVICEID_CUT(bd->bi_devid));
+#else
+#error Missing Device Definitions!
+#endif
+	else
+		printf ("\nUnknown device! (id=0x%08lx)", bd->bi_devid);
+
+#ifdef CONFIG_SH_SE_MODE
+	printf ("  [32-bit mode]\n");
+#else
+	printf ("  [29-bit mode]\n");
+#endif
+
+#ifdef CONFIG_SH_STB7100
+	print_mhz ("PLL0",		bd->bi_pll0frq);
+	print_mhz ("PLL1",		bd->bi_pll1frq);
+	print_mhz ("ST40  CPU",		bd->bi_st40cpufrq);
+	print_mhz ("ST40  BUS",		bd->bi_st40busfrq);
+	print_mhz ("ST40  PER",		bd->bi_st40perfrq);
+	print_mhz ("ST231 CPU",		bd->bi_st231frq);
+	print_mhz ("ST BUS",		bd->bi_stbusfrq);
+	print_mhz ("EMI",		bd->bi_emifrq);
+	print_mhz ("LMI",		bd->bi_lmifrq);
+#else
+	print_mhz ("EMI",		bd->bi_emifrq);
+#endif	/* CONFIG_SH_STB7100 */
+
+#if defined(CONFIG_CMD_BDI_DUMP_EMI_BANKS)
+	enabled = *ST40_EMI_BANK_ENABLE;
+	printf("#EMI Banks  = %u\n", enabled);
+	if (enabled > MAX_EMI_BANKS)
+	{
+		printf("Error: Maximum Number of Enabled Banks should be %u\n", MAX_EMI_BANKS);
+		enabled = MAX_EMI_BANKS;
+	}
+
+	/*
+	 * EmiBaseAddress[5:0] == Address[27:22] (Multiple of 4MiB)
+	 *
+	 * Retreive all the configured EMI bank bases into base[].
+	 */
+	for(i=0; i<enabled; i++)
+	{
+		const u32 start = *ST40_EMI_BASEADDRESS(i) & 0x3fu;
+		base[i] = emi_base + (start << (22));
+	}
+	/* last valid bank occupies all remaining space */
+	base[i] = emi_base + (128u << (20));	/* total size of EMI is 128MiB */
+
+	/*
+	 * Print out the ranges of each bank.
+	 */
+	for(i=0; i<enabled; i++)
+	{
+		const u32 lower = base[i];
+		const u32 upper = base[i+1];
+		printf ("EMI #%u CS%c  = 0x%08X ... 0x%08X (",
+			i,
+			'A' + i,
+			lower,
+			upper-1u);
+		print_size (upper-lower, ")\n");
+	}
+#endif	/* CONFIG_CMD_BDI_DUMP_EMI_BANKS */
+
+	return 0;
+}
+
+#else /* ! SH4 || PPC, which leaves MIPS */
 
 int do_bdinfo ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
@@ -334,6 +465,18 @@ static void print_num(const char *name, ulong value)
 	printf ("%-12s= 0x%08lX\n", name, value);
 }
 
+#if defined(CONFIG_SH4)
+static void print_mem(const char *name, ulong value)
+{
+	printf ("%-12s= 0x%08lX\t(", name, value);
+	print_size (value, ")\n");
+}
+static void print_mhz(const char *name, ulong value)
+{
+	printf ("%-12s= %3lu MHz\n", name, value);
+}
+#endif
+
 #if defined(CONFIG_PPC) || defined(CONFIG_M68K)
 static void print_str(const char *name, const char *str)
 {
diff --git a/common/cmd_boot.c b/common/cmd_boot.c
index e68f16f9da..8c12a51261 100644
--- a/common/cmd_boot.c
+++ b/common/cmd_boot.c
@@ -34,7 +34,7 @@ DECLARE_GLOBAL_DATA_PTR;
 
 int do_go (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
-	ulong	addr, rc;
+	ulong   addr, rc;
 	int     rcode = 0;
 
 	if (argc < 2) {
@@ -87,3 +87,26 @@ U_BOOT_CMD(
 	"reset   - Perform RESET of the CPU\n",
 	NULL
 );
+
+extern int do_reset_flag (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	volatile unsigned short *ST40_CPG1_WTCNT   = 0xFFC00000 + 0x08;
+	volatile unsigned short *ST40_CPG1_WTCSR   = 0xFFC00000 + 0x0C;
+	volatile unsigned short *ST40_CPG1_WTCSR2  = 0xFFC00000 + 0x1C;
+
+
+	*ST40_CPG1_WTCNT  = 0x5AF0;//0x5AF0;
+	*ST40_CPG1_WTCSR  = 0xA547;
+	*ST40_CPG1_WTCSR2 = 0xAA00;
+	*ST40_CPG1_WTCSR  = 0xA5C7;
+
+	for(;;)
+		printf("waiting for restar\n");
+}
+
+U_BOOT_CMD(
+	reboot, 1, 0,do_reset_flag,
+	"reboot   - reset flag, reboot\n",
+	NULL
+);
+
diff --git a/common/cmd_bootm.c b/common/cmd_bootm.c
index d8163494e8..f2e629e12e 100644
--- a/common/cmd_bootm.c
+++ b/common/cmd_bootm.c
@@ -29,7 +29,7 @@
 #include <command.h>
 #include <image.h>
 #include <malloc.h>
-#include <zlib.h>
+#include <u-boot/zlib.h>
 #include <bzlib.h>
 #include <environment.h>
 #include <asm/byteorder.h>
@@ -68,6 +68,9 @@ extern int do_reset (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
 #include <dataflash.h>
 #endif
 
+#if defined(CONFIG_SH4)
+#include <asm/addrspace.h>
+#endif	/* CONFIG_SH4 */
 /*
  * Some systems (for example LWMON) have very short watchdog periods;
  * we must make sure to split long operations like memmove() or
@@ -260,6 +263,10 @@ int do_bootm (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 	if (hdr->ih_arch != IH_CPU_NIOS2)
 #elif defined(__PPC__)
 	if (hdr->ih_arch != IH_CPU_PPC)
+#elif defined(__SH4__)
+	if (hdr->ih_arch != IH_CPU_SH)
+#elif defined(__ST200__)
+	if (hdr->ih_arch != IH_CPU_ST200)
 #else
 # error Unknown CPU type
 #endif
@@ -341,6 +348,61 @@ int do_bootm (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 		break;
 	case IH_COMP_GZIP:
 		printf ("   Uncompressing %s ... ", name);
+#if defined(CONFIG_SH4)
+{
+		const uchar * const isizep =		/* pointer to ISIZE */
+			(uchar *)data + ntohl(hdr->ih_size) - 4;
+		const ulong isize =			/* ISIZE (gzip's Input Size) */
+			(ulong)(isizep[0]) << 0*8 |	/* i.e. the ORIGINAL UN-compressed size */
+			(ulong)(isizep[1]) << 1*8 |
+			(ulong)(isizep[2]) << 2*8 |
+			(ulong)(isizep[3]) << 3*8;
+		const ulong Cload = data;		/* compressed load address */
+		const ulong Csize = ntohl(hdr->ih_size);/* compressed size */
+		const ulong Cend  = Cload + Csize - 1;	/* compressed end address */
+		const ulong Uload = ntohl(hdr->ih_load);/* un-compressed load address */
+		const ulong Usize = isize;		/* un-compressed size */
+		const ulong Uend  = Uload + Usize - 1;	/* un-compressed end address */
+
+#if !defined(CONFIG_SH_SE_MODE)
+		/* assert ( IS_IN_P1_REGION(Uload) ); */
+		if ( (Uload < P1SEG) || (Uend >= P2SEG) )
+		{
+			printf ("\nwarning: Uncompressing to non-P1 region (0x%08x..0x%08x)\n",
+				Uload, Uend);
+			/* just a warning, so carry on! */
+		}
+#endif	/* CONFIG_SH_SE_MODE */
+
+		/* assert (Uload >= CFG_SDRAM_BASE); */
+		if ( PHYSADDR(Uload) < PHYSADDR(CFG_SDRAM_BASE) )
+		{
+			printf ("\nERROR: Uncompressed image (0x%08x) is below RAM (0x%08x)\n",
+				Uload,
+				CFG_SDRAM_BASE);
+			return 1;	/* unable to proceed */
+		}
+
+		/* assert (Uend < CFG_MEMTEST_END); */
+		if ( PHYSADDR(Uend) >= PHYSADDR(CFG_MEMTEST_END) )
+		{
+			printf ("\nERROR: Uncompressed image (0x%08x) is beyond safe RAM (0x%08x)\n",
+				Uend,
+				CFG_MEMTEST_END);
+			return 1;	/* unable to proceed */
+		}
+
+		/* assert ( (Cload > Uend) || (Uload > Cend) ); */
+		if ( !((PHYSADDR(Cload) > PHYSADDR(Uend)) || (PHYSADDR(Uload) > PHYSADDR(Cend))) )
+		{
+			printf ("\nERROR: Overlapping images (0x%08x..0x%08x) and (0x%08x..0x%08x)\n",
+				Cload, Cend,
+				Uload, Uend);
+			return 1;	/* unable to proceed */
+		}
+		unc_len = Usize;	/* we now know that it will fit okay */
+}
+#endif	/* CONFIG_SH4 */
 		if (gunzip ((void *)ntohl(hdr->ih_load), unc_len,
 			    (uchar *)data, &len) != 0) {
 			puts ("GUNZIP ERROR - must RESET board to recover\n");
@@ -1471,6 +1533,7 @@ print_type (image_header_t *hdr)
 	case IH_CPU_SH:		arch = "SuperH";		break;
 	case IH_CPU_SPARC64:	arch = "SPARC 64 Bit";		break;
 	case IH_CPU_SPARC:	arch = "SPARC";			break;
+	case IH_CPU_ST200:	arch = "ST200";			break;
 	default:		arch = "Unknown Architecture";	break;
 	}
 
diff --git a/common/cmd_doc.c b/common/cmd_doc.c
index 3d717c039d..ae08a707f1 100644
--- a/common/cmd_doc.c
+++ b/common/cmd_doc.c
@@ -348,8 +348,8 @@ int doc_rw (struct DiskOnChip* this, int cmd,
 
 void doc_print(struct DiskOnChip *this) {
 	printf("%s at 0x%lX,\n"
-	       "\t  %d chip%s %s, size %d MB, \n"
-	       "\t  total size %ld MB, sector size %ld kB\n",
+	       "\t  %d chip%s %s, size %d MiB, \n"
+	       "\t  total size %ld MiB, sector size %ld KiB\n",
 	       this->name, this->physadr, this->numchips,
 	       this->numchips>1 ? "s" : "", this->chips_name,
 	       1 << (this->chipshift - 20),
@@ -366,9 +366,9 @@ void doc_print(struct DiskOnChip *this) {
 		       "\t    Binary partition: size %ld%s\n"
 		       "\t    Flash disk partition: size %ld%s, offset 0x%lx\n",
 		       bin_size > (1 << 20) ? bin_size >> 20 : bin_size >> 10,
-		       bin_size > (1 << 20) ? "MB" : "kB",
+		       bin_size > (1 << 20) ? "MiB" : "KiB",
 		       flash_size > (1 << 20) ? flash_size >> 20 : flash_size >> 10,
-		       flash_size > (1 << 20) ? "MB" : "kB", bin_size);
+		       flash_size > (1 << 20) ? "MiB" : "KiB", bin_size);
 	} else {
 		puts ("\t  No NFTL boot record found.\n");
 	}
@@ -794,7 +794,7 @@ static void DoC_ScanChips(struct DiskOnChip *this)
 	this->totlen = this->numchips * (1 << this->chipshift);
 
 #ifdef DOC_DEBUG
-	printf("%d flash chips found. Total DiskOnChip size: %ld MB\n",
+	printf("%d flash chips found. Total DiskOnChip size: %ld MiB\n",
 	       this->numchips, this->totlen >> 20);
 #endif
 }
@@ -990,7 +990,7 @@ static void DoC2k_init(struct DiskOnChip* this)
 	else
 		this->nftl_found = 1;
 
-	printf("%s @ 0x%lX, %ld MB\n", this->name, this->physadr, this->totlen >> 20);
+	printf("%s @ 0x%lX, %ld MiB\n", this->name, this->physadr, this->totlen >> 20);
 }
 
 int doc_read_ecc(struct DiskOnChip* this, loff_t from, size_t len,
diff --git a/common/cmd_ext2.c b/common/cmd_ext2.c
index f569406432..e3a9451396 100644
--- a/common/cmd_ext2.c
+++ b/common/cmd_ext2.c
@@ -59,10 +59,10 @@
 int do_ext2ls (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
 	char *filename = "/";
-	int dev=0;
-	int part=1;
+	int dev = 0;
+	int part = 1;
 	char *ep;
-	block_dev_desc_t *dev_desc=NULL;
+	block_dev_desc_t *dev_desc = NULL;
 	int part_length;
 
 	if (argc < 3) {
@@ -70,6 +70,7 @@ int do_ext2ls (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 		return(1);
 	}
 	dev = (int)simple_strtoul (argv[2], &ep, 16);
+	//printf("argv[1] = %s dev =%d",argv[1],dev);
 	dev_desc = get_dev(argv[1],dev);
 
 	if (dev_desc == NULL) {
@@ -114,6 +115,66 @@ int do_ext2ls (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 	return(0);
 }
 
+/**********************************************************************
+Function   :check_ext2_usb
+Descriptor :
+Input      : part: partition
+Output     : none
+return     : 0:   success
+             1:   not ext2
+             2:   ext2,but lost file
+Notice	   :
+**********************************************************************/
+extern int check_ext2_usb(int part)
+{
+	int  nfile;
+	char *filename_kernel = "vmlinux.ub";
+	char *filename_fs = "/root";
+
+	int dev=0;
+	block_dev_desc_t *dev_desc = NULL;
+	int part_length;
+
+	dev_desc = get_dev("usb",0);  //first partition
+
+	if (dev_desc == NULL)
+	{
+		printf ("[error]: Block dev not supported\n");
+		return(1);
+	}
+
+	part_length = ext2fs_set_blk_dev(dev_desc, part);
+	if (part_length == 0)
+	{
+		ext2fs_close();
+		return(1);
+	}
+
+	if (!ext2fs_mount(part_length))   //if ext2 type
+	{
+		ext2fs_close();
+		return(1);
+	}
+
+	if (ext2fs_find_dir(filename_fs))
+	{
+		printf("[error]:FileSystem not found %s ...\n",filename_fs);
+		ext2fs_close();
+		return(2);
+	}
+
+	if (ext2fs_open(filename_kernel) < 0)
+	{
+		printf("[error]:Kernel not found %s ...\n", filename_kernel);
+		ext2fs_close();
+		return(2);
+	}
+
+	ext2fs_close();
+
+	return(0);
+}
+
 U_BOOT_CMD(
 	ext2ls,	4,	1,	do_ext2ls,
 	"ext2ls  - list files in a directory (default /)\n",
diff --git a/common/cmd_ide.c b/common/cmd_ide.c
index 821dcff9bf..9e150b0e96 100644
--- a/common/cmd_ide.c
+++ b/common/cmd_ide.c
@@ -56,6 +56,10 @@
 #include <asm/io.h>
 #endif
 
+#if defined(CONFIG_SH_STB7100_SATA) && defined(CONFIG_SH_STB7100)
+#include <asm/stb7100reg.h>
+#endif
+
 #ifdef CONFIG_IDE_8xx_DIRECT
 DECLARE_GLOBAL_DATA_PTR;
 #endif
@@ -68,6 +72,12 @@ DECLARE_GLOBAL_DATA_PTR;
 # define SYNC		/* nothing */
 #endif
 
+#if defined(__GNUC__) && !defined(__STRICT_ANSI__)
+#define INT64(X) X##LL	/* explicit qualification, to avoid warnings */
+#else
+#define INT64(X) X
+#endif
+
 #ifdef CONFIG_IDE_8xx_DIRECT
 /* Timings for IDE Interface
  *
@@ -930,6 +940,23 @@ output_data(int dev, ulong *sect_buf, int words)
 	}
 #endif
 }
+#elif defined(CONFIG_SH_STB7100_SATA) && defined(CONFIG_SH_STB7100)
+static void
+output_data(int dev, ulong *sect_buf, int words)
+{
+	int count = words<<1;
+	const unsigned short *buf = (unsigned short *)sect_buf;
+	DECLARE_GLOBAL_DATA_PTR;
+	bd_t *bd = gd->bd;
+	if (STB7100_DEVICEID_7109(bd->bi_devid) && (STB7100_DEVICEID_CUT(bd->bi_devid) >= 2))
+	{
+		while (count--)
+			writew(*buf++, ATA_CURR_BASE(dev)+ATA_DATA_REG);
+	} else {
+		while (count--)
+			writel(*buf++, ATA_CURR_BASE(dev)+ATA_DATA_REG);
+	}
+}
 #else	/* ! __PPC__ */
 static void
 output_data(int dev, ulong *sect_buf, int words)
@@ -988,6 +1015,23 @@ input_data(int dev, ulong *sect_buf, int words)
 	}
 #endif
 }
+#elif defined(CONFIG_SH_STB7100_SATA) && defined(CONFIG_SH_STB7100)
+static void
+input_data(int dev, ulong *sect_buf, int words)
+{
+	unsigned short *buf = (unsigned short *)sect_buf;
+	int count = words << 1;
+	DECLARE_GLOBAL_DATA_PTR;
+	bd_t *bd = gd->bd;
+	if (STB7100_DEVICEID_7109(bd->bi_devid) && (STB7100_DEVICEID_CUT(bd->bi_devid) >= 2))
+	{
+		while (count--)
+		  *buf++ = readw(ATA_CURR_BASE(dev)+ATA_DATA_REG);
+	} else {
+		while (count--)
+		  *buf++ = readl(ATA_CURR_BASE(dev)+ATA_DATA_REG);
+	}
+}
 #else	/* ! __PPC__ */
 static void
 input_data(int dev, ulong *sect_buf, int words)
@@ -1142,8 +1186,8 @@ static void ide_ident (block_dev_desc_t *dev_desc)
 	 * 6.2.1.6: Identfy Drive, Table 39 for more details
 	 */
 
-	strswab (dev_desc->revision);
-	strswab (dev_desc->vendor);
+	strswab ((char*)dev_desc->revision);
+	strswab ((char*)dev_desc->vendor);
 #endif /* __LITTLE_ENDIAN */
 
 	if ((iop->config & 0x0080)==0x0080)
@@ -1242,7 +1286,7 @@ ulong ide_read (int device, lbaint_t blknr, ulong blkcnt, void *buffer)
 #ifdef CONFIG_LBA48
 	unsigned char lba48 = 0;
 
-	if (blknr & 0x0000fffff0000000) {
+	if (blknr & INT64(0x0000fffff0000000)) {
 		/* more than 28 bits used, use 48bit mode */
 		lba48 = 1;
 	}
@@ -1361,7 +1405,7 @@ ulong ide_write (int device, lbaint_t blknr, ulong blkcnt, void *buffer)
 #ifdef CONFIG_LBA48
 	unsigned char lba48 = 0;
 
-	if (blknr & 0x0000fffff0000000) {
+	if (blknr & INT64(0x0000fffff0000000)) {
 		/* more than 28 bits used, use 48bit mode */
 		lba48 = 1;
 	}
@@ -1752,7 +1796,7 @@ unsigned char atapi_issue(int device,unsigned char* ccb,int ccblen, unsigned cha
 	}
 
 	output_data_shorts (device, (unsigned short *)ccb,ccblen/2); /* write command block */
- 	/* ATAPI Command written wait for completition */
+	/* ATAPI Command written wait for completition */
 	udelay (5000); /* device must set bsy */
 
 	mask = ATA_STAT_DRQ|ATA_STAT_BUSY|ATA_STAT_ERR;
diff --git a/common/cmd_itest.c b/common/cmd_itest.c
index ce988723c0..c6708b65b8 100644
--- a/common/cmd_itest.c
+++ b/common/cmd_itest.c
@@ -68,17 +68,23 @@ extern int cmd_get_data_size(char* arg, int default_size);
 
 static long evalexp(char *s, int w)
 {
-	long l, *p;
+	long l=0, *p;
 
 	/* if the parameter starts with a * then assume is a pointer to the value we want */
 	if (s[0] == '*') {
 		p = (long *)simple_strtoul(&s[1], NULL, 16);
-		l = *p;
+		switch (w)
+		{
+		  case 1: l = *(char*)p; break;
+		  case 2: l = *(short*)p; break;
+		  case 4: l = *(long*)p; break;
+		  default: BUG();
+		}
 	} else {
 		l = simple_strtoul(s, NULL, 16);
 	}
 
-	return (l & ((1 << (w * 8)) - 1));
+	return (w < 4) ? (l & ((1 << (w * 8)) - 1)) : l;
 }
 
 static char * evalstr(char *s)
diff --git a/common/cmd_mem.c b/common/cmd_mem.c
index a994211138..149995c272 100644
--- a/common/cmd_mem.c
+++ b/common/cmd_mem.c
@@ -392,14 +392,14 @@ int do_mem_cp ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 	   ) {
 		int rc;
 
-		puts ("Copy to Flash... ");
+		puts ("Copy to Flash\n");
 
 		rc = flash_write ((char *)addr, dest, count*size);
 		if (rc != 0) {
 			flash_perror (rc);
 			return (1);
 		}
-		puts ("done\n");
+		puts (" done\n");
 		return 0;
 	}
 #endif
@@ -710,8 +710,9 @@ int do_mem_mtest (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 		pattern = 0;
 	}
 
+	printf ("Testing %08lx ... %08lx  (", (ulong)start, (ulong)end);
+	print_size ( (ulong)end - (ulong)start, "):\n" );
 #if defined(CFG_ALT_MEMTEST)
-	printf ("Testing %08x ... %08x:\n", (uint)start, (uint)end);
 	PRINTF("%s:%d: start 0x%p end 0x%p\n",
 		__FUNCTION__, __LINE__, start, end);
 
diff --git a/common/cmd_mii.c b/common/cmd_mii.c
index f530a38421..73e94ff0d1 100644
--- a/common/cmd_mii.c
+++ b/common/cmd_mii.c
@@ -107,7 +107,7 @@ int do_mii (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 		for (j = start; j < end; j++) {
 			if (miiphy_info (devname, j, &oui, &model, &rev) == 0) {
 				printf ("PHY 0x%02X: "
-					"OUI = 0x%04X, "
+					"OUI = 0x%06X, "
 					"Model = 0x%02X, "
 					"Rev = 0x%02X, "
 					"%3dbase%s, %s\n",
@@ -493,7 +493,7 @@ int do_mii (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 		for (j = start; j <= end; j++) {
 			if (miiphy_info (devname, j, &oui, &model, &rev) == 0) {
 				printf("PHY 0x%02X: "
-					"OUI = 0x%04X, "
+					"OUI = 0x%06X, "
 					"Model = 0x%02X, "
 					"Rev = 0x%02X, "
 					"%3dbase%s, %s\n",
diff --git a/common/cmd_nand.c b/common/cmd_nand.c
index 1fdd7a67f6..dcff015d3c 100644
--- a/common/cmd_nand.c
+++ b/common/cmd_nand.c
@@ -332,7 +332,7 @@ int do_nand(cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 				opts.buffer	= (u_char*) addr;
 				opts.length	= size;
 				opts.offset	= off;
-				opts.quiet      = quiet;
+				opts.quiet	= quiet;
 				ret = nand_read_opts(nand, &opts);
 			} else {
 				/* write */
@@ -343,10 +343,27 @@ int do_nand(cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 				opts.offset	= off;
 				/* opts.forcejffs2 = 1; */
 				opts.pad	= 1;
-				opts.blockalign = 1;
-				opts.quiet      = quiet;
+				opts.blockalign	= 1;
+				opts.quiet	= quiet;
 				ret = nand_write_opts(nand, &opts);
 			}
+#ifdef CFG_NAND_YAFFS_WRITE
+		} else if (!read && s != NULL &&
+			   (!strcmp(s, ".yaffs") || !strcmp(s, ".yaffs1"))) {
+			nand_write_options_t opts;
+			memset(&opts, 0, sizeof(opts));
+			opts.buffer	= (u_char*) addr;
+			opts.length	= size;
+			opts.offset	= off;
+			opts.pad	= 0;
+			opts.blockalign	= 1;
+			opts.quiet	= quiet;
+			opts.writeoob	= 1;
+			opts.autoplace	= 1;
+			if (s[6] == '1')
+				opts.forceyaffs = 1;
+			ret = nand_write_opts(nand, &opts);
+#endif
 		} else {
 			if (read)
 				ret = nand_read(nand, off, &size, (u_char *)addr);
@@ -458,6 +475,10 @@ U_BOOT_CMD(nand, 5, 1, do_nand,
 	"nand read[.jffs2]     - addr off|partition size\n"
 	"nand write[.jffs2]    - addr off|partition size - read/write `size' bytes starting\n"
 	"    at offset `off' to/from memory address `addr'\n"
+#ifdef CFG_NAND_YAFFS_WRITE
+	"nand write[.yaffs[1]] - addr off|partition size - write `size' byte yaffs image\n"
+	"    starting at offset `off' from memory address `addr' (.yaffs1 for 512+16 NAND)\n"
+#endif
 	"nand erase [clean] [off size] - erase `size' bytes from\n"
 	"    offset `off' (entire device if not specified)\n"
 	"nand bad - show bad blocks\n"
@@ -476,25 +497,48 @@ static int nand_load_image(cmd_tbl_t *cmdtp, nand_info_t *nand,
 	ulong cnt;
 	image_header_t *hdr;
 	int jffs2 = 0;
+	unsigned long erasesize = nand->erasesize;
+	long len;
 
 	s = strchr(cmd, '.');
 	if (s != NULL &&
 	    (!strcmp(s, ".jffs2") || !strcmp(s, ".e") || !strcmp(s, ".i")))
 		jffs2 = 1;
 
-	printf("\nLoading from %s, offset 0x%lx\n", nand->name, offset);
+	//printf("\nLoading from %s, offset 0x%lx,jffs2 = %d\n", nand->name, offset, jffs2);
 
+	jffs2 = 1;////////add by zqyang
 	cnt = nand->oobblock;
 	if (jffs2) {
-		nand_read_options_t opts;
-		memset(&opts, 0, sizeof(opts));
-		opts.buffer	= (u_char*) addr;
-		opts.length	= cnt;
-		opts.offset	= offset;
-		opts.quiet      = 1;
-		r = nand_read_opts(nand, &opts);
+		while(1) {
+			if(nand_block_isbad(nand, offset)) {
+				/* skip bad block */
+				//printf("offset = 0x%x\n",offset);
+				offset += erasesize;
+				continue;
+			}
+			printf("******nand read.jffs2*****cnt = %d addr=0x%x,offset= 0x%x\n",cnt,addr,offset);
+			nand_read_options_t opts;
+			memset(&opts, 0, sizeof(opts));
+			opts.buffer	= (u_char*) addr;
+			opts.length	= cnt;
+			opts.offset	= offset;
+			opts.quiet	= 1;
+			r = nand_read_opts(nand, &opts);
+			break;
+		}
 	} else {
-		r = nand_read(nand, offset, &cnt, (u_char *) addr);
+		while(1) {
+			if(nand_block_isbad(nand, offset)) {
+				/* skip bad block */
+				//printf("offset = 0x%x\n",offset);
+				offset += erasesize;
+				continue;
+			}
+			// printf("********no jffs2********yzqing test  cnt = %d addr=0x%x,offset= 0x%x\n",cnt,addr,offset);
+			r = nand_read(nand, offset, &cnt, (u_char *) addr);
+			break;
+		}
 	}
 
 	if (r) {
@@ -522,16 +566,35 @@ static int nand_load_image(cmd_tbl_t *cmdtp, nand_info_t *nand,
 		opts.buffer	= (u_char*) addr;
 		opts.length	= cnt;
 		opts.offset	= offset;
-		opts.quiet      = 1;
+		opts.quiet	= 1;
 		r = nand_read_opts(nand, &opts);
 	} else {
 		r = nand_read(nand, offset, &cnt, (u_char *) addr);
-	}
+		while(cnt > 0) {
+			if(nand_block_isbad(nand, offset)) {
+				/* skip bad block */
+				//printf("offset = 0x%x\n",offset);
+				offset += erasesize;
+				continue;
+			}
 
-	if (r) {
-		puts("** Read error\n");
-		show_boot_progress (-58);
-		return 1;
+			if(cnt > erasesize) {
+				len = erasesize;
+			} else {
+				len = cnt;
+			}
+			// printf("offset = 0x%x,len= 0x%x\n",offset,len);
+
+			r = nand_read(nand, offset, &len, (u_char *) addr);
+			if (r) {
+				puts("** Read error\n");
+				show_boot_progress (-58);
+				return 1;
+			}
+			cnt = cnt - len;
+			offset += len;
+			addr += len;
+		}
 	}
 	show_boot_progress (58);
 
diff --git a/common/cmd_spi.c b/common/cmd_spi.c
index 7604422141..bbd635764f 100644
--- a/common/cmd_spi.c
+++ b/common/cmd_spi.c
@@ -1,6 +1,7 @@
 /*
  * (C) Copyright 2002
  * Gerald Van Baren, Custom IDEAS, vanbaren@cideas.com
+ * (C) Copyright 2009 STMicroelectronics.  Sean McGoogan <Sean.McGoogan@st.com>
  *
  * See file CREDITS for list of people who contributed to this
  * project.
@@ -28,6 +29,7 @@
 #include <common.h>
 #include <command.h>
 #include <spi.h>
+#include <linux/ctype.h>
 
 /*-----------------------------------------------------------------------
  * Definitions
@@ -37,13 +39,6 @@
 #   define MAX_SPI_BYTES 32	/* Maximum number of bytes we can handle */
 #endif
 
-/*
- * External table of chip select functions (see the appropriate board
- * support for the actual definition of the table).
- */
-extern spi_chipsel_type spi_chipsel[];
-extern int spi_chipsel_cnt;
-
 /*
  * Values from last command.
  */
@@ -65,10 +60,10 @@ static uchar din[MAX_SPI_BYTES];
 
 int do_spi (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
-	char  *cp = 0;
+	uchar *cp = 0;
 	uchar tmp;
-	int   j;
-	int   rcode = 0;
+	int j;
+	int rcode = 0;
 
 	/*
 	 * We use the last specified parameters, unless new ones are
@@ -82,7 +77,7 @@ int do_spi (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 		if (argc >= 3)
 			bitlen = simple_strtoul(argv[2], NULL, 10);
 		if (argc >= 4) {
-			cp = argv[3];
+			cp = (uchar*)argv[3];
 			for(j = 0; *cp; j++, cp++) {
 				tmp = *cp - '0';
 				if(tmp > 9)
@@ -90,7 +85,7 @@ int do_spi (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 				if(tmp > 15)
 					tmp -= ('a' - 'A');
 				if(tmp > 15) {
-					printf("Hex conversion error on %c, giving up.\n", *cp);
+					//printf("Hex conversion error on %c, giving up.\n", *cp);
 					return 1;
 				}
 				if((j % 2) == 0)
@@ -102,31 +97,196 @@ int do_spi (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 	}
 
 	if ((device < 0) || (device >=  spi_chipsel_cnt)) {
-		printf("Invalid device %d, giving up.\n", device);
+		//printf("Invalid device %d, giving up.\n", device);
 		return 1;
 	}
 	if ((bitlen < 0) || (bitlen >  (MAX_SPI_BYTES * 8))) {
-		printf("Invalid bitlen %d, giving up.\n", bitlen);
+		//printf("Invalid bitlen %d, giving up.\n", bitlen);
 		return 1;
 	}
 
+#if 0
 	debug ("spi_chipsel[%d] = %08X\n",
 		device, (uint)spi_chipsel[device]);
+#endif
 
 	if(spi_xfer(spi_chipsel[device], bitlen, dout, din) != 0) {
-		printf("Error with the SPI transaction.\n");
+		//printf("Error with the SPI transaction.\n");
 		rcode = 1;
 	} else {
-		cp = (char *)din;
+		cp = din;
+#if 0
 		for(j = 0; j < ((bitlen + 7) / 8); j++) {
 			printf("%02X", *cp++);
 		}
 		printf("\n");
+#endif
 	}
 
 	return rcode;
 }
 
+int do_update_spi (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	unsigned char StartAddr[10] = {0};
+	unsigned char *DataBufferAddr = NULL;
+	char *str_filesize = NULL;
+	unsigned long file_size = 0;
+
+	DataBufferAddr = (unsigned char *)0x80000000;
+
+	str_filesize = getenv("filesize");
+	if (NULL == str_filesize) {
+	}
+
+	file_size = simple_strtoul(str_filesize, NULL, 16);
+	spi_write(StartAddr, 1, DataBufferAddr , file_size);
+	return 0;
+}
+
+extern int do_auto_update_uboot_to_spi (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	unsigned char StartAddr[10] = {0};
+	unsigned char *DataBufferAddr = NULL;
+	char *str_filesize = NULL;
+	unsigned long file_size = 0;
+
+	DataBufferAddr = (unsigned char *)(0x80000000+argc);
+
+	file_size = flag;
+	spi_write(StartAddr, 1, DataBufferAddr, file_size);
+	return 0;
+}
+
+extern unsigned char ReadSPIFlashDataByChar(unsigned int AddressOfFlag)
+{
+	unsigned char CharData;
+	unsigned char StartAddr[3];
+
+	StartAddr[0] = (AddressOfFlag>>16)&0xff;
+	StartAddr[1] = (AddressOfFlag>>8)&0xff;
+	StartAddr[2] = AddressOfFlag&0xff;
+
+	spi_read(StartAddr, 3, &CharData, 1);
+
+	return CharData;
+}
+
+extern unsigned char WriteSPIFlashDataByChar(unsigned int AddressOfFlag, unsigned char Data)
+{
+	unsigned char CharData;
+	unsigned char StartAddr[3];
+
+	CharData = Data;
+	StartAddr[0] = (AddressOfFlag>>16)&0xff;
+	StartAddr[1] = (AddressOfFlag>>8)&0xff;
+	StartAddr[2] = AddressOfFlag&0xff;
+
+	spi_write(StartAddr, 3, &CharData, 1);
+
+	return 0;
+}
+
+extern unsigned char ReadSPIFlashDataToBuffer(unsigned int AddressOfFlag, unsigned char *buffer, unsigned int length)
+{
+	unsigned char CharData;
+	unsigned char StartAddr[3];
+
+	StartAddr[0] = (AddressOfFlag>>16)&0xff;
+	StartAddr[1] = (AddressOfFlag>>8)&0xff;
+	StartAddr[2] = AddressOfFlag&0xff;
+
+	spi_read(StartAddr, 3, buffer, length);
+
+	return CharData;
+}
+
+extern unsigned char WriteSPIFlashDataFromBuffer(unsigned int AddressOfFlag, unsigned char *buffer, unsigned int length)
+{
+	unsigned char CharData;
+	unsigned char StartAddr[3];
+
+	StartAddr[0] = (AddressOfFlag>>16)&0xff;
+	StartAddr[1] = (AddressOfFlag>>8)&0xff;
+	StartAddr[2] = AddressOfFlag&0xff;
+
+	spi_write(StartAddr, 3, buffer, length);
+
+	return 0;
+}
+
+int do_update_flag (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	unsigned int PushUpdateFlag = 0xfbcdbcdf;
+	unsigned int StartAddr = 0x90000;
+
+	WriteSPIFlashDataFromBuffer(StartAddr, &PushUpdateFlag, 4);
+	return 0;
+}
+
+extern void EraseSPIDataByAddr(unsigned int Addr, unsigned int len)
+{
+	unsigned int StartAddr;
+	unsigned char Buffer[0x10000];
+
+	memset(Buffer, 0xff, 0x10000);
+	StartAddr = Addr;
+
+	WriteSPIFlashDataFromBuffer(StartAddr, Buffer, len);
+}
+
+static void do_EraseSPIDataByAddr(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	int nBlockNum = -1;
+	unsigned int StartAddr = 0x80000;
+	unsigned int Len = 0;
+	unsigned char Buffer[0x10000];
+
+	memset(Buffer, 0xff, 0x10000);
+	StartAddr = simple_strtoul(argv[1], NULL, 16);
+	Len = simple_strtoul(argv[2], NULL, 16);
+
+	WriteSPIFlashDataFromBuffer(StartAddr, Buffer, Len);
+}
+
+static void do_ChangeFlag(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	unsigned int StartAddr = 0x90000;
+	unsigned int date = 0;
+
+	date = simple_strtoul(argv[1], NULL, 10);
+	WriteSPIFlashDataByChar(StartAddr, date);
+}
+
+static void do_ChangeMacAddr(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	int nBlockNum = -1;
+	unsigned int Len = 0;
+	unsigned char Buffer[30];
+	unsigned int StartAddr = 0xa0000 + 19;
+	unsigned int Time = 0;
+	unsigned int j = 0;
+
+	memset(Buffer, 0xff, sizeof(Buffer));
+
+	j = 0;
+	for(Time = 0; Time < 12; Time++) {
+		for(; j < 100;) {
+			if(isxdigit(argv[1][j])) {
+				break;
+			} else {
+				j++;
+				continue;
+			}
+		}
+
+		Buffer[Time] = argv[1][j];
+		j++;
+	}
+
+	WriteSPIFlashDataFromBuffer(StartAddr, Buffer, 12);
+}
+
 /***************************************************/
 
 U_BOOT_CMD(
@@ -137,3 +297,40 @@ U_BOOT_CMD(
 	"<bit_len> - Number of bits to send (base 10)\n"
 	"<dout>    - Hexadecimal string that gets sent\n"
 );
+
+U_BOOT_CMD(
+	auto_update_uboot_to_spi,	1,	1,	do_auto_update_uboot_to_spi,
+	"auto_update_uboot_to_spi - Update new u-boo.bin to SPI Flash\n",
+	NULL
+	);
+
+U_BOOT_CMD(
+	update_spi_uboot,	1,	1,	do_update_spi,
+	"update_spi_uboot - Update uboot in SPI Flash\n",
+	NULL
+	);
+
+U_BOOT_CMD(
+	set_pushupdate_flag,	1,	1,	do_update_flag,
+	"set_pushupdate_flag - set update_uboot_flag in SPI Flash\n",
+	NULL
+	);
+
+U_BOOT_CMD(
+	eraseSPIData,	 3,	1,	do_EraseSPIDataByAddr,
+	"eraseSPIData  addr len - set ff to SPI Flash\n",
+	NULL
+	);
+
+U_BOOT_CMD(
+	changeMacAddr,	 2,	1,	do_ChangeMacAddr,
+	"changeMacAddr  addr  - set mac addr to SPI Flash\n",
+	NULL
+	);
+
+U_BOOT_CMD(
+	changeflag,	 2,	1,	do_ChangeFlag,
+	"changeflag  date - change flag to SPI Flash  ep:changeflag 255\n",
+	NULL
+	);
+
diff --git a/common/cmd_usb.c b/common/cmd_usb.c
index c6b17c2ab7..a12d7dc516 100644
--- a/common/cmd_usb.c
+++ b/common/cmd_usb.c
@@ -31,8 +31,12 @@
 #include <part.h>
 #include <usb.h>
 
+#if defined(__SH4__)
+#include <asm/cache.h>
+#endif
+
 #ifdef CONFIG_USB_STORAGE
-static int usb_stor_curr_dev=-1; /* current device */
+static int usb_stor_curr_dev = -1; /* current device */
 #endif
 
 /* some display routines (info command) */
@@ -142,15 +146,15 @@ void usb_display_class_sub(unsigned char dclass,unsigned char subclass,unsigned
 void usb_display_string(struct usb_device *dev,int index)
 {
 	char buffer[256];
-	if (index!=0) {
-		if (usb_string(dev,index,&buffer[0],256)>0);
+	if (index != 0) {
+		if (usb_string(dev,index,&buffer[0],256) > 0);
 			printf("String: \"%s\"",buffer);
 	}
 }
 
 void usb_display_desc(struct usb_device *dev)
 {
-	if (dev->descriptor.bDescriptorType==USB_DT_DEVICE) {
+	if (dev->descriptor.bDescriptorType == USB_DT_DEVICE) {
 		printf("%d: %s,  USB Revision %x.%x\n",dev->devnum,usb_get_class_desc(dev->config.if_desc[0].bInterfaceClass),
 			(dev->descriptor.bcdUSB>>8) & 0xff,dev->descriptor.bcdUSB & 0xff);
 		if (strlen(dev->mf) || strlen(dev->prod) || strlen(dev->serial))
@@ -206,7 +210,7 @@ void usb_display_ep_desc(struct usb_endpoint_descriptor *epdesc)
 		case 3: printf("Interrupt"); break;
 	}
 	printf(" MaxPacket %d",epdesc->wMaxPacketSize);
-	if ((epdesc->bmAttributes & 0x03)==0x3)
+	if ((epdesc->bmAttributes & 0x03) == 0x3)
 		printf(" Interval %dms",epdesc->bInterval);
 	printf("\n");
 }
@@ -217,15 +221,15 @@ void usb_display_config(struct usb_device *dev)
 	struct usb_config_descriptor *config;
 	struct usb_interface_descriptor *ifdesc;
 	struct usb_endpoint_descriptor *epdesc;
-	int i,ii;
+	int i, ii;
 
-	config= &dev->config;
+	config = &dev->config;
 	usb_display_conf_desc(config,dev);
-	for(i=0;i<config->no_of_if;i++) {
-		ifdesc= &config->if_desc[i];
+	for(i=0; i < config->no_of_if; i++) {
+		ifdesc = &config->if_desc[i];
 		usb_display_if_desc(ifdesc,dev);
-		for(ii=0;ii<ifdesc->no_of_ep;ii++) {
-			epdesc= &ifdesc->ep_desc[ii];
+		for(ii=0; ii < ifdesc->no_of_ep; ii++) {
+			epdesc = &ifdesc->ep_desc[ii];
 			usb_display_ep_desc(epdesc);
 		}
 	}
@@ -235,29 +239,29 @@ void usb_display_config(struct usb_device *dev)
 /* shows the device tree recursively */
 void usb_show_tree_graph(struct usb_device *dev,char *pre)
 {
-	int i,index;
-	int has_child,last_child,port;
+	int i, index;
+	int has_child, last_child, port;
 
-	index=strlen(pre);
+	index = strlen(pre);
 	printf(" %s",pre);
 	/* check if the device has connected children */
-	has_child=0;
-	for(i=0;i<dev->maxchild;i++) {
-		if (dev->children[i]!=NULL)
-			has_child=1;
+	has_child = 0;
+	for(i=0; i < dev->maxchild; i++) {
+		if (dev->children[i] != NULL)
+			has_child = 1;
 	}
 	/* check if we are the last one */
-	last_child=1;
-	if (dev->parent!=NULL) {
-		for(i=0;i<dev->parent->maxchild;i++) {
+	last_child = 1;
+	if (dev->parent != NULL) {
+		for(i=0; i < dev->parent->maxchild; i++) {
 			/* search for children */
-			if (dev->parent->children[i]==dev) {
+			if (dev->parent->children[i] == dev) {
 				/* found our pointer, see if we have a little sister */
-				port=i;
-				while(i++<dev->parent->maxchild) {
-					if (dev->parent->children[i]!=NULL) {
+				port = i;
+				while(i++ < dev->parent->maxchild) {
+					if (dev->parent->children[i] != NULL) {
 						/* found a sister */
-						last_child=0;
+						last_child = 0;
 						break;
 					} /* if */
 				} /* while */
@@ -266,15 +270,15 @@ void usb_show_tree_graph(struct usb_device *dev,char *pre)
 		printf("\b+-");
 		/* correct last child */
 		if (last_child) {
-			pre[index-1]=' ';
+			pre[index-1] = ' ';
 		}
 	} /* if not root hub */
 	else
 		printf(" ");
 	printf("%d ",dev->devnum);
-	pre[index++]=' ';
-	pre[index++]= has_child ? '|' : ' ';
-	pre[index]=0;
+	pre[index++] = ' ';
+	pre[index++] = has_child ? '|' : ' ';
+	pre[index] = 0;
 	printf(" %s (%s, %dmA)\n",usb_get_class_desc(dev->config.if_desc[0].bInterfaceClass),
 		dev->slow ? "1.5MBit/s" : "12MBit/s",dev->config.MaxPower * 2);
 	if (strlen(dev->mf) ||
@@ -282,11 +286,11 @@ void usb_show_tree_graph(struct usb_device *dev,char *pre)
 	   strlen(dev->serial))
 		printf(" %s  %s %s %s\n",pre,dev->mf,dev->prod,dev->serial);
 	printf(" %s\n",pre);
-	if (dev->maxchild>0) {
-		for(i=0;i<dev->maxchild;i++) {
-			if (dev->children[i]!=NULL) {
+	if (dev->maxchild > 0) {
+		for(i=0; i < dev->maxchild; i++) {
+			if (dev->children[i] != NULL) {
 				usb_show_tree_graph(dev->children[i],pre);
-				pre[index]=0;
+				pre[index] = 0;
 			}
 		}
 	}
@@ -310,7 +314,7 @@ int do_usbboot (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
 	char *boot_device = NULL;
 	char *ep;
-	int dev, part=1, rcode;
+	int dev, part = 1, rcode;
 	ulong addr, cnt, checksum;
 	disk_partition_t info;
 	image_header_t *hdr;
@@ -341,12 +345,12 @@ int do_usbboot (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 	}
 
 	dev = simple_strtoul(boot_device, &ep, 16);
-	stor_dev=usb_stor_get_dev(dev);
+	stor_dev = usb_stor_get_dev(dev);
 	if (stor_dev->type == DEV_TYPE_UNKNOWN) {
 		printf ("\n** Device %d not available\n", dev);
 		return 1;
 	}
-	if (stor_dev->block_read==NULL) {
+	if (stor_dev->block_read == NULL) {
 		printf("storage device not initialized. Use usb scan\n");
 		return 1;
 	}
@@ -362,9 +366,9 @@ int do_usbboot (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 		/* try to boot raw .... */
 		strncpy((char *)&info.type[0], BOOT_PART_TYPE, sizeof(BOOT_PART_TYPE));
 		strncpy((char *)&info.name[0], "Raw", 4);
-		info.start=0;
-		info.blksz=0x200;
-		info.size=2880;
+		info.start = 0;
+		info.blksz = 0x200;
+		info.size = 2880;
 		printf("error reading partinfo...try to boot raw\n");
 	}
 	if ((strncmp((char *)info.type, BOOT_PART_TYPE, sizeof(info.type)) != 0) &&
@@ -449,20 +453,23 @@ int do_usb (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 
 	if ((strncmp(argv[1], "reset", 5) == 0) ||
 		 (strncmp(argv[1], "start", 5) == 0)){
+		sh_disable_data_caches();
 		usb_stop();
 		printf("(Re)start USB...\n");
+		//udelay(10000000);
 		i = usb_init();
 #ifdef CONFIG_USB_STORAGE
 		/* try to recognize storage devices immediately */
 		if (i >= 0)
-	 		usb_stor_curr_dev = usb_stor_scan(1);
+			usb_stor_curr_dev = usb_stor_scan(1);
 #endif
+		sh_enable_data_caches();
 		return 0;
 	}
 	if (strncmp(argv[1],"stop",4) == 0) {
 #ifdef CONFIG_USB_KEYBOARD
-		if (argc==2) {
-			if (usb_kbd_deregister()!=0) {
+		if (argc == 2) {
+			if (usb_kbd_deregister() != 0) {
 				printf("USB not stopped: usbkbd still using USB\n");
 				return 1;
 			}
@@ -487,30 +494,33 @@ int do_usb (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 	}
 	if (strncmp(argv[1],"inf",3) == 0) {
 		int d;
-		if (argc==2) {
-			for(d=0;d<USB_MAX_DEVICE;d++) {
+		sh_disable_data_caches();
+		if (argc == 2) {
+			for(d = 0; d < USB_MAX_DEVICE; d++) {
 				dev=usb_get_dev_index(d);
-				if (dev==NULL)
+				if (dev == NULL)
 					break;
 				usb_display_desc(dev);
 				usb_display_config(dev);
 			}
+			sh_enable_data_caches();
 			return 0;
 		}
 		else {
 			int d;
 
-			i=simple_strtoul(argv[2], NULL, 16);
+			i = simple_strtoul(argv[2], NULL, 16);
 			printf("config for device %d\n",i);
-			for(d=0;d<USB_MAX_DEVICE;d++) {
+			for(d = 0; d < USB_MAX_DEVICE; d++) {
 				dev=usb_get_dev_index(d);
-				if (dev==NULL)
+				if (dev == NULL)
 					break;
-				if (dev->devnum==i)
+				if (dev->devnum == i)
 					break;
 			}
-			if (dev==NULL) {
+			if (dev == NULL) {
 				printf("*** NO Device avaiable ***\n");
+				sh_enable_data_caches();
 				return 0;
 			}
 			else {
@@ -518,6 +528,7 @@ int do_usb (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 				usb_display_config(dev);
 			}
 		}
+		sh_enable_data_caches();
 		return 0;
 	}
 #ifdef CONFIG_USB_STORAGE
@@ -535,9 +546,10 @@ int do_usb (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 
 	if (strncmp(argv[1],"part",4) == 0) {
 		int devno, ok;
-		for (ok=0, devno=0; devno<USB_MAX_STOR_DEV; ++devno) {
-			stor_dev=usb_stor_get_dev(devno);
-			if (stor_dev->type!=DEV_TYPE_UNKNOWN) {
+		sh_disable_data_caches();
+		for (ok = 0, devno = 0; devno < USB_MAX_STOR_DEV; ++devno) {
+			stor_dev = usb_stor_get_dev(devno);
+			if (stor_dev->type != DEV_TYPE_UNKNOWN) {
 				ok++;
 				if (devno)
 					printf("\n");
@@ -545,6 +557,7 @@ int do_usb (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 				print_part(stor_dev);
 			}
 		}
+		sh_enable_data_caches();
 		if (!ok) {
 			printf("\nno USB devices available\n");
 			return 1;
@@ -552,21 +565,21 @@ int do_usb (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 		return 0;
 	}
 	if (strcmp(argv[1],"read") == 0) {
-		if (usb_stor_curr_dev<0) {
+		if (usb_stor_curr_dev < 0) {
 			printf("no current device selected\n");
 			return 1;
 		}
-		if (argc==5) {
+		if (argc == 5) {
 			unsigned long addr = simple_strtoul(argv[2], NULL, 16);
 			unsigned long blk  = simple_strtoul(argv[3], NULL, 16);
 			unsigned long cnt  = simple_strtoul(argv[4], NULL, 16);
 			unsigned long n;
 			printf ("\nUSB read: device %d block # %ld, count %ld ... ",
 					usb_stor_curr_dev, blk, cnt);
-			stor_dev=usb_stor_get_dev(usb_stor_curr_dev);
+			stor_dev = usb_stor_get_dev(usb_stor_curr_dev);
 			n = stor_dev->block_read(usb_stor_curr_dev, blk, cnt, (ulong *)addr);
 			printf ("%ld blocks read: %s\n",n,(n==cnt) ? "OK" : "ERROR");
-			if (n==cnt)
+			if (n == cnt)
 				return 0;
 			return 1;
 		}
@@ -580,7 +593,7 @@ int do_usb (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 				return 1;
 			}
 			printf ("\n    Device %d: ", dev);
-			stor_dev=usb_stor_get_dev(dev);
+			stor_dev = usb_stor_get_dev(dev);
 			dev_print(stor_dev);
 			if (stor_dev->type == DEV_TYPE_UNKNOWN) {
 				return 1;
@@ -591,7 +604,7 @@ int do_usb (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 		}
 		else {
 			printf ("\nUSB device %d: ", usb_stor_curr_dev);
-			stor_dev=usb_stor_get_dev(usb_stor_curr_dev);
+			stor_dev = usb_stor_get_dev(usb_stor_curr_dev);
 			dev_print(stor_dev);
 			if (stor_dev->type == DEV_TYPE_UNKNOWN) {
 				return 1;
diff --git a/common/env_common.c b/common/env_common.c
index a49481244e..23c49e953c 100644
--- a/common/env_common.c
+++ b/common/env_common.c
@@ -148,8 +148,7 @@ static uchar env_get_char_init (int index)
 	uchar c;
 
 	/* if crc was bad, use the default environment */
-	if (gd->env_valid)
-	{
+	if (gd->env_valid) {
 		c = env_get_char_spec(index);
 	} else {
 		c = default_environment[index];
@@ -224,7 +223,7 @@ void env_relocate (void)
 #if defined(CONFIG_GTH)	|| defined(CFG_ENV_IS_NOWHERE)	/* Environment not changable */
 		puts ("Using default environment\n\n");
 #else
-		puts ("*** Warning - bad CRC, using default environment\n\n");
+		//puts ("*** Warning - bad CRC, using default environment\n\n");
 		show_boot_progress (-60);
 #endif
 
@@ -265,9 +264,9 @@ int env_complete(char *var, int maxv, char *cmdv[], int bufsz, char *buf)
 
 	len = strlen(var);
 	/* now iterate over the variables and select those that match */
-	for (i=0; env_get_char(i) != '\0'; i=nxt+1) {
+	for (i = 0; env_get_char(i) != '\0'; i = nxt + 1) {
 
-		for (nxt=i; env_get_char(nxt) != '\0'; ++nxt)
+		for (nxt = i; env_get_char(nxt) != '\0'; ++nxt)
 			;
 
 		lval = (char *)env_get_addr(i);
diff --git a/common/env_flash.c b/common/env_flash.c
index eccfb62a3b..f37a6ee2c0 100644
--- a/common/env_flash.c
+++ b/common/env_flash.c
@@ -53,7 +53,7 @@ DECLARE_GLOBAL_DATA_PTR;
 # endif
 #endif
 
-char * env_name_spec = "Flash";
+char * env_name_spec = "NOR Flash";
 
 #ifdef ENV_IS_EMBEDDED
 
@@ -187,8 +187,9 @@ int saveenv(void)
 		goto Done;
 	}
 
-	puts ("Writing to Flash... ");
-	debug (" %08lX ... %08lX ...",
+	puts ("Writing to Flash...");
+	debug ("  %08lX ... %08lX ...",
+	puts ("\n");
 		(ulong)&(flash_addr_new->data),
 		sizeof(env_ptr->data)+(ulong)&(flash_addr_new->data));
 	if ((rc = flash_write((char *)env_ptr->data,
@@ -207,7 +208,7 @@ int saveenv(void)
 		flash_perror (rc);
 		goto Done;
 	}
-	puts ("done\n");
+	puts (" done\n");
 
 #if CFG_ENV_SECT_SIZE > CFG_ENV_SIZE
 	if (up_data) { /* restore the rest of sector */
@@ -306,8 +307,10 @@ int saveenv(void)
 	end_addr = flash_sect_addr + 0x20000 - 1;
 #endif
 
-	debug ("Protect off %08lX ... %08lX\n",
+	puts ("Unprotecting Flash...");
+	debug ("  %08lX ... %08lX",
 		(ulong)flash_sect_addr, end_addr);
+	puts ("\n");
 
 	if (flash_sect_protect (0, flash_sect_addr, end_addr))
 		return 1;
@@ -316,16 +319,17 @@ int saveenv(void)
 	if (flash_sect_erase (flash_sect_addr, end_addr))
 		return 1;
 
-	puts ("Writing to Flash... ");
+	puts ("Writing to Flash...\n");
 	rc = flash_write((char *)env_buffer, flash_sect_addr, len);
 	if (rc != 0) {
 		flash_perror (rc);
 		rcode = 1;
 	} else {
-		puts ("done\n");
+		puts (" done\n");
 	}
 
 	/* try to re-protect */
+	puts ("Protecting Flash...\n");
 	(void) flash_sect_protect (1, flash_sect_addr, end_addr);
 	return rcode;
 }
diff --git a/common/env_nand.c b/common/env_nand.c
index 38a07f8993..598bb64e7c 100644
--- a/common/env_nand.c
+++ b/common/env_nand.c
@@ -64,7 +64,7 @@ extern nand_info_t nand_info[];
 extern uchar default_environment[];
 extern int default_environment_size;
 
-char * env_name_spec = "NAND";
+char * env_name_spec = "NAND Flash";
 
 
 #ifdef ENV_IS_EMBEDDED
diff --git a/common/lcd.c b/common/lcd.c
index 914dc2ef7c..c7d4670021 100644
--- a/common/lcd.c
+++ b/common/lcd.c
@@ -746,7 +746,7 @@ static void *lcd_logo (void)
 		strmhz(temp, gd->cpu_clk));
 	lcd_drawchars (LCD_INFO_X, LCD_INFO_Y + VIDEO_FONT_HEIGHT * 3,
 					info, strlen(info));
-	sprintf (info, "  %ld MB RAM, %ld MB Flash",
+	sprintf (info, "  %ld MiB RAM, %ld MiB Flash",
 		gd->ram_size >> 20,
 		gd->bd->bi_flashsize >> 20 );
 	lcd_drawchars (LCD_INFO_X, LCD_INFO_Y + VIDEO_FONT_HEIGHT * 4,
@@ -754,7 +754,7 @@ static void *lcd_logo (void)
 #  else
 	/* leave one blank line */
 
-	sprintf (info, "MPC823 CPU at %s MHz, %ld MB RAM, %ld MB Flash",
+	sprintf (info, "MPC823 CPU at %s MHz, %ld MiB RAM, %ld MiB Flash",
 		strmhz(temp, gd->cpu_clk),
 		gd->ram_size >> 20,
 		gd->bd->bi_flashsize >> 20 );
diff --git a/common/main.c b/common/main.c
index 379695cc42..1a950a64e0 100644
--- a/common/main.c
+++ b/common/main.c
@@ -47,8 +47,7 @@ DECLARE_GLOBAL_DATA_PTR;
 /*
  * Board-specific Platform code can reimplement show_boot_progress () if needed
  */
-void inline __show_boot_progress (int val) {}
-void inline show_boot_progress (int val) __attribute__((weak, alias("__show_boot_progress")));
+__weak void show_boot_progress(int val) {}
 
 #if defined(CONFIG_BOOT_RETRY_TIME) && defined(CONFIG_RESET_TO_RETRY)
 extern int do_reset (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);		/* for do_reset() prototype */
@@ -511,7 +510,8 @@ void reset_cmd_timeout(void)
 
 #define CTL_CH(c)		((c) - 'a' + 1)
 
-#define MAX_CMDBUF_SIZE		256
+//#define MAX_CMDBUF_SIZE		256
+#define MAX_CMDBUF_SIZE		1024
 
 #define CTL_BACKSPACE		('\b')
 #define DEL			((char)255)
@@ -696,7 +696,7 @@ static void cread_add_str(char *str, int strsize, int insert, unsigned long *num
 	}
 }
 
-static int cread_line(char *buf, unsigned int *len)
+static int cread_line(const char *const prompt, char *buf, unsigned int *len)
 {
 	unsigned long num = 0;
 	unsigned long eol_num = 0;
@@ -818,6 +818,7 @@ static int cread_line(char *buf, unsigned int *len)
 			insert = !insert;
 			break;
 		case CTL_CH('x'):
+		case CTL_CH('u'):
 			BEGINNING_OF_LINE();
 			ERASE_TO_EOL();
 			break;
@@ -867,6 +868,27 @@ static int cread_line(char *buf, unsigned int *len)
 			REFRESH_TO_EOL();
 			continue;
 		}
+#ifdef CONFIG_AUTO_COMPLETE
+		case '\t': {
+			int num2, col;
+
+			/* do not autocomplete when in the middle */
+			if (num < eol_num) {
+				getcmd_cbeep();
+				break;
+			}
+
+			buf[num] = '\0';
+			col = strlen(prompt) + eol_num;
+			num2 = num;
+			if (cmd_auto_complete(prompt, buf, &num2, &col)) {
+				col = num2 - num;
+				num += col;
+				eol_num += col;
+			}
+			break;
+		}
+#endif
 		default:
 			cread_add_char(ichar, insert, &num, &eol_num, buf, *len);
 			break;
@@ -909,7 +931,7 @@ int readline (const char *const prompt)
 
 	puts (prompt);
 
-	rc = cread_line(p, &len);
+	rc = cread_line(prompt, p, &len);
 	return rc < 0 ? rc : len;
 #else
 	char   *p = console_buffer;
diff --git a/common/soft_spi.c b/common/soft_spi.c
index e4250616c2..e4ac762095 100644
--- a/common/soft_spi.c
+++ b/common/soft_spi.c
@@ -27,7 +27,7 @@
 #include <common.h>
 #include <spi.h>
 
-#if defined(CONFIG_SOFT_SPI)
+#if defined(CONFIG_SOFT_SPI) && !defined(CONFIG_SH4)
 
 /*-----------------------------------------------------------------------
  * Definitions
diff --git a/common/usb.c b/common/usb.c
index 933afa9e7b..b18a11731b 100644
--- a/common/usb.c
+++ b/common/usb.c
@@ -67,7 +67,7 @@
 #define USB_BUFSIZ	512
 
 static struct usb_device usb_dev[USB_MAX_DEVICE];
-static int dev_index;
+int dev_index;
 static int running;
 static int asynch_allowed;
 static struct devrequest setup_packet;
@@ -83,15 +83,6 @@ int usb_hub_probe(struct usb_device *dev, int ifnum);
 void usb_hub_reset(void);
 
 
-/***********************************************************************
- * wait_ms
- */
-
-void __inline__ wait_ms(unsigned long ms)
-{
-	while(ms-->0)
-		udelay(1000);
-}
 /***************************************************************************
  * Init USB Device
  */
@@ -171,21 +162,22 @@ int usb_control_msg(struct usb_device *dev, unsigned int pipe,
 			unsigned short value, unsigned short index,
 			void *data, unsigned short size, int timeout)
 {
-	if((timeout==0)&&(!asynch_allowed)) /* request for a asynch control pipe is not allowed */
+	if((timeout==0) && (!asynch_allowed)) /* request for a asynch control pipe is not allowed */
+	{
 		return -1;
-
+	}
 	/* set setup command */
 	setup_packet.requesttype = requesttype;
 	setup_packet.request = request;
 	setup_packet.value = swap_16(value);
 	setup_packet.index = swap_16(index);
 	setup_packet.length = swap_16(size);
- 	USB_PRINTF("usb_control_msg: request: 0x%X, requesttype: 0x%X\nvalue 0x%X index 0x%X length 0x%X\n",
+	USB_PRINTF("usb_control_msg: request: 0x%X, requesttype: 0x%X\nvalue 0x%X index 0x%X length 0x%X\n",
 		request,requesttype,value,index,size);
 	dev->status=USB_ST_NOT_PROC; /*not yet processed */
 
 	submit_control_msg(dev,pipe,data,size,&setup_packet);
-	if(timeout==0) {
+	if(timeout == 0) {
 		return (int)size;
 	}
 	while(timeout--) {
@@ -193,7 +185,7 @@ int usb_control_msg(struct usb_device *dev, unsigned int pipe,
 			break;
 		wait_ms(1);
 	}
-	if(dev->status==0)
+	if(dev->status == 0)
 		return dev->act_len;
 	else {
 		return -1;
@@ -210,15 +202,15 @@ int usb_bulk_msg(struct usb_device *dev, unsigned int pipe,
 {
 	if (len < 0)
 		return -1;
-	dev->status=USB_ST_NOT_PROC; /*not yet processed */
+	dev->status = USB_ST_NOT_PROC; /*not yet processed */
 	submit_bulk_msg(dev,pipe,data,len);
 	while(timeout--) {
 		if(!((volatile unsigned long)dev->status & USB_ST_NOT_PROC))
 			break;
 		wait_ms(1);
 	}
-	*actual_length=dev->act_len;
-	if(dev->status==0)
+	*actual_length = dev->act_len;
+	if(dev->status == 0)
 		return 0;
 	else
 		return -1;
@@ -235,40 +227,57 @@ int usb_bulk_msg(struct usb_device *dev, unsigned int pipe,
  */
 int usb_maxpacket(struct usb_device *dev,unsigned long pipe)
 {
-	if((pipe & USB_DIR_IN)==0) /* direction is out -> use emaxpacket out */
+	if((pipe & USB_DIR_IN) == 0) /* direction is out -> use emaxpacket out */
 		return(dev->epmaxpacketout[((pipe>>15) & 0xf)]);
 	else
 		return(dev->epmaxpacketin[((pipe>>15) & 0xf)]);
 }
 
+	/*
+	 * Due to a bug in the SH4 compiler, it can generate
+	 * an unaligned access if we evaluate ep->wMaxPacketSize.
+	 * As a workaround, we move such accesses into a different
+	 * non-inlineable function, which will make it safe.
+	 * This should be removed, once the compiler is fixed.
+	 * See https://bugzilla.stlinux.com/show_bug.cgi?id=3313
+	 * 2008-01-24 Sean McGoogan <Sean.McGoogan@st.com>
+	 */
+static short __attribute__((noinline))
+getMaxPacketSize(const struct usb_endpoint_descriptor * const ep)
+{
+	return ep->wMaxPacketSize;
+}
+
 /*
  * set the max packed value of all endpoints in the given configuration
  */
 int usb_set_maxpacket(struct usb_device *dev)
 {
-	int i,ii,b;
+	int i, ii, b;
 	struct usb_endpoint_descriptor *ep;
+	short wMaxPacketSize;
 
-	for(i=0; i<dev->config.bNumInterfaces;i++) {
-		for(ii=0; ii<dev->config.if_desc[i].bNumEndpoints; ii++) {
-			ep=&dev->config.if_desc[i].ep_desc[ii];
-			b=ep->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK;
+	for(i = 0; i<dev->config.bNumInterfaces; i++) {
+		for(ii = 0; ii<dev->config.if_desc[i].bNumEndpoints; ii++) {
+			ep = &dev->config.if_desc[i].ep_desc[ii];
+			b = ep->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK;
+			wMaxPacketSize = getMaxPacketSize(ep);
 
-			if((ep->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK)==USB_ENDPOINT_XFER_CONTROL) {	/* Control => bidirectional */
-				dev->epmaxpacketout[b] = ep->wMaxPacketSize;
-				dev->epmaxpacketin [b] = ep->wMaxPacketSize;
+			if((ep->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) == USB_ENDPOINT_XFER_CONTROL) {	/* Control => bidirectional */
+				dev->epmaxpacketout[b] = wMaxPacketSize;
+				dev->epmaxpacketin [b] = wMaxPacketSize;
 				USB_PRINTF("##Control EP epmaxpacketout/in[%d] = %d\n",b,dev->epmaxpacketin[b]);
 			}
 			else {
-				if ((ep->bEndpointAddress & 0x80)==0) { /* OUT Endpoint */
-					if(ep->wMaxPacketSize > dev->epmaxpacketout[b]) {
-						dev->epmaxpacketout[b] = ep->wMaxPacketSize;
+				if ((ep->bEndpointAddress & 0x80) == 0) { /* OUT Endpoint */
+					if(wMaxPacketSize > dev->epmaxpacketout[b]) {
+						dev->epmaxpacketout[b] = wMaxPacketSize;
 						USB_PRINTF("##EP epmaxpacketout[%d] = %d\n",b,dev->epmaxpacketout[b]);
 					}
 				}
 				else  { /* IN Endpoint */
-					if(ep->wMaxPacketSize > dev->epmaxpacketin[b]) {
-						dev->epmaxpacketin[b] = ep->wMaxPacketSize;
+					if(wMaxPacketSize > dev->epmaxpacketin[b]) {
+						dev->epmaxpacketin[b] = wMaxPacketSize;
 						USB_PRINTF("##EP epmaxpacketin[%d] = %d\n",b,dev->epmaxpacketin[b]);
 					}
 				} /* if out */
@@ -690,16 +699,16 @@ struct usb_device * usb_get_dev_index(int index)
 struct usb_device * usb_alloc_new_device(void)
 {
 	int i;
-	USB_PRINTF("New Device %d\n",dev_index);
-	if(dev_index==USB_MAX_DEVICE) {
+	//USB_PRINTF("New Device %d\n",dev_index);
+	if(dev_index == USB_MAX_DEVICE) {
 		printf("ERROR, too many USB Devices, max=%d\n",USB_MAX_DEVICE);
 		return NULL;
 	}
-	usb_dev[dev_index].devnum=dev_index+1; /* default Address is 0, real addresses start with 1 */
-	usb_dev[dev_index].maxchild=0;
-	for(i=0;i<USB_MAXCHILDREN;i++)
-		usb_dev[dev_index].children[i]=NULL;
-	usb_dev[dev_index].parent=NULL;
+	usb_dev[dev_index].devnum = dev_index + 1; /* default Address is 0, real addresses start with 1 */
+	usb_dev[dev_index].maxchild = 0;
+	for(i = 0; i < USB_MAXCHILDREN; i++)
+		usb_dev[dev_index].children[i] = NULL;
+	usb_dev[dev_index].parent = NULL;
 	dev_index++;
 	return &usb_dev[dev_index-1];
 }
@@ -855,13 +864,13 @@ void usb_scan_devices(void)
 	struct usb_device *dev;
 
 	/* first make all devices unknown */
-	for(i=0;i<USB_MAX_DEVICE;i++) {
+	for(i = 0; i < USB_MAX_DEVICE; i++) {
 		memset(&usb_dev[i],0,sizeof(struct usb_device));
-		usb_dev[i].devnum=-1;
+		usb_dev[i].devnum = -1;
 	}
-	dev_index=0;
+	dev_index = 0;
 	/* device 0 is always present (root hub, so let it analyze) */
-	dev=usb_alloc_new_device();
+	dev = usb_alloc_new_device();
 	usb_new_device(dev);
 	printf("%d USB Device(s) found\n",dev_index);
 	/* insert "driver" if possible */
@@ -947,12 +956,12 @@ static void usb_hub_power_on(struct usb_hub_device *hub)
 
 void usb_hub_reset(void)
 {
-	usb_hub_index=0;
+	usb_hub_index = 0;
 }
 
 struct usb_hub_device *usb_hub_allocate(void)
 {
-	if(usb_hub_index<USB_MAX_HUB) {
+	if(usb_hub_index < USB_MAX_HUB) {
 		return &hub_dev[usb_hub_index++];
 	}
 	printf("ERROR: USB_MAX_HUB (%d) reached\n",USB_MAX_HUB);
@@ -970,7 +979,7 @@ static int hub_port_reset(struct usb_device *dev, int port,
 
 
 	USB_HUB_PRINTF("hub_port_reset: resetting port %d...\n", port);
-	for(tries=0;tries<MAX_TRIES;tries++) {
+	for(tries = 0; tries < MAX_TRIES; tries++) {
 
 		usb_set_port_feature(dev, port + 1, USB_PORT_FEAT_RESET);
 		wait_ms(200);
@@ -999,7 +1008,7 @@ static int hub_port_reset(struct usb_device *dev, int port,
 		wait_ms(200);
 	}
 
-	if (tries==MAX_TRIES) {
+	if (tries == MAX_TRIES) {
 		USB_HUB_PRINTF("Cannot enable port %i after %i retries, disabling port.\n", port+1, MAX_TRIES);
 		USB_HUB_PRINTF("Maybe the USB cable is bad?\n");
 		return -1;
@@ -1034,7 +1043,7 @@ void usb_hub_port_connect_change(struct usb_device *dev, int port)
 
 	/* Disconnect any existing devices under this port */
 	if (((!(portstatus & USB_PORT_STAT_CONNECTION)) &&
-	     (!(portstatus & USB_PORT_STAT_ENABLE)))|| (dev->children[port])) {
+	     (!(portstatus & USB_PORT_STAT_ENABLE))) || (dev->children[port])) {
 		USB_HUB_PRINTF("usb_disconnect(&hub->children[port]);\n");
 		/* Return now if nothing is connected */
 		if (!(portstatus & USB_PORT_STAT_CONNECTION))
@@ -1051,11 +1060,11 @@ void usb_hub_port_connect_change(struct usb_device *dev, int port)
 	wait_ms(200);
 
 	/* Allocate a new device struct for it */
-	usb=usb_alloc_new_device();
+	usb = usb_alloc_new_device();
 	usb->slow = (portstatus & USB_PORT_STAT_LOW_SPEED) ? 1 : 0;
 
 	dev->children[port] = usb;
-	usb->parent=dev;
+	usb->parent = dev;
 	/* Run it through the hoops (find a driver, etc) */
 	if (usb_new_device(usb)) {
 		/* Woops, disable the port */
@@ -1074,10 +1083,10 @@ int usb_hub_configure(struct usb_device *dev)
 	struct usb_hub_device *hub;
 
 	/* "allocate" Hub device */
-	hub=usb_hub_allocate();
-	if(hub==NULL)
+	hub = usb_hub_allocate();
+	if(hub == NULL)
 		return -1;
-	hub->pusb_dev=dev;
+	hub->pusb_dev = dev;
 	/* Get the the hub descriptor */
 	if (usb_get_hub_descriptor(dev, buffer, 4) < 0) {
 		USB_HUB_PRINTF("usb_hub_configure: failed to get hub descriptor, giving up %lX\n",dev->status);
@@ -1088,7 +1097,7 @@ int usb_hub_configure(struct usb_device *dev)
 	/* silence compiler warning if USB_BUFSIZ is > 256 [= sizeof(char)] */
 	i = descriptor->bLength;
 	if (i > USB_BUFSIZ) {
-		USB_HUB_PRINTF("usb_hub_configure: failed to get hub descriptor - too long: %d\N",
+		USB_HUB_PRINTF("usb_hub_configure: failed to get hub descriptor - too long: %d\n",
 			descriptor->bLength);
 		return -1;
 	}
@@ -1099,17 +1108,17 @@ int usb_hub_configure(struct usb_device *dev)
 	}
 	memcpy((unsigned char *)&hub->desc,buffer,descriptor->bLength);
 	/* adjust 16bit values */
-	hub->desc.wHubCharacteristics=swap_16(descriptor->wHubCharacteristics);
+	hub->desc.wHubCharacteristics = swap_16(descriptor->wHubCharacteristics);
 	/* set the bitmap */
-	bitmap=(unsigned char *)&hub->desc.DeviceRemovable[0];
+	bitmap = (unsigned char *)&hub->desc.DeviceRemovable[0];
 	memset(bitmap,0xff,(USB_MAXCHILDREN+1+7)/8); /* devices not removable by default */
-	bitmap=(unsigned char *)&hub->desc.PortPowerCtrlMask[0];
+	bitmap = (unsigned char *)&hub->desc.PortPowerCtrlMask[0];
 	memset(bitmap,0xff,(USB_MAXCHILDREN+1+7)/8); /* PowerMask = 1B */
-	for(i=0;i<((hub->desc.bNbrPorts + 1 + 7)/8);i++) {
-		hub->desc.DeviceRemovable[i]=descriptor->DeviceRemovable[i];
+	for(i = 0; i < ((hub->desc.bNbrPorts + 1 + 7)/8); i++) {
+		hub->desc.DeviceRemovable[i] = descriptor->DeviceRemovable[i];
 	}
-	for(i=0;i<((hub->desc.bNbrPorts + 1 + 7)/8);i++) {
-		hub->desc.DeviceRemovable[i]=descriptor->PortPowerCtrlMask[i];
+	for(i = 0; i < ((hub->desc.bNbrPorts + 1 + 7)/8); i++) {
+		hub->desc.DeviceRemovable[i] = descriptor->PortPowerCtrlMask[i];
 	}
 	dev->maxchild = descriptor->bNbrPorts;
 	USB_HUB_PRINTF("%d ports detected\n", dev->maxchild);
diff --git a/common/usb_storage.c b/common/usb_storage.c
index 443d78574a..56f5e7478e 100644
--- a/common/usb_storage.c
+++ b/common/usb_storage.c
@@ -55,6 +55,11 @@
 #include <asm/processor.h>
 
 
+#if defined(__SH4__)
+#include <asm/cache.h>
+#endif
+
+
 #if defined(CONFIG_CMD_USB)
 #include <part.h>
 #include <usb.h>
@@ -147,29 +152,29 @@ struct us_data {
 	unsigned char		subclass;	 /* as in overview */
 	unsigned char		protocol;	 /* .............. */
 	unsigned char		attention_done;	 /* force attn on first cmd */
-	unsigned short	ip_data;	 /* interrupt data */
-	int							action;		 /* what to do */
-	int							ip_wanted; /* needed */
-	int							*irq_handle;	 /* for USB int requests */
+	unsigned short		ip_data;	 /* interrupt data */
+	int			action;		 /* what to do */
+	int			ip_wanted;	 /* needed */
+	int			*irq_handle;	 /* for USB int requests */
 	unsigned int		irqpipe;	 /* pipe for release_irq */
-	unsigned char		irqmaxp;	/* max packed for irq Pipe */
-	unsigned char	irqinterval; /* Intervall for IRQ Pipe */
-	ccb							*srb;		 /* current srb */
-	trans_reset			transport_reset; /* reset routine */
-	trans_cmnd			transport; /* transport routine */
+	unsigned char		irqmaxp;	 /* max packed for irq Pipe */
+	unsigned char		irqinterval;	 /* Intervall for IRQ Pipe */
+	ccb			*srb;		 /* current srb */
+	trans_reset		transport_reset; /* reset routine */
+	trans_cmnd		transport;	 /* transport routine */
 };
 
 static struct us_data usb_stor[USB_MAX_STOR_DEV];
 
 
-#define USB_STOR_TRANSPORT_GOOD	   0
+#define USB_STOR_TRANSPORT_GOOD    0
 #define USB_STOR_TRANSPORT_FAILED -1
 #define USB_STOR_TRANSPORT_ERROR  -2
 
 
 int usb_stor_get_info(struct usb_device *dev, struct us_data *us, block_dev_desc_t *dev_desc);
 int usb_storage_probe(struct usb_device *dev, unsigned int ifnum,struct us_data *ss);
-unsigned long usb_stor_read(int device, unsigned long blknr, unsigned long blkcnt, void *buffer);
+unsigned long usb_stor_read(int device, lbaint_t blknr, unsigned long blkcnt, void *buffer);
 struct usb_device * usb_get_dev_index(int index);
 void uhci_show_temp_int_td(void);
 
@@ -214,25 +219,25 @@ int usb_stor_scan(int mode)
 	/* GJ */
 	memset(usb_stor_buf, 0, sizeof(usb_stor_buf));
 
-	if(mode==1) {
+	if(mode == 1) {
 		printf("       scanning bus for storage devices... ");
 	}
 	usb_disable_asynch(1); /* asynch transfer not allowed */
 
-	for(i=0;i<USB_MAX_STOR_DEV;i++) {
+	for(i = 0; i < USB_MAX_STOR_DEV; i++) {
 		memset(&usb_dev_desc[i],0,sizeof(block_dev_desc_t));
-		usb_dev_desc[i].target=0xff;
-		usb_dev_desc[i].if_type=IF_TYPE_USB;
-		usb_dev_desc[i].dev=i;
-		usb_dev_desc[i].part_type=PART_TYPE_UNKNOWN;
-		usb_dev_desc[i].block_read=usb_stor_read;
+		usb_dev_desc[i].target = 0xff;
+		usb_dev_desc[i].if_type = IF_TYPE_USB;
+		usb_dev_desc[i].dev = i;
+		usb_dev_desc[i].part_type = PART_TYPE_UNKNOWN;
+		usb_dev_desc[i].block_read = usb_stor_read;
 	}
 
-	usb_max_devs=0;
-	for(i=0;i<USB_MAX_DEVICE;i++) {
-		dev=usb_get_dev_index(i); /* get device */
+	usb_max_devs = 0;
+	for(i = 0; i < USB_MAX_DEVICE; i++) {
+		dev = usb_get_dev_index(i); /* get device */
 		USB_STOR_PRINTF("i=%d\n",i);
-		if(dev==NULL) {
+		if(dev == NULL) {
 			break; /* no more devices avaiable */
 		}
 		if(usb_storage_probe(dev,0,&usb_stor[usb_max_devs])) { /* ok, it is a storage devices */
@@ -240,7 +245,7 @@ int usb_stor_scan(int mode)
 			if(usb_stor_get_info(dev, &usb_stor[usb_max_devs], &usb_dev_desc[usb_max_devs]))
 				usb_max_devs++;
 		} /* if storage device */
-		if(usb_max_devs==USB_MAX_STOR_DEV) {
+		if(usb_max_devs == USB_MAX_STOR_DEV) {
 			printf("max USB Storage Device reached: %d stopping\n",usb_max_devs);
 			break;
 		}
@@ -248,19 +253,24 @@ int usb_stor_scan(int mode)
 
 	usb_disable_asynch(0); /* asynch transfer allowed */
 	printf("%d Storage Device(s) found\n", usb_max_devs);
-	if(usb_max_devs>0)
+	if(usb_max_devs > 0)
 		return 0;
 	else
-		return-1;
+		return -1;
+}
+
+extern int GetStorageDevicesNum(void)
+{
+	return usb_max_devs;
 }
 
 static int usb_stor_irq(struct usb_device *dev)
 {
 	struct us_data *us;
-	us=(struct us_data *)dev->privptr;
+	us = (struct us_data *)dev->privptr;
 
 	if(us->ip_wanted) {
-		us->ip_wanted=0;
+		us->ip_wanted = 0;
 	}
 	return 0;
 }
@@ -272,7 +282,7 @@ static void usb_show_srb(ccb * pccb)
 {
 	int i;
 	printf("SRB: len %d datalen 0x%lX\n ",pccb->cmdlen,pccb->datalen);
-	for(i=0;i<12;i++) {
+	for(i = 0; i < 12; i++) {
 		printf("%02X ",pccb->cmd[i]);
 	}
 	printf("\n");
@@ -325,7 +335,7 @@ static int us_one_transfer(struct us_data *us, int pipe, char *buf, int length)
 					      this_xfer, &partial, USB_CNTL_TIMEOUT*5);
 			USB_STOR_PRINTF("bulk_msg returned %d xferred %d/%d\n",
 				  result, partial, this_xfer);
-			if(us->pusb_dev->status!=0) {
+			if(us->pusb_dev->status != 0) {
 				/* if we stall, we need to clear it before we go on */
 #ifdef USB_STOR_DEBUG
 				display_int_status(us->pusb_dev->status);
@@ -334,7 +344,7 @@ static int us_one_transfer(struct us_data *us, int pipe, char *buf, int length)
 					USB_STOR_PRINTF("stalled ->clearing endpoint halt for pipe 0x%x\n", pipe);
 					stat = us->pusb_dev->status;
 					usb_clear_halt(us->pusb_dev, pipe);
-					us->pusb_dev->status=stat;
+					us->pusb_dev->status = stat;
 					if(this_xfer == partial) {
 						USB_STOR_PRINTF("bulk transferred with error %X, but data ok\n",us->pusb_dev->status);
 						return 0;
@@ -496,13 +506,13 @@ int usb_stor_CB_comdat(ccb *srb, struct us_data *us)
 	unsigned int pipe;
 	unsigned long status;
 
-	retry=5;
-		dir_in=US_DIRECTION(srb->cmd[0]);
+	retry = 5;
+	dir_in = US_DIRECTION(srb->cmd[0]);
 
-		if(dir_in)
-			pipe=usb_rcvbulkpipe(us->pusb_dev, us->ep_in);
-		else
-			pipe=usb_sndbulkpipe(us->pusb_dev, us->ep_out);
+	if(dir_in)
+		pipe = usb_rcvbulkpipe(us->pusb_dev, us->ep_in);
+	else
+		pipe = usb_sndbulkpipe(us->pusb_dev, us->ep_out);
 	while(retry--) {
 		USB_STOR_PRINTF("CBI gets a command: Try %d\n",5-retry);
 #ifdef USB_STOR_DEBUG
@@ -551,6 +561,7 @@ int usb_stor_CBI_get_status (ccb * srb, struct us_data *us)
 	submit_int_msg (us->pusb_dev, us->irqpipe,
 			(void *) &us->ip_data, us->irqmaxp, us->irqinterval);
 	timeout = 1000;
+	//printf("[uboot_iptv]:usb_stor_CBI_get_status\n");
 	while (timeout--) {
 		if ((volatile int *) us->ip_wanted == 0)
 			break;
@@ -660,9 +671,9 @@ int usb_stor_BBB_transport(ccb *srb, struct us_data *us)
 	printf("\n");
 #endif
 	/* STATUS phase + error handling */
-   st:
+st:
 	retry = 0;
-   again:
+again:
 	USB_STOR_PRINTF("STATUS phase\n");
 	result = usb_bulk_msg(us->pusb_dev, pipein, &csw, UMASS_BBB_CSW_SIZE,
 				&actlen, USB_CNTL_TIMEOUT*5);
@@ -727,27 +738,27 @@ int usb_stor_CB_transport(ccb *srb, struct us_data *us)
 	ccb reqsrb;
 	int retry,notready;
 
-	psrb=&reqsrb;
-	status=USB_STOR_TRANSPORT_GOOD;
-	retry=0;
-	notready=0;
+	psrb = &reqsrb;
+	status = USB_STOR_TRANSPORT_GOOD;
+	retry = 0;
+	notready = 0;
 	/* issue the command */
 do_retry:
-	result=usb_stor_CB_comdat(srb,us);
+	result = usb_stor_CB_comdat(srb,us);
 	USB_STOR_PRINTF("command / Data returned %d, status %X\n",result,us->pusb_dev->status);
 	/* if this is an CBI Protocol, get IRQ */
-	if(us->protocol==US_PR_CBI) {
-		status=usb_stor_CBI_get_status(srb,us);
+	if(us->protocol == US_PR_CBI) {
+		status = usb_stor_CBI_get_status(srb,us);
 		/* if the status is error, report it */
-		if(status==USB_STOR_TRANSPORT_ERROR) {
+		if(status == USB_STOR_TRANSPORT_ERROR) {
 			USB_STOR_PRINTF(" USB CBI Command Error\n");
 			return status;
 		}
-		srb->sense_buf[12]=(unsigned char)(us->ip_data>>8);
-		srb->sense_buf[13]=(unsigned char)(us->ip_data&0xff);
+		srb->sense_buf[12] = (unsigned char)(us->ip_data>>8);
+		srb->sense_buf[13] = (unsigned char)(us->ip_data&0xff);
 		if(!us->ip_data) {
 		/* if the status is good, report it */
-			if(status==USB_STOR_TRANSPORT_GOOD) {
+			if(status == USB_STOR_TRANSPORT_GOOD) {
 				USB_STOR_PRINTF(" USB CBI Command Good\n");
 				return status;
 			}
@@ -760,36 +771,36 @@ do_retry:
 		us->transport_reset(us);
 		return USB_STOR_TRANSPORT_ERROR;
 	}
-	if((us->protocol==US_PR_CBI) &&
-			((srb->cmd[0]==SCSI_REQ_SENSE) ||
-			(srb->cmd[0]==SCSI_INQUIRY))) { /* do not issue an autorequest after request sense */
+	if((us->protocol == US_PR_CBI) &&
+			((srb->cmd[0] == SCSI_REQ_SENSE) ||
+			(srb->cmd[0] == SCSI_INQUIRY))) { /* do not issue an autorequest after request sense */
 		USB_STOR_PRINTF("No auto request and good\n");
 		return USB_STOR_TRANSPORT_GOOD;
 	}
 	/* issue an request_sense */
 	memset(&psrb->cmd[0],0,12);
-	psrb->cmd[0]=SCSI_REQ_SENSE;
-	psrb->cmd[1]=srb->lun<<5;
-	psrb->cmd[4]=18;
-	psrb->datalen=18;
-	psrb->pdata=&srb->sense_buf[0];
-	psrb->cmdlen=12;
+	psrb->cmd[0] = SCSI_REQ_SENSE;
+	psrb->cmd[1] = srb->lun<<5;
+	psrb->cmd[4] = 18;
+	psrb->datalen = 18;
+	psrb->pdata = &srb->sense_buf[0];
+	psrb->cmdlen = 12;
 	/* issue the command */
-	result=usb_stor_CB_comdat(psrb,us);
+	result = usb_stor_CB_comdat(psrb,us);
 	USB_STOR_PRINTF("auto request returned %d\n",result);
 	/* if this is an CBI Protocol, get IRQ */
-	if(us->protocol==US_PR_CBI) {
-		status=usb_stor_CBI_get_status(psrb,us);
+	if(us->protocol == US_PR_CBI) {
+		status = usb_stor_CBI_get_status(psrb,us);
 	}
-	if((result<0)&&!(us->pusb_dev->status & USB_ST_STALLED)) {
+	if((result < 0) && !(us->pusb_dev->status & USB_ST_STALLED)) {
 		USB_STOR_PRINTF(" AUTO REQUEST ERROR %d\n",us->pusb_dev->status);
 		return USB_STOR_TRANSPORT_ERROR;
 	}
 	USB_STOR_PRINTF("autorequest returned 0x%02X 0x%02X 0x%02X 0x%02X\n",srb->sense_buf[0],srb->sense_buf[2],srb->sense_buf[12],srb->sense_buf[13]);
 	/* Check the auto request result */
-	if((srb->sense_buf[2]==0) &&
-		 (srb->sense_buf[12]==0) &&
-		 (srb->sense_buf[13]==0)) /* ok, no sense */
+	if((srb->sense_buf[2] == 0) &&
+		 (srb->sense_buf[12] == 0) &&
+		 (srb->sense_buf[13] == 0)) /* ok, no sense */
 		return USB_STOR_TRANSPORT_GOOD;
 	/* Check the auto request result */
 	switch(srb->sense_buf[2]) {
@@ -823,17 +834,17 @@ do_retry:
 static int usb_inquiry(ccb *srb,struct us_data *ss)
 {
 	int retry,i;
-	retry=5;
+	retry = 5;
 	do {
 		memset(&srb->cmd[0],0,12);
-		srb->cmd[0]=SCSI_INQUIRY;
-		srb->cmd[1]=srb->lun<<5;
-		srb->cmd[4]=36;
-		srb->datalen=36;
-		srb->cmdlen=12;
-		i=ss->transport(srb,ss);
+		srb->cmd[0] = SCSI_INQUIRY;
+		srb->cmd[1] = srb->lun<<5;
+		srb->cmd[4] = 36;
+		srb->datalen = 36;
+		srb->cmdlen = 12;
+		i = ss->transport(srb,ss);
 		USB_STOR_PRINTF("inquiry returns %d\n",i);
-		if(i==0)
+		if(i == 0)
 			break;
 	} while(retry--);
 
@@ -848,17 +859,17 @@ static int usb_request_sense(ccb *srb,struct us_data *ss)
 {
 	char *ptr;
 
-	ptr=(char *)srb->pdata;
+	ptr = (char *)srb->pdata;
 	memset(&srb->cmd[0],0,12);
-	srb->cmd[0]=SCSI_REQ_SENSE;
-	srb->cmd[1]=srb->lun<<5;
-	srb->cmd[4]=18;
-	srb->datalen=18;
-	srb->pdata=&srb->sense_buf[0];
-	srb->cmdlen=12;
+	srb->cmd[0] = SCSI_REQ_SENSE;
+	srb->cmd[1] = srb->lun<<5;
+	srb->cmd[4] = 18;
+	srb->datalen = 18;
+	srb->pdata = &srb->sense_buf[0];
+	srb->cmdlen = 12;
 	ss->transport(srb,ss);
 	USB_STOR_PRINTF("Request Sense returned %02X %02X %02X\n",srb->sense_buf[2],srb->sense_buf[12],srb->sense_buf[13]);
-	srb->pdata=(uchar *)ptr;
+	srb->pdata = (uchar *)ptr;
 	return 0;
 }
 
@@ -868,11 +879,11 @@ static int usb_test_unit_ready(ccb *srb,struct us_data *ss)
 
 	do {
 		memset(&srb->cmd[0],0,12);
-		srb->cmd[0]=SCSI_TST_U_RDY;
-		srb->cmd[1]=srb->lun<<5;
-		srb->datalen=0;
-		srb->cmdlen=12;
-		if(ss->transport(srb,ss)==USB_STOR_TRANSPORT_GOOD) {
+		srb->cmd[0] = SCSI_TST_U_RDY;
+		srb->cmd[1] = srb->lun<<5;
+		srb->datalen = 0;
+		srb->cmdlen = 12;
+		if(ss->transport(srb,ss) == USB_STOR_TRANSPORT_GOOD) {
 			return 0;
 		}
 		usb_request_sense (srb, ss);
@@ -888,11 +899,11 @@ static int usb_read_capacity(ccb *srb,struct us_data *ss)
 	retry = 3; /* retries */
 	do {
 		memset(&srb->cmd[0],0,12);
-		srb->cmd[0]=SCSI_RD_CAPAC;
-		srb->cmd[1]=srb->lun<<5;
-		srb->datalen=8;
-		srb->cmdlen=12;
-		if(ss->transport(srb,ss)==USB_STOR_TRANSPORT_GOOD) {
+		srb->cmd[0] = SCSI_RD_CAPAC;
+		srb->cmd[1] = srb->lun<<5;
+		srb->datalen = 8;
+		srb->cmdlen = 12;
+		if(ss->transport(srb,ss) == USB_STOR_TRANSPORT_GOOD) {
 			return 0;
 		}
 	} while(retry--);
@@ -903,15 +914,15 @@ static int usb_read_capacity(ccb *srb,struct us_data *ss)
 static int usb_read_10(ccb *srb,struct us_data *ss, unsigned long start, unsigned short blocks)
 {
 	memset(&srb->cmd[0],0,12);
-	srb->cmd[0]=SCSI_READ10;
-	srb->cmd[1]=srb->lun<<5;
-	srb->cmd[2]=((unsigned char) (start>>24))&0xff;
-	srb->cmd[3]=((unsigned char) (start>>16))&0xff;
-	srb->cmd[4]=((unsigned char) (start>>8))&0xff;
-	srb->cmd[5]=((unsigned char) (start))&0xff;
-	srb->cmd[7]=((unsigned char) (blocks>>8))&0xff;
-	srb->cmd[8]=(unsigned char) blocks & 0xff;
-	srb->cmdlen=12;
+	srb->cmd[0] = SCSI_READ10;
+	srb->cmd[1] = srb->lun<<5;
+	srb->cmd[2] = ((unsigned char) (start>>24))&0xff;
+	srb->cmd[3] = ((unsigned char) (start>>16))&0xff;
+	srb->cmd[4] = ((unsigned char) (start>>8))&0xff;
+	srb->cmd[5] = ((unsigned char) (start))&0xff;
+	srb->cmd[7] = ((unsigned char) (blocks>>8))&0xff;
+	srb->cmd[8] = (unsigned char) blocks & 0xff;
+	srb->cmdlen = 12;
 	USB_STOR_PRINTF("read10: start %lx blocks %x\n",start,blocks);
 	return ss->transport(srb,ss);
 }
@@ -941,13 +952,14 @@ static void usb_bin_fixup(struct usb_device_descriptor descriptor,
 
 #define USB_MAX_READ_BLK 20
 
-unsigned long usb_stor_read(int device, unsigned long blknr, unsigned long blkcnt, void *buffer)
+unsigned long usb_stor_read(int device, lbaint_t blknr, unsigned long blkcnt, void *buffer)
 {
 	unsigned long start,blks, buf_addr;
 	unsigned short smallblks;
 	struct usb_device *dev;
-	int retry,i;
+	int retry, i;
 	ccb *srb = &usb_ccb;
+	const int my_data_caches_on = sh_data_caches_on;
 
 	if (blkcnt == 0)
 		return 0;
@@ -956,55 +968,64 @@ unsigned long usb_stor_read(int device, unsigned long blknr, unsigned long blkcn
 	/* Setup  device
 	 */
 	USB_STOR_PRINTF("\nusb_read: dev %d \n",device);
-	dev=NULL;
-	for(i=0;i<USB_MAX_DEVICE;i++) {
-		dev=usb_get_dev_index(i);
-		if(dev==NULL) {
+	dev = NULL;
+	for(i = 0; i < USB_MAX_DEVICE; i++) {
+		dev = usb_get_dev_index(i);
+		if(dev == NULL) {
 			return 0;
 		}
-		if(dev->devnum==usb_dev_desc[device].target)
+		if(dev->devnum == usb_dev_desc[device].target)
 			break;
 	}
 
+	if (my_data_caches_on)	/* is data cache on ? */
+		sh_disable_data_caches();
+
 	usb_disable_asynch(1); /* asynch transfer not allowed */
-	srb->lun=usb_dev_desc[device].lun;
-	buf_addr=(unsigned long)buffer;
-	start=blknr;
-	blks=blkcnt;
+	srb->lun = usb_dev_desc[device].lun;
+	buf_addr = (unsigned long)buffer;
+	start = blknr;
+	blks = blkcnt;
 	if(usb_test_unit_ready(srb,(struct us_data *)dev->privptr)) {
+		if (my_data_caches_on)	/* were the data caches on ? */
+			sh_enable_data_caches();
 		printf("Device NOT ready\n   Request Sense returned %02X %02X %02X\n",
 			srb->sense_buf[2],srb->sense_buf[12],srb->sense_buf[13]);
 		return 0;
 	}
 	USB_STOR_PRINTF("\nusb_read: dev %d startblk %lx, blccnt %lx buffer %lx\n",device,start,blks, buf_addr);
 	do {
-		retry=2;
-		srb->pdata=(unsigned char *)buf_addr;
-		if(blks>USB_MAX_READ_BLK) {
-			smallblks=USB_MAX_READ_BLK;
+		retry = 2;
+		srb->pdata = (unsigned char *)buf_addr;
+		if(blks > USB_MAX_READ_BLK) {
+			smallblks = USB_MAX_READ_BLK;
 		} else {
-			smallblks=(unsigned short) blks;
+			smallblks = (unsigned short) blks;
 		}
 retry_it:
-		if(smallblks==USB_MAX_READ_BLK)
+		if(smallblks == USB_MAX_READ_BLK)
 			usb_show_progress();
-		srb->datalen=usb_dev_desc[device].blksz * smallblks;
-		srb->pdata=(unsigned char *)buf_addr;
+		srb->datalen = usb_dev_desc[device].blksz * smallblks;
+		srb->pdata = (unsigned char *)buf_addr;
 		if(usb_read_10(srb,(struct us_data *)dev->privptr, start, smallblks)) {
 			USB_STOR_PRINTF("Read ERROR\n");
 			usb_request_sense(srb,(struct us_data *)dev->privptr);
 			if(retry--)
 				goto retry_it;
-			blkcnt-=blks;
+			blkcnt -= blks;
 			break;
 		}
-		start+=smallblks;
-		blks-=smallblks;
-		buf_addr+=srb->datalen;
-	} while(blks!=0);
+		start += smallblks;
+		blks -= smallblks;
+		buf_addr += srb->datalen;
+	} while(blks != 0);
+
+	if (my_data_caches_on)	/* were the data caches on ? */
+		sh_enable_data_caches();
+
 	USB_STOR_PRINTF("usb_read: end startblk %lx, blccnt %x buffer %lx\n",start,smallblks,buf_addr);
 	usb_disable_asynch(0); /* asynch transfer allowed */
-	if(blkcnt>=USB_MAX_READ_BLK)
+	if(blkcnt >= USB_MAX_READ_BLK)
 		printf("\n");
 	return(blkcnt);
 }
@@ -1139,17 +1160,17 @@ int usb_storage_probe(struct usb_device *dev, unsigned int ifnum,struct us_data
 		ss->irqinterval = (ss->irqinterval > 0) ? ss->irqinterval : 255;
 		ss->irqpipe = usb_rcvintpipe(ss->pusb_dev, ss->ep_int);
 		ss->irqmaxp = usb_maxpacket(dev, ss->irqpipe);
-		dev->irq_handle=usb_stor_irq;
+		dev->irq_handle = usb_stor_irq;
 	}
-	dev->privptr=(void *)ss;
+	dev->privptr = (void *)ss;
 	return 1;
 }
 
 int usb_stor_get_info(struct usb_device *dev,struct us_data *ss,block_dev_desc_t *dev_desc)
 {
-	unsigned char perq,modi;
+	unsigned char perq, modi;
 	unsigned long cap[2];
-	unsigned long *capacity,*blksz;
+	unsigned long *capacity, *blksz;
 	ccb *pccb = &usb_ccb;
 
 	/* for some reasons a couple of devices would not survive this reset */
diff --git a/cpu/i386/start.S b/cpu/i386/start.S
index 1a54dd10e3..51a27aa21d 100644
--- a/cpu/i386/start.S
+++ b/cpu/i386/start.S
@@ -55,7 +55,7 @@ early_board_init_ret:
 	/* so we try to indicate progress */
 	movw	$0x01, %ax
 	movl	$.progress0, %ebp
-	jmp	__show_boot_progress
+	jmp	show_boot_progress
 .progress0:
 
 	/* size memory */
@@ -74,7 +74,7 @@ mem_init_ret:
 	/* indicate (lack of) progress */
 	movw	$0x81, %ax
 	movl	$.progress0a, %ebp
-	jmp	__show_boot_progress
+	jmp	show_boot_progress
 .progress0a:
 	jmp 	die
 mem_ok:
@@ -82,7 +82,7 @@ mem_ok:
 	/* indicate progress */
 	movw	$0x02, %ax
 	movl	$.progress1, %ebp
-	jmp	__show_boot_progress
+	jmp	show_boot_progress
 .progress1:
 
 	/* create a stack after the bss */
@@ -104,7 +104,7 @@ no_stack:
 	/* indicate (lack of) progress */
 	movw	$0x82, %ax
 	movl	$.progress1a, %ebp
-	jmp	__show_boot_progress
+	jmp	show_boot_progress
 .progress1a:
 	jmp die
 
@@ -113,7 +113,7 @@ stack_ok:
 	/* indicate progress */
 	movw	$0x03, %ax
 	movl	$.progress2, %ebp
-	jmp	__show_boot_progress
+	jmp	show_boot_progress
 .progress2:
 
 	/* copy data section to ram, size must be 4-byte aligned */
@@ -136,7 +136,7 @@ data_fail:
 	/* indicate (lack of) progress */
 	movw	$0x83, %ax
 	movl	$.progress2a, %ebp
-	jmp	__show_boot_progress
+	jmp	show_boot_progress
 .progress2a:
 	jmp 	die
 
@@ -145,7 +145,7 @@ data_ok:
 	/* indicate progress */
 	movw	$0x04, %ax
 	movl	$.progress3, %ebp
-	jmp	__show_boot_progress
+	jmp	show_boot_progress
 .progress3:
 
 	/* clear bss section in ram, size must be 4-byte aligned  */
@@ -168,7 +168,7 @@ bss_fail:
 	/* indicate (lack of) progress */
 	movw	$0x84, %ax
 	movl	$.progress3a, %ebp
-	jmp	__show_boot_progress
+	jmp	show_boot_progress
 .progress3a:
 	jmp 	die
 
@@ -180,7 +180,7 @@ bss_ok:
 	/* indicate progress */
 	movw	$0x05, %ax
 	movl	$.progress4, %ebp
-	jmp	__show_boot_progress
+	jmp	show_boot_progress
 .progress4:
 
 	call	start_i386boot  /* Enter, U-boot! */
@@ -188,7 +188,7 @@ bss_ok:
 	/* indicate (lack of) progress */
 	movw	$0x85, %ax
 	movl	$.progress4a, %ebp
-	jmp	__show_boot_progress
+	jmp	show_boot_progress
 .progress4a:
 
 die:	hlt
diff --git a/cpu/sh/Makefile b/cpu/sh/Makefile
new file mode 100644
index 0000000000..2835bc972b
--- /dev/null
+++ b/cpu/sh/Makefile
@@ -0,0 +1,51 @@
+#
+# (C) Copyright 2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(CPU).a
+
+START	= start.o
+COBJS	= cpu.o interrupts.o usb.o cmd_pmb.o
+COBJS	+= ecc.o stm-nand.o cmd_copybbt.o	# NAND
+COBJS	+= sata-init.o sata-probe.o		# SATA
+COBJS	+= spi.o env_eeprom.o			# SPI
+SOBJS	=
+
+SRCS	:= $(START:.o=.S) $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS) $(SOBJS))
+START	:= $(addprefix $(obj),$(START))
+
+all:	$(obj).depend $(START) $(LIB)
+
+$(LIB):	$(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/cpu/sh/cmd_copybbt.c b/cpu/sh/cmd_copybbt.c
new file mode 100644
index 0000000000..25ca5f82c3
--- /dev/null
+++ b/cpu/sh/cmd_copybbt.c
@@ -0,0 +1,256 @@
+/*
+ * (C) Copyright 2009 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+
+
+#if defined(CFG_NAND_SKIP_BAD_BLOCKS_ON_RELOCATING) && defined(CONFIG_CMD_NAND)
+
+
+#include <nand.h>
+
+
+#define NAND_SIGNATURE_OFFSET		0x80u
+#define NAND_SIGNATURE_LENGTH		0x40u
+#define NAND_BB_SKIP_OFFSET		(NAND_SIGNATURE_OFFSET + NAND_SIGNATURE_LENGTH)
+
+
+typedef struct skip_bb			/* see cpu/sh/start.S for more details */
+{
+	uchar	pattern[8];
+	u32	block_size;
+	u32	num_blocks;
+	u32	array[0];
+} skip_bb;
+
+
+static int check_skip_bb(const ulong addr)
+{
+	const uchar * const signature = (uchar*)(addr+NAND_SIGNATURE_OFFSET);
+	const skip_bb * const ptr = (skip_bb*)(addr+NAND_BB_SKIP_OFFSET);
+	const uchar pattern[] = "SKIP_BBs";
+	size_t i;
+
+	/*
+	 * ensure the (64-byte) NAND magic signature is correct
+	 */
+	for(i=0; i<NAND_SIGNATURE_LENGTH; i++)
+	{
+		if (signature[i] != i)
+		{
+			printf ("Error: "
+				"Invalid NAND signature at 0x%08x (%x != %x)\n",
+				&signature[i],
+				signature[i],
+				i);
+			return (1);	/* image is INVALID */
+		}
+	}
+
+	/*
+	 * ensure the (8-byte) "skip_bb" pattern is correct.
+	 */
+	for(i=0; i<sizeof(ptr->pattern); i++)
+	{
+		if (ptr->pattern[i] != pattern[i])
+		{
+			printf ("Error: "
+				"Invalid SKIP_BB pattern at 0x%08x (%x != %x)\n",
+				ptr->pattern,
+				ptr->pattern[i],
+				pattern[i]);
+			return (1);	/* image is INVALID */
+		}
+	}
+
+	/*
+	 * ensure the address provided is 4-byte aligned!
+	 */
+	if (addr % 4ul != 0ul)
+	{
+		printf ("Error: "
+			"address (0x%08lx) must be 4-byte aligned\n",
+			addr);
+		return (1);		/* 'addr' is INVALID */
+	}
+
+	/*
+	 * ensure the physical NAND device has been initialized & selected.
+	 */
+	if ((nand_curr_device < 0) || (nand_curr_device >= CFG_MAX_NAND_DEVICE))
+	{
+		printf ("Error: "
+			"Invalid NAND device (%d) currently selected\n",
+			nand_curr_device);
+		return (1);		/* NAND device is INVALID */
+	}
+
+	/*
+	 * ensure the Block size agrees with physical NAND device.
+	 */
+	if (ptr->block_size != nand_info[nand_curr_device].erasesize)
+	{
+		printf ("Error: "
+			"Block Size (%uKiB) does not agree with physical NAND (%uKiB)\n",
+			ptr->block_size >> 10,
+			nand_info[nand_curr_device].erasesize >> 10);
+		return (1);		/* Block Size does NOT AGREE */
+	}
+
+	/*
+	 * test to see if physical block #0 is tagged as being "BAD"
+	 */
+	if (ptr->array[0])
+	{
+		printf ("Warning: "
+			"Block #0 is marked as being BAD - are you sure?\n");
+	}
+
+	return (0);			/* image is okay */
+}
+
+
+static int do_info(const ulong addr)
+{
+	const skip_bb * const ptr = (skip_bb*)(addr+NAND_BB_SKIP_OFFSET);
+	size_t i;
+	size_t skipped;
+
+	if (check_skip_bb(addr))	/* is image invalid ? */
+		return (1);		/* bad image */
+
+	printf( "info: The skip_bb structure at 0x%x looks okay,\n"
+		"info: There is space for %u bad blocks (each of %u KiB).\n",
+		addr + NAND_BB_SKIP_OFFSET,
+		ptr->num_blocks,
+		ptr->block_size >> 10);
+
+	/* how many blocks are to be skipped ? */
+	for(i=skipped=0; i<ptr->num_blocks; i++)
+	{
+		if (ptr->array[i])
+			skipped++;
+	}
+
+	if (skipped == 0)
+	{
+		printf("info: There are NO blocks marked to be skipped\n");
+	}
+	else
+	{
+		printf("info: There are %u blocks marked to be skipped:\n",
+			skipped);
+		for(i=0; i<ptr->num_blocks; i++)
+		{
+			if (ptr->array[i])
+			{
+				printf("\tblock #%u is marked to be skipped (at 0x%x)\n",
+				i,
+				i*ptr->block_size);
+			}
+		}
+	}
+
+	return (0);			/* okay */
+}
+
+
+static int do_copy(const ulong addr)
+{
+	skip_bb * const ptr = (skip_bb*)(addr+NAND_BB_SKIP_OFFSET);
+	ulong start;
+	size_t i;
+
+	if (check_skip_bb(addr))	/* is image invalid ? */
+		return (1);		/* bad image */
+
+	for(i=start=0; i<ptr->num_blocks; i++,start+=ptr->block_size)
+	{
+		ulong read;
+		nand_info_t * const nand = &nand_info[nand_curr_device];
+		const ulong skip = nand_block_isbad(nand, start) ? 1 : 0;
+		if (skip)	/* do we skip it ? */
+		{
+			printf( "info: "
+				"tagging block #%u as bad (at 0x%x)\n",
+				i,
+				start);
+		}
+
+		/* update the array in the skip_bb structure */
+		*(volatile ulong*)(&ptr->array[i]) = skip;
+
+		/* did we succeed ? */
+		read = *(volatile ulong*)(&ptr->array[i]);
+		if (read != skip)
+		{
+			printf( "Error: "
+				"For block #%u, poke to 0x%08x failed! (%u != %u)\n",
+				i,
+				&ptr->array[i],
+				skip,
+				read);
+			return (1);		/* poke FAILED */
+		}
+	}
+
+	return (0);			/* okay */
+}
+
+
+extern int do_copybbt (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	if ( (argc==3) && (strcmp (argv[1], "info")==0))
+	{
+		const ulong addr = simple_strtoul (argv[2], NULL, 16);
+		return do_info(addr);
+	}
+	else if ( (argc==3) && (strcmp (argv[1], "copy")==0))
+	{
+		const ulong addr = simple_strtoul (argv[2], NULL, 16);
+		return do_copy(addr);
+	}
+	else
+	{
+		printf ("Usage:\n%s\n", cmdtp->usage);
+		return (1);		/* bad command usage */
+	}
+
+	return (0);
+}
+
+
+U_BOOT_CMD(
+	copybbt, 3, 0, do_copybbt,
+	"copybbt - copies abridged version of NAND BBT\n",
+	"info [addr] - shows status of copied BBT in RAM\n"
+	"copybbt copy [addr] - copies BBT into RAM copy of u-boot.bin\n"
+	"\t\t      this may be done prior to burning to NAND\n"
+);
+
+
+#endif /* CFG_NAND_SKIP_BAD_BLOCKS_ON_RELOCATING */
+
+
diff --git a/cpu/sh/cmd_pmb.c b/cpu/sh/cmd_pmb.c
new file mode 100644
index 0000000000..07b1c689d9
--- /dev/null
+++ b/cpu/sh/cmd_pmb.c
@@ -0,0 +1,181 @@
+/*
+ * (C) Copyright 2008 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/pmb.h>
+#include <asm/addrspace.h>
+
+
+//#define DEBUG
+
+#if defined(CONFIG_SH_SE_MODE)
+
+
+#define PMB_ADDR(i)	((volatile unsigned long*)(P4SEG_PMB_ADDR+((i)<<8)))
+#define PMB_DATA(i)	((volatile unsigned long*)(P4SEG_PMB_DATA+((i)<<8)))
+
+
+#ifdef DEBUG
+#define SHOULD_BE_VALID(pmb)							\
+do {										\
+	if ((valid & (1u<<(pmb))) == 0u)					\
+		printf ("ERROR: PMB[%u].V == 0, but it should be   Valid\n",	\
+			(pmb));							\
+} while(0)
+#define SHOULD_BE_INVALID(pmb)							\
+do {										\
+	if ((valid & (1u<<(pmb))) != 0u)					\
+		printf ("ERROR: PMB[%u].V == 1, but it should be INvalid\n",	\
+			(pmb));							\
+} while(0)
+#endif	/* DEBUG */
+
+
+static unsigned pmb_page_size (const unsigned long data)
+{
+	const unsigned long size = data & 0x90ul;
+
+	return	(size==0x00ul) ?  16 :
+		(size==0x10ul) ?  64 :
+		(size==0x80ul) ? 128 :
+				 512;
+}
+
+static void display_pmb (void)
+{
+	size_t i;
+#ifdef DEBUG
+	unsigned valid = 0;	/* assume all PMBs are invalid */
+#endif	/* DEBUG */
+
+	printf ("\ninfo: sizeof(LMI) = 0x%08x = %uMB (uses %u PMB slot%s)\n\n",
+		CFG_SDRAM_SIZE, CFG_SDRAM_SIZE/1024/1024,
+		(CFG_SH_LMI_NEEDS_2_PMB_ENTRIES) ? 2 : 1,
+		(CFG_SH_LMI_NEEDS_2_PMB_ENTRIES) ? "s" : "");
+
+	for (i=0; i<16; i++)
+	{
+		const unsigned long data = *PMB_DATA(i);
+		const unsigned long addr = *PMB_ADDR(i);
+		const unsigned long mb   = pmb_page_size(data);
+		const unsigned long vpn  = addr >> 24;
+		const unsigned long ppn  = data >> 24;
+
+#ifdef DEBUG
+		if ((data & 0x100) != (addr & 0x100))
+			printf ("ERROR: PMB[%u].V disagrees!\n", i);
+#endif	/* DEBUG */
+
+		if (!(data & 0x100))		/* V == 0 ? */
+			continue;		/* skip to next if not valid */
+
+		/* print entry if it is valid */
+		printf ("PMB[%2u]  =  VPN:%02x...%02x  PPN:%02x...%02x  %2s  %1s  %2s  %3uMB\n",
+			i,
+			vpn,				/* VPN (first page) */
+			vpn + (mb >> 4) - 1,		/* VPN (last page) */
+			ppn,				/* PPN (first page) */
+			ppn + (mb >> 4) - 1,		/* PPN (last page) */
+			(data & (1<<0)) ? "WT" : "CB",	/* write-through / copy-back */
+			(data & (1<<3)) ? "C" : "",	/* cacheability */
+			(data & (1<<9)) ? "UB" : "",	/* Unbuffered */
+			mb);				/* SZ */
+
+#ifdef DEBUG
+		valid |= 1u<<i;		/* set bit 'i', in the mask set */
+		switch (i)
+		{
+			case 0:
+				if (vpn != 0x80)
+					printf ("ERROR: PMB[0].VPN != 0x80\n");
+				break;
+
+			case 1:
+				if (vpn != 0x88)
+					printf ("ERROR: PMB[1].VPN != 0x88\n");
+				if (ppn != ((*PMB_DATA(0)>>24)+0x08))
+					printf ("ERROR: PMB[1].PPN != PMB[0].PPN+0x08\n");
+				break;
+
+			case 2:
+				if (vpn != 0x90)
+					printf ("ERROR: PMB[2].VPN != 0x90\n");
+				if (ppn != (*PMB_DATA(0)>>24))
+					printf ("ERROR: PMB[2].PPN != PMB[0].PPN\n");
+				if ((data&0x90) != (*PMB_DATA(0)&0x90))
+					printf ("ERROR: PMB[2].SZ != PMB[0].SZ\n");
+				break;
+
+			case 3:
+				if (vpn != 0x98)
+					printf ("ERROR: PMB[3].VPN != 0x98\n");
+				if (ppn != (*PMB_DATA(1)>>24))
+					printf ("ERROR: PMB[3].PPN != PMB[1].PPN\n");
+				if (ppn != ((*PMB_DATA(2)>>24)+0x08))
+					printf ("ERROR: PMB[3].PPN != PMB[2].PPN+0x08\n");
+				if ((data&0x90) != (*PMB_DATA(1)&0x90))
+					printf ("ERROR: PMB[3].SZ != PMB[1].SZ\n");
+				break;
+
+			default:
+				if ( (vpn < 0xa0) || (vpn > 0xbf) )
+					printf ("ERROR: PMB[%u].VPN not in range 0xa0..0xbf\n",i);
+		}
+#endif	/* DEBUG */
+	}
+
+#ifdef DEBUG
+	/* perform additional checks on validity */
+	SHOULD_BE_VALID(0);
+#if CFG_SH_LMI_NEEDS_2_PMB_ENTRIES
+	SHOULD_BE_VALID(1);
+#else
+	SHOULD_BE_INVALID(1);
+#endif	/* CFG_SH_LMI_NEEDS_2_PMB_ENTRIES */
+	SHOULD_BE_VALID(2);
+#if CFG_SH_LMI_NEEDS_2_PMB_ENTRIES
+	SHOULD_BE_VALID(3);
+#else
+	SHOULD_BE_INVALID(3);
+#endif	/* CFG_SH_LMI_NEEDS_2_PMB_ENTRIES */
+	SHOULD_BE_INVALID(15);
+#endif	/* DEBUG */
+}
+
+extern int do_pmb (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	display_pmb ();
+	return (0);
+}
+
+
+U_BOOT_CMD(
+	pmb, 1, 0, do_pmb,
+	"pmb     - displays the contents of the PMB\n",
+	"- displays the contents of the PMB (when V==1)\n"
+);
+
+#endif	/* CONFIG_SH_SE_MODE */
+
diff --git a/cpu/sh/config.mk b/cpu/sh/config.mk
new file mode 100644
index 0000000000..b16c9b50d9
--- /dev/null
+++ b/cpu/sh/config.mk
@@ -0,0 +1,32 @@
+#
+# (C) Copyright 2003
+# Wolfgang Denk, DENX Software Engineering, <wd@denx.de>
+#
+# (C) Copyright 2009 STMicroelectronics.
+# Sean McGoogan <Sean.McGoogan@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+### old:  PLATFORM_CPPFLAGS += -m4 -m4-nofpu -U__sh3__
+### want: PLATFORM_CPPFLAGS += -m4 -mno-implicit-fp
+PLATFORM_CPPFLAGS += -m4-nofpu -U__sh3__ -D__SH4__=1
+
+# all SH (ST40) CPUs will use the same linker script file
+LDSCRIPT := $(SRCTREE)/cpu/$(CPU)/u-boot.lds
diff --git a/cpu/sh/cpu.c b/cpu/sh/cpu.c
new file mode 100644
index 0000000000..0308118fed
--- /dev/null
+++ b/cpu/sh/cpu.c
@@ -0,0 +1,167 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "common.h"
+#include <asm/cache.h>
+#include <asm/io.h>
+#include <asm/sh4reg.h>
+
+struct __large_struct { unsigned long buf[100]; };
+#define __m(x) (*(struct __large_struct *)(x))
+
+/*
+ * Write back the dirty D-caches, but not invalidate them.
+ *
+ * START: Virtual Address (U0, P1, or P3)
+ * SIZE: Size of the region.
+ */
+#if 0
+static void __flush_wback_region(void *start, int size)
+{
+	unsigned long v;
+	unsigned long begin, end;
+
+	begin = (unsigned long)start & ~(L1_CACHE_BYTES-1);
+	end = ((unsigned long)start + size + L1_CACHE_BYTES-1)
+		& ~(L1_CACHE_BYTES-1);
+	for (v = begin; v < end; v+=L1_CACHE_BYTES) {
+		asm volatile("ocbwb	%0"
+			     : /* no output */
+			     : "m" __m(v));
+	}
+}
+#endif
+
+/*
+ * Write back the dirty D-caches and invalidate them.
+ *
+ * START: Virtual Address (U0, P1, or P3)
+ * SIZE: Size of the region.
+ */
+static void __flush_purge_region(unsigned long start, int size)
+{
+	unsigned long v;
+	unsigned long begin, end;
+
+	begin = (unsigned long)start & ~(L1_CACHE_BYTES-1);
+	end = ((unsigned long)start + size + L1_CACHE_BYTES-1)
+		& ~(L1_CACHE_BYTES-1);
+	for (v = begin; v < end; v+=L1_CACHE_BYTES) {
+		asm volatile("ocbp	%0"
+			     : /* no output */
+			     : "m" __m(v));
+	}
+}
+
+#if 0
+/*
+ * No write back please
+ */
+static void __flush_invalidate_region(void *start, int size)
+{
+	unsigned long v;
+	unsigned long begin, end;
+
+	begin = (unsigned long)start & ~(L1_CACHE_BYTES-1);
+	end = ((unsigned long)start + size + L1_CACHE_BYTES-1)
+		& ~(L1_CACHE_BYTES-1);
+	for (v = begin; v < end; v+=L1_CACHE_BYTES) {
+		asm volatile("ocbi	%0"
+			     : /* no output */
+			     : "m" __m(v));
+	}
+}
+#endif
+
+void flush_cache (ulong start_addr, ulong size)
+{
+   __flush_purge_region(start_addr, size);
+}
+
+/*
+ * Flush all the data cache lines
+ */
+extern void sh_flush_cache_all(void)
+{
+	unsigned long addr;
+	const unsigned long end_addr = CACHE_OC_ADDRESS_ARRAY +
+		(DCACHE_SETS << DCACHE_ENTRY_SHIFT) * DCACHE_WAYS;
+	const unsigned long entry_offset = 1ul << DCACHE_ENTRY_SHIFT;
+
+	for (addr = CACHE_OC_ADDRESS_ARRAY;
+	     addr < end_addr;
+	     addr += entry_offset) {
+		ctrl_outl(0, addr);
+	}
+}
+
+/*
+ * sh_disable_data_caches() and sh_enable_data_caches()
+ * compliment each other. They are designed to be used in
+ * pairs to surround code that is designed to work with code
+ * that is not cache-coherency aware. e.g. immature drivers.
+ *
+ * The default assumption is that the chaches are normally ON,
+ * and the OFF state is a temporary exception.
+ *
+ * As an optimization, consequtive calls to change the data
+ * cacheability will do nothing, if the caches are correct.
+ * A global variable 'sh_data_caches_on' is used to track
+ * the current state of the data caches.
+ */
+int sh_data_caches_on = 1;	/* assume caches are ON */
+
+extern void sh_disable_data_caches(void)
+{
+	if (!sh_data_caches_on)	/* already OFF ? */
+		return;		/* do nothing */
+
+	/*
+	 * Flush the operand caches, to ensure that there is
+	 * no unwritten data residing only in the data cache.
+	 */
+	sh_flush_cache_all();
+
+	/* Disable the Operand Caches */
+	sh_cache_clear_op(SH4_CCR_OCE);
+
+	sh_data_caches_on = 0;	/* caches are OFF */
+}
+
+extern void sh_enable_data_caches(void)
+{
+	if (sh_data_caches_on)	/* already ON ? */
+		return;		/* do nothing */
+
+	/* Invalidate, and enable the data caches */
+	sh_cache_set_op(SH4_CCR_OCI|SH4_CCR_OCE);
+
+	sh_data_caches_on = 1;	/* caches are ON */
+}
+
+int cleanup_before_linux (void)
+{
+	return (0);
+}
+
diff --git a/cpu/sh/ecc.c b/cpu/sh/ecc.c
new file mode 100644
index 0000000000..1f17e8c11d
--- /dev/null
+++ b/cpu/sh/ecc.c
@@ -0,0 +1,489 @@
+/*
+ * Synopsis : Error Correction Codes (ECC) Algorithms.
+ *
+ * Copyright (c) 2008-2009 STMicroelectronics Limited.  All right reserved.
+ *
+ * See ecc.h for a description of this module.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+#if defined(CONFIG_CMD_NAND)
+
+#include <asm/ecc.h>
+
+
+static const unsigned char byte_parity_table[] =   /* Parity look up table */
+{
+  0x00, 0x2B, 0x2D, 0x06, 0x33, 0x18, 0x1E, 0x35,
+  0x35, 0x1E, 0x18, 0x33, 0x06, 0x2D, 0x2B, 0x00,
+  0x4B, 0x60, 0x66, 0x4D, 0x78, 0x53, 0x55, 0x7E,
+  0x7E, 0x55, 0x53, 0x78, 0x4D, 0x66, 0x60, 0x4B,
+  0x4D, 0x66, 0x60, 0x4B, 0x7E, 0x55, 0x53, 0x78,
+  0x78, 0x53, 0x55, 0x7E, 0x4B, 0x60, 0x66, 0x4D,
+  0x06, 0x2D, 0x2B, 0x00, 0x35, 0x1E, 0x18, 0x33,
+  0x33, 0x18, 0x1E, 0x35, 0x00, 0x2B, 0x2D, 0x06,
+  0x53, 0x78, 0x7E, 0x55, 0x60, 0x4B, 0x4D, 0x66,
+  0x66, 0x4D, 0x4B, 0x60, 0x55, 0x7E, 0x78, 0x53,
+  0x18, 0x33, 0x35, 0x1E, 0x2B, 0x00, 0x06, 0x2D,
+  0x2D, 0x06, 0x00, 0x2B, 0x1E, 0x35, 0x33, 0x18,
+  0x1E, 0x35, 0x33, 0x18, 0x2D, 0x06, 0x00, 0x2B,
+  0x2B, 0x00, 0x06, 0x2D, 0x18, 0x33, 0x35, 0x1E,
+  0x55, 0x7E, 0x78, 0x53, 0x66, 0x4D, 0x4B, 0x60,
+  0x60, 0x4B, 0x4D, 0x66, 0x53, 0x78, 0x7E, 0x55,
+  0x55, 0x7E, 0x78, 0x53, 0x66, 0x4D, 0x4B, 0x60,
+  0x60, 0x4B, 0x4D, 0x66, 0x53, 0x78, 0x7E, 0x55,
+  0x1E, 0x35, 0x33, 0x18, 0x2D, 0x06, 0x00, 0x2B,
+  0x2B, 0x00, 0x06, 0x2D, 0x18, 0x33, 0x35, 0x1E,
+  0x18, 0x33, 0x35, 0x1E, 0x2B, 0x00, 0x06, 0x2D,
+  0x2D, 0x06, 0x00, 0x2B, 0x1E, 0x35, 0x33, 0x18,
+  0x53, 0x78, 0x7E, 0x55, 0x60, 0x4B, 0x4D, 0x66,
+  0x66, 0x4D, 0x4B, 0x60, 0x55, 0x7E, 0x78, 0x53,
+  0x06, 0x2D, 0x2B, 0x00, 0x35, 0x1E, 0x18, 0x33,
+  0x33, 0x18, 0x1E, 0x35, 0x00, 0x2B, 0x2D, 0x06,
+  0x4D, 0x66, 0x60, 0x4B, 0x7E, 0x55, 0x53, 0x78,
+  0x78, 0x53, 0x55, 0x7E, 0x4B, 0x60, 0x66, 0x4D,
+  0x4B, 0x60, 0x66, 0x4D, 0x78, 0x53, 0x55, 0x7E,
+  0x7E, 0x55, 0x53, 0x78, 0x4D, 0x66, 0x60, 0x4B,
+  0x00, 0x2B, 0x2D, 0x06, 0x33, 0x18, 0x1E, 0x35,
+  0x35, 0x1E, 0x18, 0x33, 0x06, 0x2D, 0x2B, 0x00
+};
+
+static const unsigned char  bit_count_table[] =   /* Parity look up table */
+{
+  0, 1, 1, 2, 1, 2, 2, 3,
+  1, 2, 2, 3, 2, 3, 3, 4,
+  1, 2, 2, 3, 2, 3, 3, 4,
+  2, 3, 3, 4, 3, 4, 4, 5,
+  1, 2, 2, 3, 2, 3, 3, 4,
+  2, 3, 3, 4, 3, 4, 4, 5,
+  2, 3, 3, 4, 3, 4, 4, 5,
+  3, 4, 4, 5, 4, 5, 5, 6,
+  1, 2, 2, 3, 2, 3, 3, 4,
+  2, 3, 3, 4, 3, 4, 4, 5,
+  2, 3, 3, 4, 3, 4, 4, 5,
+  3, 4, 4, 5, 4, 5, 5, 6,
+  2, 3, 3, 4, 3, 4, 4, 5,
+  3, 4, 4, 5, 4, 5, 5, 6,
+  3, 4, 4, 5, 4, 5, 5, 6,
+  4, 5, 5, 6, 5, 6, 6, 7,
+  1, 2, 2, 3, 2, 3, 3, 4,
+  2, 3, 3, 4, 3, 4, 4, 5,
+  2, 3, 3, 4, 3, 4, 4, 5,
+  3, 4, 4, 5, 4, 5, 5, 6,
+  2, 3, 3, 4, 3, 4, 4, 5,
+  3, 4, 4, 5, 4, 5, 5, 6,
+  3, 4, 4, 5, 4, 5, 5, 6,
+  4, 5, 5, 6, 5, 6, 6, 7,
+  2, 3, 3, 4, 3, 4, 4, 5,
+  3, 4, 4, 5, 4, 5, 5, 6,
+  3, 4, 4, 5, 4, 5, 5, 6,
+  4, 5, 5, 6, 5, 6, 6, 7,
+  3, 4, 4, 5, 4, 5, 5, 6,
+  4, 5, 5, 6, 5, 6, 6, 7,
+  4, 5, 5, 6, 5, 6, 6, 7,
+  5, 6, 6, 7, 6, 7, 7, 8
+};
+
+/*******************************************************************************/
+#define COL_LOOP_STEP(c__f, c__e, c__o, c__t) \
+  c__o ^= (c__f ? c__t : 1); \
+  c__e ^= (c__f ? 1 : c__t);
+
+/* Generate 3 byte ECC code for ecc_size block p_data.
+   "p_data" is a pointer to the data and must be 4-byte aligned.
+   "size" gives length of "p_data" - one of enum ecc_size.
+ */
+ecc_t ecc_gen(const unsigned char* p_data, const enum ecc_size size)
+{
+  const unsigned long* const p_data_long = (unsigned long*)p_data;
+  unsigned long parity_bits[18];  /* maximum number */
+  unsigned long reg32;
+  unsigned long temp;
+  unsigned long int_cnt;
+  unsigned long bit_cnt;
+
+  unsigned int num_parity_bits;
+
+  unsigned char* p_byt;
+  unsigned char byte_reg;
+  unsigned char byte_a;
+  unsigned char byte_b;
+  unsigned char byte_c;
+  unsigned char byte_d;
+
+  ecc_t result;
+  if ( (size!=128) || (((unsigned long)p_data)%4!=0) )	/* QQQ - DELETE */
+  {							/* QQQ - DELETE */
+	printf("ERROR: %s(p_data=%p, size=%u)\n",	/* QQQ - DELETE */
+		__FUNCTION__, p_data, (unsigned)size);	/* QQQ - DELETE */
+  }							/* QQQ - DELETE */
+
+  switch (size)
+  {
+    case ECC_128:
+    default:
+      num_parity_bits = 14;
+      break;
+    case ECC_256:
+      num_parity_bits = 16;
+      break;
+    case ECC_512:
+      num_parity_bits = 18;
+      break;
+  }
+
+  /* Initialize variables */
+  byte_reg = 0;
+  reg32 = 0;
+
+  result.byte[0] = result.byte[1] = result.byte[2] = 0;
+
+  for(bit_cnt = 0; bit_cnt < num_parity_bits; bit_cnt ++)
+  {
+    parity_bits[bit_cnt] = 0;
+  } /* for bit_cnt */
+
+  /* Build up column parity */
+  for(int_cnt = 0; int_cnt < size/sizeof(unsigned long); int_cnt++)
+  {
+    temp = p_data_long[int_cnt];
+
+    switch (size)
+    {
+      case ECC_512:
+        COL_LOOP_STEP((int_cnt & 0x40), parity_bits[16], parity_bits[17], temp);
+        /* fall through */
+      case ECC_256:
+        COL_LOOP_STEP((int_cnt & 0x20), parity_bits[14], parity_bits[15], temp);
+        /* fall through */
+      case ECC_128:
+        COL_LOOP_STEP((int_cnt & 0x01), parity_bits[4], parity_bits[5], temp);
+        COL_LOOP_STEP((int_cnt & 0x02), parity_bits[6], parity_bits[7], temp);
+        COL_LOOP_STEP((int_cnt & 0x04), parity_bits[8], parity_bits[9], temp);
+        COL_LOOP_STEP((int_cnt & 0x08), parity_bits[10], parity_bits[11], temp);
+        COL_LOOP_STEP((int_cnt & 0x10), parity_bits[12], parity_bits[13], temp);
+    }
+  } /* for int_cnt */
+
+  reg32 = parity_bits[12] ^ parity_bits[13];
+
+  p_byt = (unsigned char*)&reg32;
+#if __LITTLE_ENDIAN__
+  byte_a = p_byt[3];
+  byte_b = p_byt[2];
+  byte_c = p_byt[1];
+  byte_d = p_byt[0];
+#else
+  byte_a = p_byt[0];
+  byte_b = p_byt[1];
+  byte_c = p_byt[2];
+  byte_d = p_byt[3];
+#endif
+
+  byte_reg = byte_a ^ byte_b ^ byte_c ^ byte_d;
+
+  byte_reg = byte_parity_table[byte_reg] >> 1;
+
+
+  /* Create line parity */
+  parity_bits[0] = byte_d ^ byte_b;
+  parity_bits[1] = byte_c ^ byte_a;
+  parity_bits[2] = byte_d ^ byte_c;
+  parity_bits[3] = byte_b ^ byte_a;
+
+  for(bit_cnt = 4; bit_cnt < num_parity_bits; bit_cnt++)
+  {
+    p_byt = (unsigned char*)(parity_bits + bit_cnt);
+    p_byt[0] ^= (p_byt[1] ^ p_byt[2] ^ p_byt[3]); /* NB Only LS Byte of parity_bits used from now on */
+  } /* for bit_cnt */
+
+  /* Calculate final ECC code */
+  for(bit_cnt = 0; bit_cnt < 8; bit_cnt ++)
+    result.byte[0] |= (byte_parity_table[ (unsigned char)parity_bits[bit_cnt] ] & 0x01) << bit_cnt;
+  for(; bit_cnt < 16 && bit_cnt < num_parity_bits; bit_cnt ++)
+    result.byte[1] |= (byte_parity_table[ (unsigned char)parity_bits[bit_cnt] ] & 0x01) << (bit_cnt - 8);
+  for(; bit_cnt < num_parity_bits; bit_cnt ++)
+    result.byte[2] |= (byte_parity_table[ (unsigned char)parity_bits[bit_cnt] ] & 0x01) << (bit_cnt - 16);
+
+  result.byte[2] = (unsigned char)(byte_reg << 2) | (result.byte[2] & 0x03);
+
+  return result;
+} /* ecc_gen */
+
+
+/*******************************************************************************/
+/* Detect and correct a 1 bit error in a 128, 256 or 512 byte block.
+   "p_data" is a pointer to the data.
+   "old_ecc" is the proper ECC for the data.
+   "new_ecc" is the ECC generated from the (possibly) corrupted data.
+   The size of the block is given in "size".
+
+   Returns whether the data needed correcting, or was not correctable.
+   If the result code is E_D1_CHK, then the data will have been modified.
+ */
+enum ecc_check ecc_correct(unsigned char* p_data,
+                           ecc_t old_ecc,
+                           ecc_t new_ecc,
+                           enum ecc_size size)
+{
+  unsigned char bit_cnt02;
+  unsigned char bit_addr02;
+  unsigned int byte_addr02;
+
+  unsigned char ecc_xor[3];
+
+  unsigned char error_bit_count;
+  switch (size)
+  {
+    case ECC_128:
+    default:
+      error_bit_count = 10;
+      break;
+    case ECC_256:
+      error_bit_count = 11;
+      break;
+    case ECC_512:
+      error_bit_count = 12;
+      break;
+  }
+
+  /* Basic Error Detection phase */
+  ecc_xor[0] = new_ecc.byte[0] ^ old_ecc.byte[0];
+  ecc_xor[1] = new_ecc.byte[1] ^ old_ecc.byte[1];
+  ecc_xor[2] = new_ecc.byte[2] ^ old_ecc.byte[2];
+
+  if ((ecc_xor[0] | ecc_xor[1] | ecc_xor[2]) == 0)
+  {
+    return E_NO_CHK;  /* No errors */
+  }
+  /* If we get here then there were errors */
+
+  if (size == ECC_512)
+  {
+    /* 512-byte error correction requires a little more than 128 or 256.
+       If there is a correctable error then the xor will have 12 bits set,
+       but there can also be 12 bits set in some uncorrectable errors.
+       This can be solved by xoring the odd and even numbered bits.
+
+       0xAA = 10101010
+       0x55 = 01010101
+     */
+    bit_cnt02  = bit_count_table[ ((ecc_xor[0] & 0xAA) >> 1) ^ (ecc_xor[0] & 0x55) ];
+    bit_cnt02 += bit_count_table[ ((ecc_xor[1] & 0xAA) >> 1) ^ (ecc_xor[1] & 0x55) ];
+    bit_cnt02 += bit_count_table[ ((ecc_xor[2] & 0xAA) >> 1) ^ (ecc_xor[2] & 0x55) ];
+  }
+  else
+  {
+    /* Counts the number of bits set in ecc code */
+    bit_cnt02  = bit_count_table[ ecc_xor[0] ];
+    bit_cnt02 += bit_count_table[ ecc_xor[1] ];
+    bit_cnt02 += bit_count_table[ ecc_xor[2] ];
+  }
+
+  if (bit_cnt02 == error_bit_count)
+  {
+    /* Set the bit address */
+    bit_addr02 = ((ecc_xor[2] >> 3) & 0x01) |
+                 ((ecc_xor[2] >> 4) & 0x02) |
+                 ((ecc_xor[2] >> 5) & 0x04);
+
+    /* Evaluate 2 LS bits of address */
+    byte_addr02 = ((ecc_xor[0] >> 1) & 0x01) | ((ecc_xor[0] >> 2) & 0x02);
+
+    /* Add in remaining bits of address */
+    switch (size)
+    {
+      case ECC_512:
+        byte_addr02 |= (((unsigned int)ecc_xor[2]) << 7) & 0x100;
+        /* Fall through */
+      case ECC_256:
+        byte_addr02 |= (ecc_xor[1] & 0x80);
+        /* Fall through */
+      case ECC_128:
+        byte_addr02 |= ((ecc_xor[0] >> 3) & 0x04) |
+                       ((ecc_xor[0] >> 4) & 0x08) |
+                       ((ecc_xor[1] << 3) & 0x10) |
+                       ((ecc_xor[1] << 2) & 0x20) |
+                       ((ecc_xor[1] << 1) & 0x40);
+    }
+
+
+    /* Correct bit error in the data */
+    p_data[byte_addr02] ^= (0x01 << bit_addr02);
+
+    /* NB p_old_code is okay, p_new_code is corrupt */
+
+    return E_D1_CHK;  /* Data had 1-bit error (now corrected) */
+  } /* if (bit_cnt02 == 11) */
+  else
+  {
+    if (bit_cnt02 == 1)
+    {
+      return E_C1_CHK;  /* ECC code has 1-bit error, data is okay */
+    } /* if (bit_cnt02 == 1) */
+    else
+    {
+      return E_UN_CHK;  /* Uncorrectable Error */
+    } /* else !(bit_cnt02 == 1) */
+  } /* else !(bit_cnt02 == 11) */
+} /* ecc_correct */
+/*******************************************************************************/
+
+
+#ifdef TESTING
+/* To test this code, compile as follows:
+
+       sh4gcc -mboard=<board> -g ecc.c -DTESTING
+
+   This provides a sanity test ONLY. It gives complete coverage of the code,
+   but does not fully exercise the mathmatics behind the algorithm.
+ */
+#include <stdlib.h>
+#include <time.h>
+
+int main()
+{
+  unsigned char data[512];
+  ecc_t ecc1;
+  ecc_t ecc2;
+  int i, size;
+
+  for (size = 128; size <= 512; size *= 2)
+  {
+    /* Create a data set */
+    for (i = 0; i < size; i++)
+      data[i] = i & 0xFF;
+
+    /* Create the initial ecc */
+    ecc1 = ecc_gen(data, size);
+
+    /* Make sure that it doesn't try to "correct" it before it's corrupted */
+    if (ecc_correct(data, ecc1, ecc1, size) != E_NO_CHK)
+    {
+      printf("Error: failed to detect good data.\n");
+      exit(1);
+    }
+
+    for (i = 0; i < size; i++)
+      if (data[i] != (i & 0xFF))
+      {
+  printf("Error: corrupted good data.\n");
+  exit(1);
+      }
+
+    /* Deliberately corrupt the data with 1 bit error only */
+    data[size-42] ^= 1;
+
+    /* Create a new ecc for the bad data */
+    ecc2 = ecc_gen(data, size);
+
+    /* Make sure that it can fix the issues */
+    if (ecc_correct(data, ecc1, ecc2, size) != E_D1_CHK)
+    {
+      printf("Error: failed to diagnose 1 bit data error.\n");
+      exit(1);
+    }
+
+    for (i = 0; i < size; i++)
+      if (data[i] != (i & 0xFF))
+      {
+        printf("Error: did not correct bad data.\n");
+        exit(1);
+      }
+    /* Data is now GOOD */
+
+    /* Deliberately corrupt the ECC with 1 bit error */
+    ecc2.byte[0] = ecc1.byte[0];
+    ecc2.byte[1] = ecc1.byte[1] ^ 4;
+    ecc2.byte[2] = ecc1.byte[2];
+
+    /* Simulate reading bad ECC from flash, but calculating good ECC from data */
+    if (ecc_correct(data, ecc2, ecc1, size) != E_C1_CHK)
+    {
+      printf("Error: failed to diagnose 1 bit ECC error.\n");
+      exit(1);
+    }
+
+    /* Deliberately corrupt the data with a 2-bit error */
+    data[size-42] ^= 3;
+
+    /* Create a new ecc for the bad data */
+    ecc2 = ecc_gen(data, size);
+
+    /* Check that it reports that it cannot correct the issue */
+    if (ecc_correct(data, ecc1, ecc2, size) != E_UN_CHK)
+    {
+      printf("Error: failed to diagnose 2-bit corruption.\n");
+      exit(1);
+    }
+
+    printf("ECC %d working as expected\n", size);
+  }
+
+  /* The above tests show that all is well with the various code paths.
+     However, it does not test detection of 2-bit error detection so well.
+     These tests generate and corrupt random data sets and ensures that
+     the algorithm does not mis-diagnose the condition.
+
+     Notes:
+     1. There is nothing to stop it corrupting the same bit twice - in which
+     case it will correctly diagnose a 1-bit error.
+     2. 3-bit errors and worse cause undefined behaviour, so we don't test those.
+   */
+  printf("\nECC 512 random data tests (interrupt when satisfied)\n");
+
+  srand(time(NULL));
+  while (1)
+  {
+    for (i = 0; i < 512; i++)
+      /* Random number 0..255 */
+      data[i] = (unsigned char)(256.0 * rand() / (RAND_MAX + 1.0));
+
+    ecc1 = ecc_gen(data, ECC_512);
+
+    for (i = 0; i < 2; i++)
+    {
+      /* Random number 0..514 */
+      int corruptbyte = (int)(515.0 * rand() / (RAND_MAX + 1.0));
+      /* Random number 0..7 */
+      int corruptbit = (int)(8.0 * rand() / (RAND_MAX + 1.0));
+
+      if (corruptbyte < 512)
+        data[corruptbyte] ^= 1 << corruptbit;
+      else
+        ecc1.byte[corruptbyte - 512] ^= 1 << corruptbit;
+
+      printf("%3d:%d ", corruptbyte, corruptbit);
+    }
+
+    ecc2 = ecc_gen(data, ECC_512);
+
+    if (ecc_correct(data, ecc1, ecc2, ECC_512) != E_UN_CHK)
+      printf("Error: failed to diagnose 2-bit-corruption\n");
+    else
+      printf("OK\n");
+  }
+
+  return 0;
+}
+#endif
+#endif	/* CONFIG_CMD_NAND */
diff --git a/cpu/sh/env_eeprom.c b/cpu/sh/env_eeprom.c
new file mode 100644
index 0000000000..eda86bab81
--- /dev/null
+++ b/cpu/sh/env_eeprom.c
@@ -0,0 +1,270 @@
+/*
+ * (C) Copyright 2000-2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * (C) Copyright 2001 Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Andreas Heppel <aheppel@sysgo.de>
+ *
+ * (C) Copyright 2009 STMicroelectronics Ltd.
+ * Sean McGoogan <Sean.McGoogan@st.com>
+
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+/*
+ * NOTE: For the ST40 series of SoCs, we use the "eeprom" set of
+ * commands to access SPI serial flash memory devices.
+ *
+ * Hence we need to define CFG_ENV_IS_IN_EEPROM is we want the
+ * environment stored in SPI serial flash.
+ *
+ * This file allows us to store U-boot's environment in SPI
+ * serial flash, and boot from SPI using the SPIBOOT mode
+ * controller in the STMicroelectronics' EMI.
+ *
+ * Sometimes (during initialization) we access the SPI via the
+ * SPIBOOT mode controller, other times (post-initialization)
+ * we access the SPI serial flash via the SSC (or PIOs).
+ * This file tries to take care of dealing with the
+ * duality aspects of all this.
+ *
+ * If CFG_BOOT_FROM_SPI is defined, then we assume we are booting
+ * from SPI serial flash, using the SoC's SPIBOOT mode, to re-map
+ * the serial flash to 0xA0000000 in the EMI space. Otherwise,
+ * we assume we are *not* booting using the SoC's SPIBOOT mode,
+ * in which case we need to use either the SSC or PIO to talk
+ * to the SPI serial flash.
+ * The main difference in usage, is the environment variables
+ * will always be honoured if CFG_BOOT_FROM_SPI is defined,
+ * whereas, if CFG_BOOT_FROM_SPI is not defined, then
+ * the environment variables will only be honoured *after* the
+ * SPI has been initialized (i.e. after serial initialization).
+ * Hence, "baudrate" may not be honoured if the environment is
+ * stored in SPI, unless CFG_BOOT_FROM_SPI is also defined.
+ */
+
+#if defined(CFG_ENV_IS_IN_EEPROM)
+
+#include <command.h>
+#include <environment.h>
+#include <linux/stddef.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+env_t *env_ptr = NULL;
+
+char * env_name_spec = "SPI Serial Flash";
+
+extern uchar (*env_get_char)(int);
+extern uchar env_get_char_memory (int index);
+
+
+#if defined(CFG_BOOT_FROM_SPI)
+	/*
+	 * The following function will read a 32-bit value
+	 * from the serial flash, via the SPIBOOT controller,
+	 * whilst in SPI Boot mode.
+	 */
+static inline u32 spiboot_get_u32(const int index)
+{
+	return *(u32*)(CFG_EMI_SPI_BASE + index);
+}
+
+
+	/*
+	 * The following function will read a byte
+	 * from the serial flash, via the SPIBOOT
+	 * controller, whilst in SPI boot mode.
+	 * NOTE: we *need* to perform a 4-byte read, and only
+	 * extract the one byte we are really interested in.
+	 */
+static inline uchar spiboot_get_byte(const int index)
+{
+	const u32 word = spiboot_get_u32(index & ~0x3u);
+	return ( ( word >> (index%4)*8 ) & 0xffu );
+}
+
+
+/************************************************************************
+ * Initialize Environment use
+ *
+ * Note: as we are using SPIBOOT mode to read the serial flash,
+ * then we need to perform 32-bit accesses only. Hence, we loop
+ * whilst reading 4-bytes into 'buf' and then update the CRC.
+ */
+extern int env_init(void)
+{
+	ulong crc, len, new;
+	unsigned off;
+	uchar buf[4];		/* only do 32-bits per iteration */
+
+	/* read old CRC (from flash) */
+	crc = spiboot_get_u32(CFG_ENV_OFFSET + offsetof(env_t,crc));
+
+	/* compute current CRC */
+	new = 0;
+	len = ENV_SIZE;
+	off = CFG_ENV_OFFSET + offsetof(env_t,data);
+	while (len > 0)
+	{
+		int n = (len > sizeof(buf)) ? sizeof(buf) : len;
+		*(ulong*)buf = spiboot_get_u32(off);
+		new = crc32 (new, buf, n);
+		len -= n;
+		off += n;
+	}
+
+	/* is the flash environment good ? */
+	if (crc == new)
+	{
+		gd->env_addr  = CFG_ENV_OFFSET + offsetof(env_t,data);
+		gd->env_valid = 1;
+	}
+	else
+	{
+		gd->env_addr  = 0;
+		gd->env_valid = 0;
+	}
+
+	return (0);
+}
+#endif	/* CFG_BOOT_FROM_SPI */
+
+
+/************************************************************************
+ * Initialize Environment use
+ *
+ * Note: for this case, we are storing the environment
+ * in SPI serial flash - but we are *not* booting from SPI
+ * serial flash, so we can not obtain the proper environment
+ * until we have probed for the SPI serial flash - which we do later.
+ * So, we initially just "fake" the environment by pretending
+ * that there is not one!
+ */
+#if !defined(CFG_BOOT_FROM_SPI)
+extern int env_init(void)
+{
+	gd->env_addr  = 0;
+	gd->env_valid = 0;	/* no valid environment */
+
+	return (0);
+}
+
+/*
+ * The following function is performed to initialize
+ * the environment *after* the SPI driver has been
+ * initialized.
+ */
+extern int env_init_after_spi_done(void)
+{
+	ulong crc, len, new;
+	unsigned off;
+	uchar buf[64];
+
+	/* read old CRC */
+	eeprom_read (CFG_DEF_EEPROM_ADDR,
+		     CFG_ENV_OFFSET+offsetof(env_t,crc),
+		     (uchar *)&crc, sizeof(ulong));
+
+	new = 0;
+	len = ENV_SIZE;
+	off = offsetof(env_t,data);
+	while (len > 0) {
+		int n = (len > sizeof(buf)) ? sizeof(buf) : len;
+
+		eeprom_read (CFG_DEF_EEPROM_ADDR, CFG_ENV_OFFSET+off, buf, n);
+		new = crc32 (new, buf, n);
+		len -= n;
+		off += n;
+	}
+
+	if (crc == new) {
+		gd->env_addr  = offsetof(env_t,data);
+		gd->env_valid = 1;
+	} else {
+		gd->env_addr  = 0;
+		gd->env_valid = 0;
+	}
+
+	return (0);
+}
+#endif	/* !CFG_BOOT_FROM_SPI */
+
+
+extern uchar env_get_char_spec (int index)
+{
+	uchar c;
+
+#if defined(CFG_BOOT_FROM_SPI)
+	if ( (env_ptr==NULL) ||
+	     (gd->env_addr != (ulong)&(env_ptr->data)) )
+	{
+		/*
+		 * Not relocated the environment yet.
+		 * So the SPI is not yet initialized, so use the SPI-BOOT
+		 * controller to read the environment directly via the EMI.
+		 */
+		c = spiboot_get_byte(CFG_ENV_OFFSET + index);
+	}
+	else
+#endif	/* CFG_BOOT_FROM_SPI */
+	{
+		/*
+		 * Serial flash accessible via SSC or PIO, so
+		 * we can need to use the 'normal' SPI interfaces
+		 * to talk to the SPI serial flash device.
+		 */
+		eeprom_read (CFG_DEF_EEPROM_ADDR,
+			     CFG_ENV_OFFSET+index+offsetof(env_t,data),
+			     &c, 1);
+	}
+
+	return (c);
+}
+
+
+extern void env_relocate_spec (void)
+{
+#if defined(CFG_BOOT_FROM_SPI)
+	const uchar * const from = (uchar*)(CFG_EMI_SPI_BASE + CFG_ENV_OFFSET);
+	memcpy( (uchar*)env_ptr, from, CFG_ENV_SIZE);
+#else
+	eeprom_read (
+		CFG_DEF_EEPROM_ADDR,
+		CFG_ENV_OFFSET,
+		(uchar *)env_ptr,
+		CFG_ENV_SIZE);
+#endif	/* CFG_BOOT_FROM_SPI */
+}
+
+
+extern int saveenv(void)
+{
+	return eeprom_write (CFG_DEF_EEPROM_ADDR,
+			     CFG_ENV_OFFSET,
+			     (uchar *)env_ptr,
+			     CFG_ENV_SIZE);
+}
+
+
+#endif	/* CFG_ENV_IS_IN_EEPROM */
+
+
diff --git a/cpu/sh/init_ram.S b/cpu/sh/init_ram.S
new file mode 100644
index 0000000000..ccd6d505f0
--- /dev/null
+++ b/cpu/sh/init_ram.S
@@ -0,0 +1,250 @@
+/*
+ * (C) Copyright 2004-2009 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ * Start Menefy <stuart.menefy@st.com>
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include "asm/regdef.h"
+#include "asm/asmdefs.h"
+#include "asm/linkage.h"
+
+/*
+ *	NOTE:	 ALL THIS CODE MUST BE PIC !!!!
+ *
+ *	This code expects to be run with the caches enabled.
+ */
+
+	.section .text.init, "ax"
+
+ENTRY(init_ram)
+	/* Stash the pr somewhere safe */
+	sts	pr, r14
+
+	/*
+	 * We need to get the poke loop & associated data
+	 * into caches. The poke loop is structured so that it is
+	 * all pulled into cache on it 1st iteration.
+	 * To get the poke table into D-cache, we simply read it all.
+	 */
+	GETDEVID r7
+	mova	poke_loop_address, r0	/* R6: &poke_loop() */
+	mov.l	@r0, r6
+	add	r0, r6
+	mov.l	p2_to_p1_mask, r3	/* R3: P2 -> P1 mapping */
+	and	r3, r6			/* convert to P1 addresses */
+	mov.l	data_start_address, r1	/* R1 = start address */
+	add	r0, r1
+	mov.l	data_end_address, r2	/* R2 = end address */
+	add	r0, r2
+	and	r3, r1			/* convert to a P1 addresses */
+	and	r3, r2
+	mov	r1, r5			/* R5 = scratch data ptr */
+
+1:	mov.l	@r5+, r4		/* Load poke table in D$ */
+	cmp/eq	r5, r2
+	bf	1b
+
+	/*
+	 * Its now safe to call the poke loop with real data, since it
+	 * and its associated data table are in onchip caches. Setting
+	 * up the memory interfaces may cause the EMI (where this FLASH
+	 * image resides) to briefly hang - but the CPU will be safely
+	 * executing from cache should this happen.
+	 */
+do_pokes:
+	jsr	@r6		/* R6 still points poke_loop() */
+	  nop
+
+	/* Restore the PR */
+	lds	r14, pr
+	rts
+	  nop
+
+
+	.balign 4
+poke_loop_address:	.long poke_loop - poke_loop_address
+data_start_address:	.long __memory_setup_table - poke_loop_address
+data_end_address:	.long __memory_setup_table_end - poke_loop_address
+p2_to_p1_mask:		.long ~0x20000000
+
+
+/*
+ * This is derived from STMicroelectronics gnu toolchain example:
+ *	sh-superh-elf/examples/os21/romdynamic/bootstrap.S
+ * but it is not identical, because concurrently U-Boot added the
+ * IF_DEVID, IF_NOT_DEVID, ELSE and ENDIF commands, while the toolset
+ * added IF. This merged version supports both.
+ */
+
+/*
+ * The poke table is a series of long words, in the format
+ *
+ *	opcode, address, operand, ...
+ *
+ * An opcode of 0 marks the table end
+ */
+
+#define POKE_UPDATE_LONG(A1, A2, AND, SHIFT, OR)	.long 8, A1, A2, AND, SHIFT, OR
+#define WHILE_NE(A, AND, VAL)				.long 7, A, AND, VAL
+#define UPDATE_LONG(A, AND, OR)				.long 6, A, AND, OR
+#define OR_LONG(A, V)					.long 5, A, V
+#define POKE_LONG(A, V)					.long 4, A, V
+#define POKE_SHORT(A, V)				.long 2, A, V
+#define POKE_CHAR(A, V)					.long 1, A, V
+#define IF_DEVID(V)					.long 9,  (1f - .) -8, V
+#define IF_NOT_DEVID(V)					.long 10, (1f - .) -8, V
+#define ELSE						.long 11, (2f - .) - 4 ; 1:
+#define ENDIF						2: ; 1:
+#define IF(A, AND, VAL, COMMAND)			.long 12, A, AND, VAL; COMMAND
+#define END_MARKER					.long 0, 0, 0
+
+
+#define STB7100_CUT1 (STB7100_DEVID_7100_VAL << STB7100_DEVID_ID_SHIFT)
+#define STB7100_CUT2 (STB7100_DEVID_7100_VAL << STB7100_DEVID_ID_SHIFT) | (1 << STB7100_DEVID_CUT_SHIFT)
+#define STB7100_CUT3 (STB7100_DEVID_7100_VAL << STB7100_DEVID_ID_SHIFT) | (2 << STB7100_DEVID_CUT_SHIFT)
+#define STB7109_CUT1 (STB7100_DEVID_7109_VAL << STB7100_DEVID_ID_SHIFT)
+#define STB7109_CUT2 (STB7100_DEVID_7109_VAL << STB7100_DEVID_ID_SHIFT) | (1 << STB7100_DEVID_CUT_SHIFT)
+#define STB7109_CUT3 (STB7100_DEVID_7109_VAL << STB7100_DEVID_ID_SHIFT) | (2 << STB7100_DEVID_CUT_SHIFT)
+#define STX7200_CUT1 (STX7200_DEVID_7200c1_VAL << STX7200_DEVID_ID_SHIFT)
+#define STX7200_CUT2 (STX7200_DEVID_7200c2_VAL << STX7200_DEVID_ID_SHIFT) | (1 << STX7200_DEVID_CUT_SHIFT)
+
+/*
+ * Routine to setup peripheral registers.
+ * It is executed from within the I-cache,
+ * with all its data in the D-cache
+ */
+poke_loop:
+	mov.l	@r1+, r0	/* opcode */
+	mov.l	@r1+, r2	/* address */
+	mov.l	@r1+, r3	/* value */
+
+	cmp/eq	#0, r0		/* End marker ? */
+	bf	1f
+
+	rts			/* Return point */
+	  nop
+
+1:	cmp/eq	#4, r0		/* 4 byte write... */
+	bf	1f
+	mov.l	r3, @r2
+
+1:	cmp/eq	#2, r0		/* 2 byte write... */
+	bf	1f
+	mov.w	r3, @r2
+
+1:	cmp/eq	#1, r0		/* 1 byte write... */
+	bf	1f
+	mov.b	r3, @r2
+
+1:	cmp/eq	#5, r0		/* 4 byte OR... */
+	bf	1f
+	mov.l	@r2,r4
+	or	r3,r4
+	mov.l	r4,@r2
+
+1:	cmp/eq	#6, r0		/* 4 byte UPDATE... */
+	bf	1f
+	mov.l	@r2,r4
+	and	r3,r4
+	mov.l	@r1+,r3
+	or	r3,r4
+	mov.l	r4,@r2
+
+1:	cmp/eq	#8, r0		/* 4 byte write UPDATE... */
+	bf	1f
+	mov.l	@r3,r4
+	mov.l	@r1+,r3
+	and	r3,r4
+	mov.l	@r1+,r3
+	shld	r3,r4
+	mov.l	@r1+,r3
+	or	r3,r4
+	mov.l	r4,@r2
+
+1:	cmp/eq	#7, r0		/* WHILE != ... */
+	bf	1f
+	mov.l	@r1+,r5
+2:	mov.l	@r2,r4
+	and	r3,r4
+	cmp/eq	r4,r5
+	bf	2b
+
+1:	cmp/eq	#9, r0		/* IF_DEVID */
+	bf	1f		/* r2 skip offset, r3 condition, r7 holds out cut value */
+	cmp/eq	r3, r7
+	bt	poke_loop	/* go ahead with these pokes */
+	add	r2, r1
+	bra	poke_loop
+	  nop
+
+1:	cmp/eq	#10, r0		/* IF_NOT_DEVID */
+	bf	1f		/* r2 skip offset, r3 condition, r7 holds out cut value */
+	cmp/eq	r3, r7
+	bf	poke_loop	/* go ahead with these pokes */
+	add	r2, r1
+	bra	poke_loop
+	  nop
+
+1:	cmp/eq	#11, r0		/* ELSE */
+	bf	1f		/* r2 skip offset, r3 condition, r7 holds out cut value */
+	add	r2, r1
+	bra	poke_loop
+	  nop
+
+1:	cmp/eq	#12,r0		/* IF == ... next op */
+	bf	delay
+	mov.l	@r1+,r5
+	mov.l	@r2,r4
+	and	r3,r4
+	cmp/eq	r4,r5
+	bt	poke_loop	/* Compare succeeded - perform next op */
+2:				/* Skip the next operation (read past it) */
+	mov.l	@r1+,r0		/* R0 = opcode */
+	mov.l	@r1+,r2		/* skip address */
+	mov.l	@r1+,r2		/* skip value */
+				/* How many further reads do we need to skip? */
+	cmp/eq	#12,r0		/* If it's another IF, skip 1 and go back to start of skip loop */
+	bf	3f
+	mov.l	@r1+,r2
+	bra	2b
+	  nop
+
+3:	mov	#5,r2
+	cmp/gt	r2,r0
+	bf	5f		/* 0 further reads */
+
+	cmp/eq	#8,r0		/* Is it number 8 (3 reads, otherwise 1 read) */
+	bf	4f
+	mov.l	@r1+,r2		/* Skip 1 read */
+	mov.l	@r1+,r2		/* Skip 1 read */
+4:	mov.l	@r1+,r2		/* Skip 1 read and continue */
+5:	bra	poke_loop
+	  nop
+
+delay:	mov	#1,r0		/* small delay after EACH opcode */
+	swap.w	r0, r0		/* 0x10000 iterations (~65k) */
+2:	add	#-1,r0
+	cmp/eq	#0, r0
+	bf	2b
+	bt	poke_loop
diff --git a/cpu/sh/interrupts.c b/cpu/sh/interrupts.c
new file mode 100644
index 0000000000..0bcea59a19
--- /dev/null
+++ b/cpu/sh/interrupts.c
@@ -0,0 +1,34 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "common.h"
+
+void enable_interrupts (void)
+{
+}
+
+int disable_interrupts (void)
+{
+	return 0;
+}
diff --git a/cpu/sh/sata-init.c b/cpu/sh/sata-init.c
new file mode 100644
index 0000000000..4530e533dd
--- /dev/null
+++ b/cpu/sh/sata-init.c
@@ -0,0 +1,366 @@
+/*
+ * STM SATA initialization
+ *
+ * Copyright (C) 2007,2009 STMicroelectronics Limited
+ * Author: Stuart Menefy <stuart.menefy@st.com>
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * This file is based on "arch/sh/kernel/cpu/sh4/sata-init.c"
+ * in STMicroelectronics' release "stm23_0119" of the linux kernel.
+ */
+
+#include <common.h>
+
+
+#if defined(CONFIG_SH_STM_SATA)
+
+
+#include <asm/errno.h>
+#include <asm/st40reg.h>
+#include <asm/io.h>
+#include <asm/soc.h>
+#include <asm/socregs.h>
+
+
+#if defined(CONFIG_SH_STX7105)		/* Cut 3.x (or later) */
+#define SYS_STA00	STX7105_SYSCONF_SYS_STA00
+#define SYS_CFG33	STX7105_SYSCONF_SYS_CFG33
+#elif defined(CONFIG_SH_STX7141)	/* Cut 2.x (or later) */
+#define SYS_STA00	STX7141_SYSCONF_SYS_STA00
+#define SYS_CFG33	STX7141_SYSCONF_SYS_CFG33
+#elif defined(CONFIG_SH_STX7200)	/* Cut 3.x (or later) */
+#define SYS_STA00	STX7200_SYSCONF_SYS_STA00
+#define SYS_CFG33	STX7200_SYSCONF_SYS_CFG33
+#else
+#	error Missing Device Definitions!
+#endif
+
+
+/* sysconf status 0 */
+#define sata_tdo	(1<<1)
+
+/* sysconf config 33 */
+#define soft_jtag_en	(1<<6)
+#define tms_sata_en	(1<<5)
+#define trstn_sata	(1<<4)
+#define tdi_high	(1<<1)
+#define tdi_low		(0<<1)
+#define tck_high	(1<<0)
+#define tck_low		(0<<0)
+
+
+/*
+ * to minimize (future) maintenance with the linux sources,
+ * we "fake" the sysconf_field struct.
+ */
+typedef int sysconf_field;
+
+/* when reading, only interested in SYS_STA00[2:0] */
+#define sysconf_read(sc)	((readl((sc))) & 0x07)
+
+/* when writing, only interested in SYS_CFG33[6:0] */
+#define sysconf_write(sc, val)	\
+	do { writel((((readl(sc))&(~0x7F))|(val)),(sc)); } while (0)
+
+
+static void SATA_JTAG_IR_Select_MIPHY(
+	const sysconf_field sc)
+{
+	/* Flush trst synchronizer with two tck clocks */
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+
+	/* Set tap into idle state */
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+
+	/* Set tap into shift ir state */
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_high);
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_high);
+
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+
+	/* Shift in MacroMicroBusAccess TDI = 101 */
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tdi_high | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tdi_high | tck_high);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tdi_low | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tdi_low | tck_high);
+
+	/* Set tap into idle mode */
+	sysconf_write(sc,
+		      soft_jtag_en | tms_sata_en | trstn_sata | tdi_high |
+		      tck_low);
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tdi_high | tck_high);
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_high);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+}
+
+static void SATA_JTAG_DR_Write_MIPHY(
+	const sysconf_field sc,
+	const u8 regno,
+	const u8 data)
+{
+	int k;
+	u8 x;
+
+	/* Set TAP into shift dr state */
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_high);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+
+	/* Shift in DR=[17:10]=data;[9:2]address=regno;[1]rd=0;[0]wr=1  */
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tdi_high | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tdi_high | tck_high);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+
+	/* Push in the register address */
+	for (k = 0; k < 8; k++) {
+		x = ((regno >> k) & 0x1);
+		x = x << 1;
+		sysconf_write(sc, soft_jtag_en | trstn_sata | x | tck_low);
+		sysconf_write(sc, soft_jtag_en | trstn_sata | x | tck_high);
+	}
+
+	/* Push in the data to be written */
+	x = 0;
+	for (k = 0; k < 7; k++) {
+		x = ((data >> k) & 0x1);
+		x = x << 1;
+		sysconf_write(sc, soft_jtag_en | trstn_sata | x | tck_low);
+		sysconf_write(sc, soft_jtag_en | trstn_sata | x | tck_high);
+	}
+
+	/* Set TAP back round into SHIFT DR STATE
+	 * (exit1_dr,update_dr,idle,idle,select_dr,capture_dr) */
+	x = ((data >> 7) & 0x1);
+	x = x << 1;
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | x | tck_low);
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | x | tck_high);
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_high);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_high);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+
+	/*Set TAP into idle mode */
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_high);
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_high);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+}
+
+static u32 SATA_JTAG_DR_Read_MIPHY(
+	const sysconf_field sc,
+	const sysconf_field status_sc,
+	const u8 regno)
+{
+	int k;
+	u8 x;
+	u32 ctrlbit, regvalue = 0;
+
+	/* Set TAP into shift DR state */
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_high);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+
+	/* Shift in DR=[17:10]dummy_data;[9:2]address=regno;[1]rd=1;[0]wr=0  */
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tdi_high | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tdi_high | tck_high);
+
+	/*  push in the register address */
+	for (k = 0; k < 8; k++) {
+		x = ((regno >> k) & 0x1);
+		x = x << 1;
+		sysconf_write(sc, soft_jtag_en | trstn_sata | x | tck_low);
+		sysconf_write(sc, soft_jtag_en | trstn_sata | x | tck_high);
+	}
+
+	/* Push in 0 in the data field */
+	for (k = 0; k < 7; k++) {
+		sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+		sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+	}
+
+	/* Set TAP back round into SHIFT DR STATE
+	 * (exit1_dr,update_dr,idle,idle,select_dr,capture_dr) */
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_high);
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_high);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_high);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+
+	/* Shift out the MIPHY register contents */
+
+	/* Discard first 10 bits */
+	for (k = 0; k < 10; k++) {
+		sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+		sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+	}
+
+	for (k = 0; k < 7; k++) {
+		sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+		sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+		ctrlbit = sysconf_read(status_sc);
+		ctrlbit = ctrlbit & sata_tdo;
+		ctrlbit = ctrlbit >> 1;
+		regvalue = ((ctrlbit & 0x1) << k) | regvalue;
+	}
+
+	/* Set TAP into idle mode */
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_high);
+	ctrlbit = sysconf_read(status_sc);
+	ctrlbit = ctrlbit & sata_tdo;
+	ctrlbit = ctrlbit >> 1;
+	regvalue = ((ctrlbit & 0x1) << 7) | regvalue;
+
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | tms_sata_en | trstn_sata | tck_high);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_low);
+	sysconf_write(sc, soft_jtag_en | trstn_sata | tck_high);
+
+	return (regvalue);
+}
+
+extern void stm_sata_miphy_init(void)
+{
+	const sysconf_field sc        = (sysconf_field)SYS_CFG33;	/* SYS_CFG33[6:0] */
+	const sysconf_field status_sc = (sysconf_field)SYS_STA00;	/* SYS_STA00[2:0] */
+
+	SATA_JTAG_IR_Select_MIPHY(sc);
+
+	/* Force Macro1 in reset and request PLL calibration reset */
+
+	/* Force PLL calibration reset, PLL reset and assert
+	 * Deserializer Reset */
+	SATA_JTAG_DR_Write_MIPHY(sc, 0x00, 0x16);
+	SATA_JTAG_DR_Write_MIPHY(sc, 0x11, 0x0);
+	/* Force macro1 to use rx_lspd, tx_lspd (by default rx_lspd
+	 * and tx_lspd set for Gen1)  */
+	SATA_JTAG_DR_Write_MIPHY(sc, 0x10, 0x1);
+
+	/* Force Recovered clock on first I-DLL phase & all
+	 * Deserializers in HP mode */
+
+	/* Force Rx_Clock on first I-DLL phase on macro1 */
+	SATA_JTAG_DR_Write_MIPHY(sc, 0x72, 0x40);
+	/* Force Des in HP mode on macro1 */
+	SATA_JTAG_DR_Write_MIPHY(sc, 0x12, 0x00);
+
+	/* Wait for HFC_READY = 0 */
+	while (SATA_JTAG_DR_Read_MIPHY(sc, status_sc, 0x1) & 0x3)
+		;
+
+	/* Restart properly Process compensation & PLL Calibration */
+
+	/* Set properly comsr definition for 30 MHz ref clock */
+	SATA_JTAG_DR_Write_MIPHY(sc, 0x41, 0x1E);
+	/* comsr compensation reference */
+	SATA_JTAG_DR_Write_MIPHY(sc, 0x42, 0x33);
+	/* Set properly comsr definition for 30 MHz ref clock */
+	SATA_JTAG_DR_Write_MIPHY(sc, 0x41, 0x1E);
+	/* comsr cal gives more suitable results in fast PVT for comsr
+	   used by TX buffer to build slopes making TX rise/fall fall
+	   times. */
+	SATA_JTAG_DR_Write_MIPHY(sc, 0x42, 0x33);
+	/* Force VCO current to value defined by address 0x5A */
+	SATA_JTAG_DR_Write_MIPHY(sc, 0x51, 0x2);
+	/* Force VCO current to value defined by address 0x5A */
+	SATA_JTAG_DR_Write_MIPHY(sc, 0x5A, 0xF);
+	/* Enable auto load compensation for pll_i_bias */
+	SATA_JTAG_DR_Write_MIPHY(sc, 0x47, 0x2A);
+	/* Force restart compensation and enable auto load for
+	 * Comzc_Tx, Comzc_Rx & Comsr on macro1 */
+	SATA_JTAG_DR_Write_MIPHY(sc, 0x40, 0x13);
+
+	/* Wait for comzc & comsr done */
+	while ((SATA_JTAG_DR_Read_MIPHY(sc, status_sc, 0x40) & 0xC) != 0xC)
+		;
+
+	/* Recommended settings for swing & slew rate FOR SATA GEN 1
+	 * from CPG */
+	SATA_JTAG_DR_Write_MIPHY(sc, 0x20, 0x00);
+	/* (Tx Swing target 500-550mV peak-to-peak diff) */
+	SATA_JTAG_DR_Write_MIPHY(sc, 0x21, 0x2);
+	/* (Tx Slew target120-140 ps rising/falling time) */
+	SATA_JTAG_DR_Write_MIPHY(sc, 0x22, 0x4);
+
+	/* Force Macro1 in partial mode & release pll cal reset */
+	SATA_JTAG_DR_Write_MIPHY(sc, 0x00, 0x10);
+	udelay(10);
+
+	SATA_JTAG_DR_Write_MIPHY(sc, 0x50, 0x8D);
+	SATA_JTAG_DR_Write_MIPHY(sc, 0x50, 0x8D);
+
+	/*  Wait for phy_ready */
+	/*  When phy is in ready state ( register 0x01 of macro1 to 0x13) */
+	while ((SATA_JTAG_DR_Read_MIPHY(sc, status_sc, 0x01) & 0x03) != 0x03)
+		;
+
+	/* Enable macro1 to use rx_lspd  & tx_lspd from link interface */
+	SATA_JTAG_DR_Write_MIPHY(sc, 0x10, 0x00);
+	/* Release Rx_Clock on first I-DLL phase on macro1 */
+	SATA_JTAG_DR_Write_MIPHY(sc, 0x72, 0x00);
+
+	/* Deassert deserializer reset */
+	SATA_JTAG_DR_Write_MIPHY(sc, 0x00, 0x00);
+	/* des_bit_lock_en is set */
+	SATA_JTAG_DR_Write_MIPHY(sc, 0x02, 0x08);
+
+	/* bit lock detection strength */
+	SATA_JTAG_DR_Write_MIPHY(sc, 0x86, 0x61);
+}
+
+
+#endif	/* CONFIG_SH_STM_SATA */
+
+
diff --git a/cpu/sh/sata-probe.c b/cpu/sh/sata-probe.c
new file mode 100644
index 0000000000..67be2397f9
--- /dev/null
+++ b/cpu/sh/sata-probe.c
@@ -0,0 +1,171 @@
+/*
+ * STM SATA initialization
+ *
+ * Copyright (C) 2005-2009 STMicroelectronics Limited
+ * Stuart Menefy <stuart.menefy@st.com>
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * This file is based on "drivers/ata/sata_stm.c"
+ * in STMicroelectronics' release "stm23_0119" of the linux kernel.
+ */
+
+#include <common.h>
+
+
+#if defined(CONFIG_SH_STM_SATA)
+
+
+#include <asm/errno.h>
+#include <asm/st40reg.h>
+#include <asm/io.h>
+#include <asm/soc.h>
+#include <asm/socregs.h>
+
+
+#if defined(CONFIG_SH_STX7105)		/* Cut 3.x (or later) */
+#define pc_glue_logic_init	0	/* arch/sh/kernel/cpu/sh4/setup-stx7105.c */
+#elif defined(CONFIG_SH_STX7141)	/* Cut 2.x (or later) */
+#define pc_glue_logic_init	0	/* arch/sh/kernel/cpu/sh4/setup-stx7141.c */
+#elif defined(CONFIG_SH_STX7200)	/* Cut 3.x (or later) */
+#define pc_glue_logic_init	0	/* arch/sh/kernel/cpu/sh4/setup-stx7200.c */
+#else
+#	error Missing Device Definitions!
+#endif
+
+
+/*
+ * Bases addresses of the SATA component blocks:
+ *	Wrapper registers		0x000 - 0x3FF
+ *	DMA Controller registers	0x400 - 0x7FF
+ *	SATA Host Controller		0x800 - 0xBFF
+ */
+#define SATA_BASE_ADDR				(CFG_ATA_BASE_ADDR & ~0xfff)	/* 4K aligned */
+#define SATA_AHB2STBUS_BASE			(SATA_BASE_ADDR + 0x000)
+#define SATA_AHBDMA_BASE			(SATA_BASE_ADDR + 0x400)
+#define SATA_AHBHOST_BASE			(SATA_BASE_ADDR + 0x800)
+
+/* AHB_STBus protocol converter */
+#define SATA_AHB2STBUS_STBUS_OPC		(SATA_AHB2STBUS_BASE + 0x000)
+#define SATA_AHB2STBUS_MESSAGE_SIZE_CONFIG	(SATA_AHB2STBUS_BASE + 0x004)
+#define SATA_AHB2STBUS_CHUNK_SIZE_CONFIG	(SATA_AHB2STBUS_BASE + 0x008)
+#define SATA_AHB2STBUS_SW_RESET			(SATA_AHB2STBUS_BASE + 0x00c)
+#define SATA_AHB2STBUS_PC_STATUS		(SATA_AHB2STBUS_BASE + 0x010)
+#define SATA_PC_GLUE_LOGIC			(SATA_AHB2STBUS_BASE + 0x014)
+#define SATA_PC_GLUE_LOGICH			(SATA_AHB2STBUS_BASE + 0x018)
+
+/* AHB host controller */
+#define SATA_CDR0				(SATA_AHBHOST_BASE + 0x000)
+#define SATA_CDR1				(SATA_AHBHOST_BASE + 0x004)
+#define SATA_CDR2				(SATA_AHBHOST_BASE + 0x008)
+#define SATA_CDR3				(SATA_AHBHOST_BASE + 0x00c)
+#define SATA_CDR4				(SATA_AHBHOST_BASE + 0x010)
+#define SATA_CDR5				(SATA_AHBHOST_BASE + 0x014)
+#define SATA_CDR6				(SATA_AHBHOST_BASE + 0x018)
+#define SATA_CDR7				(SATA_AHBHOST_BASE + 0x01c)
+#define SATA_CLR0				(SATA_AHBHOST_BASE + 0x020)
+#define SATA_SCR0				(SATA_AHBHOST_BASE + 0x024)
+#define SATA_SCR1				(SATA_AHBHOST_BASE + 0x028)
+#define SATA_SCR2				(SATA_AHBHOST_BASE + 0x02c)
+#define SATA_SCR3				(SATA_AHBHOST_BASE + 0x030)
+#define SATA_SCR4				(SATA_AHBHOST_BASE + 0x034)
+#define SATA_DMACR				(SATA_AHBHOST_BASE + 0x070)
+#define SATA_DBTSR				(SATA_AHBHOST_BASE + 0x074)
+#define SATA_PHYCR				(SATA_AHBHOST_BASE + 0x088)
+#define SATA_VERSIONR				(SATA_AHBHOST_BASE + 0x0f8)
+
+/* AHB DMA controller */
+#define DMAC_COMP_VERSION			(SATA_AHBDMA_BASE + 0x3fc)
+
+
+
+extern int stm_sata_probe(void)
+{
+	int t, timeout;
+
+	/* AHB bus wrapper setup */
+
+	// SATA_AHB2STBUS_STBUS_OPC
+	// 2:0  -- 100 = Store64/Load64
+	// 4    -- 1   = Enable write posting
+	// DMA Read, write posting always = 0
+	/* opcode = Load4 |Store4 */
+	writel(3, SATA_AHB2STBUS_STBUS_OPC);
+
+	// SATA_AHB2STBUS_MESSAGE_SIZE_CONFIG
+	// 3:0  -- 0111 = 128 Packets
+	// 3:0  -- 0110 =  64 Packets
+	/* WAS: Message size = 64 packet when 6 now 3 */
+	writel(3, SATA_AHB2STBUS_MESSAGE_SIZE_CONFIG);
+
+	// SATA_AHB2STBUS_CHUNK_SIZE_CONFIG
+	// 3:0  -- 0110 = 64 Packets
+	// 3:0  -- 0001 =  2 Packets
+	/* WAS Chunk size = 2 packet when 1, now 0 */
+	writel(2, SATA_AHB2STBUS_CHUNK_SIZE_CONFIG);
+
+        // PC_GLUE_LOGIC
+        // 7:0  -- 0xFF = Set as reset value, 256 STBus Clock Cycles
+        // 8    -- 1  = Time out enabled
+	// (has bit 8 moved to bit 16 on 7109 cut2?)
+	/* time out count = 0xa0(160 dec)
+	 * time out enable = 1
+	 */
+	if (pc_glue_logic_init)
+	{
+		writel(pc_glue_logic_init, SATA_PC_GLUE_LOGIC);
+	}
+
+	/* Clear initial Serror */
+	writel(-1, SATA_SCR1);
+
+#if 0
+{
+	/*
+	 * Note: for this code to be executed, it is imperative
+	 * that this SATA initialization takes place *AFTER*
+	 * the serial console has been initialized!
+	 */
+	const unsigned sata_rev = readl(SATA_VERSIONR);
+	const unsigned dmac_rev = readl(DMAC_COMP_VERSION);
+
+	printf("info: SATA version %c.%c%c DMA version %c.%c%c\n",
+		(int)(sata_rev >> 24) & 0xff,
+		(int)(sata_rev >> 16) & 0xff,
+		(int)(sata_rev >>  8) & 0xff,
+		(int)(dmac_rev >> 24) & 0xff,
+		(int)(dmac_rev >> 16) & 0xff,
+		(int)(dmac_rev >>  8) & 0xff);
+}
+#endif
+
+	/*
+	 * Now we reset the SATA PHY.
+	 */
+	writel(0x301, SATA_SCR2);	/* issue phy wake/reset */
+	readl(SATA_SCR0);		/* dummy read; flush */
+	udelay(1000);			/* 1 ms  -  a guess */
+	writel(0x300, SATA_SCR2);	/* phy wake/clear reset */
+
+	/* wait for phy to become ready, if necessary */
+	timeout = 25;
+	do
+	{
+		udelay(200000);		/* 200 ms */
+		t = readl(SATA_SCR0);
+		if ((t & 0xf) != 1)
+			break;
+	} while (--timeout);
+
+	/* QQQ: we could now print the link status if we want ... */
+
+	return 0;			/* Okay */
+}
+
+
+#endif	/* CONFIG_SH_STM_SATA */
+
+
diff --git a/cpu/sh/spi.c b/cpu/sh/spi.c
new file mode 100644
index 0000000000..730c654401
--- /dev/null
+++ b/cpu/sh/spi.c
@@ -0,0 +1,974 @@
+/*
+ * (C) Copyright 2007,2009 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/soc.h>
+#include <asm/socregs.h>
+#include <asm/io.h>
+#include <spi.h>
+#include <asm/clk.h>
+
+
+/**********************************************************************/
+
+
+#if defined(CONFIG_SPI)
+
+
+/**********************************************************************/
+
+
+#if !defined(CONFIG_SOFT_SPI)			/* Use SSC for SPI */
+/* SSC Baud Rate Generator Register */
+#define SSC_BRG			0x0000
+
+/* SSC Transmit Buffer Register */
+#define SSC_TBUF		0x0004
+
+/* SSC Receive Buffer Register */
+#define SSC_RBUF		0x0008
+
+/* SSC Control Register */
+#define SSC_CON			0x000C
+#define SSC_CON_HB		(1ul<<4)	/* endianness */
+#define SSC_CON_PH		(1ul<<5)	/* clock phase */
+#define SSC_CON_PO		(1ul<<6)	/* clock polarity */
+#define SSC_CON_SR		(1ul<<7)	/* SSC software reset */
+#define SSC_CON_MS		(1ul<<8)	/* master/slave select */
+#define SSC_CON_EN		(1ul<<9)	/* SSC enable */
+#define SSC_CON_LPB		(1ul<<10)	/* SSC loopback mode */
+#define SSC_CON_TXFIFO		(1ul<<11)	/* transmit-side FIFO */
+#define SSC_CON_RXFIFO		(1ul<<12)	/* receive-side FIFO */
+#define SSC_CON_CLSTRX		(1ul<<13)	/* clock stretch mechanism */
+
+/* SSC Interrupt Enable Register */
+#define SSC_IEN			0x0010
+
+/* SSC Status Register */
+#define SSC_STAT		0x0014
+#define SSC_STAT_RIR		(1ul<<0)	/* receive buffer full flag */
+#define SSC_STAT_TIR		(1ul<<1)	/* transmit buffer empty flag */
+#define SSC_STAT_TE		(1ul<<2)	/* transmit Error flag */
+#define SSC_STAT_RE		(1ul<<3)	/* receive Error flag */
+#define SSC_STAT_PE		(1ul<<4)	/* phase Error flag */
+
+/* SSC I2C Control Register */
+#define SSC_I2C			0x0018
+
+#define SPI_CPHA		0x01		/* clock phase */
+#define SPI_CPOL		0x02		/* clock polarity */
+#define SPI_LSB_FIRST		0x08		/* endianness */
+#define SPI_LOOP		0x20		/* loop-back test mode */
+
+#define SPI_MODE_0		(0|0)
+#define SPI_MODE_1		(0|SPI_CPHA)
+#define SPI_MODE_2		(SPI_CPOL|0)
+#define SPI_MODE_3		(SPI_CPOL|SPI_CPHA)
+
+#endif	/* CONFIG_SOFT_SPI */
+
+
+/**********************************************************************/
+
+
+#define MIN(a,b)	( (a) < (b) ? (a) : (b) )
+
+
+/**********************************************************************/
+
+
+#if defined(CONFIG_SPI_FLASH_ATMEL)
+/* For Atmel AT45DB321D Serial Flash */
+#define CFG_STM_SPI_MODE	SPI_MODE_3
+#define CFG_STM_SPI_FREQUENCY	(10*1000*1000)	/* 10 MHz */
+#define CFG_STM_SPI_DEVICE_MASK	0x3cu		/* Mask Bits [5:2] */
+#define CFG_STM_SPI_DEVICE_VAL	0x34u		/* Binary xx1101xx */
+
+#define OP_READ_STATUS		0xd7u		/* Status Register Read */
+#define OP_READ_DEVID		0x9fu		/* Manufacturer & Device ID Read */
+//#define OP_READ_ARRAY		0xe8u		/* Continuous Array Read */
+//#define OP_READ_ARRAY		0x0bu		/* Continuous Array Read */
+#define OP_READ_ARRAY		0x03u		/* Continuous Array Read */
+#define OP_WRITE_VIA_BUFFER1	0x82u		/* Main Memory Page Program via Buffer 1 */
+#define OP_WRITE_VIA_BUFFER2	0x85u		/* Main Memory Page Program via Buffer 2 */
+#define OP_PAGE_TO_BUFFER1	0x53u		/* Main Memory Page to Buffer 1 Transfer */
+#define OP_PAGE_TO_BUFFER2	0x55u		/* Main Memory Page to Buffer 2 Transfer */
+
+#define SR_READY		(1u<<7)		/* Status Register Read/nBusy bit */
+
+#elif defined(CONFIG_SPI_FLASH_ST)	/******************************/
+
+/* For ST M25Pxx Serial Flash */
+#define CFG_STM_SPI_MODE	SPI_MODE_3
+#define CFG_STM_SPI_FREQUENCY	(10*1000*1000)	/* 10 MHz */
+#define CFG_STM_SPI_DEVICE_MASK	0x60u		/* Mask Bits [6:5] */
+#define CFG_STM_SPI_DEVICE_VAL	0x00u		/* Binary x00xxxxx */
+
+#define OP_READ_STATUS		0x05u		/* Read Status Register */
+#define OP_WRITE_STATUS		0x01u		/* Write Status Register */
+#define OP_READ_DEVID		0x9fu		/* Read ID */
+#define OP_READ_ARRAY		0x03u		/* Read Data Bytes */
+#define OP_WREN			0x06u		/* Write Enable */
+//#define OP_SE			0xD8u		/* Sector Erase */
+#define OP_SE			0x20u		/* Sector Erase iptv winbond*/
+#define OP_PP			0x02u		/* Page Program */
+
+#define SR_WIP			(1u<<0)		/* Status Register Write In Progress bit */
+#define SR_BP_MASK		0x1c		/* Block Protect Bits (BP[2:0]) */
+
+#elif defined(CONFIG_SPI_FLASH_MXIC)	/******************************/
+
+/* For Macronix MX25Lxxx Serial Flash */
+#define CFG_STM_SPI_MODE	SPI_MODE_3
+#define CFG_STM_SPI_FREQUENCY	(10*1000*1000)	/* 10 MHz */
+#define CFG_STM_SPI_DEVICE_MASK	0x00u		/* Mask Bits */
+#define CFG_STM_SPI_DEVICE_VAL	0x00u		/* Binary xxxxxxxx */
+
+#define OP_READ_STATUS		0x05u		/* Read Status Register */
+#define OP_WRITE_STATUS		0x01u		/* Write Status Register */
+#define OP_READ_DEVID		0x9fu		/* Read ID */
+#define OP_READ_ARRAY		0x03u		/* Read Data Bytes */
+#define OP_WREN			0x06u		/* Write Enable */
+#define OP_SE			0x20u		/* Sector Erase */
+#define OP_PP			0x02u		/* Page Program */
+
+#define SR_WIP			(1u<<0)		/* Status Register Write In Progress bit */
+#define SR_BP_MASK		0x3c		/* Block Protect Bits (BP[3:0]) */
+
+#else					/******************************/
+
+#error Please specify which SPI Serial Flash is being used
+
+#endif	/* defined(CONFIG_STM_SPI_xxxxxx) */
+
+
+/**********************************************************************/
+
+
+#define CFG_STM_SPI_SSC_BASE	ST40_SSC0_REGS_BASE	/* SSC #0 */
+static const unsigned long ssc = CFG_STM_SPI_SSC_BASE;	/* SSC base */
+
+#define ssc_write(offset, value)	writel((value), (ssc)+(offset))
+#define ssc_read(offset)		readl((ssc)+(offset))
+
+
+/**********************************************************************/
+
+
+static unsigned pageSize;	/* 256, 512 or 528 bytes per page ? */
+static unsigned eraseSize;	/* smallest supported erase size */
+static unsigned deviceSize;	/* Size of the device in Bytes */
+static const char * deviceName;	/* Name of the device */
+
+
+
+/*
+ * Transfer (i.e. exchange) one "word" with selected SPI device.
+ * Typically one word is 8-bits (an octet), but it does not need to be,
+ * this function is word-width agnostic - when using the SSC.
+ * However, for PIO bit-banging, then one word is explicitly
+ * unconditionally assumed to be exactly 8-bits in length.
+ *
+ *	input:   "out" is word to be send to slave SPI device
+ *	returns: one word read from the slave SPI device
+ *
+ * It is the caller's responsibility to ensure that the
+ * chip select (SPI_NOTCS) is correctly asserted.
+ */
+static unsigned int spi_xfer_one_word(const unsigned int out)
+{
+	unsigned int in = 0;
+
+#if defined(CONFIG_SOFT_SPI)		/* Use PIO Bit-Banging for SPI */
+	signed int i;
+	for(i=7; i>=0; i--)		/* for each bit in turn ... */
+	{				/* do 8 bits, msb first */
+		SPI_SCL(0);		/* SPI_CLK = low */
+		SPI_SDA(out & (1u<<i));	/* output next bit on SPI_DOUT */
+		SPI_DELAY;		/* clock low cycle */
+
+		SPI_SCL(1);		/* SPI_CLK = high */
+		SPI_DELAY;		/* sample on RISING clock edge */
+
+		in <<= 1;		/* shift */
+		in |= SPI_READ;		/* get next bit from SPI_DIN */
+	}
+#else					/* Use SSC for SPI */
+	/* write out data 'out' */
+	ssc_write(SSC_TBUF, out);
+
+	/* wait for Receive Buffer Full flag to be asserted */
+	while ((ssc_read(SSC_STAT) & SSC_STAT_RIR) == 0)
+	{
+		;	/* busy poll - do nothing */
+	}
+
+	/* read in data */
+	in = ssc_read(SSC_RBUF);
+#endif	/* CONFIG_SOFT_SPI */
+
+	/* return exchanged data */
+	return in;
+}
+
+
+/**********************************************************************/
+
+
+/*
+ * transfer (i.e. exchange) a series of "words" with SPI device.
+ * Typically one word is 8-bits (an octet).
+ * This function is expects a word to be exactly 8-bits.
+ *
+ *	input:   chipsel is pointer to the chip-select function (if !NULL)
+ *		 bitlen number of *bits* (not bytes) to be exchanged
+ *		 dout pointer to array of words to be sent to SPI
+ *		 din pointer to array of words that were read from SPI
+ *	returns: zero on success, else non-zero.
+ *
+ *	Note: 'din' may be NULL if caller does not need to see it.
+ */
+extern int spi_xfer(
+	spi_chipsel_type const chipsel,
+	const int bitlen,
+	uchar * const dout,
+	uchar * const din)
+{
+	size_t i;
+	const int bytelen = bitlen / 8;	/* number of 8-bit bytes */
+
+	/*
+	 * This code assumes that as we are using the SSC, that we will always
+	 * be swapping multiples of *whole* 8-bit bytes between the master
+	 * and the slave device.
+	 * This assumption is strictly unnecessary, as we could re-program
+	 * the SSC to allow any bit-size we want. However, this initial version
+	 * of the code sets the pervading transfers to 8-bits in the SSC.
+	 * So, right now, we just give up if the number of bits is not a
+	 * whole number of (8-bit) bytes - after printing a suitable diagnostic.
+	 */
+	if (bitlen & 0x7)
+	{
+		printf("ERROR: %s() called with non-multiple of octets (%u bits)\n",
+			__FUNCTION__,
+			bitlen);
+		return 1;	/* error status */
+	}
+
+#if 0	/* QQQ - DELETE */
+	hexdump(dout, bytelen);
+#endif	/* QQQ - DELETE */
+
+	if(chipsel)
+	{	/* assert SPI CS */
+		chipsel(1);
+	}
+
+	/* transfer: write bytes in 'dout', and read into 'din' */
+	for(i=0; i<bytelen; i++)
+	{
+		uchar data;
+		data = spi_xfer_one_word(dout[i]);
+		if (din != NULL) din[i] = data;
+	}
+
+	if(chipsel)
+	{	/* de-assert SPI CS */
+		chipsel(0);
+	}
+
+	return 0;	/* success */
+}
+
+
+/**********************************************************************/
+
+
+/*
+ * read the SPI slave device's "Status Register".
+ *
+ * input:   none
+ * returns: the value of the status register.
+ */
+static unsigned int spi_read_status(
+	spi_chipsel_type const chipsel)
+{
+	unsigned char data[2] = { OP_READ_STATUS, 0x00 };
+
+	/* issue the Status Register Read command */
+	spi_xfer(chipsel, sizeof(data)*8, data, data);
+
+	/* return the status byte read */
+	return data[1];
+}
+
+
+/**********************************************************************/
+
+
+/*
+ * poll the "Status Register" waiting till it is not busy.
+ *
+ * input:   none
+ * returns: none
+ */
+static void spi_wait_till_ready(
+	spi_chipsel_type const chipsel)
+{
+#if defined(CONFIG_SPI_FLASH_ATMEL)
+	while (!(spi_read_status(chipsel) & SR_READY))
+		;	/* do nothing */
+#elif defined(CONFIG_SPI_FLASH_ST) || defined(CONFIG_SPI_FLASH_MXIC)
+	while (spi_read_status(chipsel) & SR_WIP)
+		;	/* do nothing */
+#else
+#error Please specify which SPI Serial Flash is being used
+#endif	/* defined(CONFIG_STM_SPI_xxxxxx) */
+}
+
+
+/**********************************************************************/
+
+
+/*
+ * probe the serial flash on the SPI bus, to ensure
+ * it is a known type, and initialize its properties.
+ */
+static int spi_probe_serial_flash(
+	spi_chipsel_type const chipsel)
+{
+	unsigned int status;
+	unsigned char devid[8] = {
+		OP_READ_DEVID,
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, };
+
+	/* read & detect the SPI device type */
+	status = spi_read_status(chipsel);
+	if (
+		(status == 0xffu)	/* nothing talking to us ? */	||
+		( (status & CFG_STM_SPI_DEVICE_MASK) != CFG_STM_SPI_DEVICE_VAL )
+	   )
+	{
+		printf("ERROR: Unknown SPI Device detected, status = 0x%02x\n",
+			status);
+		return -1;
+	}
+
+	/*
+	 * if we get here, then we think we may have a SPI
+	 * device, so now check it is the correct one!
+	 */
+	spi_xfer(chipsel, sizeof(devid)*8, devid, devid);
+
+#if defined(CONFIG_SPI_FLASH_ATMEL)
+
+	/* extract the page size */
+	if (
+		(devid[1] != 0x1fu)	||	/* Manufacturer ID */
+		(devid[2] != 0x27u)	||	/* Memory Type */
+		(devid[3] != 0x01u)		/* Code + Version */
+	   )
+	{
+		printf("ERROR: Unknown SPI Device detected, devid = 0x%02x, 0x%02x, 0x%02x\n",
+			devid[1], devid[2], devid[3]);
+		return -1;
+	}
+	pageSize = (status & 1u) ? 512u : 528u;
+	eraseSize = pageSize;
+	deviceSize = 8192u * pageSize;		/* 32 Mbit == 4 MiB */
+	deviceName = "Atmel AT45DB321D";
+
+#elif defined(CONFIG_SPI_FLASH_ST)
+
+	if (
+		!((devid[1] == 0xefu) || (devid[1] == 0x20u))	||	/* Manufacturer ID */
+		!((devid[2] == 0x40u) || (devid[2] == 0x20u))	||	/* Memory Type */
+		(				/* Memory Capacity */
+			(devid[3] != 0x14u) &&	/* M25P80 */
+			(devid[3] != 0x15u) &&	/* M25P16 */
+			(devid[3] != 0x16u) &&	/* M25P32 */
+			(devid[3] != 0x17u) &&	/* M25P64 */
+			(devid[3] != 0x18u)	/* M25P128 */
+		)
+	   )
+	{
+		printf("ERROR: Unknown SPI Device detected, devid = 0x%02x, 0x%02x, 0x%02x\n",
+			devid[1], devid[2], devid[3]);
+		return -1;
+	}
+	pageSize   = 256u;
+	eraseSize  = 4u<<10;			/* 4 KiB, 16 pages/sector */
+	deviceSize = 1u<<devid[3];		/* Memory Capacity */
+	if (devid[3] == 0x14u)
+	{
+		deviceName = "ST M25P80";	/* 8 Mbit == 1 MiB */
+	}
+	else if (devid[3] == 0x15u)
+	{
+		deviceName = "ST M25P16";	/* 16 Mbit == 2 MiB */
+	}
+	else if (devid[3] == 0x16u)
+	{
+		deviceName = "ST M25P32";	/* 32 Mbit == 4 MiB */
+	}
+	else if (devid[3] == 0x17u)
+	{
+		deviceName = "ST M25P64";	/* 64 Mbit == 8 MiB */
+	}
+	else if (devid[3] == 0x18u)
+	{
+		deviceName = "ST M25P128";	/* 128 Mbit == 16 MiB */
+		eraseSize = 256u<<10;		/* 256 KiB, 1024 pages/sector */
+	}
+
+#elif defined(CONFIG_SPI_FLASH_MXIC)
+
+	if (
+		(devid[1] != 0xc2u)	||	/* Manufacturer ID */
+		(devid[2] != 0x26u)	||	/* Memory Type */
+		(				/* Memory Capacity */
+			(devid[3] != 0x15u) &&	/* MX25L1655D */
+			(devid[3] != 0x17u) &&	/* MX25L6455E */
+			(devid[3] != 0x18u)	/* MX25L12855E */
+		)
+	   )
+	{
+		printf("ERROR: Unknown SPI Device detected, devid = 0x%02x, 0x%02x, 0x%02x\n",
+			devid[1], devid[2], devid[3]);
+		return -1;
+	}
+	pageSize   = 256u;
+	eraseSize  = 4u<<10;			/* 4 KiB, 16 pages/sector */
+	deviceSize = 1u<<devid[3];		/* Memory Capacity */
+	if (devid[3] == 0x15u)
+	{
+		deviceName = "MXIC MX25L1655D";	/* 16 Mbit == 2 MiB */
+	}
+	else if (devid[3] == 0x17u)
+	{
+		deviceName = "MXIC MX25L6455E";	/* 64 Mbit == 8 MiB */
+	}
+	else if (devid[3] == 0x18u)
+	{
+		deviceName = "MXIC MX25L12855E";/* 128 Mbit == 16 MiB */
+	}
+
+#else
+#error Please specify which SPI Serial Flash is being used
+#endif	/* defined(CONFIG_STM_SPI_xxxxxx) */
+
+#if 1
+	/* tell them what we found */
+	printf("SPI: %s (%uMiB) device (page=%u,erase=%u)\n",
+		deviceName,
+		deviceSize >> 20,	/* in MiB */
+		pageSize,		/* in bytes */
+		eraseSize);		/* in bytes */
+#endif
+
+#if defined(CONFIG_SPI_FLASH_ST) || defined(CONFIG_SPI_FLASH_MXIC)
+	/* is the device in a write protected mode ? */
+	if (status & SR_BP_MASK)	/* BPx != 0 ? */
+	{
+		printf( "warning: "
+			"SPI device may be write-protected (status=0x%02x)\n",
+			status);
+#if 0	/* do we want to un-lock it, if we can ? */
+{
+	unsigned char enable[1] = { OP_WREN };
+	unsigned char unlock[2] = { OP_WRITE_STATUS, 0x00 };
+
+	/* let the user know we are trying to un-lock it */
+	printf("info: unlocking SPI ...\n");
+
+	/* issue a WRITE ENABLE (WREN) command */
+	spi_xfer(chipsel, sizeof(enable)*8, enable, NULL);
+
+	/* issue a WRITE Status Register (WRSR) command */
+	spi_xfer(chipsel, sizeof(unlock)*8, unlock, NULL);
+
+	/* give it some time to clear the non-volatile flags */
+	udelay(2 * 1000);	/* 2 ms */
+
+	/* re-read (and display) the updated status register */
+	status = spi_read_status(chipsel);
+	if (status & SR_BP_MASK)	/* BPx != 0 ? */
+	{	/* we MAY have succeeded, but we needed a longer delay! */
+		printf("warning:            ... FAILED! (status=0x%02x)\n",
+			status);
+	}
+	else
+	{	/* the delay was long enough, and we succeeded. */
+		printf("info:               ... succeeded.\n");
+	}
+}
+#endif	/* unlock it */
+	}
+#endif	/* CONFIG_SPI_FLASH_ST || CONFIG_SPI_FLASH_MXIC */
+
+	return 0;
+}
+
+
+/**********************************************************************/
+
+
+/*
+ * initialise the SSC to talk to the slave SPI device.
+ */
+extern void spi_init(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	spi_chipsel_type const chipsel = spi_chipsel[0];	/* SPI Device #0 */
+
+#if !defined(CONFIG_SOFT_SPI)			/* Use SSC for SPI */
+	unsigned long reg;
+	const unsigned long bits_per_word = 8;	/* one word == 8-bits */
+	const unsigned long mode = CFG_STM_SPI_MODE /* | SPI_LOOP */;
+	const unsigned long fcomms = get_peripheral_clk_rate();
+	const unsigned long hz = CFG_STM_SPI_FREQUENCY;
+	      unsigned long sscbrg = fcomms/(2*hz);
+
+#if defined(CONFIG_SH_STX5197)
+	/* configure SSC0 to use the SPI pads (not PIO1[7:6]) */
+	reg = *STX5197_HD_CONF_MON_CONFIG_CONTROL_M;
+	reg |= 1ul<<14;	/* CFG_CTRL_M.SPI_BOOTNOTCOMMS = 1 [14] */
+	*STX5197_HD_CONF_MON_CONFIG_CONTROL_M = reg;
+#endif	/* CONFIG_SH_STX5197 */
+
+#endif	/* CONFIG_SOFT_SPI */
+
+	/* de-assert SPI CS */
+	(*chipsel)(0);
+
+#if !defined(CONFIG_SOFT_SPI)			/* Use SSC for SPI */
+	/* program the SSC's Baud-Rate Generator */
+	if ((sscbrg < 0x07u) || (sscbrg > (0x1u << 16)))
+	{
+		printf("ERROR: Unable to set SSC buad-rate generator to 0x%04x\n",
+			sscbrg);
+		return;
+	}
+	/* TODO: program pre-scaler for slower baud rates */
+	if (sscbrg == (0x1 << 16)) /* 16-bit counter wraps */
+	{
+		sscbrg = 0x0;	/* slowest possible clock frequency */
+	}
+	ssc_write(SSC_BRG,sscbrg);
+#if 0	/* QQQ */
+	printf("info: fcomms=%uMHz, SPI=%uHz, brg=0x%04x\n",
+		fcomms/1000/1000, hz, sscbrg);
+#endif
+
+	/* Disable I2C sub-system */
+	ssc_write( SSC_I2C, 0x0);
+
+	/* Perform a S/W reset the SSC */
+	reg = ssc_read( SSC_CON);
+	reg |= SSC_CON_SR;		/* enable software reset */
+	ssc_write( SSC_CON, reg);
+	udelay(1);			/* let reset propagate */
+	reg = ssc_read( SSC_CON);
+	reg &= ~SSC_CON_SR;		/* disable software reset */
+	ssc_write( SSC_CON, reg);
+
+	/* Configure & enable the SSC's control register */
+	reg = ssc_read(SSC_CON);
+	reg |= SSC_CON_EN;		/* Enable the SSC */
+	reg |= SSC_CON_MS;		/* set SSC as the SPI master */
+	if (mode & SPI_CPOL)
+		reg |= SSC_CON_PO;	/* Clock idles at logic 1 */
+	else
+		reg &= ~SSC_CON_PO;	/* Clock idles at logic 0 */
+	if (mode & SPI_CPHA)
+		reg |= SSC_CON_PH;	/* Pulse in first half-cycle */
+	else
+		reg &= ~SSC_CON_PH;	/* Pulse in second half-cycle */
+	if (mode & SPI_LSB_FIRST)
+		reg &= ~SSC_CON_HB;	/* LSB first */
+	else
+		reg |= SSC_CON_HB;	/* MSB first */
+	if (mode & SPI_LOOP)
+		reg |= SSC_CON_LPB;	/* put SSC in loop-back mode */
+	else
+		reg &= ~SSC_CON_LPB;	/* remove SSC from loop-back mode */
+	reg &= ~0x0ful;			/* set bit width */
+	reg |= (bits_per_word - 1ul);	/* set bit width */
+	ssc_write(SSC_CON,reg);
+
+	/* clear the status register */
+	(void)ssc_read(SSC_RBUF);
+#endif	/* CONFIG_SOFT_SPI */
+
+	/* now probe the serial flash, to ensure it is the correct one */
+	spi_probe_serial_flash(chipsel);
+}
+
+
+/**********************************************************************/
+
+
+extern void spi_init_f (void) { }
+extern void spi_init_r (void) { }
+
+
+/**********************************************************************/
+
+
+static unsigned long get_binary_offset(const uchar * addr, int alen)
+{
+	unsigned long offset = 0;
+
+	for(;alen>0;--alen)
+	{
+		offset <<= 8;
+		offset |= *addr++;
+	}
+
+	return offset;
+}
+
+
+/**********************************************************************/
+
+
+static unsigned long get_dataflash_offset(const unsigned long addr)
+{
+	unsigned long offset;
+
+	/* optionally map a 'binary' address to a 'dataflash' address */
+	if (pageSize == 528u)
+	{	/* one page is 528 (0x210) bytes */
+		const unsigned long page = addr / pageSize;
+		const unsigned long byte = addr % pageSize;
+		offset = (page << 10) | (byte);
+	}
+	else
+	{	/* no special mapping needed */
+		offset = addr;
+	}
+
+	return offset;
+}
+
+
+/**********************************************************************/
+
+
+extern ssize_t spi_read (
+	uchar * const addr,
+	const int alen,
+	uchar * const buffer,
+	const int len)
+{
+	int i;
+	const unsigned long start = get_binary_offset(addr,alen);
+	const unsigned long offset = get_dataflash_offset(start);
+	const unsigned long last   = start + len - 1ul;
+	spi_chipsel_type const chipsel = spi_chipsel[0];	/* SPI Device #0 */
+
+	if (len < 1) return len;
+	if (last >= deviceSize)	/* Out of range ? */
+	{
+		printf("ERROR: Offset out of range (max=0x%lx)\n",
+			deviceSize-1ul);
+		return 0;
+	}
+
+	/* assert SPI CS */
+	(*chipsel)(1);
+
+	/* issue appropriate READ array command */
+	spi_xfer_one_word(OP_READ_ARRAY);
+
+	/* write the 24-bit address to start reading from */
+	spi_xfer_one_word( (offset>>16) & 0xffu );
+	spi_xfer_one_word( (offset>>8)  & 0xffu );
+	spi_xfer_one_word( (offset>>0)  & 0xffu );
+
+#if (OP_READ_ARRAY==0xe8u)	/* Legacy command needs 4 dummy bytes */
+	spi_xfer_one_word(0x00);
+	spi_xfer_one_word(0x00);
+	spi_xfer_one_word(0x00);
+	spi_xfer_one_word(0x00);
+#elif (OP_READ_ARRAY==0x0bu)	/* High-Speed command needs 1 dummy byte */
+	spi_xfer_one_word(0x00);
+#endif
+
+	/* now read in each byte in turn, and put it in "buffer" */
+	for(i=0; i<len; i++)
+	{
+		buffer[i] = spi_xfer_one_word(0x00);
+	}
+
+	/* de-assert SPI CS */
+	(*chipsel)(0);
+
+	return len;
+}
+
+
+/**********************************************************************/
+
+
+static void my_spi_write(
+	spi_chipsel_type const chipsel,
+	const unsigned long address,
+	const uchar * const buffer,
+	unsigned long len)
+#if defined(CONFIG_SPI_FLASH_ATMEL)
+{
+	const unsigned long offset = get_dataflash_offset(address);
+	size_t i;
+
+#if 0	/* QQQ - DELETE */
+	printf("%s():\t buffer=0x%08x, len=%-3u  0x%06x..0x%06x\n",
+		__FUNCTION__, buffer, len, address, address+len-1u);
+#endif	/* QQQ - DELETE */
+
+	if (len != pageSize)	/* partial page update ? */
+	{
+		/*
+		 * Need to read, merge, erase & write one page.
+		 * That is, we copy the whole page into one
+		 * of the serial-flash buffers, and then just over-write
+		 * with the new data to be updated (in 'buffer'). Then
+		 * we erase & write back the whole (merged) page.
+		 */
+
+		unsigned char transfer[4] = {
+			OP_PAGE_TO_BUFFER1,
+			(offset>>16) & 0xffu,
+			(offset>>8)  & 0xffu,
+			(offset>>0)  & 0xffu,
+		};
+
+		/* copy page (to be updated) in serial flash into buffer #1 */
+		spi_xfer(chipsel, sizeof(transfer)*8, transfer, NULL);
+
+		/* now wait until the transfer has completed ... */
+		spi_wait_till_ready(chipsel);
+	}
+
+	/* assert SPI CS */
+	(*chipsel)(1);
+
+	/* issue appropriate WRITE command */
+	spi_xfer_one_word(OP_WRITE_VIA_BUFFER1);
+
+	/* write the 24-bit address to start writing to */
+	spi_xfer_one_word( (offset>>16) & 0xffu );
+	spi_xfer_one_word( (offset>>8)  & 0xffu );
+	spi_xfer_one_word( (offset>>0)  & 0xffu );
+
+	/* now write in each byte in turn */
+	for(i=0; i<len; i++)
+	{
+		spi_xfer_one_word(buffer[i]);
+	}
+
+	/* de-assert SPI CS */
+	(*chipsel)(0);
+
+	/* now wait until the programming has completed ... */
+	spi_wait_till_ready(chipsel);
+}
+#elif defined(CONFIG_SPI_FLASH_ST) || defined(CONFIG_SPI_FLASH_MXIC)
+{
+	const unsigned pages       = eraseSize / pageSize;
+	const unsigned long sector = (address / eraseSize) * eraseSize;
+	unsigned long page_base;
+	size_t i;
+	unsigned page;
+	const uchar * ptr;
+#if defined(CONFIG_SPI_FLASH_ST)
+	static unsigned char buff[256<<10];	/* maximum of 256 KiB erase size */
+#elif defined(CONFIG_SPI_FLASH_MXIC)
+	static unsigned char buff[4<<10];	/* maximum of 4 KiB erase size */
+#endif
+	unsigned char enable[1] = { OP_WREN };
+	unsigned char erase[4] = {
+		OP_SE,
+		(sector>>16) & 0xffu,
+		(sector>>8)  & 0xffu,
+		(sector>>0)  & 0xffu,
+	};
+
+#if 0	/* QQQ - DELETE */
+	printf("%s():\t buffer=0x%08x, len=%-5u  0x%06x..0x%06x\n",
+		__FUNCTION__, buffer, len, address, address+len-1u);
+#endif	/* QQQ - DELETE */
+
+	if (len != eraseSize)	/* partial sector update ? */
+	{
+		/*
+		 * Need to read, merge, erase & write one sector.
+		 * That is, we copy the whole sector from
+		 * the serial-flash into RAM, and then just over-write
+		 * with the new data to be updated (in 'buffer'). Then
+		 * we erase & write back the whole (merged) sector.
+		 */
+		unsigned char addr[3] = {
+			(sector>>16) & 0xffu,
+			(sector>>8)  & 0xffu,
+			(sector>>0)  & 0xffu,
+		};
+		const unsigned long offset = address - sector;
+
+		/* read the entire extant sector's content into RAM */
+		spi_read ( addr, sizeof(addr), buff, eraseSize );
+
+		/* now merge the old with the new data */
+		for( i=0; i<len; i++)
+		{
+			buff[offset+i] = buffer[i];
+		}
+		ptr = buff;	/* use "merged" buffer */
+	}
+	else
+	{
+		ptr = buffer;	/* use original buffer */
+	}
+
+	/* issue a WRITE ENABLE (WREN) command */
+	spi_xfer(chipsel, sizeof(enable)*8, enable, NULL);
+
+	/* issue a Sector Erase command */
+	spi_xfer(chipsel, sizeof(erase)*8, erase, NULL);
+
+	/* now wait until the erase has completed ... */
+	spi_wait_till_ready(chipsel);
+
+	/* now program each page in turn ... */
+	for (page_base=sector,page=0u; page<pages; page++)
+	{
+		/* issue a WRITE ENABLE (WREN) command */
+		spi_xfer(chipsel, sizeof(enable)*8, enable, NULL);
+
+		/* assert SPI CS */
+		(*chipsel)(1);
+
+		/* issue a Page Program command */
+		spi_xfer_one_word(OP_PP);
+
+		/* write the 24-bit address to start writing to */
+		spi_xfer_one_word( (page_base>>16) & 0xffu );
+		spi_xfer_one_word( (page_base>>8)  & 0xffu );
+		spi_xfer_one_word( (page_base>>0)  & 0xffu );
+
+		/* now write in each byte in turn */
+		for(i=0; i<pageSize; i++)
+		{
+			spi_xfer_one_word(*ptr++);
+		}
+
+		/* de-assert SPI CS */
+		(*chipsel)(0);
+
+		/* now wait until the programming has completed ... */
+		spi_wait_till_ready(chipsel);
+
+		/* advance to next page */
+		page_base += pageSize;
+	}
+}
+#else
+#error Please specify which SPI Serial Flash is being used
+#endif	/* defined(CONFIG_STM_SPI_xxxxxx) */
+
+
+/**********************************************************************/
+
+
+extern ssize_t spi_write (
+	uchar * const addr,
+	const int alen,
+	uchar * buffer,
+	const int len)
+{
+	const unsigned long first  = get_binary_offset(addr,alen);
+	const unsigned long last   = first + len - 1ul;
+	const unsigned long lsector= (first + len) / eraseSize;
+	      unsigned long sector = first / eraseSize;
+	const unsigned long byte   = first % eraseSize;
+	      unsigned long ptr    = first;
+	unsigned written = 0;		/* amount written between two dots */
+	spi_chipsel_type const chipsel = spi_chipsel[0];	/* SPI Device #0 */
+
+	if (len < 1) return len;
+	if (last >= deviceSize)	/* Out of range ? */
+	{
+		printf("ERROR: Offset out of range (max=0x%lx)\n", deviceSize-1ul);
+		return 0;
+	}
+
+	/* process up to end of first erase block */
+	if (byte != 0)
+	{
+		/* till end of first erase block, or entirety, which is less */
+		const unsigned long size = MIN(len,eraseSize-byte);
+		my_spi_write(chipsel, first, buffer, size);
+
+		sector++;
+		ptr += size;
+		buffer += size;
+		written += size;
+	}
+
+	/* process each whole erase block in turn */
+	while(sector<lsector)
+	{
+		/* print a series of dots (every 16KiB) */
+		if ( (written+=eraseSize,written) >= (16u<<10) )
+		{
+			printf(".");	/* print a dot */
+			written = 0;	/* reset counter */
+		}
+
+		/* a whole erase block */
+		my_spi_write(chipsel, ptr, buffer, eraseSize);
+
+		sector++;
+		ptr += eraseSize;
+		buffer += eraseSize;
+
+	}
+	printf("\n");	/* terminate any row of printed dots */
+
+	/* finally, process any data at the tail */
+	if (ptr <= last)
+	{
+		my_spi_write(chipsel, ptr, buffer, last-ptr+1u);
+	}
+
+	return len;
+}
+
+
+/**********************************************************************/
+
+
+#endif	/* defined(CONFIG_SPI) */
+
+
diff --git a/cpu/sh/start.S b/cpu/sh/start.S
new file mode 100644
index 0000000000..7d1b13cc9b
--- /dev/null
+++ b/cpu/sh/start.S
@@ -0,0 +1,572 @@
+/*
+ * (C) Copyright 2004-2009 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include "asm/regdef.h"
+#include "asm/addrspace.h"
+#include "asm/sh4reg.h"
+#include "asm/asmdefs.h"
+#include "asm/pmb.h"
+#include "asm/socregs.h"
+
+
+	.section .text.init, "ax"
+
+	.global _start
+_start:
+
+	/* Add a few NOP instructions, to workaround the
+	 * problem reported in the following bugzilla report:
+	 * https://bugzilla.stlinux.com/show_bug.cgi?id=4173 */
+	nop
+	nop
+
+	/* Set SR:	MD=1, RB=0, BL=0, FD=0, IMASK=0xF */
+set_sr:
+	MOV_CONST32_R0 0x400000F0
+	ldc	r0, sr
+
+	/* disable the watchdog timer */
+disable_watchdog:
+	MOV_CONST32_R0 ST40_CPG_WTCSR
+	mov	r0, r1
+	MOV_CONST16_R0 0xA500	/* WTCSR.TME=0 */
+	mov.w   r0, @r1
+
+
+	/*
+	 * If were are going to boot U-boot from NAND flash, then
+	 * we need add a special "signature" pattern in the first
+	 * logical block (block zero).
+	 */
+#ifdef CFG_BOOT_FROM_NAND
+skip_signature:
+	bra	skipped_signature	/* skip over the "block 0 signature" */
+	 nop
+
+	/*
+	 * Write out the 64-byte preamble signature pattern, to identify
+	 * the current NAND flash block, as the good "logical block ZERO".
+	 * This signature must start at offset +0x0080 in the block.
+	 */
+	.balign 0x80, 0x00		/* starts 128 bytes into "Block Zero" */
+preamble_signature_pattern:
+	bytes 0x00 0x3f			/* 64-bytes: 0x00, 0x01, ..., 0x3f */
+
+#if defined(CFG_NAND_SKIP_BAD_BLOCKS_ON_RELOCATING)
+	/*
+	 *	const static struct skip_bb
+	 *	{
+	 *		char	pattern[8];
+	 *		u32	block_size;
+	 *		u32	num_blocks;
+	 *		u32	array[num_blocks];
+	 *	} skip_bb;
+	 *
+	 *	"array[]" is a set of flags, whose value is
+	 *	interpreted as:
+	 *		if array[x] == 0,
+	 *		then physical block #x is GOOD,
+	 *		else physical block #x is BAD.
+	 *	NOTE Physical Block #0 *must* always be GOOD.
+	 *
+	 *	assert( strcmp(pattern,"SKIP_BBs") == 0 );
+	 *	assert( (block_size % (16<<10)) == 0 );
+	 *	assert( sizeof(array) == num_blocks * 4 );
+	 *	assert( array[0] == 0 );
+	 *
+	 *	By default the linker will fill "array[]"
+	 *	with ZEROS (assume all blocks are GOOD).
+	 *	If is the responsibility of the configurer
+	 *	to ensure that "array[]" is big enough.
+	 *	It is the responsibility of the NAND flasher
+	 *	to fill the array appropriately.
+	 */
+skip_bb:			/* the skip_bb structure */
+skip_bb_pattern:		/* 8-byte "magic" pattern */
+	.ascii "SKIP_BBs"
+skip_bb_size:			/* size of each NAND block */
+	.long	CFG_NAND_SKIP_BLOCK_SIZE
+skip_bb_count:			/* number of bad-block entries in array */
+	.long	CFG_NAND_SKIP_BLOCK_COUNT
+skip_bb_array:			/* the array itself (0==GOOD) */
+	.fill CFG_NAND_SKIP_BLOCK_COUNT, 4, 0
+#endif	/* CFG_NAND_SKIP_BAD_BLOCKS_ON_RELOCATING */
+
+skipped_signature:
+					/* resume from here */
+#endif	/* CFG_BOOT_FROM_NAND */
+
+
+	/*
+	 * If were are going to boot U-boot from SPI (serial flash),
+	 * then the following pokes are required/recommended to be
+	 * done early, when using the EMI's SPIBOOT mode controller.
+	 */
+#if defined(CFG_BOOT_FROM_SPI)
+config_spiboot_controller:
+	MOV_CONST32_R0 ST40_EMI_SPI_REGS_BASE
+	mov	r0, r1
+
+	MOV_CONST32_R0 0x00020011	/* *ST40_EMI_SPI_CONFIGDATA = 0x00020010|ST */
+	mov.l	r0, @(ST40_EMI_SPI_CONFIGDATA-ST40_EMI_SPI_REGS_BASE,r1)
+
+#if 1
+	/* For serial flash we use FAST_READ */
+	mov	#2, r0			/* *ST40_EMI_SPI_MODESELECT = FAST_READ */
+#else
+	mov	#3, r0			/* *ST40_EMI_SPI_MODESELECT = CONTIG_MODE|FAST_READ */
+#endif
+	mov.l	r0, @(ST40_EMI_SPI_MODESELECT-ST40_EMI_SPI_REGS_BASE,r1)
+
+	/* Slow (divide) the SPI clock down to improve reliability. */
+	mov	#4, r0			/* *ST40_EMI_SPI_CLOCKDIV = 4 */
+	mov.l	r0, @(ST40_EMI_SPI_CLOCKDIV-ST40_EMI_SPI_REGS_BASE,r1)
+
+#endif	/* CFG_BOOT_FROM_SPI */
+
+
+	/*
+	 * Determine if we are in the correct location ? (i.e. RAM)
+	 *  r8 == 1 in RAM, assume initialization already done by GDB.
+	 *  r8 == 0 in FLASH, need to relocate, set up memory, etc...
+	 *  r9 == where we actually ARE      (PIC relocate source).
+	 * r10 == were we WANT to be [BEGIN] (PIC relocate target).
+	 * r11 == were we WANT to be [END]   (PIC relocate target).
+	 *
+	 * NOTE: when CONFIG_SH_SE_MODE is defined, then also:
+	 *  r8 == 1 assume we are already in 32-bit SE mode (done by GDB).
+	 *  r8 == 0 we are in 29-bit mode, and need to switch to 32-bit mode.
+	 */
+which_location:
+	MOV_CONST32_R0 0x1fffffff	/* set up P0 mask  */
+	mov	r0, r4
+	mova	_start_offset, r0	/* Load source address in r9 */
+	mov	r0, r9			/* i.e. where we actually ARE */
+	mov.l	@r9, r10
+	sub	r10, r9
+#ifndef CONFIG_SH_SE_MODE
+	and	r4, r9			/* make sure its P0 (cached) */
+#endif	/* CONFIG_SH_SE_MODE */
+	mov.l	target_addr, r10	/* Load target address in r10 */
+					/* i.e. were we WANT to be */
+#ifndef CONFIG_SH_SE_MODE
+	and	r4, r10			/* make sure its P0 (cached) */
+#endif	/* CONFIG_SH_SE_MODE */
+	mov.l	bss_start, r11		/* load target END address in r11 */
+#ifndef CONFIG_SH_SE_MODE
+	and	r4, r11			/* make sure its P0 (cached) */
+#endif	/* CONFIG_SH_SE_MODE */
+	cmp/eq	r9, r10			/* Are we in correct place already ? */
+	movt	r8			/* save SR.T in r8. */
+#ifdef CONFIG_SH_SE_MODE
+	and	r4, r9			/* make sure its P0 (cached) */
+#endif	/* CONFIG_SH_SE_MODE */
+
+	/* set up the PMB entries we want to use */
+#ifdef CONFIG_SH_SE_MODE
+	/*
+	 * explicitly invalidate all unused entries
+	 * NOTE: for running from RAM, then keep PMB[0] as is.
+	 */
+invalidate_pmb:
+	MOV_CONST32_R0 (P4SEG_PMB_ADDR)
+	mov	r0, r1
+	mov	#0, r2			/* PMB[n].V = 0, i.e. INVALID */
+	mov	#1, r3
+	shll8	r3			/* R3 = address stride is 0x100 */
+	mov	#1, r0			/* R0 = counter (indexes: 1..15) */
+1:	add	r3, r1			/* next index pointer */
+	mov.l	r2, @r1			/* invalidate current entry */
+	cmp/eq	#15, r0			/* finished ? */
+	bf/s	1b			/* more to do ? */
+	  add	#1, r0			/* next index counter */
+
+	/* set up the new PMB entries we want to use */
+set_pmb:
+#if defined(CONFIG_SH_STB7100)
+	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI-Sys UN-cached */
+	SH4_SET_PMB 2 0x90 0x40 128 0 0 1	/* LMI-Sys UN-cached */
+	#if CFG_SH_LMI_NEEDS_2_PMB_ENTRIES
+	#error Need to configure PMBs properly when more than 128MiB.
+	#endif
+	SH4_SET_PMB 4 0xa0 0x00  16 0 0 1	/* NOR FLASH UN-cached */
+	SH4_SET_PMB 5 0xa8 0x00  16		/* NOR FLASH CACHED */
+	SH4_SET_PMB 6 0xb2 0x02  16 0 0 1	/* OFF-chip  Peripherals UN-cached */
+	SH4_SET_PMB 7 0xb8 0x18  64 0 0 1	/* ON-chip   Peripherals UN-cached */
+	SH4_SET_PMB 8 0xbc 0x1c  64 0 0 1	/* ST40 core Peripherals UN-cached */
+#elif defined(CONFIG_SH_STX5197) && defined(CONFIG_SH_MB704)
+	SH4_SET_PMB 0 0x80 0x40  64 0 0 1	/* LMI-Sys UN-cached */
+	SH4_SET_PMB 2 0x90 0x40  64 0 0 1	/* LMI-Sys UN-cached */
+	SH4_SET_PMB 4 0xa0 0x00 128 0 0 1	/* SPI Flash (in SPIBOOT mode) UN-cached */
+#elif defined(CONFIG_SH_STX5197) && defined(CONFIG_SH_5197CAB)
+	SH4_SET_PMB 0 0x80 0x40  64 0 0 1	/* LMI-Sys UN-cached */
+	SH4_SET_PMB 2 0x90 0x40  64 0 0 1	/* LMI-Sys UN-cached */
+	SH4_SET_PMB 4 0xa0 0x00 128 0 0 1	/* SPI Flash (in SPIBOOT mode) UN-cached */
+#elif defined(CONFIG_SH_STX7105) && defined(CONFIG_SH_MB680)
+	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI0 (first-half)  UN-cached */
+	SH4_SET_PMB 2 0x90 0x40 128 0 0 1	/* LMI0 (first-half)  UN-cached */
+	#if CFG_SH_LMI_NEEDS_2_PMB_ENTRIES
+	SH4_SET_PMB 1 0x88 0x48 128 0 0 1	/* LMI0 (second-half) UN-cached */
+	SH4_SET_PMB 3 0x98 0x48 128 0 0 1	/* LMI0 (second-half) UN-cached */
+	#endif
+	#ifdef CFG_BOOT_FROM_NAND /* booting from NAND, so CSA and CSB swapped in EPLD */
+	SH4_SET_PMB 4 0xa0 0x00  16 0 0 1	/* NAND FLASH UN-cached */
+	SH4_SET_PMB 5 0xa4 0x04  16 0 0 1	/* NOR FLASH UN-cached */
+	SH4_SET_PMB 6 0xa5 0x05  16 0 0 1	/* NOR FLASH UN-cached */
+	SH4_SET_PMB 7 0xa8 0x04  16		/* NOR FLASH CACHED */
+	SH4_SET_PMB 8 0xa9 0x05  16		/* NOR FLASH CACHED */
+	#else	/* else, CSA and CSB are not swapped in EPLD */
+	SH4_SET_PMB 4 0xa0 0x00  16 0 0 1	/* NOR FLASH UN-cached */
+	SH4_SET_PMB 5 0xa1 0x01  16 0 0 1	/* NOR FLASH UN-cached */
+	SH4_SET_PMB 6 0xa4 0x04  16 0 0 1	/* NAND FLASH UN-cached */
+	SH4_SET_PMB 7 0xa8 0x00  16		/* NOR FLASH CACHED */
+	SH4_SET_PMB 8 0xa9 0x01  16		/* NOR FLASH CACHED */
+	#endif	/* CFG_BOOT_FROM_NAND */
+	SH4_SET_PMB 9 0xb7 0x07  16 0 0 1	/* EPLD UN-cached */
+#elif defined(CONFIG_SH_STX7105) && defined(CONFIG_SH_PDK7105)
+	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI0 (first-half)  UN-cached */
+	SH4_SET_PMB 2 0x90 0x40 128 0 0 1	/* LMI0 (first-half)  UN-cached */
+	#if CFG_SH_LMI_NEEDS_2_PMB_ENTRIES
+	SH4_SET_PMB 1 0x88 0x48 128 0 0 1	/* LMI0 (second-half) UN-cached */
+	SH4_SET_PMB 3 0x98 0x48 128 0 0 1	/* LMI0 (second-half) UN-cached */
+	#endif
+	SH4_SET_PMB  4 0xa0 0x00  64 0 0 1	/* NOR FLASH UN-cached */
+	SH4_SET_PMB  5 0xa4 0x04  16 0 0 1	/* NOR FLASH UN-cached */
+	SH4_SET_PMB  6 0xa5 0x05  16 0 0 1	/* NOR FLASH UN-cached */
+	SH4_SET_PMB  7 0xa6 0x06  16 0 0 1	/* NAND + CI UN-cached */
+	SH4_SET_PMB  8 0xa7 0x07  16 0 0 1	/* PCI UN-cached */
+	SH4_SET_PMB  9 0xa8 0x00  64		/* NOR FLASH CACHED */
+	SH4_SET_PMB 10 0xac 0x04  16		/* NOR FLASH CACHED */
+	SH4_SET_PMB 11 0xad 0x05  16		/* NOR FLASH CACHED */
+	SH4_SET_PMB 12 0xae 0x06  16		/* NAND + CI CACHED */
+	SH4_SET_PMB 13 0xaf 0x07  16		/* PCI CACHED */
+#elif defined(CONFIG_SH_STX7105) && defined(CONFIG_SH_IPIDTV7105)
+	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI0 (first-half)  UN-cached */
+	SH4_SET_PMB 2 0x90 0x40 128 0 0 1	/* LMI0 (first-half)  UN-cached */
+	#if CFG_SH_LMI_NEEDS_2_PMB_ENTRIES
+	SH4_SET_PMB 1 0x88 0x48 128 0 0 1	/* LMI0 (second-half) UN-cached */
+	SH4_SET_PMB 3 0x98 0x48 128 0 0 1	/* LMI0 (second-half) UN-cached */
+	#endif
+#elif defined(CONFIG_SH_STX7111) && defined(CONFIG_SH_MB618)
+	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI UN-cached */
+	SH4_SET_PMB 2 0x90 0x40 128 0 0 1	/* LMI UN-cached */
+	#if CFG_SH_LMI_NEEDS_2_PMB_ENTRIES
+	#error Need to configure PMBs properly when more than 128MiB.
+	#endif
+	SH4_SET_PMB 4 0xa0 0x00  16 0 0 1	/* NOR/NAND FLASH UN-cached */
+	SH4_SET_PMB 5 0xa1 0x01  16 0 0 1	/* NOR/NAND FLASH UN-cached */
+	SH4_SET_PMB 6 0xa8 0x00  16		/* NOR/NAND FLASH CACHED */
+	SH4_SET_PMB 7 0xa9 0x01  16		/* NOR/NAND FLASH CACHED */
+#ifndef CONFIG_SH_NO_EPLD
+	SH4_SET_PMB 8 0xb6 0x06  16 0 0 1	/* EPLD UN-cached */
+#endif	/* CONFIG_SH_NO_EPLD */
+#elif defined(CONFIG_SH_STX7111) && defined(CONFIG_SH_HDK7111)
+	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI UN-cached */
+	SH4_SET_PMB 2 0x90 0x40 128 0 0 1	/* LMI UN-cached */
+	#if CFG_SH_LMI_NEEDS_2_PMB_ENTRIES
+	SH4_SET_PMB 1 0x88 0x48 128 0 0 1	/* LMI0 (second-half) UN-cached */
+	SH4_SET_PMB 3 0x98 0x48 128 0 0 1	/* LMI0 (second-half) UN-cached */
+	#endif
+	SH4_SET_PMB 4 0xa0 0x00  64 0 0 1	/* NOR/NAND/SPI FLASH UN-cached */
+	SH4_SET_PMB 5 0xa8 0x00  64		/* NOR/NAND/SPI FLASH CACHED */
+	SH4_SET_PMB 6 0xa4 0x04  16 0 0 1	/* NOR/NAND     FLASH UN-cached */
+	SH4_SET_PMB 7 0xa5 0x05  16 0 0 1	/* NOR/NAND     FLASH UN-cached */
+	SH4_SET_PMB 8 0xac 0x04  16		/* NOR/NAND     FLASH CACHED */
+	SH4_SET_PMB 9 0xad 0x05  16		/* NOR/NAND     FLASH CACHED */
+#elif defined(CONFIG_SH_STX7141) && defined(CONFIG_SH_MB628)
+	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI UN-cached */
+	SH4_SET_PMB 2 0x90 0x40 128 0 0 1	/* LMI UN-cached */
+	#if CFG_SH_LMI_NEEDS_2_PMB_ENTRIES
+	#error Need to configure PMBs properly when more than 128MiB.
+	#endif
+	SH4_SET_PMB 4 0xa0 0x00  16 0 0 1	/* NOR/NAND FLASH UN-cached */
+	SH4_SET_PMB 5 0xa1 0x01  16 0 0 1	/* NOR/NAND FLASH UN-cached */
+	SH4_SET_PMB 6 0xa8 0x00  16		/* NOR/NAND FLASH CACHED */
+	SH4_SET_PMB 7 0xa9 0x01  16		/* NOR/NAND FLASH CACHED */
+	SH4_SET_PMB 8 0xb5 0x05  16 0 0 1	/* EPLD UN-cached */
+#elif defined(CONFIG_SH_STX7200) && defined(CONFIG_SH_MB519)
+	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI0 UN-cached */
+	SH4_SET_PMB 2 0x90 0x40 128 0 0 1	/* LMI0 UN-cached */
+	#if CFG_SH_LMI_NEEDS_2_PMB_ENTRIES
+	#error Need to configure PMBs properly when more than 128MiB.
+	#endif
+	SH4_SET_PMB 4 0xa0 0x00  16 0 0 1	/* NOR FLASH UN-cached */
+	SH4_SET_PMB 5 0xa1 0x01  16 0 0 1	/* NOR FLASH UN-cached */
+	SH4_SET_PMB 6 0xa8 0x00  16		/* NOR FLASH CACHED */
+	SH4_SET_PMB 7 0xa9 0x01  16		/* NOR FLASH CACHED */
+	SH4_SET_PMB 8 0xb5 0x05  16 0 0 1	/* EPLD UN-cached */
+#elif defined(CONFIG_SH_STX7200) && defined(CONFIG_SH_CB101)
+	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI0 UN-cached */
+	SH4_SET_PMB 2 0x90 0x40 128 0 0 1	/* LMI0 UN-cached */
+	#if CFG_SH_LMI_NEEDS_2_PMB_ENTRIES
+	#error Need to configure PMBs properly when more than 128MiB.
+	#endif
+	SH4_SET_PMB 4 0xa0 0x00  16 0 0 1	/* NOR FLASH UN-cached */
+	SH4_SET_PMB 5 0xa1 0x01  16 0 0 1	/* NOR FLASH UN-cached */
+	SH4_SET_PMB 6 0xa8 0x00  16		/* NOR FLASH CACHED */
+	SH4_SET_PMB 7 0xa9 0x01  16		/* NOR FLASH CACHED */
+	SH4_SET_PMB 8 0xa2 0x02  16 0 0 1	/* NAND FLASH UN-cached */
+	SH4_SET_PMB 9 0xa3 0x03  16 0 0 1	/* NAND FLASH UN-cached */
+#elif defined(CONFIG_SH_STX7200) && defined(CONFIG_SH_MB671)
+	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI0 (first-half)  UN-cached */
+	SH4_SET_PMB 2 0x90 0x40 128 0 0 1	/* LMI0 (first-half)  UN-cached */
+	#if CFG_SH_LMI_NEEDS_2_PMB_ENTRIES
+	SH4_SET_PMB 1 0x88 0x48 128 0 0 1	/* LMI0 (second-half) UN-cached */
+	SH4_SET_PMB 3 0x98 0x48 128 0 0 1	/* LMI0 (second-half) UN-cached */
+	#endif
+	SH4_SET_PMB 4 0xa0 0x00  16 0 0 1	/* NOR FLASH UN-cached */
+	SH4_SET_PMB 5 0xa1 0x01  16 0 0 1	/* NOR FLASH UN-cached */
+	SH4_SET_PMB 6 0xa8 0x00  16		/* NOR FLASH CACHED */
+	SH4_SET_PMB 7 0xa9 0x01  16		/* NOR FLASH CACHED */
+	SH4_SET_PMB 8 0xb5 0x05  16 0 0 1	/* EPLD UN-cached */
+#elif defined(CONFIG_SH_STX7200) && defined(CONFIG_SH_CB102)
+	SH4_SET_PMB 0 0x80 0x40 128 0 0 1	/* LMI0 (first-half)  UN-cached */
+	SH4_SET_PMB 2 0x90 0x40 128 0 0 1	/* LMI0 (first-half)  UN-cached */
+	#if CFG_SH_LMI_NEEDS_2_PMB_ENTRIES
+	SH4_SET_PMB 1 0x88 0x48 128 0 0 1	/* LMI0 (second-half) UN-cached */
+	SH4_SET_PMB 3 0x98 0x48 128 0 0 1	/* LMI0 (second-half) UN-cached */
+	#endif
+	SH4_SET_PMB 4 0xa0 0x00  16 0 0 1	/* NOR FLASH UN-cached */
+	SH4_SET_PMB 5 0xa1 0x01  16 0 0 1	/* NOR FLASH UN-cached */
+	SH4_SET_PMB 6 0xa8 0x00  16		/* NOR FLASH CACHED */
+	SH4_SET_PMB 7 0xa9 0x01  16		/* NOR FLASH CACHED */
+#else
+	#error Do not know which board/chip we are using for PMB setup.
+#endif	/* defined(CONFIG_SH_STB7100) */
+#endif	/* CONFIG_SH_SE_MODE */
+
+concider_hyperspace:
+	cmp/pl	r8			/* Are we in correct place already ? */
+	bt	hyperspace
+
+	/* disable the caches */
+do_disable_caches:
+	mov	#-1, a0		/* clear all bits in the CCR */
+	CALL	sh_cache_clear_op_offset
+
+	/* invalidate+enable the caches: both I$ & D$ (with copy-back) */
+do_enable_caches:
+	MOV_CONST16_R0 (SH4_CCR_OCI|SH4_CCR_ICI|SH4_CCR_ICE|SH4_CCR_OCE|SH4_CCR_CB|SH4_CCR_EMODE)
+	mov	r0, a0
+	CALL	sh_cache_set_op_offset
+
+	/*
+	 * switch to P0 region (cachable), if we need to.
+	 * Recall, we are still in 29-bit mode at this juncture.
+	 */
+enter_p0:
+	ENTER_P0
+
+	/*
+	 * initialize the memory controllers, if we need to.
+	 */
+do_init_ram:
+	CALL	init_ram_offset		/* init_ram() */
+
+	/*
+	 * enable SE (32-bit) mode, if we need to.
+	 */
+#ifdef CONFIG_SH_SE_MODE
+enable_se_mode:
+#ifdef CONFIG_CPU_SUBTYPE_SH4_2XX	/* it is an SH4-200 */
+	/* enable SE mode & invalidate the UTLB/ITLB */
+	MOV_CONST32_R0 SH4_CCN_MMUCR
+	mov	#(SH4_MMUCR_TI|SH4_MMUCR_SE), r1
+	mov.l	r1, @r0			/* MMUCR.TI = MMUCR.SE = 1 */
+#else					/* it is an SH4-300 */
+	/* invalidate the UTLB/ITLB, first. */
+	MOV_CONST32_R0 SH4_CCN_MMUCR
+	mov	#(SH4_MMUCR_TI), r1
+	mov.l	r1, @r0			/* MMUCR.TI = 1 */
+	/* then, enable SE mode */
+	MOV_CONST32_R0 SH4_PASCR_SE
+	mov	r0, r1
+	MOV_CONST32_R0 SH4_CCN_PASCR
+	mov.l	r1, @r0			/* PASCR.SE = 1 */
+#endif	/* CONFIG_CPU_SUBTYPE_SH4_2XX */
+	/* ensure MMU coherency, by issuing an RTE instruction */
+	/* this idiom works for all SH4-x00 series cores */
+	mova	relocate, r0
+	ldc	r0, spc		/* SPC = address of relocate */
+	stc	sr, r0
+	ldc	r0, ssr		/* SSR = SR */
+	rte			/* do it */
+	  nop
+.balign 4
+#endif	/* CONFIG_SH_SE_MODE */
+
+
+	/*
+	 * now relocate "u-boot.bin" (from FLASH to RAM):
+	 *	r0 == scratch/temp
+	 *	r1 == source address (SRC)
+	 *	r2 == destination address (DST)
+	 *	r3 == destination END address
+	 *	r4 == &skip_bb.array[x] (x=block number: 0,1,2,...)
+	 *	r5 == skip_bb.block_size	(CFG_NAND_SKIP_BLOCK_SIZE)
+	 *	r6 == skip_bb.block_size - 1	(block mask)
+	 *
+	 *	NOTE:	r4, r5 & r6 are only used if the the macro
+	 *		CFG_NAND_SKIP_BAD_BLOCKS_ON_RELOCATING is defined.
+	 *
+	 *	QQQ: in 32-bit mode, "DST" is UN-cached - should optimize this.
+	 */
+relocate:
+	mov	#0x1f, r0
+	not	r0, r0			/* mask = 0xffffffe0 */
+	mov	r9, r1			/* where we actually ARE */
+	and	r0, r1			/* ensure source is 32-byte cache aligned */
+	mov	r10, r2			/* were we WANT to be: START off */
+	and	r0, r2			/* ensure destination is 32-byte cache aligned */
+	mov	r11, r3			/* were we WANT to be: END off */
+#if defined(CFG_BOOT_FROM_NAND) && defined(CFG_NAND_SKIP_BAD_BLOCKS_ON_RELOCATING)
+	mov.l	skip_bb_offset, r4	/* r4 = &skip_bb - _start */
+	add	r9, r4			/* r4 = &skip_bb (P0 (cached)) */
+	mov.l	@(8,r4), r5		/* r5 = NAND block_size */
+	mov	r5, r6
+	add	#-1, r6			/* r6 = block_size - 1 (i.e. mask) */
+	add	#16, r4			/* r4 = &array[0]  */
+#endif	/* CFG_BOOT_FROM_NAND && CFG_NAND_SKIP_BAD_BLOCKS_ON_RELOCATING */
+1:	mov.l	@(0,r1), r0		/* read & write a cache line at a time */
+	mov.l	r0, @(0,r2)
+	mov.l	@(4,r1), r0
+	mov.l	r0, @(4,r2)
+	mov.l	@(8,r1), r0
+	mov.l	r0, @(8,r2)
+	mov.l	@(12,r1), r0
+	mov.l	r0, @(12,r2)
+	mov.l	@(16,r1), r0
+	mov.l	r0, @(16,r2)
+	mov.l	@(20,r1), r0
+	mov.l	r0, @(20,r2)
+	mov.l	@(24,r1), r0
+	mov.l	r0, @(24,r2)
+	mov.l	@(28,r1), r0
+	mov.l	r0, @(28,r2)
+	ocbp	@r2			/* flush one line */
+	add	#32, r1			/* next source line */
+#if defined(CFG_BOOT_FROM_NAND) && defined(CFG_NAND_SKIP_BAD_BLOCKS_ON_RELOCATING)
+	mov	r1, r0			/* test for a new block */
+	and	r6, r0			/* r0 = SRC & (block_size - 1) */
+	cmp/eq	#0, r0			/* is it a new block ? */
+	bf	do_next_line		/* branch if it is the same block */
+do_next_block:				/* okay, we are on a new NAND block */
+	add	#4, r4
+	mov.l	@r4, r0			/* r0 = array[++x] */
+	cmp/eq	#0, r0			/* is it a GOOD block ? */
+	bt	do_next_line		/* branch if it is a GOOD block */
+					/* okay, we have a BAD block, try NEXT */
+	bra	do_next_block		/* check it is good as well! */
+	  add	r5, r1			/* SRC += block_size */
+do_next_line:
+#endif	/* CFG_BOOT_FROM_NAND && CFG_NAND_SKIP_BAD_BLOCKS_ON_RELOCATING */
+	pref	@r1			/* pre-fetch next line */
+	add	#32, r2			/* next line */
+	cmp/hi	r2, r3			/* while (r2<=r3) ... */
+	bt	1b
+
+
+	/*
+	 * now jump to absolute (non-PIC) address environment.
+	 */
+do_hyperspace:
+	mov.l	hyperspace_addr, r1
+	jmp	@r1		/* never returns */
+	  nop
+
+hyperspace:
+
+	/*
+	 * At this point:
+	 *	We can stop using PIC, and use absolute code.
+	 *	The EMI/LMI initialization has been completed.
+	 */
+
+#ifdef CONFIG_SH_SE_MODE
+do_enable_pmb_cache:
+	/* Enable the cacheability for PMB array #0 */
+	CALL sh_toggle_pmb_cacheability_offset
+#endif	/* CONFIG_SH_SE_MODE */
+
+	/* init stack pointer */
+init_sp:
+	mov.l	stack_addr, sp
+
+	/* Clear the bss */
+clear_bss:
+	mov.l	bss_start, r1
+	add	#4, r1
+	mov.l	bss_end, r2
+	mov	#0, r0
+1:	cmp/hs	r2, r1
+	bf/s	1b			/* while (r1 < r2) */
+	  mov.l	r0, @-r2
+done_bss:
+
+	/* prepare to call board init routine: start_sh4boot() */
+do_start_sh4boot:
+	mov.l	start_sh4boot_addr, r1
+	jmp	@r1			/* never returns */
+	  mov r8, a0
+
+
+	/* Constants used above */
+
+.balign 4
+_start_offset:	.long . - _start
+target_addr:	.long TEXT_BASE
+stack_addr:	.long TEXT_BASE - (CFG_GBL_DATA_SIZE + CFG_MALLOC_LEN + CFG_BOOTPARAMS_LEN)
+bss_start:	.long __bss_start
+bss_end:	.long __bss_end
+hyperspace_addr:.long hyperspace
+#if defined(CFG_BOOT_FROM_NAND) && defined(CFG_NAND_SKIP_BAD_BLOCKS_ON_RELOCATING)
+skip_bb_offset:	.long skip_bb - _start
+#endif	/* CFG_BOOT_FROM_NAND && CFG_NAND_SKIP_BAD_BLOCKS_ON_RELOCATING */
+
+start_sh4boot_addr:.long start_sh4boot
+
+	/* offsets for PIC calls */
+
+init_ram_offset:		.long init_ram - .
+sh_cache_clear_op_offset:	.long sh_cache_clear_op - .
+sh_cache_set_op_offset:		.long sh_cache_set_op - .
+#ifdef CONFIG_SH_SE_MODE
+sh_toggle_pmb_cacheability_offset:
+				.long sh_toggle_pmb_cacheability - .
+#endif	/* CONFIG_SH_SE_MODE */
+
+
+#if defined(CFG_ENV_IS_IN_EEPROM)
+	/*
+	 * The following is a hack to work around a awkward linker
+	 * dependency issue. We need to force "ld" to pull in the CPU
+	 * specific version of "env_eeprom.o", rather than the generic
+	 * "common/env_eeprom.o" file that the linker seems to prefer!
+	 * QQQ: try to solve this properly, or make it non-loadable!
+	 */
+	.long env_init	/* any reference to anything in "env_eeprom.o" */
+#endif /* CFG_ENV_IS_IN_EEPROM */
+
diff --git a/cpu/sh/stb7100/Makefile b/cpu/sh/stb7100/Makefile
new file mode 100644
index 0000000000..fb2691ffee
--- /dev/null
+++ b/cpu/sh/stb7100/Makefile
@@ -0,0 +1,47 @@
+#
+# (C) Copyright 2000, 2001, 2002
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(SOC).a
+
+COBJS	= stb7100.o
+SOBJS	=
+
+SRCS	:= $(START:.o=.S) $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS) $(SOBJS))
+START	:= $(addprefix $(obj),$(START))
+
+all:	$(obj).depend $(LIB)
+
+$(LIB):	$(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/cpu/sh/stb7100/stb7100.c b/cpu/sh/stb7100/stb7100.c
new file mode 100644
index 0000000000..b9f7c8eec0
--- /dev/null
+++ b/cpu/sh/stb7100/stb7100.c
@@ -0,0 +1,394 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/soc.h>
+#include <asm/stb7100reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+#include <asm/stbus.h>
+#include <ata.h>
+
+#define PIO_BASE  0xb8020000	/* Phys 0x18020000 */
+
+static int st40c_div[] = {1, 2, 3, 4, 6, 8, 1, 1};
+static int st40b_div[] = {1, 2, 3, 4, 6, 8, 2, 2};
+static int st40p_div[] = {4, 2, 4, 4, 6, 8, 4, 4};
+
+void stb7100_clocks(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	bd_t *bd = gd->bd;
+	unsigned long data, mdiv, ndiv, pdiv, pll0frq, pll1frq, mainfrq ;
+
+	data = *STB7100_CLOCKGENA_PLL0_CFG;
+	mdiv = data & 0xff;
+	ndiv = (data >> 8) & 0xff;
+	pdiv = (data >> 16) & 0x7;
+
+	pll0frq = ((2 * INPUT_CLOCK_RATE * ndiv)/ mdiv) / (1 << pdiv);
+	mainfrq = pll0frq / 2;
+
+	data = *STB7100_CLOCKGENA_PLL1_CFG;
+	mdiv = data & 0xff;
+	ndiv = (data >> 8) & 0xff;
+	pdiv = (data >> 16) & 0x7;
+	pll1frq = ((2 * INPUT_CLOCK_RATE * ndiv)/ mdiv) / (1 << pdiv);
+
+	bd->bi_pll0frq = pll0frq;
+	bd->bi_pll1frq = pll1frq;
+	bd->bi_st40cpufrq = mainfrq / st40c_div[*STB7100_CLOCKGENA_PLL0_CLK1_CTRL & 0x7];
+	bd->bi_st40busfrq = mainfrq / st40b_div[*STB7100_CLOCKGENA_PLL0_CLK2_CTRL & 0x7];
+	bd->bi_st40perfrq = mainfrq / st40p_div[*STB7100_CLOCKGENA_PLL0_CLK3_CTRL & 0x7];
+	bd->bi_st231frq = pll1frq;
+	bd->bi_stbusfrq = pll1frq/2;
+	bd->bi_emifrq = pll1frq/4;
+	bd->bi_lmifrq = pll1frq/2;
+}
+
+#ifdef CONFIG_DRIVER_NETSTMAC
+
+#define MAC_SPEED_SEL       0x00100000 /* MAC is running at 100 Mbps speed */
+#define PHY_CLK_EXT         0x00080000 /* PHY clock is external (RMII mode)*/
+#define MII_MODE            0x00040000 /* RMII interface activated */
+#define ETH_IF_ON           0x00010000 /* ETH interface on */
+#define DVO_ETH_PAD_DISABLE 0x00020000 /* DVO eth pad disable */
+
+extern int stmac_default_pbl(void)
+{
+  DECLARE_GLOBAL_DATA_PTR;
+  bd_t *bd = gd->bd;
+  if (STB7100_DEVICEID_CUT(bd->bi_devid) == 1)
+    return 1;
+  return 32; /*  may be modified externally */
+}
+
+extern void stmac_set_mac_speed(int speed)
+{
+	unsigned long sysconf = *STB7100_SYSCONF_SYS_CFG07;
+//	printf("QQQ: %s(speed=%u)\n", __FUNCTION__, speed); /* QQQ - DELETE */
+
+	if (speed == 100)
+		sysconf |= MAC_SPEED_SEL;
+	else if (speed == 10)
+		sysconf &= ~MAC_SPEED_SEL;
+
+	*STB7100_SYSCONF_SYS_CFG07 = sysconf;
+}
+
+/* ETH MAC pad configuration */
+static void stmac_eth_hw_setup(void)
+{
+	unsigned long sysconf;
+
+	sysconf = *STB7100_SYSCONF_SYS_CFG07;
+	sysconf |= (DVO_ETH_PAD_DISABLE | ETH_IF_ON /*| MAC_SPEED_SEL*/);
+
+#ifdef CONFIG_STMAC_STE101P_RMII	/* QQQ - DELETE */
+	sysconf |= MII_MODE; /* RMII selected*/
+#else					/* QQQ - DELETE */
+	sysconf &= ~MII_MODE; /* MII selected */
+#endif					/* QQQ - DELETE */
+	*STB7100_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* STe101P: enable the external interrupts */
+	sysconf = *STB7100_SYSCONF_SYS_CFG10;
+	sysconf |= 0x0000000f;
+	*STB7100_SYSCONF_SYS_CFG10;
+
+       /* Configure e/net PHY clock */
+	SET_PIO_PIN(PIO_PORT(3), 7, STPIO_ALT_OUT);
+
+	return;
+}
+#endif
+
+int soc_init(void)
+{
+  DECLARE_GLOBAL_DATA_PTR;
+  bd_t *bd = gd->bd;
+
+  stb7100_clocks();
+
+  #ifdef CONFIG_DRIVER_NETSTMAC
+  if (STB7100_DEVICEID_7109(*STB7100_SYSCONF_DEVICEID_0))
+	stmac_eth_hw_setup();
+  else
+	printf("warning STMAC configured for a non STb7109 device\n");
+  #endif
+
+  bd->bi_devid = *STB7100_SYSCONF_DEVICEID_0;
+
+  /*  Make sure reset period is shorter than WDT timeout */
+
+ *STB7100_SYSCONF_SYS_CFG09 = (*STB7100_SYSCONF_SYS_CFG09 & 0xFF000000) | 0x000A8C;
+
+  return 0;
+}
+
+#if defined(CONFIG_SH_STB7100_SATA)
+
+#define SATA_AHB2STBUS_BASE			0xB9209000
+#define SATA_AHBHOST_BASE			0xB9209800
+
+/* AHB_STBus protocol converter */
+#define SATA_AHB2STBUS_STBUS_OPC		(SATA_AHB2STBUS_BASE + 0x0000)
+#define SATA_AHB2STBUS_MESSAGE_SIZE_CONFIG	(SATA_AHB2STBUS_BASE + 0x0004)
+#define SATA_AHB2STBUS_CHUNK_SIZE_CONFIG	(SATA_AHB2STBUS_BASE + 0x0008)
+#define SATA_AHB2STBUS_SW_RESET			(SATA_AHB2STBUS_BASE + 0x000c)
+#define SATA_AHB2STBUS_PC_STATUS		(SATA_AHB2STBUS_BASE + 0x0010)
+#define SATA_PC_GLUE_LOGIC			(SATA_AHB2STBUS_BASE + 0x0014)
+#define SATA_PC_GLUE_LOGICH			(SATA_AHB2STBUS_BASE + 0x0018)
+
+#define SATA_CDR0                               (SATA_AHBHOST_BASE + 0x00000000)
+#define SATA_CDR1                               (SATA_AHBHOST_BASE + 0x00000004)
+#define SATA_CDR2                               (SATA_AHBHOST_BASE + 0x00000008)
+#define SATA_CDR3                               (SATA_AHBHOST_BASE + 0x0000000c)
+#define SATA_CDR4                               (SATA_AHBHOST_BASE + 0x00000010)
+#define SATA_CDR5                               (SATA_AHBHOST_BASE + 0x00000014)
+#define SATA_CDR6                               (SATA_AHBHOST_BASE + 0x00000018)
+#define SATA_CDR7                               (SATA_AHBHOST_BASE + 0x0000001c)
+#define SATA_CLR0                               (SATA_AHBHOST_BASE + 0x00000020)
+#define SATA_SCR0                               (SATA_AHBHOST_BASE + 0x00000024)
+#define SATA_SCR1                               (SATA_AHBHOST_BASE + 0x00000028)
+#define SATA_SCR2                               (SATA_AHBHOST_BASE + 0x0000002c)
+#define SATA_SCR3                               (SATA_AHBHOST_BASE + 0x00000030)
+#define SATA_SCR4                               (SATA_AHBHOST_BASE + 0x00000034)
+#define SATA_DMACR                              (SATA_AHBHOST_BASE + 0x00000070)
+#define SATA_DBTSR                              (SATA_AHBHOST_BASE + 0x00000074)
+
+#define SATA_PHYCR				(SATA_AHBHOST_BASE + 0x88)
+
+static void stm_phy_reset(void)
+{
+  DECLARE_GLOBAL_DATA_PTR;
+  bd_t *bd = gd->bd;
+
+  if (STB7100_DEVICEID_7100(bd->bi_devid))
+  {
+    if (STB7100_DEVICEID_CUT(bd->bi_devid) == 1)
+	writel(0x0013704A, SATA_PHYCR);
+    else if (STB7100_DEVICEID_CUT(bd->bi_devid) == 3)
+	writel(0x388FC, SATA_PHYCR);
+    else
+	writel(0x3889C, SATA_PHYCR);
+  }
+
+  udelay(100000);
+}
+
+void stb7100_sata_init(void)
+{
+	int t;
+
+	/* AHB bus wrapper setup */
+
+	/*
+	// SATA_AHB2STBUS_STBUS_OPC
+	// 2:0  -- 100 = Store64/Load64
+	// 4    -- 1   = Enable write posting
+	// DMA Read, write posting always = 0
+	*/
+
+	/* opcode = Load4 |Store 4*/
+	writel(0, SATA_AHB2STBUS_STBUS_OPC);
+
+	/*
+	// SATA_AHB2STBUS_MESSAGE_SIZE_CONFIG
+	// 3:0  -- 0111 = 128 Packets
+	// 3:0  -- 0110 =  64 Packets
+	*/
+	/* WAS: Message size = 64 packet when 6 now 3*/
+	writel(3, SATA_AHB2STBUS_MESSAGE_SIZE_CONFIG);
+
+	/*
+	// SATA_AHB2STBUS_CHUNK_SIZE_CONFIG
+	// 3:0  -- 0110 = 64 Packets
+	// 3:0  -- 0001 =  2 Packets
+	*/
+
+	/* WAS Chunk size = 2 packet when 1, now 0 */
+	writel(0, SATA_AHB2STBUS_CHUNK_SIZE_CONFIG);
+
+	/*
+	// PC_GLUE_LOGIC
+	// 7:0  -- 0xFF = Set as reset value, 256 STBus Clock Cycles
+	// 8    -- 1  = Time out enabled
+	*/
+	/* time out count = 0xa0(160 dec)
+	 * time out enable = 1
+	 */
+
+	writel(0x1ff, SATA_PC_GLUE_LOGIC);
+
+	stm_phy_reset();
+
+	writel(0x301, SATA_SCR2);  /* issue phy wake/reset */
+	readl(SATA_SCR0);          /* dummy read; flush */
+	udelay(400);               /* FIXME: a guess */
+
+	writel(0x300, SATA_SCR2);  /* issue phy wake/reset */
+
+	{
+	  int timeout = 25;
+	  do {
+	    udelay(200000);
+	    t = readl(SATA_SCR0);
+	    if ((t & 0xf) != 1)
+	      break;
+	  } while (--timeout);
+	}
+
+	return;
+}
+
+extern ulong ide_bus_offset[CFG_IDE_MAXBUS];
+
+	/*
+	 * The following 2 functions are only required to
+	 * workround a silicon bug on the STb710x on SATA.
+	 *
+	 * This bug is present on all STb7100 chips, and
+	 * cut 1.x of the STb7109.  It was fixed on
+	 * cut 2.x (and later) of the STb7109.
+	 *
+	 * If is safe to enable these fuctions on all STb710x
+	 * chips, but it is less efficent if is not required.
+	 */
+
+extern void ide_outb(int dev, int port, unsigned char val)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	bd_t *bd = gd->bd;
+	if ( STB7100_DEVICEID_7109(bd->bi_devid) &&
+	     (STB7100_DEVICEID_CUT(bd->bi_devid) >= 2) )
+	  writeb(val, ATA_CURR_BASE(dev)+port);
+	else
+	  writel(val, ATA_CURR_BASE(dev)+port);
+}
+
+extern unsigned char ide_inb(int dev, int port)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	bd_t *bd = gd->bd;
+	if ( STB7100_DEVICEID_7109(bd->bi_devid) &&
+	     (STB7100_DEVICEID_CUT(bd->bi_devid) >= 2) )
+	  return readb(ATA_CURR_BASE(dev)+port);
+	else
+	  return readl(ATA_CURR_BASE(dev)+port);
+}
+
+#endif /* defined(CONFIG_SH_STB7100_SATA) */
+
+
+#if defined(CONFIG_USB_OHCI_NEW)
+
+extern void stb7100_usb_init(void)
+{
+	unsigned long reg;
+	DECLARE_GLOBAL_DATA_PTR;
+	bd_t *bd = gd->bd;
+
+	/* Work around for USB over-current detection chip being
+	 * active low, and the 710x being active high.
+	 *
+	 * This test is wrong for 7100 cut 3.0 (which needs the work
+	 * around), but as we can't reliably determine the minor
+	 * revision number, hard luck, this works for most people.
+	 */
+	if ( ( (STB7100_DEVICEID_7109(bd->bi_devid)) &&
+	       (STB7100_DEVICEID_CUT(bd->bi_devid) < 2) ) ||
+	     ( (STB7100_DEVICEID_7100(bd->bi_devid)) &&
+	       (STB7100_DEVICEID_CUT(bd->bi_devid) < 3) ) )
+	{
+		/* Setup PIO for USB over-current */
+		SET_PIO_PIN(PIO_PORT(5), 6, STPIO_OUT);
+		STPIO_SET_PIN(PIO_PORT(5), 6, 0);
+	}
+
+	/*
+	 * There have been two changes to the USB power enable signal:
+	 *
+	 * - 7100 upto and including cut 3.0 and 7109 1.0 generated an
+	 *   active high enables signal. From 7100 cut 3.1 and 7109 cut 2.0
+	 *   the signal changed to active low.
+	 *
+	 * - The 710x ref board (mb442) has always used power distribution
+	 *   chips which have active high enables signals (on rev A and B
+	 *   this was a TI TPS2052, rev C used the ST equivalent a ST2052).
+	 *   However rev A and B had a pull up on the enables signal, while
+	 *   rev C changed this to a pull down.
+	 *
+	 * The net effect of all this is that the easiest way to drive
+	 * this signal is ignore the USB hardware and drive it as a PIO
+	 * pin.
+	 *
+	 * (Note the USB over current input on the 710x changed from active
+	 * high to low at the same cuts, but board revs A and B had a resistor
+	 * option to select an inverted output from the TPS2052, so no
+	 * software work around is required.)
+	 */
+	/* Setup PIO for USB power */
+	SET_PIO_PIN(PIO_PORT(5), 7, STPIO_OUT);
+	STPIO_SET_PIN(PIO_PORT(5), 7, 1);
+
+	/* Make sure PLL is on */
+#define SYS_CFG2_PLL_POWER_DOWN_BIT	1
+	reg = readl(STB7100_SYSCONF_SYS_CFG02);
+	if (reg & SYS_CFG2_PLL_POWER_DOWN_BIT)
+	{
+		writel(reg & (~SYS_CFG2_PLL_POWER_DOWN_BIT),
+			STB7100_SYSCONF_SYS_CFG02);
+		udelay(100000);	/* QQQ: can this delay be shorter ? */
+	}
+
+	/* Set strap mode */
+#define STRAP_MODE	AHB2STBUS_STRAP_16_BIT
+	reg = readl(AHB2STBUS_STRAP);
+#if STRAP_MODE == 0
+	reg &= ~AHB2STBUS_STRAP_16_BIT;
+#else
+	reg |= STRAP_MODE;
+#endif
+	writel(reg, AHB2STBUS_STRAP);
+
+	/* Start PLL */
+	reg = readl(AHB2STBUS_STRAP);
+	writel(reg | AHB2STBUS_STRAP_PLL, AHB2STBUS_STRAP);
+	udelay(100000);	/* QQQ: can this delay be shorter ? */
+	writel(reg & (~AHB2STBUS_STRAP_PLL), AHB2STBUS_STRAP);
+	udelay(100000);	/* QQQ: can this delay be shorter ? */
+
+	/* Set the STBus Opcode Config for 32-bit access */
+	writel(AHB2STBUS_STBUS_OPC_32BIT, AHB2STBUS_STBUS_OPC);
+
+	/* Set the Message Size Config to 4 packets per message */
+	writel(AHB2STBUS_MSGSIZE_4, AHB2STBUS_MSGSIZE);
+
+	/* Set the Chunk Size Config to 4 packets per chunk */
+	writel(AHB2STBUS_CHUNKSIZE_4, AHB2STBUS_CHUNKSIZE);
+}
+#endif /* defined(CONFIG_USB_OHCI_NEW) */
+
diff --git a/cpu/sh/stm-nand.c b/cpu/sh/stm-nand.c
new file mode 100644
index 0000000000..4d3efbf7fd
--- /dev/null
+++ b/cpu/sh/stm-nand.c
@@ -0,0 +1,1027 @@
+/*
+ * (C) Copyright 2008-2009 STMicroelectronics, Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <malloc.h>
+
+
+#if defined(CONFIG_CMD_NAND)
+
+#include <nand.h>
+#include <asm/stm-nand.h>
+#include <asm/ecc.h>
+#include <asm/errno.h>
+#include <asm/st40reg.h>
+#include <asm/io.h>
+#include <asm/socregs.h>
+
+
+#define isprint(x)	( ((x)>=0x20u) && ((x)<0x7fu) )
+
+
+#define DEBUG_FLEX		0	/* Enable additional debugging of the FLEX controller */
+#define VERBOSE_ECC		0	/* Enable for verbose ECC information  */
+
+
+/*
+ * Define the bad/good block scan pattern which are used while scanning
+ * the NAND device for any factory marked good/bad blocks.
+ *
+ * For small page devices, factory bad block markers are in byte 5.
+ * For large page devices, factory bad block markers are in bytes 0 & 1.
+ * Any bit in those bytes being a zero, implies the entire block is bad.
+ *
+ * Using "SCANALLPAGES" takes a significant performance hit - tens of seconds!
+ * So, we override the default structures (which is to scan *all* pages),
+ * and instead, we only scan the first & 2nd pages in each block.
+ * However, we do also check the entire data area in those 2 pages,
+ * to see if they are properly erased. Improperly erased pages
+ * result in the entire bock also being treated as bad.
+ */
+static uint8_t scan_pattern[] = { 0xffu, 0xffu };
+
+struct nand_bbt_descr stm_nand_badblock_pattern_16 = {
+	.pattern = scan_pattern,
+	.options = NAND_BBT_SCANEMPTY /* | NAND_BBT_SCANALLPAGES */ | NAND_BBT_SCAN2NDPAGE,
+	.offs = 5,	/* Byte 5 */
+	.len = 1
+};
+
+struct nand_bbt_descr stm_nand_badblock_pattern_64 = {
+	.pattern = scan_pattern,
+	.options = NAND_BBT_SCANEMPTY /* | NAND_BBT_SCANALLPAGES */ | NAND_BBT_SCAN2NDPAGE,
+	.offs = 0,	/* Bytes 0-1 */
+	.len = 2
+};
+
+
+#ifdef CFG_NAND_ECC_HW3_128	/* for STM "boot-mode" */
+
+	/* for SMALL-page devices */
+static struct nand_oobinfo stm_nand_oobinfo_16 = {
+	.useecc = MTD_NANDECC_AUTOPLACE,
+	.eccbytes = 12,
+	.eccpos = {
+		 0,  1,  2,	/* ECC for 1st 128-byte record */
+		 4,  5,  6,	/* ECC for 2nd 128-byte record */
+		 8,  9, 10,	/* ECC for 3rd 128-byte record */
+		12, 13, 14},	/* ECC for 4th 128-byte record */
+	.oobfree = { {3, 1}, {7, 1}, {11, 1}, {15, 1} }
+};
+
+	/* for LARGE-page devices */
+static struct nand_oobinfo stm_nand_oobinfo_64 = {
+	.useecc = MTD_NANDECC_AUTOPLACE,
+	.eccbytes = 48,
+	.eccpos = {
+		 0,  1,  2,	/* ECC for  1st 128-byte record */
+		 4,  5,  6,	/* ECC for  2nd 128-byte record */
+		 8,  9, 10,	/* ECC for  3rd 128-byte record */
+		12, 13, 14,	/* ECC for  4th 128-byte record */
+		16, 17, 18,	/* ECC for  5th 128-byte record */
+		20, 21, 22,	/* ECC for  6th 128-byte record */
+		24, 25, 26,	/* ECC for  7th 128-byte record */
+		28, 29, 30,	/* ECC for  8th 128-byte record */
+		32, 33, 34,	/* ECC for  9th 128-byte record */
+		36, 37, 38,	/* ECC for 10th 128-byte record */
+		40, 41, 42,	/* ECC for 11th 128-byte record */
+		44, 45, 46,	/* ECC for 12th 128-byte record */
+		48, 49, 50,	/* ECC for 13th 128-byte record */
+		52, 53, 54,	/* ECC for 14th 128-byte record */
+		56, 57, 58,	/* ECC for 15th 128-byte record */
+		60, 61, 62},	/* ECC for 16th 128-byte record */
+	.oobfree = {
+		{ 3, 1}, { 7, 1}, {11, 1}, {15, 1},
+		{19, 1}, {23, 1}, {27, 1}, {31, 1},
+		{35, 1}, {39, 1}, {43, 1}, {47, 1},
+		{51, 1}, {55, 1}, {59, 1}, {63, 1} },
+};
+
+
+/*
+ * define a structure to hold the fields in the "struct mtd_info"
+ * and "struct nand_chip" structures that we need to over-write
+ * to allow 2 (incompatible) ECC configurations to exist on
+ * the same physical NAND flash device at the same time!
+ *
+ * This is required as some of the STi7xxx devices, have a property
+ * that when in NAND "boot-mode" (i.e. boot-from-NAND) that an ECC
+ * configuration of 3 ECC bytes per 128 byte record *must* be used.
+ * However, when not in "boot-mode", less aggressive ECC configuration
+ * of either 3 ECC bytes per 256 or 512 bytes may be used.
+ *
+ * When using this "hybrid" of 2 different ECC configurations on the
+ * same physical device, we use 2 instances of this structure:
+ *	1) based on the normal (default) configuration (e.g. S/W ECC)
+ *	2) the "boot-mode" 'special' with 3/128 H/W compatibility.
+ *
+ * Various functions are intercepted to ensure that the mtd_info
+ * and nand_chip structures always have the correct "view" of the ECC
+ * configurations, then the default functions can be safely used as is.
+ */
+struct stm_mtd_nand_ecc
+{
+	struct	/* holds differences in "struct nand_chip" */
+	{
+		int			eccmode;
+		int			eccsize;
+		int			eccsteps;
+		struct nand_oobinfo	*autooob;
+		int (*calculate_ecc)(struct mtd_info *, const u_char *, u_char *);
+		int (*correct_data)(struct mtd_info *, u_char *, u_char *, u_char *);
+	}	nand;
+	struct	/* holds differences in "struct mtd_info" */
+	{
+		u_int32_t		oobavail;
+		u_int32_t		eccsize;
+		struct nand_oobinfo	oobinfo;
+	}	mtd;
+};
+
+
+static struct stm_mtd_nand_ecc default_ecc;	/* ECC diffs for the normal SW case */
+static struct stm_mtd_nand_ecc special_ecc;	/* ECC diffs for the "special" hybrid case */
+static int done_ecc_info = 0;			/* are the 2 ECC structures initialized ? */
+
+
+#endif	/* CFG_NAND_ECC_HW3_128 */
+
+
+#ifdef CFG_NAND_FLEX_MODE	/* for STM "flex-mode" (c.f. "bit-banging") */
+
+/* Flex-Mode Data {Read,Write} Config Registers & Flex-Mode {Command,Address} Registers */
+#define FLEX_WAIT_RBn			( 1u << 27 )	/* wait for RBn to be asserted (i.e. ready) */
+#define FLEX_BEAT_COUNT_1		( 1u << 28 )	/* One Beat */
+#define FLEX_BEAT_COUNT_2		( 2u << 28 )	/* Two Beats */
+#define FLEX_BEAT_COUNT_3		( 3u << 28 )	/* Three Beats */
+#define FLEX_BEAT_COUNT_4		( 0u << 28 )	/* Four Beats */
+#define FLEX_CSn_STATUS			( 1u << 31 )	/* Deasserts CSn after current operation completes */
+
+/* Flex-Mode Data-{Read,Write} Config Registers */
+#define FLEX_1_BYTE_PER_BEAT		( 0u << 30 )	/* One Byte per Beat */
+#define FLEX_2_BYTES_PER_BEAT		( 1u << 30 )	/* Two Bytes per Beat */
+
+/* Flex-Mode Configuration Register */
+#define FLEX_CFG_ENABLE_FLEX_MODE	( 1u <<  0 )	/* Enable Flex-Mode operations */
+#define FLEX_CFG_ENABLE_AFM		( 2u <<  0 )	/* Enable Advanced-Flex-Mode operations */
+#define FLEX_CFG_SW_RESET		( 1u <<  3 )	/* Enable Software Reset */
+#define FLEX_CFG_CSn_STATUS		( 1u <<  4 )	/* Deasserts CSn in current Flex bank */
+
+
+enum stm_nand_flex_mode {
+	flex_quiecent,		/* next byte_write is *UNEXPECTED* */
+	flex_command,		/* next byte_write is a COMMAND */
+	flex_address		/* next byte_write is a ADDRESS */
+};
+
+
+/*
+ * NAND device connected to STM NAND Controller operating in FLEX mode.
+ * There may be several NAND device connected to the NAND controller.
+ */
+struct stm_nand_flex_device {
+	int			csn;
+	struct nand_chip	*chip;
+	struct mtd_info		*mtd;
+	struct nand_timing_data *timing_data;
+};
+
+
+/*
+ * STM NAND Controller operating in FLEX mode.
+ * There is only a single one of these.
+ */
+static struct stm_nand_flex_controller {
+	int			initialized;	/* is the FLEX controller initialized ? */
+	int			current_csn;	/* Currently Selected Device (CSn) */
+	int			next_csn;	/* First free NAND Device (CSn) */
+	enum stm_nand_flex_mode mode;
+	struct stm_nand_flex_device device[CFG_MAX_NAND_DEVICE];
+	uint8_t			*buf;		/* Bounce buffer for non-aligned xfers */
+} flex;
+
+
+#endif /* CFG_NAND_FLEX_MODE */
+
+
+extern int stm_nand_default_bbt (struct mtd_info *mtd)
+{
+	struct nand_chip * const this = (struct nand_chip *)(mtd->priv);
+
+	/* over-write the default "badblock_pattern", with our one */
+	/* choose the correct pattern struct, depending on the OOB size */
+	if (mtd->oobsize > 16)
+		this->badblock_pattern = &stm_nand_badblock_pattern_64;	/* LARGE-page */
+	else
+		this->badblock_pattern = &stm_nand_badblock_pattern_16;	/* SMALL-page */
+
+	/* now call the generic BBT function */
+	return nand_default_bbt (mtd);
+}
+
+
+#ifdef CFG_NAND_ECC_HW3_128	/* for STM "boot-mode" */
+
+
+extern int stm_nand_calculate_ecc (
+	struct mtd_info * const mtd,
+	const u_char * const dat,
+	u_char * const ecc_code)
+{
+	const struct nand_chip const * this = mtd->priv;
+
+	if (this->eccmode!=NAND_ECC_HW3_128)
+	{
+		printf("ERROR: Can not calculate ECC: Internal Error (eccmode=%u)\n",
+			this->eccmode);
+		BUG();
+		return -1;	/* Note: caller ignores this value! */
+	}
+	else if ((((unsigned long)dat)%4)!=0)	/* data *must* be 4-bytes aligned */
+	{
+		/* QQQ: change this case to use a properly aligned bounce buffer */
+		printf("ERROR: Can not calculate ECC: data (%08lx) must be 4-byte aligned!\n",
+			(unsigned long)dat);
+		ecc_code[0] = 'B';
+		ecc_code[1] = 'A';
+		ecc_code[2] = 'D';
+		return -1;	/* Note: caller ignores this value! */
+	}
+	else
+	{	/* calculate 3 ECC bytes per 128 bytes of data */
+		const ecc_t computed_ecc = ecc_gen(dat, ECC_128);
+		/* poke them into the right place */
+		ecc_code[0] = computed_ecc.byte[0];
+		ecc_code[1] = computed_ecc.byte[1];
+		ecc_code[2] = computed_ecc.byte[2];
+	}
+
+	return 0;
+}
+
+
+extern int stm_nand_correct_data (
+	struct mtd_info *mtd,
+	u_char *dat,
+	u_char *read_ecc,
+	u_char *calc_ecc)
+{
+	ecc_t read, calc;
+	enum ecc_check result;
+	const struct nand_chip const * this = mtd->priv;
+
+	if (this->eccmode!=NAND_ECC_HW3_128)
+	{
+		printf("ERROR: Can not correct ECC: Internal Error (eccmode=%u)\n",
+			this->eccmode);
+		BUG();
+		return -1;
+	}
+
+	/* do we need to try and correct anything ? */
+	if (    (read_ecc[0] == calc_ecc[0]) &&
+		(read_ecc[1] == calc_ecc[1]) &&
+		(read_ecc[2] == calc_ecc[2])    )
+	{
+		return 0;		/* ECCs agree, nothing to do */
+	}
+
+#if VERBOSE_ECC
+	printf("warning: ECC error detected!  "
+		"read_ecc %02x:%02x:%02x (%c%c%c) != "
+		"calc_ecc %02x:%02x:%02x (%c%c%c)\n",
+		(unsigned)read_ecc[0],
+		(unsigned)read_ecc[1],
+		(unsigned)read_ecc[2],
+		isprint(read_ecc[0]) ? read_ecc[0] : '.',
+		isprint(read_ecc[1]) ? read_ecc[1] : '.',
+		isprint(read_ecc[2]) ? read_ecc[2] : '.',
+		(unsigned)calc_ecc[0],
+		(unsigned)calc_ecc[1],
+		(unsigned)calc_ecc[2],
+		isprint(calc_ecc[0]) ? calc_ecc[0] : '.',
+		isprint(calc_ecc[1]) ? calc_ecc[1] : '.',
+		isprint(calc_ecc[2]) ? calc_ecc[2] : '.');
+#endif	/* VERBOSE_ECC */
+
+	/* put ECC bytes into required structure */
+	read.byte[0] = read_ecc[0];
+	read.byte[1] = read_ecc[1];
+	read.byte[2] = read_ecc[2];
+	calc.byte[0] = calc_ecc[0];
+	calc.byte[1] = calc_ecc[1];
+	calc.byte[2] = calc_ecc[2];
+
+	/* correct a 1-bit error (if we can) */
+	result = ecc_correct(dat, read, calc, ECC_128);
+
+	/* let the user know if we were able to recover it or not! */
+	switch (result)
+	{
+		case E_D1_CHK:
+			printf("info: 1-bit error in data was corrected\n");
+			break;
+		case E_C1_CHK:
+			printf("info: 1-bit error in ECC ignored (data was okay)\n");
+			break;
+		default:
+#if VERBOSE_ECC
+			/* QQQ: filter out genuinely ERASED pages - TO DO */
+			printf("ERROR: uncorrectable ECC error not corrected!\n");
+#endif	/* VERBOSE_ECC */
+			break;
+	}
+
+	/* return zero if all okay, and -1 if we have an uncorrectable issue */
+	if ((result==E_D1_CHK)||(result==E_C1_CHK))
+	{
+		return 0;	/* okay (correctable) */
+	}
+	else
+	{
+		return -1;	/* uncorrectable */
+	}
+}
+
+
+/*
+ * fill in the "default_ecc" and "special_ecc" structures.
+ */
+static void initialize_ecc_diffs (
+	const struct mtd_info * const mtd)
+{
+	const struct nand_chip * const this = (struct nand_chip *)(mtd->priv);
+	struct nand_oobinfo * autooob;
+
+	/* choose the correct OOB info struct, depending on the OOB size */
+	if (mtd->oobsize > 16)
+		autooob = &stm_nand_oobinfo_64;	/* LARGE-page */
+	else
+		autooob = &stm_nand_oobinfo_16;	/* SMALL-page */
+
+	/* fill in "default_ecc" from the current "live" (default) structures */
+	default_ecc.nand.eccmode	= this->eccmode;
+	default_ecc.nand.eccsize	= this->eccsize;
+	default_ecc.nand.eccsteps	= this->eccsteps;
+	default_ecc.nand.autooob	= this->autooob;
+	default_ecc.nand.calculate_ecc	= this->calculate_ecc;
+	default_ecc.nand.correct_data	= this->correct_data;
+	default_ecc.mtd.oobavail	= mtd->oobavail;
+	default_ecc.mtd.eccsize		= mtd->eccsize;
+	memcpy(&default_ecc.mtd.oobinfo, &mtd->oobinfo, sizeof(struct nand_oobinfo));
+
+	/* fill in "special_ecc" for our special "hybrid" ECC paradigm */
+	special_ecc.nand.eccmode	= NAND_ECC_HW3_128;
+	special_ecc.nand.eccsize	= 128;
+	special_ecc.nand.eccsteps	= mtd->oobblock / special_ecc.nand.eccsize;
+	special_ecc.nand.autooob	= autooob;
+	special_ecc.nand.calculate_ecc	= stm_nand_calculate_ecc;
+	special_ecc.nand.correct_data	= stm_nand_correct_data;
+	if (this->options & NAND_BUSWIDTH_16) {
+		special_ecc.mtd.oobavail= mtd->oobsize - (autooob->eccbytes + 2);
+		special_ecc.mtd.oobavail= special_ecc.mtd.oobavail & ~0x01;
+	} else {
+		special_ecc.mtd.oobavail= mtd->oobsize - (autooob->eccbytes + 1);
+	}
+	special_ecc.mtd.eccsize		= special_ecc.nand.eccsize;
+	memcpy(&special_ecc.mtd.oobinfo, autooob, sizeof(struct nand_oobinfo));
+}
+
+
+/*
+ * Make the "live" MTD structures use the ECC configuration
+ * as described in the passed "diffs" structure.
+ */
+static void set_ecc_diffs (
+	struct mtd_info * const mtd,
+	const struct stm_mtd_nand_ecc * const diffs)
+{
+	struct nand_chip * const this = (struct nand_chip *)(mtd->priv);
+
+	this->eccmode		= diffs->nand.eccmode;
+	this->eccsize		= diffs->nand.eccsize;
+	this->eccsteps		= diffs->nand.eccsteps;
+	this->autooob		= diffs->nand.autooob;
+	this->calculate_ecc	= diffs->nand.calculate_ecc;
+	this->correct_data	= diffs->nand.correct_data;
+
+	mtd->oobavail		= diffs->mtd.oobavail;
+	mtd->eccsize		= diffs->mtd.eccsize;
+	memcpy(&mtd->oobinfo, &diffs->mtd.oobinfo, sizeof(struct nand_oobinfo));
+
+	/* also, we need to reinitialize oob_buf */
+	this->oobdirty		= 1;
+
+#if VERBOSE_ECC
+	printf("info: switching to NAND \"%s\" ECC (%u/%u)\n",
+		(diffs==&special_ecc) ? "BOOT-mode" : "NON-boot-mode",
+		this->eccbytes,
+		this->eccsize);
+#endif	/* VERBOSE_ECC */
+}
+
+
+static int set_ecc_mode (
+	struct mtd_info * const mtd,
+	const loff_t addr,
+	const size_t len)
+{
+	struct nand_chip * const this = (struct nand_chip *)(mtd->priv);
+
+	if (!done_ecc_info)		/* first time ? */
+	{
+		initialize_ecc_diffs (mtd);
+		done_ecc_info = 1;	/* do not do this again */
+	}
+
+	/* do we need to switch ECC mode ? */
+	if ( addr >= CFG_NAND_STM_BOOT_MODE_BOUNDARY )
+	{	/* entire range is *not* in "boot-mode" (i.e. default ECC) */
+		if (this->eccmode == NAND_ECC_HW3_128)
+		{	/* we are in the wrong ECC mode, so change */
+			set_ecc_diffs (mtd, &default_ecc);
+		}
+	}
+	else if ( addr + len <= CFG_NAND_STM_BOOT_MODE_BOUNDARY )
+	{	/* entire range is in "boot-mode" (i.e. 3 bytes of ECC per 128 record */
+		if (this->eccmode != NAND_ECC_HW3_128)
+		{	/* we are in the wrong ECC mode, so change */
+			set_ecc_diffs (mtd, &special_ecc);
+		}
+	}
+	else
+	{	/* the range is split over *both* "boot" and "non-boot" modes! */
+		printf("ERROR: NAND range crosses \"boot-mode\" boundary (0x%08x)\n",
+			CFG_NAND_STM_BOOT_MODE_BOUNDARY);
+		return -EINVAL;
+	}
+
+	return 0;	/* success */
+}
+
+
+extern void stm_nand_enable_hwecc (
+	struct mtd_info *mtd,
+	int mode)
+{
+	/* do nothing - we are only emulating HW in SW */
+}
+
+
+extern int stm_nand_read (struct mtd_info *mtd, loff_t from, size_t len, size_t * retlen, u_char * buf)
+{
+	int result;
+
+	result = set_ecc_mode (mtd, from, len);
+	if (result != 0)
+	{
+		*retlen = 0;
+	}
+	else
+	{
+		result = nand_read_ecc (mtd, from, len, retlen, buf, NULL, NULL);
+	}
+
+	return result;
+}
+
+
+extern int stm_nand_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
+	size_t * retlen, u_char * buf, u_char * eccbuf, struct nand_oobinfo *oobsel)
+{
+	int result;
+
+	result = set_ecc_mode (mtd, from, len);
+	if (result != 0)
+	{
+		*retlen = 0;
+	}
+	else
+	{
+		result = nand_read_ecc (mtd, from, len, retlen, buf, eccbuf, oobsel);
+	}
+
+	return result;
+}
+
+
+extern int stm_nand_read_oob (struct mtd_info *mtd, loff_t from, size_t len, size_t * retlen, u_char * buf)
+{
+	int result;
+
+	result = set_ecc_mode (mtd, from, len);
+	if (result != 0)
+	{
+		*retlen = 0;
+	}
+	else
+	{
+		result = nand_read_oob (mtd, from, len, retlen, buf);
+	}
+
+	return result;
+}
+
+
+extern int stm_nand_write (struct mtd_info *mtd, loff_t to, size_t len, size_t * retlen, const u_char * buf)
+{
+	int result;
+
+	result = set_ecc_mode (mtd, to, len);
+	if (result != 0)
+	{
+		*retlen = 0;
+	}
+	else
+	{
+		result = nand_write_ecc (mtd, to, len, retlen, buf, NULL, NULL);
+	}
+
+	return result;
+}
+
+
+extern int stm_nand_write_ecc (struct mtd_info *mtd, loff_t to, size_t len,
+	size_t * retlen, const u_char * buf, u_char * eccbuf, struct nand_oobinfo *oobsel)
+{
+	int result;
+
+	result = set_ecc_mode (mtd, to, len);
+	if (result != 0)
+	{
+		*retlen = 0;
+	}
+	else
+	{
+		result = nand_write_ecc (mtd, to, len, retlen, buf, eccbuf, oobsel);
+	}
+
+	return result;
+}
+
+
+extern int stm_nand_write_oob (struct mtd_info *mtd, loff_t to, size_t len, size_t * retlen, const u_char *buf)
+{
+	int result;
+
+	result = set_ecc_mode (mtd, to, len);
+	if (result != 0)
+	{
+		*retlen = 0;
+	}
+	else
+	{
+		result = nand_write_oob (mtd, to, len, retlen, buf);
+	}
+
+	return result;
+}
+
+
+#endif	/* CFG_NAND_ECC_HW3_128 */
+
+
+#ifdef CFG_NAND_FLEX_MODE	/* for STM "flex-mode" (c.f. "bit-banging") */
+
+
+/* Configure NAND controller timing registers */
+/* QQQ: to write & use this function (for performance reasons!) */
+#ifdef QQQ
+static void flex_set_timings(struct nand_timing_data * const tm)
+{
+	uint32_t n;
+	uint32_t reg;
+	uint32_t emi_clk;
+	uint32_t emi_t_ns;
+
+	/* Timings are set in units of EMI clock cycles */
+	emi_clk = clk_get_rate(clk_get(NULL, "emi_master"));
+	emi_t_ns = 1000000000UL / emi_clk;
+
+	/* CONTROL_TIMING */
+	n = (tm->sig_setup + emi_t_ns - 1u)/emi_t_ns;
+	reg = (n & 0xffu) << 0;
+
+	n = (tm->sig_hold + emi_t_ns - 1u)/emi_t_ns;
+	reg |= (n & 0xffu) << 8;
+
+	n = (tm->CE_deassert + emi_t_ns - 1u)/emi_t_ns;
+	reg |= (n & 0xffu) << 16;
+
+	n = (tm->WE_to_RBn + emi_t_ns - 1u)/emi_t_ns;
+	reg |= (n & 0xffu) << 24;
+
+#if DEBUG_FLEX
+	printf("info: CONTROL_TIMING = 0x%08x\n", reg);
+#endif
+	*ST40_EMI_NAND_CTL_TIMING = reg;
+
+	/* WEN_TIMING */
+	n = (tm->wr_on + emi_t_ns - 1u)/emi_t_ns;
+	reg = (n & 0xffu) << 0;
+
+	n = (tm->wr_off + emi_t_ns - 1u)/emi_t_ns;
+	reg |= (n & 0xffu) << 8;
+
+#if DEBUG_FLEX
+	printf("info: WEN_TIMING = 0x%08x\n", reg);
+#endif
+	*ST40_EMI_NAND_WEN_TIMING = reg;
+
+	/* REN_TIMING */
+	n = (tm->rd_on + emi_t_ns - 1u)/emi_t_ns;
+	reg = (n & 0xffu) << 0;
+
+	n = (tm->rd_off + emi_t_ns - 1u)/emi_t_ns;
+	reg |= (n & 0xffu) << 8;
+
+#if DEBUG_FLEX
+	printf("info: REN_TIMING = 0x%08x\n", reg);
+#endif
+	*ST40_EMI_NAND_REN_TIMING = reg;
+}
+#endif
+
+
+/*
+ * hardware specific access to the Ready/not_Busy signal.
+ * Signal is routed through the EMI NAND Controller block.
+ */
+extern int stm_flex_device_ready(struct mtd_info * const mtd)
+{
+	/* Apply a small delay before sampling the RBn signal */
+#if 1
+	ndelay(500);	/* QQQ: do we really need this ??? */
+#endif
+	/* extract bit 2: status of RBn pin on the FLEX bank */
+	return ((*ST40_EMI_NAND_RBN_STA) & (1ul<<2)) ? 1 : 0;
+}
+
+
+static void init_flex_mode(void)
+{
+	u_int32_t reg;
+
+	/* Disable the BOOT-mode controller */
+	*ST40_EMI_NAND_BOOTBANK_CFG = 0;
+
+	/* Perform a S/W reset the FLEX-mode controller */
+	/* need to assert it for at least one (EMI) clock cycle. */
+	*ST40_EMI_NAND_FLEXMODE_CFG = FLEX_CFG_SW_RESET;
+	udelay(1);	/* QQQ: can we do something shorter ??? */
+	*ST40_EMI_NAND_FLEXMODE_CFG = 0;
+
+	/* Disable all interrupts in FLEX mode */
+	*ST40_EMI_NAND_INT_EN = 0;
+
+	/* Set FLEX-mode controller to enable FLEX-mode */
+	*ST40_EMI_NAND_FLEXMODE_CFG = FLEX_CFG_ENABLE_FLEX_MODE;
+
+	/*
+	 * Configure (pervading) FLEX_DATA to write 4-bytes at a time.
+	 * DATA is only written by write_buf(), not write_byte().
+	 * Hence, we only need to configure this once (ever)!
+	 * As we may be copying directly from NOR flash to NAND flash,
+	 * we need to deassert the CSn after *each* access, as we
+	 * can not guarantee the buffer is in RAM (or not in the EMI).
+	 * Note: we could run memcpy() in write_buf() instead.
+	 */
+	reg = FLEX_BEAT_COUNT_4 | FLEX_1_BYTE_PER_BEAT;
+	reg |= FLEX_CSn_STATUS;		/* deassert CSn after each flex data write */
+#if 0
+	reg |= FLEX_WAIT_RBn;		/* QQQ: do we want this ??? */
+#endif
+	*ST40_EMI_NAND_FLEX_DATAWRT_CFG = reg;
+}
+
+
+/* FLEX mode chip select: For now we only support 1 chip per
+ * 'stm_nand_flex_device' so chipnr will be 0 for select, -1 for deselect.
+ *
+ * So, if we change device:
+ *   - Set bank in mux_control_reg to data->csn
+ *   - Update read/write timings (to do)
+ */
+extern void stm_flex_select_chip(
+	struct mtd_info * const mtd,
+	const int chipnr)
+{
+	struct nand_chip * const chip = mtd->priv;
+	struct stm_nand_flex_device * data = chip->priv;
+
+#if DEBUG_FLEX
+	printf("\t\t\t\t---- SELECT = %2d ----\n", chipnr);
+#endif
+
+	if (!flex.initialized)		/* is the H/W yet to be initialized ? */
+	{
+		/* initialize the FLEX mode controller H/W */
+		init_flex_mode();
+		/* initialize the "flex" software structure */
+		flex.mode          = flex_quiecent;	/* nothing pending */
+		flex.next_csn      = 0;			/* start with first EMI CSn */
+		flex.current_csn   = -1;		/* no NAND device selected */
+							/* allocate a bounce buffer */
+		flex.buf = malloc(NAND_MAX_PAGESIZE + NAND_MAX_OOBSIZE);
+		if (flex.buf==NULL)
+		{
+			printf("ERROR: Unable to allocate memory for a bounce buffer\n");
+			BUG();
+		}
+		flex.initialized   = 1;			/* initialization done */
+	}
+
+	if (data == NULL)		/* device not yet scanned ? */
+	{
+#ifdef CFG_NAND_FLEX_CSn_MAP
+		const int csn_map[CFG_MAX_NAND_DEVICE] = CFG_NAND_FLEX_CSn_MAP;
+#endif	/* CFG_NAND_FLEX_CSn_MAP */
+		int csn            = flex.next_csn++;		/* first free CSn */
+		chip->priv = data  = &(flex.device[csn]);	/* first free "private" structure */
+		if (csn >= CFG_MAX_NAND_DEVICE) BUG();
+#ifdef CFG_NAND_FLEX_CSn_MAP
+		csn                = csn_map[csn];		/* Re-map to different CSn if needed */
+#endif	/* CFG_NAND_FLEX_CSn_MAP */
+#if DEBUG_FLEX
+		printf("info: stm_nand_flex_device.csn = %u\n", csn);
+#endif
+
+		data->csn          = csn;			/* fill in the private structure ... */
+		data->mtd          = mtd;
+		data->chip         = chip;
+		data->timing_data  = NULL;			/* QQQ: to do */
+#ifdef CFG_NAND_ECC_HW3_128
+		mtd->read          = stm_nand_read;
+		mtd->write         = stm_nand_write;
+		mtd->read_ecc      = stm_nand_read_ecc;
+		mtd->write_ecc     = stm_nand_write_ecc;
+		mtd->read_oob      = stm_nand_read_oob;
+		mtd->write_oob     = stm_nand_write_oob;
+		chip->enable_hwecc = stm_nand_enable_hwecc;
+#endif /* CFG_NAND_ECC_HW3_128 */
+	}
+
+	/* Deselect, do nothing */
+	if (chipnr == -1) {
+		return;
+
+	} else if (chipnr == 0) {
+		/* If same chip as last time, no need to change anything */
+		if (data->csn == flex.current_csn)
+			return;
+
+		/* Set correct EMI Chip Select (CSn) on FLEX controller */
+		flex.current_csn = data->csn;
+		*ST40_EMI_NAND_FLEX_MUXCTRL = 1ul << data->csn;
+
+		/* Set up timing parameters */
+#if 0
+		/* The default times will work for 200MHz (or slower) */
+		/* QQQ: to do - BUT this is also the WRONG place to do this! */
+		flex_set_timings(data->timing_data);
+#endif
+
+	} else {
+		printf("ERROR: In %s() attempted to select chipnr = %d\n",
+			__FUNCTION__,
+			chipnr);
+	}
+}
+
+
+extern void stm_flex_hwcontrol (
+	struct mtd_info * const mtd,
+	int control)
+{
+	switch(control) {
+
+	case NAND_CTL_SETCLE:
+#if DEBUG_FLEX
+		printf("\t\t\t\t\t\t----START COMMAND----\n");
+		if (flex.mode != flex_quiecent) BUG();
+#endif
+		flex.mode = flex_command;
+		break;
+
+#if DEBUG_FLEX
+	case NAND_CTL_CLRCLE:
+		printf("\t\t\t\t\t\t---- end  command----\n");
+		if (flex.mode != flex_command) BUG();
+		flex.mode = flex_quiecent;
+		break;
+#endif
+
+	case NAND_CTL_SETALE:
+#if DEBUG_FLEX
+		printf("\t\t\t\t\t\t----START ADDRESS----\n");
+		if (flex.mode != flex_quiecent) BUG();
+#endif
+		flex.mode = flex_address;
+		break;
+
+#if DEBUG_FLEX
+	case NAND_CTL_CLRALE:
+		printf("\t\t\t\t\t\t---- end  address----\n");
+		if (flex.mode != flex_address) BUG();
+		flex.mode = flex_quiecent;
+		break;
+#endif
+
+#if DEBUG_FLEX
+	default:
+		printf("ERROR: Unexpected parameter (control=0x%x) in %s()\n",
+			control,
+			__FUNCTION__);
+		BUG();
+#endif
+	}
+}
+
+
+/**
+ * nand_read_byte - [DEFAULT] read one byte from the chip
+ * @mtd:	MTD device structure
+ */
+extern u_char stm_flex_read_byte(
+	struct mtd_info * const mtd)
+{
+	u_char byte;
+	u_int32_t reg;
+
+	/* read 1-byte at a time */
+	reg = FLEX_BEAT_COUNT_1 | FLEX_1_BYTE_PER_BEAT;
+	reg |= FLEX_CSn_STATUS;		/* deassert CSn after each flex data read */
+#if 0
+	reg |= FLEX_WAIT_RBn;		/* QQQ: do we want this ??? */
+#endif
+	*ST40_EMI_NAND_FLEX_DATA_RD_CFG = reg;
+
+	/* read it */
+	byte = (u_char)*ST40_EMI_NAND_FLEX_DATA;
+
+#if DEBUG_FLEX
+	printf("\t\t\t\t\t\t\t\t\t READ = 0x%02x\n", byte);
+#endif
+
+	/* return it */
+	return byte;
+}
+
+
+/**
+ * nand_write_byte - [DEFAULT] write one byte to the chip
+ * @mtd:	MTD device structure
+ * @byte:	pointer to data byte to write
+ */
+extern void stm_flex_write_byte(
+	struct mtd_info * const mtd,
+	u_char byte)
+{
+	u_int32_t reg;
+
+#if DEBUG_FLEX
+	printf("\t\t\t\t\t\t\t\t\tWRITE = 0x%02x\t%s\n", byte,
+		(flex.mode==flex_command) ? "command" :
+		((flex.mode==flex_address) ? "address" : "*UNKNOWN*"));
+#endif
+
+	switch (flex.mode)
+	{
+		case flex_command:
+			reg = byte | FLEX_BEAT_COUNT_1;
+			reg |= FLEX_CSn_STATUS;	/* deassert CSn after each flex command write */
+#if 0
+			reg |= FLEX_WAIT_RBn;		/* QQQ: do we want this ??? */
+#endif
+			*ST40_EMI_NAND_FLEX_CMD = reg;
+			break;
+
+		case flex_address:
+			reg = byte | FLEX_BEAT_COUNT_1;
+			reg |= FLEX_CSn_STATUS;	/* deassert CSn after each flex address write */
+#if 0
+			reg |= FLEX_WAIT_RBn;		/* QQQ: do we want this ??? */
+#endif
+			*ST40_EMI_NAND_FLEX_ADD_REG = reg;
+#if 0			/* QQQ: do we need this - I think not! */
+			while (!nand_device_ready()) ;	/* wait till NAND is ready */
+#endif
+			break;
+
+		default:
+			BUG();
+	}
+}
+
+
+/**
+ * nand_read_buf - [DEFAULT] read chip data into buffer
+ * @mtd:	MTD device structure
+ * @buf:	buffer to store data
+ * @len:	number of bytes to read
+ */
+extern void stm_flex_read_buf(
+	struct mtd_info * const mtd,
+	u_char * const buf,
+	const int len)
+{
+	int i;
+	uint32_t *p;
+	u_int32_t reg;
+
+	/* our buffer needs to be 4-byte aligned, for the FLEX controller */
+	p = ((uint32_t)buf & 0x3) ? (void*)flex.buf : (void*)buf;
+
+#if DEBUG_FLEX
+	printf("info: stm_flex_read_buf( buf=%p, len=0x%x )\t\tp=%p%s\n",
+		buf, len, p,
+		((uint32_t)buf & 0x3) ? "\t\t**** UN-ALIGNED *****" : "");
+#endif
+
+	/* configure to read 4-bytes at a time */
+	reg = FLEX_BEAT_COUNT_4 | FLEX_1_BYTE_PER_BEAT;
+	reg |= FLEX_CSn_STATUS;		/* deassert CSn after each flex data read */
+#if 0
+	reg |= FLEX_WAIT_RBn;		/* QQQ: do we want this ??? */
+#endif
+	*ST40_EMI_NAND_FLEX_DATA_RD_CFG = reg;
+
+	/* copy the data (from NAND) as 4-byte words ... */
+	for(i=0; i<len/4; i++)
+	{
+		p[i] = *ST40_EMI_NAND_FLEX_DATA;
+	}
+
+	/* copy back into user-supplied buffer, if it was unaligned */
+	if ((void*)p != (void*)buf)
+		memcpy(buf, p, len);
+
+#if DEBUG_FLEX
+	printf("READ BUF\t\t\t\t");
+	for (i=0; i<16; i++)
+		printf("%02x ", buf[i]);
+	printf("...\n");
+#endif
+}
+
+
+/**
+ * nand_write_buf - [DEFAULT] write buffer to chip
+ * @mtd:	MTD device structure
+ * @buf:	data buffer
+ * @len:	number of bytes to write
+ */
+extern void stm_flex_write_buf(
+	struct mtd_info * const mtd,
+	const u_char * const buf,
+	const int len)
+{
+	int i;
+	uint32_t *p;
+
+#if DEBUG_FLEX
+	printf("WRITE BUF\t\t");
+	for (i=0; i<16; i++)
+		printf("%02x ", buf[i]);
+	printf("...\n");
+#endif
+
+	/* our buffer needs to be 4-byte aligned, for the FLEX controller */
+	p = ((uint32_t)buf & 0x3) ? (void*)flex.buf : (void*)buf;
+
+	/* copy from user-supplied buffer, if it is unaligned */
+	if ((void*)p != (void*)buf)
+		memcpy(p, buf, len);
+
+	/* configured to write 4-bytes at a time */
+	/* copy the data (to NAND) as 32-bit words ... */
+	for(i=0; i<len/4; i++)
+	{
+		*ST40_EMI_NAND_FLEX_DATA = p[i];
+	}
+}
+
+
+#endif /* CFG_NAND_FLEX_MODE */
+
+
+#endif	/* CONFIG_CMD_NAND */
diff --git a/cpu/sh/stx5197/Makefile b/cpu/sh/stx5197/Makefile
new file mode 100644
index 0000000000..4458d8023d
--- /dev/null
+++ b/cpu/sh/stx5197/Makefile
@@ -0,0 +1,47 @@
+#
+# (C) Copyright 2009 STMicroelectronics.
+# Sean McGoogan <Sean.McGoogan@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(SOC).a
+
+COBJS	= stx5197.o
+SOBJS	=
+
+SRCS	:= $(START:.o=.S) $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS) $(SOBJS))
+START	:= $(addprefix $(obj),$(START))
+
+all:	$(obj).depend $(LIB)
+
+$(LIB):	$(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/cpu/sh/stx5197/stx5197.c b/cpu/sh/stx5197/stx5197.c
new file mode 100644
index 0000000000..d4e29961cd
--- /dev/null
+++ b/cpu/sh/stx5197/stx5197.c
@@ -0,0 +1,218 @@
+/*
+ * (C) Copyright 2008-2009 STMicroelectronics.
+ *
+ * Stuart Menefy <stuart.menefy@st.com>
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/soc.h>
+#include <asm/stx5197reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+#include <asm/stbus.h>
+#include <ata.h>
+#include <spi.h>
+
+
+#define SET_SYSCONF_BIT(reg,flag,bit)			\
+	do {						\
+		if (flag)				\
+		{	/* set bit 'bit' */		\
+			reg |= (1ul<<(bit));		\
+		}					\
+		else					\
+		{	/* clear bit 'bit' */		\
+			reg &= ~(1ul<<(bit));		\
+		}					\
+	} while (0)
+
+#define SET_SYSCONF_BITS(reg,flag,first,last,yes,no)	\
+	do {						\
+		const unsigned long _mask = 		\
+			(1ul<<((last)-(first)+1))-1ul;	\
+		/* clear all bits in 'first':'last' */	\
+		reg &= ~(_mask<<(first));		\
+		if (flag)				\
+		{	/* set 'yes' in first:last */	\
+			reg |= ((yes)<<(first));	\
+		}					\
+		else					\
+		{	/* set 'no' in first:last */	\
+			reg |= ((no)<<(first));		\
+		}					\
+	} while (0)
+
+
+static void stx5197_clocks(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	bd_t *bd = gd->bd;
+
+	/*
+	 * FIXME
+	 * Gross hack to get the serial port working.
+	 * See the defintion of PCLK in drivers/stm-asc.c
+	 * for where this is used.
+	 */
+	bd->bi_emifrq = 140;	/* comms_clk = 140 MHz */
+}
+
+
+#ifdef CONFIG_DRIVER_NETSTMAC
+extern int stmac_default_pbl(void)
+{
+	return 32;
+}
+
+extern void stmac_set_mac_speed(const int speed)
+{
+	unsigned long sysconf;
+
+	sysconf = *STX5197_HD_CONF_MON_CONFIG_CONTROL_E;
+
+	/* MAC speed*/
+	/* CFG_CTRL_E.MAC_SPEED_SEL = speed==100 ? 1 : 0 [1] */
+	SET_SYSCONF_BIT(sysconf, speed==100, 1);
+
+	*STX5197_HD_CONF_MON_CONFIG_CONTROL_E = sysconf;
+}
+
+/* ETH MAC pad configuration */
+static void stmac_eth_hw_setup(const int rmii, const int ext_clk, const int phy_bus)
+{
+	unsigned long sysconf;
+
+	sysconf = *STX5197_HD_CONF_MON_CONFIG_CONTROL_E;
+
+	/* Ethernet interface on */
+	/* CFG_CTRL_E.ETHERNET_INTERFACE_ON = 1 [0] */
+	SET_SYSCONF_BIT(sysconf, 1, 0);
+
+	/* MII plyclk out enable: 0=output, 1=input */
+	/* CFG_CTRL_E.MII_PHYCLK_OUT_EN = ext_clk ? 1 : 0 [6] */
+	SET_SYSCONF_BIT(sysconf, ext_clk, 6);
+
+	/* RMII/MII pin mode */
+	/* CFG_CTRL_E.MII_ETHERNET_SEL = rmii ? 2 : 3 [8:7] */
+	SET_SYSCONF_BITS(sysconf, rmii, 7, 8, 0x2, 0x3);
+
+	/* MII mode */
+	/* CFG_CTRL_E.MII_MODE = rmii ? 0 : 1 [2] */
+	SET_SYSCONF_BIT(sysconf, !rmii, 2);
+
+	*STX5197_HD_CONF_MON_CONFIG_CONTROL_E = sysconf;
+}
+#endif	/* CONFIG_DRIVER_NETSTMAC */
+
+
+#if defined(CONFIG_USB_OHCI_NEW)
+extern void stx5197_usb_init(void)
+{
+	unsigned long sysconf;
+
+	/* USB power down */
+	sysconf = *STX5197_HD_CONF_MON_CONFIG_CONTROL_H;
+	sysconf &= ~(1ul<<8);	/* CFG_CTRL_H.USB_POWERDOWN_REQ = 0 [8] */
+	*STX5197_HD_CONF_MON_CONFIG_CONTROL_H = sysconf;
+
+	/* DDR enable for ULPI */
+	sysconf = *STX5197_HD_CONF_MON_CONFIG_CONTROL_M;
+	sysconf &= ~(1ul<<12);	/* CFG_CTRL_M.ULPI_DDR_EN_I = 0 [12] */
+				/* 0=8-bit SDR ULPI, 1=4-bit DDR ULPI */
+	*STX5197_HD_CONF_MON_CONFIG_CONTROL_M = sysconf;
+
+	/* start the USB Wrapper Host Controller */
+	ST40_start_host_control(
+		USB_FLAGS_STRAP_16BIT		|
+		USB_FLAGS_STRAP_PLL		|
+		USB_FLAGS_STBUS_CONFIG_THRESHOLD256);
+}
+#endif /* defined(CONFIG_USB_OHCI_NEW) */
+
+
+/**********************************************************************/
+
+
+/*
+ * assert or de-assert the SPI Chip Select line.
+ *
+ *	input: cs == true, assert CS, else deassert CS
+ */
+#if defined(CONFIG_SPI) && !defined(CONFIG_SOFT_SPI)
+static void spi_chip_select(const int cs)
+{
+	unsigned long reg;
+
+	reg = *STX5197_HD_CONF_MON_CONFIG_CONTROL_M;
+
+	if (cs)
+	{	/* assert SPI CS */
+		reg &= ~(1ul<<13);	/* CFG_CTRL_M.SPI_CS_WHEN_SSC_USED = 0 [13] */
+	}
+	else
+	{	/* DE-assert SPI CS */
+		reg |= 1ul<<13;		/* CFG_CTRL_M.SPI_CS_WHEN_SSC_USED = 1 [13] */
+	}
+
+	*STX5197_HD_CONF_MON_CONFIG_CONTROL_M = reg;
+
+	if (cs)
+	{	/* wait 250ns for CS assert to propagate  */
+		udelay(1);	/* QQQ: can we make this shorter ? */
+	}
+}
+
+
+/*
+ * The SPI command uses this table of functions for controlling the SPI
+ * chip selects: it calls the appropriate function to control the SPI
+ * chip selects.
+ */
+spi_chipsel_type spi_chipsel[] =
+{
+	spi_chip_select
+};
+int spi_chipsel_cnt = sizeof(spi_chipsel) / sizeof(spi_chipsel[0]);
+#endif	/* CONFIG_SPI && !defined(CONFIG_SOFT_SPI) */
+
+
+/**********************************************************************/
+
+
+extern int soc_init(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	bd_t *bd = gd->bd;
+
+	stx5197_clocks();
+
+	/* obtain the chip cut + device id */
+	bd->bi_devid = *STX5197_HD_CONF_MON_CONFIG_MONITOR_H;
+
+#ifdef CONFIG_DRIVER_NETSTMAC
+	stmac_eth_hw_setup(0, 1, 0);
+#endif	/* CONFIG_DRIVER_NETSTMAC */
+
+	return 0;
+}
+
diff --git a/cpu/sh/stx7105/Makefile b/cpu/sh/stx7105/Makefile
new file mode 100644
index 0000000000..4d165a4838
--- /dev/null
+++ b/cpu/sh/stx7105/Makefile
@@ -0,0 +1,47 @@
+#
+# (C) Copyright 2008 STMicroelectronics.
+# Sean McGoogan <Sean.McGoogan@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(SOC).a
+
+COBJS	= stx7105.o
+SOBJS	=
+
+SRCS	:= $(START:.o=.S) $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS) $(SOBJS))
+START	:= $(addprefix $(obj),$(START))
+
+all:	$(obj).depend $(LIB)
+
+$(LIB):	$(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/cpu/sh/stx7105/stx7105.c b/cpu/sh/stx7105/stx7105.c
new file mode 100644
index 0000000000..ee8673f298
--- /dev/null
+++ b/cpu/sh/stx7105/stx7105.c
@@ -0,0 +1,369 @@
+/*
+ * (C) Copyright 2008-2009 STMicroelectronics.
+ *
+ * Stuart Menefy <stuart.menefy@st.com>
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/soc.h>
+#include <asm/stx7105reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+#include <asm/stbus.h>
+#include <ata.h>
+#include <spi.h>
+
+
+static void stx7105_clocks(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	bd_t *bd = gd->bd;
+
+	/*
+	 * FIXME
+	 * Gross hack to get the serial port working.
+	 * See the defintion of PCLK in drivers/stm-asc.c
+	 * for where this is used.
+	 */
+	bd->bi_emifrq = 100;
+}
+
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+
+#define ETHERNET_INTERFACE_ON	(1ul<<16)
+#define EXT_MDIO		(1ul<<17)
+#define RMII_MODE		(1ul<<18)
+#define PHY_CLK_EXT		(1ul<<19)
+#define MAC_SPEED_SEL           (1ul<<20)
+#define PHY_INTF_SEL_MASK	(0x3ul<<25)
+#define ENMII			(1ul<<27)
+/* Remaining bits define pad functions, default appears to work */
+
+extern int stmac_default_pbl(void)
+{
+	return 8;
+}
+
+extern void stmac_set_mac_speed(int speed)
+{
+	unsigned long sysconf = *STX7105_SYSCONF_SYS_CFG07;
+
+	/* MAC_SPEED_SEL = 0|1 */
+	if (speed == 100)
+		sysconf |= MAC_SPEED_SEL;
+	else if (speed == 10)
+		sysconf &= ~MAC_SPEED_SEL;
+
+	*STX7105_SYSCONF_SYS_CFG07 = sysconf;
+}
+
+/* ETH MAC pad configuration */
+static void stmac_eth_hw_setup( int reverse_mii, int rmii_mode, int mode,
+				int ext_mdio, int ext_clk, int phy_bus)
+{
+	unsigned long sysconf;
+
+	sysconf = *STX7105_SYSCONF_SYS_CFG07;
+	/* Ethernet ON */
+	sysconf |= (ETHERNET_INTERFACE_ON);
+	/* MII M-DIO select: 1: miim_dio from external input, 0: from GMAC */
+	if (ext_mdio)
+		sysconf |= (EXT_MDIO);
+	else
+		sysconf &= ~(EXT_MDIO);
+	/* RMII pin multiplexing: 0: MII interface active, 1: RMII interface */
+	/* cut 1: This register was not connected, so only MII available */
+	if (rmii_mode)
+		sysconf |= (RMII_MODE);
+	else
+		sysconf &= ~(RMII_MODE);
+	/*
+	 * PHY EXT CLOCK: 0: provided by STx7105; 1: external
+	 * cut 1: sysconf7[19], however this was not connected, so only
+	 * input supported.
+	 * cut 2: direction now based on PIO direction, so this code removed.
+	 */
+	/* Default GMII/MII selection */
+	sysconf &= ~(PHY_INTF_SEL_MASK);
+	sysconf |= ((mode&3ul)<<25);
+	/* MII mode */
+	if (reverse_mii)
+		sysconf &= ~(ENMII);
+	else
+		sysconf |= (ENMII);
+	*STX7105_SYSCONF_SYS_CFG07 = sysconf;
+
+	/* Pin configuration... */
+
+	/* PIO7[4] CFG37[8+4,4] = Alternate1 = MIIRX_DV/MII_EXCRS */
+	/* PIO7[5] CFG37[8+5,5] = Alternate1 = MIIRX_ER/MII_EXCOL */
+	/* PIO7[6] CFG37[8+6,6] = Alternate1 = MIITXD[0] */
+	/* PIO7[7] CFG37[8+7,7] = Alternate1 = MIITXD[1] */
+	sysconf = *STX7105_SYSCONF_SYS_CFG37;
+	sysconf &= ~(0xf0f0ul);	/* Mask=3,3,3,3 */
+	sysconf |=   0x0000ul;	/* OR  =0,0,0,0 */
+	*STX7105_SYSCONF_SYS_CFG37 = sysconf;
+	SET_PIO_PIN(PIO_PORT(7), 4, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(7), 5, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(7), 6, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(7), 7, STPIO_ALT_OUT);
+
+	/* PIO8[0] CFG46[8+0,0] = Alternate1 = MIITXD[2] */
+	/* PIO8[1] CFG46[8+1,1] = Alternate1 = MIITXD[3] */
+	/* PIO8[2] CFG46[8+2,2] = Alternate1 = MIITX_EN */
+	/* PIO8[3] CFG46[8+3,3] = Alternate1 = MIIMDIO */
+	/* PIO8[4] CFG46[8+4,4] = Alternate1 = MIIMDC */
+	/* PIO8[5] CFG46[8+5,5] = Alternate1 = MIIRXCLK */
+	/* PIO8[6] CFG46[8+6,6] = Alternate1 = MIIRXD[0] */
+	/* PIO8[7] CFG46[8+7,7] = Alternate1 = MIIRXD[1] */
+	sysconf = *STX7105_SYSCONF_SYS_CFG46;
+	sysconf &= ~(0xfffful);	/* Mask=3,3,3,3,3,3,3,3 */
+	sysconf |=   0x0000ul;	/* OR  =0,0,0,0,0,0,0,0 */
+	*STX7105_SYSCONF_SYS_CFG46 = sysconf;
+	SET_PIO_PIN(PIO_PORT(8), 0, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(8), 1, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(8), 2, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(8), 3, STPIO_ALT_BIDIR);
+	SET_PIO_PIN(PIO_PORT(8), 4, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(8), 5, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(8), 6, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(8), 7, STPIO_IN);
+
+	/* PIO9[0] CFG47[8+0,0] = Alternate1 = MIIRXD[2] */
+	/* PIO9[1] CFG47[8+1,1] = Alternate1 = MIIRXD[3] */
+	/* PIO9[2] CFG47[8+2,2] = Alternate1 = MIITXCLK */
+	/* PIO9[3] CFG47[8+3,3] = Alternate1 = MIICOL */
+	/* PIO9[4] CFG47[8+4,4] = Alternate1 = MIICRS */
+	/* PIO9[5] CFG47[8+5,5] = Alternate1 = MIIPHYCLK */
+	/* PIO9[6] CFG47[8+6,6] = Alternate1 = MIIMDINT */
+	sysconf = *STX7105_SYSCONF_SYS_CFG47;
+	sysconf &= ~(0x7f7ful);	/* Mask=3,3,3,3,3,3,3 */
+	sysconf |=   0x0000ul;	/* OR  =0,0,0,0,0,0,0 */
+	*STX7105_SYSCONF_SYS_CFG47 = sysconf;
+	SET_PIO_PIN(PIO_PORT(9), 0, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(9), 1, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(9), 2, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(9), 3, STPIO_IN);
+	SET_PIO_PIN(PIO_PORT(9), 4, STPIO_IN);
+	/* MIIPHYCLK */
+	/* Not implemented in cut 1 (DDTS GNBvd69906) - clock never output */
+	/* In cut 2 PIO direction used to control input or output. */
+	if (ext_clk)
+		SET_PIO_PIN(PIO_PORT(9), 5, STPIO_IN);
+	else
+		SET_PIO_PIN(PIO_PORT(9), 5, STPIO_ALT_OUT);
+	SET_PIO_PIN(PIO_PORT(9), 6, STPIO_IN);
+}
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+int soc_init(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	bd_t *bd = gd->bd;
+
+	stx7105_clocks();
+
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+#ifdef CONFIG_SYS_STM_GMAC_NOT_EXT_CLK
+	stmac_eth_hw_setup (0, 0, 0, 0, 0, 0);
+#else
+	stmac_eth_hw_setup (0, 0, 0, 0, 1, 0);
+#endif
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+	bd->bi_devid = *STX7105_SYSCONF_DEVICEID_0;
+
+	/*
+	 * Make sure the reset period is shorter than WDT time-out,
+	 * and that the reset loop-back chain is *not* bypassed.
+	 *	SYS_CFG09[29]    = long_reset_mode
+	 *	SYS_CFG09[28:27] = cpu_rst_out_bypass(1:0)
+	 *	SYS_CFG09[25:0]  = ResetOut_period
+	 */
+//QQQ	*STX7105_SYSCONF_SYS_CFG09 = (*STX7105_SYSCONF_SYS_CFG09 & 0xF7000000) | 0x000A8C;
+	*STX7105_SYSCONF_SYS_CFG09 = (*STX7105_SYSCONF_SYS_CFG09 & 0xF4000000ul) | 0x000A8Cul;
+
+	return 0;
+}
+
+
+#if defined(CONFIG_USB_OHCI_NEW)
+extern int stx7105_usb_init(int port, int over_current, int power_ctrl)
+{
+	unsigned long reg;
+	const unsigned char oc_pins[2]    = {4, 6};	/* PIO4 */
+	const unsigned char power_pins[2] = {5, 7};	/* PIO4 */
+
+	if (port >= sizeof(oc_pins))	/* invalid port number ? */
+		return -1;		/* failed to initialize! */
+
+	/* Power on the USB */
+	reg = readl(STX7105_SYSCONF_SYS_CFG32);
+	/* Power up USB host controller */
+	/* USBn_HC_POWER_DOWN_REQ = 0 = Powered Up */
+	reg &= ~(1ul<<(4+port));
+	/* Power up USB PHY */
+	/* USBn_PHY_POWER_DOWN_REQ = 0 = Powered Up */
+	reg &= ~(1ul<<(6+port));
+	writel(reg, STX7105_SYSCONF_SYS_CFG32);
+
+	if (over_current) {
+		/* USB overcurrent enable */
+		reg = readl(STX7105_SYSCONF_SYS_CFG04);
+		/* USB0_PRT_OVCURR_POL = 0 = Active Low */
+		reg &= ~(1ul<<(3+port));
+		/* USBn_PRT_OVCURR_IN = 0 = PIO4[oc_pins[port]] */
+		reg &= ~(1ul<<(5+port));
+		/* CFG_USBn_OVRCURR_ENABLE = 1 = OC Enabled */
+		reg |= 1ul<<(11+port);
+		writel(reg, STX7105_SYSCONF_SYS_CFG04);
+
+		/* Route USBn OC Routing via PIO4[oc_pins[port]] */
+		reg = readl(STX7105_SYSCONF_SYS_CFG34);
+		/* PIO4[oc_pins[port]] CFG34[8+oc_pins[port],oc_pins[port]] = Alternate4 */
+		reg &= ~(0x0101ul<<(oc_pins[port]));	/* Mask=3 */
+		reg |=   0x0101ul<<(oc_pins[port]);	/* OR=3 */
+		writel(reg, STX7105_SYSCONF_SYS_CFG34);
+		/* set PIO directionality, for OC as IN */
+		SET_PIO_PIN(PIO_PORT(4), oc_pins[port], STPIO_IN);
+	}
+
+	if (power_ctrl) {
+		/* Route USBn POWER Routing via PIO4[power_pins[port]] */
+		reg = readl(STX7105_SYSCONF_SYS_CFG34);
+		/* PIO4[power_pins[port]] CFG34[8+power_pins[port],power_pins[port]] = Alternate4 */
+		reg &= ~(0x0101ul<<(power_pins[port]));	/* Mask=3 */
+		reg |=   0x0101ul<<(power_pins[port]);	/* OR=3 */
+		writel(reg, STX7105_SYSCONF_SYS_CFG34);
+		/* set PIO directionality, for POWER as ALT_OUT */
+		SET_PIO_PIN(PIO_PORT(4), power_pins[port], STPIO_ALT_OUT);
+	}
+
+	/* start the USB Wrapper Host Controller */
+	ST40_start_host_control(
+		USB_FLAGS_STRAP_8BIT |
+		USB_FLAGS_STBUS_CONFIG_THRESHOLD128);
+
+	return 0;
+}
+
+#endif /* defined(CONFIG_USB_OHCI_NEW) */
+
+
+#if defined(CONFIG_SH_STM_SATA)
+extern void stx7105_configure_sata(void)
+{
+	static int initialised_phy = 0;
+	unsigned long sysconf;
+
+	if (!initialised_phy)
+	{
+		/* Power up the SATA PHY */
+		sysconf = *STX7105_SYSCONF_SYS_CFG32;
+		sysconf &= ~(1u<<9);	/* [11] SATA1_PHY_POWER_DOWN_REQ */
+		*STX7105_SYSCONF_SYS_CFG32 = sysconf;
+
+		/* initialize the SATA PHY */
+		stm_sata_miphy_init();
+
+		/* Power up the SATA host */
+		sysconf = *STX7105_SYSCONF_SYS_CFG32;
+		sysconf &= ~(1u<<11);	/* [9] SATA1_HC_POWER_DOWN_REQ */
+		*STX7105_SYSCONF_SYS_CFG32 = sysconf;
+
+		/* configure the SATA host controller */
+		stm_sata_probe();
+
+		initialised_phy = 1;
+	}
+}
+#endif	/* CONFIG_SH_STM_SATA */
+
+
+#if defined(CONFIG_SOFT_SPI)			/* Use "bit-banging" for SPI */
+extern void stx7105_spi_scl(const int val)
+{
+	const int pin = 0;	/* PIO15[0] = SPI_CLK */
+	STPIO_SET_PIN(PIO_PORT(15), pin, val ? 1 : 0);
+}
+
+extern void stx7105_spi_sda(const int val)
+{
+	const int pin = 1;	/* PIO15[1] = SPI_DOUT */
+	STPIO_SET_PIN(PIO_PORT(15), pin, val ? 1 : 0);
+}
+
+extern unsigned char stx7105_spi_read(void)
+{
+	const int pin = 3;	/* PIO15[3] = SPI_DIN */
+	return STPIO_GET_PIN(PIO_PORT(15), pin);  //gongjia mark
+}
+
+extern unsigned char stx7105_key_read(void)
+{
+	const int pin = 1;	/* PIO0[1] =  */
+	return STPIO_GET_PIN(PIO_PORT(0), pin);  //gongjia mark
+}
+
+extern unsigned char stx7105_led_write(int led)
+{
+	const int pin = 4;	/* PIO0[1] =  */
+	STPIO_SET_PIN(PIO_PORT(0), pin,led);  //gongjia mark
+}
+/*
+ * assert or de-assert the SPI Chip Select line.
+ *
+ *	input: cs == true, assert CS, else deassert CS
+ */
+static void spi_chip_select(const int cs)
+{
+	const int pin = 2;	/* PIO15[2] = SPI_NOTCS */
+
+	if (cs)
+	{	/* assert SPI CSn */
+		STPIO_SET_PIN(PIO_PORT(15), pin, 0);
+	}
+	else
+	{	/* DE-assert SPI CSn */
+		STPIO_SET_PIN(PIO_PORT(15), pin, 1);
+	}
+
+	if (cs)
+	{	/* wait 250ns for CSn assert to propagate  */
+		udelay(1);	/* QQQ: can we make this shorter ? */
+	}
+}
+
+/*
+ * The SPI command uses this table of functions for controlling the SPI
+ * chip selects: it calls the appropriate function to control the SPI
+ * chip selects.
+ */
+spi_chipsel_type spi_chipsel[] =
+{
+	spi_chip_select
+};
+int spi_chipsel_cnt = sizeof(spi_chipsel) / sizeof(spi_chipsel[0]);
+#endif	/* CONFIG_SOFT_SPI */
+
+
diff --git a/cpu/sh/stx7111/Makefile b/cpu/sh/stx7111/Makefile
new file mode 100644
index 0000000000..22e0ae0956
--- /dev/null
+++ b/cpu/sh/stx7111/Makefile
@@ -0,0 +1,47 @@
+#
+# (C) Copyright 2008 STMicroelectronics.
+# Sean McGoogan <Sean.McGoogan@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(SOC).a
+
+COBJS	= stx7111.o
+SOBJS	=
+
+SRCS	:= $(START:.o=.S) $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS) $(SOBJS))
+START	:= $(addprefix $(obj),$(START))
+
+all:	$(obj).depend $(LIB)
+
+$(LIB):	$(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/cpu/sh/stx7111/stx7111.c b/cpu/sh/stx7111/stx7111.c
new file mode 100644
index 0000000000..a9f43cf8e9
--- /dev/null
+++ b/cpu/sh/stx7111/stx7111.c
@@ -0,0 +1,258 @@
+/*
+ * (C) Copyright 2008-2009 STMicroelectronics.
+ *
+ * Stuart Menefy <stuart.menefy@st.com>
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/soc.h>
+#include <asm/stx7111reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+#include <asm/stbus.h>
+#include <ata.h>
+#include <spi.h>
+
+#define PIO_BASE  ST40_PIO0_REGS_BASE
+
+static void stx7111_clocks(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	bd_t *bd = gd->bd;
+
+	/*
+	 * FIXME
+	 * Gross hack to get the serial port working.
+	 * See the definition of PCLK in drivers/stm-asc.c
+	 * for where this is used.
+	 */
+	bd->bi_emifrq = 100;
+}
+
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+
+#define ETHERNET_INTERFACE_ON	(1ul<<16)
+#define PHY_CLK_EXT		(1ul<<19)
+#define MAC_SPEED_SEL           (1ul<<20)
+#define PHY_INTF_SEL_MASK	(0x7ul<<24)
+#define ENMII			(1ul<<27)
+
+/* Remaining bits define pad functions, default appears to work */
+
+extern int stmac_default_pbl(void)
+{
+	return 32;
+}
+
+extern void stmac_set_mac_speed(int speed)
+{
+	unsigned long sysconf = *STX7111_SYSCONF_SYS_CFG07;
+
+	/* MAC_SPEED_SEL = 0|1 */
+	if (speed == 100)
+		sysconf |= MAC_SPEED_SEL;
+	else if (speed == 10)
+		sysconf &= ~MAC_SPEED_SEL;
+
+	*STX7111_SYSCONF_SYS_CFG07 = sysconf;
+}
+
+/* ETH MAC pad configuration */
+static void stmac_eth_hw_setup(void)
+{
+	const unsigned long en_mii  = 1;
+	const unsigned long sel     = 0;
+	const unsigned long ext_clk = 0;
+
+	unsigned long sysconf = *STX7111_SYSCONF_SYS_CFG07;
+
+	/* Ethernet ON */
+	sysconf |= ETHERNET_INTERFACE_ON;
+
+	/* PHY EXT CLOCK: 0: provided by STX7111; 1: external */
+	if (ext_clk)
+		sysconf |= PHY_CLK_EXT;
+	else
+		sysconf &= ~PHY_CLK_EXT;
+
+	/* Default GMII/MII selection */
+	sysconf &= ~PHY_INTF_SEL_MASK;
+	sysconf |= ((sel<<24) & PHY_INTF_SEL_MASK);
+
+	/* MII mode */
+	if (en_mii)
+		sysconf |= ENMII;
+	else
+		sysconf &= ~ENMII;
+
+	*STX7111_SYSCONF_SYS_CFG07 = sysconf;
+}
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+int soc_init(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	bd_t *bd = gd->bd;
+
+	stx7111_clocks();
+
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+	stmac_eth_hw_setup();
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+	bd->bi_devid = *STX7111_SYSCONF_DEVICEID_0;
+
+	/*  Make sure reset period is shorter than WDT timeout */
+	*STX7111_SYSCONF_SYS_CFG09 = (*STX7111_SYSCONF_SYS_CFG09 & 0xFF000000) | 0x000A8C;
+
+	return 0;
+}
+
+
+#if defined(CONFIG_USB_OHCI_NEW)
+extern void stx7111_usb_init(void)
+{
+	unsigned long reg, req_reg;
+
+	/* Power on the USB */
+	reg = readl(STX7111_SYSCONF_SYS_CFG32);
+	reg &= ~(1ul<<4); /* USB_POWER_DOWN_REQ = 0 */
+	writel(reg, STX7111_SYSCONF_SYS_CFG32);
+
+	/* Work around for USB over-current detection chip being
+	 * active low, and the 7111 being active high.
+	 * Note this is an undocumented bit, which apparently enables
+	 * an inverter on the over-current signal.
+	 */
+	reg = readl(STX7111_SYSCONF_SYS_CFG06);
+	reg |= 1ul<<29;
+	writel(reg, STX7111_SYSCONF_SYS_CFG06);
+
+	/* USB oc */
+	SET_PIO_PIN(PIO_PORT(5), 6, STPIO_IN);
+	/* USB power */
+	SET_PIO_PIN(PIO_PORT(5), 7, STPIO_ALT_OUT);
+	STPIO_SET_PIN(PIO_PORT(5), 7, 1);
+
+	/* Set strap mode */
+#define STRAP_MODE	AHB2STBUS_STRAP_16_BIT
+	reg = readl(AHB2STBUS_STRAP);
+#if STRAP_MODE == 0
+	reg &= ~AHB2STBUS_STRAP_16_BIT;
+#else
+	reg |= STRAP_MODE;
+#endif
+	writel(reg, AHB2STBUS_STRAP);
+
+	/* Start PLL */
+	reg = readl(AHB2STBUS_STRAP);
+	writel(reg | AHB2STBUS_STRAP_PLL, AHB2STBUS_STRAP);
+	udelay(100000);	/* QQQ: can this delay be shorter ? */
+	writel(reg & (~AHB2STBUS_STRAP_PLL), AHB2STBUS_STRAP);
+	udelay(100000);	/* QQQ: can this delay be shorter ? */
+
+	req_reg =
+		(1<<21) |  /* Turn on read-ahead */
+		(5<<16) |  /* Opcode is store/load 32 */
+		(0<<15) |  /* Turn off write posting */
+		(1<<14) |  /* Enable threshold */
+		(3<<9)  |  /* 2**3 Packets in a chunk */
+		(0<<4)  |  /* No messages */
+		(8<<0);    /* Threshold is 256 */
+
+	do {
+		writel(req_reg, AHB2STBUS_STBUS_CONFIG);
+		reg = readl(AHB2STBUS_STBUS_CONFIG);
+	} while ((reg & 0x7FFFFFFF) != req_reg);
+}
+
+#endif /* defined(CONFIG_USB_OHCI_NEW) */
+
+
+/**********************************************************************/
+
+
+#if defined(CONFIG_SPI)
+
+#if defined(CONFIG_SOFT_SPI)			/* Use "bit-banging" for SPI */
+extern void stx7111_spi_scl(const int val)
+{
+	const int pin = 0;	/* PIO2[0] = SPI_CLK */
+	STPIO_SET_PIN(PIO_PORT(2), pin, val ? 1 : 0);
+}
+
+extern void stx7111_spi_sda(const int val)
+{
+	const int pin = 1;	/* PIO2[1] = SPI_DOUT */
+	STPIO_SET_PIN(PIO_PORT(2), pin, val ? 1 : 0);
+}
+
+extern unsigned char stx7111_spi_read(void)
+{
+	const int pin = 2;	/* PIO2[2] = SPI_DIN */
+	return STPIO_GET_PIN(PIO_PORT(2), pin);
+}
+#else
+#error Still to impliment SPI via SSC for the STx7111.
+#endif	/* CONFIG_SOFT_SPI */
+
+/*
+ * assert or de-assert the SPI Chip Select line.
+ *
+ *	input: cs == true, assert CS, else deassert CS
+ *
+ * this is used for both S/W bit-banging, and H/W SSC.
+ */
+static void spi_chip_select(const int cs)
+{
+	const int pin = 7;	/* PIO6[7] = SPI_NOTCS */
+
+	if (cs)
+	{	/* assert SPI CSn */
+		STPIO_SET_PIN(PIO_PORT(6), pin, 0);
+	}
+	else
+	{	/* DE-assert SPI CSn */
+		STPIO_SET_PIN(PIO_PORT(6), pin, 1);
+	}
+
+	if (cs)
+	{	/* wait 250ns for CSn assert to propagate  */
+		udelay(1);	/* QQQ: can we make this shorter ? */
+	}
+}
+
+/*
+ * The SPI command uses this table of functions for controlling the SPI
+ * chip selects: it calls the appropriate function to control the SPI
+ * chip selects.
+ */
+spi_chipsel_type spi_chipsel[] =
+{
+	spi_chip_select
+};
+int spi_chipsel_cnt = sizeof(spi_chipsel) / sizeof(spi_chipsel[0]);
+
+#endif	/* CONFIG_SPI */
+
+
diff --git a/cpu/sh/stx7141/Makefile b/cpu/sh/stx7141/Makefile
new file mode 100644
index 0000000000..e400ff6238
--- /dev/null
+++ b/cpu/sh/stx7141/Makefile
@@ -0,0 +1,47 @@
+#
+# (C) Copyright 2008 STMicroelectronics.
+# Sean McGoogan <Sean.McGoogan@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(SOC).a
+
+COBJS	= stx7141.o
+SOBJS	=
+
+SRCS	:= $(START:.o=.S) $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS) $(SOBJS))
+START	:= $(addprefix $(obj),$(START))
+
+all:	$(obj).depend $(LIB)
+
+$(LIB):	$(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/cpu/sh/stx7141/stx7141.c b/cpu/sh/stx7141/stx7141.c
new file mode 100644
index 0000000000..27bbac6d6a
--- /dev/null
+++ b/cpu/sh/stx7141/stx7141.c
@@ -0,0 +1,258 @@
+/*
+ * (C) Copyright 2008-2009 STMicroelectronics.
+ *
+ * Stuart Menefy <stuart.menefy@st.com>
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/soc.h>
+#include <asm/stx7141reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+#include <asm/stbus.h>
+#include <ata.h>
+
+
+static void stx7141_clocks(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	bd_t *bd = gd->bd;
+
+	/*
+	 * FIXME
+	 * Gross hack to get the serial port working.
+	 * See the defintion of PCLK in drivers/stm-asc.c
+	 * for where this is used.
+	 */
+	bd->bi_emifrq = 100;
+}
+
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+
+#define ETHERNET_INTERFACE_ON	(1ul<<16)
+#define PHY_CLK_EXT		(1ul<<19)
+#define MAC_SPEED_SEL           (1ul<<20)
+#define PHY_INTF_SEL_MASK	(0x7ul<<24)
+#define ENMII			(1ul<<27)
+
+/* Remaining bits define pad functions, default appears to work */
+
+extern int stmac_default_pbl(void)
+{
+	return 32;
+}
+
+extern void stmac_set_mac_speed(int speed)
+{
+#ifdef QQQ	/* QQQ - TO DO */
+	/* QQQ: check this code is actually correct for the 7141 */
+	unsigned long sysconf = *STX7141_SYSCONF_SYS_CFG07;
+
+//	printf("QQQ: %s(speed=%u)\n", __FUNCTION__, speed); /* QQQ - DELETE */
+	/* MAC_SPEED_SEL = 0|1 */
+	if (speed == 100)
+		sysconf |= MAC_SPEED_SEL;
+	else if (speed == 10)
+		sysconf &= ~MAC_SPEED_SEL;
+
+	*STX7141_SYSCONF_SYS_CFG07 = sysconf;
+#endif		/* QQQ - TO DO */
+}
+
+/* ETH MAC pad configuration */
+static void stmac_eth_hw_setup(void)
+{
+#ifdef QQQ	/* QQQ - TO DO */
+	const unsigned long en_mii  = 1;
+	const unsigned long sel     = 0;
+	const unsigned long ext_clk = 0;
+
+	unsigned long sysconf = *STX7141_SYSCONF_SYS_CFG07;
+
+	/* Ethernet ON */
+	sysconf |= ETHERNET_INTERFACE_ON;
+
+	/* PHY EXT CLOCK: 0: provided by STX7141; 1: external */
+	if (ext_clk)
+		sysconf |= PHY_CLK_EXT;
+	else
+		sysconf &= ~PHY_CLK_EXT;
+
+	/* Default GMII/MII slection */
+	sysconf &= ~PHY_INTF_SEL_MASK;
+	sysconf |= ((sel<<24) & PHY_INTF_SEL_MASK);
+
+	/* MII mode */
+	if (en_mii)
+		sysconf |= ENMII;
+	else
+		sysconf &= ~ENMII;
+
+	*STX7141_SYSCONF_SYS_CFG07 = sysconf;
+#endif		/* QQQ - TO DO */
+}
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+int soc_init(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	bd_t *bd = gd->bd;
+	unsigned long reg;
+
+	stx7141_clocks();
+
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+	stmac_eth_hw_setup();
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+	bd->bi_devid = *STX7141_SYSCONF_DEVICEID_0;
+
+	/*
+	 * Reset Generation Configuration
+	 * Make sure reset period is shorter than WDT time-out,
+	 * and that the reset is not bypassed.
+	 *
+	 *	[28:27] = CPU_RST_OUT_BYPASS[1:0]
+	 *	[25:0]  = RESETOUT_PERIOD
+	 */
+	reg = *STX7141_SYSCONF_SYS_CFG09;
+	/* Propagate the reset signal */
+	reg = (reg & (~(3ul<<27))) | ((0ul)<<27);
+	/* use the default "short" reset time of 100us */
+	reg = (reg & (~0x03FFFFFFul)) | 0x00000A8Cul;
+	*STX7141_SYSCONF_SYS_CFG09 = reg;
+
+	/*
+	 * SH4 Boot Configuration
+	 * Unmask the reset signal from the SH4 core.
+	 *
+	 *	[4:3] = SH4_MASK_RST_OUT[1:0]
+	 *
+	 * SH4_MASK_RST_OUT[1]: mask rst_out signal from SH4-eCM core
+	 * SH4_MASK_RST_OUT[0]: mask rst_out signal from SH4-eSTB core
+	 */
+	reg = *STX7141_SYSCONF_SYS_CFG08;
+#if 1
+	/* Unmask the reset signal from the SH4-eSTB core */
+	reg = (reg & (~(1ul<<3))) | ((0ul)<<3);
+#else
+	/* Unmask the reset signal from the SH4-eCM core */
+	reg = (reg & (~(1ul<<4))) | ((0ul)<<4);
+#endif
+	*STX7141_SYSCONF_SYS_CFG08 = reg;
+
+	return 0;
+}
+
+
+#if defined(CONFIG_USB_OHCI_NEW)
+extern void stx7141_usb_init(void)
+{
+#ifdef QQQ	/* QQQ - TO DO */
+	unsigned long reg, req_reg;
+
+	/* Power on the USB */
+	reg = readl(STX7141_SYSCONF_SYS_CFG32);
+	reg &= ~(1ul<<4); /* USB_POWER_DOWN_REQ = 0 */
+	writel(reg, STX7141_SYSCONF_SYS_CFG32);
+
+	/* Work around for USB over-current detection chip being
+	 * active low, and the 7141 being active high.
+	 * Note this is an undocumented bit, which apparently enables
+	 * an inverter on the overcurrent signal.
+	 */
+	reg = readl(STX7141_SYSCONF_SYS_CFG06);
+	reg |= 1ul<<29;
+	writel(reg, STX7141_SYSCONF_SYS_CFG06);
+
+	/* USB oc */
+	SET_PIO_PIN(PIO_PORT(5), 6, STPIO_IN);
+	/* USB power */
+	SET_PIO_PIN(PIO_PORT(5), 7, STPIO_ALT_OUT);
+	STPIO_SET_PIN(PIO_PORT(5), 7, 1);
+
+	/* Set strap mode */
+#define STRAP_MODE	AHB2STBUS_STRAP_16_BIT
+	reg = readl(AHB2STBUS_STRAP);
+#if STRAP_MODE == 0
+	reg &= ~AHB2STBUS_STRAP_16_BIT;
+#else
+	reg |= STRAP_MODE;
+#endif
+	writel(reg, AHB2STBUS_STRAP);
+
+	/* Start PLL */
+	reg = readl(AHB2STBUS_STRAP);
+	writel(reg | AHB2STBUS_STRAP_PLL, AHB2STBUS_STRAP);
+	udelay(100000);	/* QQQ: can this delay be shorter ? */
+	writel(reg & (~AHB2STBUS_STRAP_PLL), AHB2STBUS_STRAP);
+	udelay(100000);	/* QQQ: can this delay be shorter ? */
+
+	req_reg =
+		(1<<21) |  /* Turn on read-ahead */
+		(5<<16) |  /* Opcode is store/load 32 */
+		(0<<15) |  /* Turn off write posting */
+		(1<<14) |  /* Enable threshold */
+		(3<<9)  |  /* 2**3 Packets in a chunk */
+		(0<<4)  |  /* No messages */
+		(8<<0);    /* Threshold is 256 */
+
+	do {
+		writel(req_reg, AHB2STBUS_STBUS_CONFIG);
+		reg = readl(AHB2STBUS_STBUS_CONFIG);
+	} while ((reg & 0x7FFFFFFF) != req_reg);
+#endif		/* QQQ - TO DO */
+}
+
+#endif /* defined(CONFIG_USB_OHCI_NEW) */
+
+
+#if defined(CONFIG_SH_STM_SATA)
+extern void stx7141_configure_sata(void)
+{
+	static int initialised_phy = 0;
+	unsigned long sysconf;
+
+	if (!initialised_phy)
+	{
+		/* enable reset  */
+		sysconf = *STX7141_SYSCONF_SYS_CFG04;
+		sysconf |= 1u<<9;
+		*STX7141_SYSCONF_SYS_CFG04 = sysconf;
+
+		sysconf = *STX7141_SYSCONF_SYS_CFG32;
+		sysconf |= 1u<<6;	/* [6] SATA_SLUMBER_POWER_MODE */
+		*STX7141_SYSCONF_SYS_CFG32 = sysconf;
+
+		/* initialize the SATA PHY */
+		stm_sata_miphy_init();
+
+		/* configure the SATA host controller */
+		stm_sata_probe();
+
+		initialised_phy = 1;
+	}
+}
+#endif	/* CONFIG_SH_STM_SATA */
+
+
diff --git a/cpu/sh/stx7200/Makefile b/cpu/sh/stx7200/Makefile
new file mode 100644
index 0000000000..47279021e8
--- /dev/null
+++ b/cpu/sh/stx7200/Makefile
@@ -0,0 +1,47 @@
+#
+# (C) Copyright 2007 STMicroelectronics.
+# Stuart Menefy <stuart.menefy@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(SOC).a
+
+COBJS	= stx7200.o
+SOBJS	=
+
+SRCS	:= $(START:.o=.S) $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS) $(SOBJS))
+START	:= $(addprefix $(obj),$(START))
+
+all:	$(obj).depend $(LIB)
+
+$(LIB):	$(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/cpu/sh/stx7200/stx7200.c b/cpu/sh/stx7200/stx7200.c
new file mode 100644
index 0000000000..58cf0d3270
--- /dev/null
+++ b/cpu/sh/stx7200/stx7200.c
@@ -0,0 +1,553 @@
+/*
+ * (C) Copyright 2007, 2009 STMicroelectronics.
+ *
+ * Stuart Menefy <stuart.menefy@st.com>
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/soc.h>
+#include <asm/stx7200reg.h>
+#include <asm/io.h>
+#include <asm/pio.h>
+#include <asm/stbus.h>
+#include <ata.h>
+
+#define PIO_BASE  ST40_PIO0_REGS_BASE
+
+static void stx7200_clocks(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	bd_t *bd = gd->bd;
+
+	/*
+	 * FIXME
+	 * Gross hack to get the serial port working.
+	 * See the defintion of PCLK in drivers/stm-asc.c
+	 * for where this is used.
+	 */
+	bd->bi_emifrq = 100;
+}
+
+#ifdef CONFIG_DRIVER_NETSTMAC
+
+#define MII_MODE		(1<<0)
+#define PHY_CLK_EXT             (1<<2)
+#define MAC_SPEED               (1<<4)
+#define VCI_ACK_SOURCE          (1<<6)
+#define RESET                   (1<<8)
+#define DISABLE_MSG_READ        (1<<12)
+#define DISABLE_MSG_WRITE       (1<<14)
+/* Remaining bits define pad functions, default appears to work */
+
+extern int stmac_default_pbl(void)
+{
+	return 32;
+}
+
+extern void stmac_set_mac_speed(int speed)
+{
+#if defined(CONFIG_STMAC_MAC0)
+	const int mac = 0;    /* First MAC */
+#elif defined(CONFIG_STMAC_MAC1)
+	const int mac = 1;    /* Second MAC */
+#endif
+	unsigned long sysconf = *STX7200_SYSCONF_SYS_CFG41;
+
+	if (speed == 100)
+		sysconf |= (MAC_SPEED << mac);
+	else if (speed == 10)
+		sysconf &= ~(MAC_SPEED << mac);
+
+	*STX7200_SYSCONF_SYS_CFG41 = sysconf;
+}
+
+/* ETH MAC pad configuration */
+extern void stx7200_configure_ethernet(
+	int mac, int rmii, int ext_clk, int phy_bus)
+{
+	unsigned long sysconf;
+
+	sysconf = *STX7200_SYSCONF_SYS_CFG41;
+
+	/* Route Ethernet pins to output */
+	/* bit26-16: conf_pad_eth(10:0) */
+	if (mac == 0) {
+		/* MII0: conf_pad_eth(0) = 0 (ethernet) */
+		sysconf &= ~(1<<16);
+	} else {
+		/* MII1: conf_pad_eth(2) = 0, (3)=0, (4)=0, (9)=0, (10)=0 (eth)
+		 * MII1: conf_pad_eth(6) = 0 (MII1TXD[0] = output)
+		 * (remaining bits have no effect in ethernet mode */
+		sysconf &= ~( (1<<(16+2)) | (1<<(16+3)) | (1<<(16+4)) |
+			      (1<<(16+5)) | (1<<(16+6)) | (1<<(16+7)) |
+			      (1<<(16+8)) | (1<<(16+9)) | (1<<(16+10))  );
+	}
+
+	/* DISABLE_MSG_FOR_WRITE=0 */
+	sysconf &= ~(DISABLE_MSG_WRITE << mac);
+
+	/* DISABLE_MSG_FOR_READ=0 */
+	sysconf &= ~(DISABLE_MSG_READ << mac);
+
+	/* VCI_ACK_SOURCE = 0 */
+        sysconf &= ~(VCI_ACK_SOURCE << mac);
+
+	/* ETHERNET_INTERFACE_ON (aka RESET) = 1 */
+        sysconf |= (RESET << mac);
+
+	/* RMII_MODE */
+	if (rmii)
+		sysconf |= (MII_MODE << mac);
+	else
+		sysconf &= ~(MII_MODE << mac);
+
+	/* PHY_CLK_EXT */
+	if (ext_clk)
+		sysconf |= (PHY_CLK_EXT << mac);
+	else
+		sysconf &= ~(PHY_CLK_EXT << mac);
+
+	*STX7200_SYSCONF_SYS_CFG41 = sysconf;
+}
+#endif	/* CONFIG_DRIVER_NETSTMAC */
+
+int soc_init(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	bd_t *bd = gd->bd;
+
+	stx7200_clocks();
+
+	bd->bi_devid = *STX7200_SYSCONF_DEVICEID_0;
+
+	/*  Make sure reset period is shorter than WDT timeout */
+	*STX7200_SYSCONF_SYS_CFG09 = (*STX7200_SYSCONF_SYS_CFG09 & 0xFF000000) | 0x000A8C;
+
+	return 0;
+}
+
+
+#if defined(CONFIG_USB_OHCI_NEW)
+
+#ifdef CONFIG_USB_STI7200_CUT1_SOFT_JTAG_RESET_WORKAROUND
+/*
+ * The following function *may* be required for boards
+ * with cut 1.x of the STi7200 chip. This function must
+ * *not* be used on cut 2.x (or later) of that chip.
+ * There is a board modifiction comprising a R-C delay
+ * which if applied negates the requirement to use this
+ * workaround, so it is optional. However, it should be safe
+ * to use this workaround with any cut 1.x silicon,
+ * irrespective of the presence of the R-C delay board fix.
+ *
+ * NOTE: Register reads and USB_tdo variable:
+ * All the reads are for USB_tdo, which is not used in this code.
+ * They were commented-out debugging prints following each read,
+ * so it's entirely possible that the reads could be dropped. But
+ * they will affect timing and so might be significant. In the
+ * absence of any understanding of how exactly this "black box"
+ * code works, leave them in for safety.
+ */
+static void usb_soft_jtag_reset(void)
+{
+	int i, j;
+	unsigned long USB_tdo;
+
+	/* ENABLE SOFT JTAG */
+	writel(0x00000040, STX7200_SYSCONF_SYS_CFG33);
+
+	/* RELEASE TAP RESET */
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+
+	/* SET TAP INTO IDLE STATE */
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+
+	/* SET TAP INTO SHIFT IR STATE */
+	writel(0x0000004c, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004d, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004c, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004d, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+
+	/* SHIFT DATA IN TDI = 101 select TCB*/
+	writel(0x00000046, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000047, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004E, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004F, STX7200_SYSCONF_SYS_CFG33);
+
+	/* SET TAP INTO IDLE MODE */
+	writel(0x0000004c, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004d, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+
+	/* SET TAP INTO SHIFT DR STATE */
+	writel(0x0000004c, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004d, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+
+	/* SHIFT DATA IN TCB */
+	for (i = 0; i <= 53; i++)
+	{
+		if ((i == 0) || (i == 1) || (i == 19) || (i == 36))
+		{
+			writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+			writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+		}
+		if ((i == 53))
+		{
+			writel(0x0000004c, STX7200_SYSCONF_SYS_CFG33);
+			writel(0x0000004D, STX7200_SYSCONF_SYS_CFG33);
+		}
+		writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+		writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+	}
+
+	/* SET TAP INTO IDLE MODE */
+	writel(0x0000004c, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004d, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+
+	for (i = 0; i <= 53; i++)
+	{
+		writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+		writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+		USB_tdo = readl(STX7200_SYSCONF_SYS_CFG00);
+	}
+
+	writel(0x00000040, STX7200_SYSCONF_SYS_CFG33);
+
+	/* RELEASE TAP RESET */
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+
+	/* SET TAP INTO IDLE STATE */
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+
+	/* SET TAP INTO SHIFT IR STATE */
+	writel(0x0000004c, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004d, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004c, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004d, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+
+	/* SHIFT DATA IN TDI = 110 select TPR */
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000046, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000047, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004E, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004F, STX7200_SYSCONF_SYS_CFG33);
+
+	/* SET TAP INTO IDLE MODE */
+	writel(0x0000004c, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004d, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+
+	/* SET TAP INTO SHIFT DR STATE */
+	writel(0x0000004c, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004d, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+
+	/* SHIFT DATA IN TDO */
+	for (i = 0; i <= 366; i++)
+	{
+		writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+		writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+		USB_tdo = readl(STX7200_SYSCONF_SYS_CFG00);
+	}
+
+	for (j = 0; j < 2; j++)
+	{
+		for (i = 0; i <= 365; i++)
+		{
+			if ((i == 71) || (i == 192) || (i == 313))
+			{
+				writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+				writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+			}
+			writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+			writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+			if ((i == 365))
+			{
+				writel(0x0000004c, STX7200_SYSCONF_SYS_CFG33);
+				writel(0x0000004d, STX7200_SYSCONF_SYS_CFG33);
+			}
+		}
+	}
+
+	for (i = 0; i <= 366; i++)
+	{
+		writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+		writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+		USB_tdo = readl(STX7200_SYSCONF_SYS_CFG00);
+	}
+
+	/* SET TAP INTO IDLE MODE */
+	writel(0x0000004C, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004D, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004C, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004D, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+
+	/* SET TAP INTO SHIFT IR STATE */
+	writel(0x0000004c, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004d, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004c, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004d, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+
+	/* SHIFT DATA IN TDI = 101 select TCB */
+	writel(0x00000046, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000047, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004E, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004F, STX7200_SYSCONF_SYS_CFG33);
+
+	/* SET TAP INTO IDLE MODE */
+	writel(0x0000004c, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004d, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+
+	/* SET TAP INTO SHIFT DR STATE */
+	writel(0x0000004c, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004d, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+
+	/* SHIFT DATA IN TCB */
+	for (i = 0; i <= 53; i++)
+	{
+		if ((i == 0) || (i == 1) || (i == 18) || (i == 19)
+		    || (i == 36) || (i == 37))
+		{
+			writel(0x00000046, STX7200_SYSCONF_SYS_CFG33);
+			writel(0x00000047, STX7200_SYSCONF_SYS_CFG33);
+		}
+		if ((i == 53))
+		{
+			writel(0x0000004c, STX7200_SYSCONF_SYS_CFG33);
+			writel(0x0000004D, STX7200_SYSCONF_SYS_CFG33);
+		}
+		writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+		writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+	}
+
+	/* SET TAP INTO IDLE MODE */
+	writel(0x0000004c, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004d, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004c, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004d, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+
+	for (i = 0; i <= 53; i++)
+	{
+		writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+		writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+		USB_tdo = readl(STX7200_SYSCONF_SYS_CFG00);
+	}
+
+	/* SET TAP INTO SHIFT IR STATE */
+	writel(0x0000004c, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004d, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004c, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004d, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+
+	/* SHIFT DATA IN TDI = 110 select TPR */
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000046, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000047, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004E, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004F, STX7200_SYSCONF_SYS_CFG33);
+
+	/* SET TAP INTO IDLE MODE */
+	writel(0x0000004c, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004d, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+
+	/* SET TAP INTO SHIFT DR STATE */
+	writel(0x0000004c, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004d, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+
+	for (i = 0; i <= 366; i++)
+	{
+		writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+		writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+		USB_tdo = readl(STX7200_SYSCONF_SYS_CFG00);
+	}
+
+	/* SET TAP INTO IDLE MODE */
+	writel(0x0000004c, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004d, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004c, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x0000004d, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000044, STX7200_SYSCONF_SYS_CFG33);
+	writel(0x00000045, STX7200_SYSCONF_SYS_CFG33);
+
+	/* 20ms delay */
+	udelay(20000);
+
+	/* ENABLE SOFT JTAG */
+	writel(0x00000040, STX7200_SYSCONF_SYS_CFG33);
+}
+#endif	/* CONFIG_USB_STI7200_CUT1_SOFT_JTAG_RESET_WORKAROUND */
+
+extern void stx7200_usb_init(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	const bd_t * const bd = gd->bd;
+	unsigned long reg;
+	const unsigned char power_pins[3] = {1, 3, 4};
+	const unsigned char oc_pins[3] = {0, 2, 5};
+#if CFG_USB_BASE == CFG_USB0_BASE
+	const size_t port = 0;
+#elif CFG_USB_BASE == CFG_USB1_BASE
+	const size_t port = 1;
+#elif CFG_USB_BASE == CFG_USB2_BASE
+	const size_t port = 2;
+#else
+#error Unknown USB Host Controller Base Address
+#endif
+
+	/* ClockgenB powers up with all the frequency synths bypassed.
+	 * Enable them all here.  Without this, USB 1.1 doesn't work,
+	 * as it needs a 48MHz clock which is separate from the USB 2
+	 * clock which is derived from the SATA clock. */
+	writel(0, STX7200_CLOCKGENB_OUT_MUX_CFG);
+
+	/* route USB and parts of MAFE instead of DVO.*/
+	/* DVO output selection (probably ignored). */
+	reg = readl(STX7200_SYSCONF_SYS_CFG07);
+	reg &= ~(1ul<<26); /* conf_pad_pio[2] = 0 */
+	reg &= ~(1ul<<27); /* conf_pad_pio[3] = 0 */
+	writel(reg, STX7200_SYSCONF_SYS_CFG07);
+
+	/* Enable soft JTAG mode for USB and SATA */
+	reg = readl(STX7200_SYSCONF_SYS_CFG33);
+	reg |= (1ul<<6);    /* soft_jtag_en = 1 */
+	reg &= ~(0xful<<0); /* tck = tdi = trstn_usb = tms_usb = 0 */
+	writel(reg, STX7200_SYSCONF_SYS_CFG33);
+
+#ifdef CONFIG_USB_STI7200_CUT1_SOFT_JTAG_RESET_WORKAROUND
+	/* reset USB HC via the JTAG scan path */
+	usb_soft_jtag_reset();
+#endif
+
+	/* USB power */
+	SET_PIO_PIN(PIO_PORT(7), power_pins[port], STPIO_ALT_OUT);
+	STPIO_SET_PIN(PIO_PORT(7), power_pins[port], 1);
+
+	/* USB Over-Current */
+ 	if (STX7200_DEVICEID_CUT(bd->bi_devid) < 2)
+		SET_PIO_PIN(PIO_PORT(7), oc_pins[port], STPIO_ALT_BIDIR);
+	else
+		SET_PIO_PIN(PIO_PORT(7), oc_pins[port], STPIO_IN);
+
+	/* tusb_powerdown_req[port] = 0 */
+	reg = readl(STX7200_SYSCONF_SYS_CFG22);
+	reg &= ~(1ul<<(port+3));
+	writel(reg, STX7200_SYSCONF_SYS_CFG22);
+
+	/* Set strap mode */
+#define STRAP_MODE	AHB2STBUS_STRAP_16_BIT
+	reg = readl(AHB2STBUS_STRAP);
+#if STRAP_MODE == 0
+	reg &= ~AHB2STBUS_STRAP_16_BIT;
+#else
+	reg |= STRAP_MODE;
+#endif
+	writel(reg, AHB2STBUS_STRAP);
+
+	/* Start PLL */
+	reg = readl(AHB2STBUS_STRAP);
+	writel(reg | AHB2STBUS_STRAP_PLL, AHB2STBUS_STRAP);
+	udelay(100000);	/* QQQ: can this delay be shorter ? */
+	writel(reg & (~AHB2STBUS_STRAP_PLL), AHB2STBUS_STRAP);
+	udelay(100000);	/* QQQ: can this delay be shorter ? */
+
+	/* Set the STBus Opcode Config for 32-bit access */
+	writel(AHB2STBUS_STBUS_OPC_32BIT, AHB2STBUS_STBUS_OPC);
+
+	/* Set the Message Size Config to 4 packets per message */
+	writel(AHB2STBUS_MSGSIZE_4, AHB2STBUS_MSGSIZE);
+
+	/* Set the Chunk Size Config to 4 packets per chunk */
+	writel(AHB2STBUS_CHUNKSIZE_4, AHB2STBUS_CHUNKSIZE);
+}
+
+#endif /* defined(CONFIG_USB_OHCI_NEW) */
+
+
+#if defined(CONFIG_SH_STM_SATA)
+extern void stx7200_configure_sata(void)
+{
+	static int initialised_phy = 0;
+
+	if (!initialised_phy)
+	{
+		/* initialize the SATA PHY */
+		stm_sata_miphy_init();
+
+		/* configure the SATA host controller */
+		stm_sata_probe();
+
+		initialised_phy = 1;
+	}
+}
+#endif	/* CONFIG_SH_STM_SATA */
+
+
diff --git a/cpu/sh/u-boot.lds b/cpu/sh/u-boot.lds
new file mode 100644
index 0000000000..2b60636c1f
--- /dev/null
+++ b/cpu/sh/u-boot.lds
@@ -0,0 +1,77 @@
+/*
+ * (C) Copyright 2007-2009 STMicroelectronics.
+ *
+ * Stuart Menefy <stuart.menefy@st.com>
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_ARCH(sh4)
+ENTRY(_start)
+
+SECTIONS
+{
+	.text ALIGN(0x4):
+	{
+		__text_start = .;
+		cpu/sh/start.o (.text.init)
+		*(.text.init)		/* pre-initialization code */
+		. = ALIGN(32);		/* align to a cache-line */
+		*(.data.init)		/* pre-initialization data */
+		*(.text)		/* post-initialization code */
+		__text_end = .;
+	}
+
+	.rodata ALIGN(0x4):
+	{
+		__rodata_start = .;
+		*(.rodata)
+		__rodata_end = .;
+	}
+
+	.data ALIGN(0x4):
+	{
+		__data_start = .;
+		*(.data)
+		__data_end = .;
+	}
+
+	.u_boot_cmd ALIGN(0x4):
+	{
+		__u_boot_cmd_start = .;
+		*(.u_boot_cmd)
+		__u_boot_cmd_end = .;
+	}
+
+	_uboot_end_data = .;
+
+	.bss ALIGN(0x4):
+	{
+		__bss_start = .;
+		*(.bss)
+		*(COMMON)		/* ensure common data is initialized */
+		__bss_end = .;
+	}
+	_uboot_end = .;
+}
diff --git a/cpu/sh/usb.c b/cpu/sh/usb.c
new file mode 100644
index 0000000000..1f9bcc6df8
--- /dev/null
+++ b/cpu/sh/usb.c
@@ -0,0 +1,163 @@
+/*
+ * Copyright (C) 2007-2009 STMicroelectronics Limited
+ * Stuart Menefy <stuart.menefy@st.com>
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/stbus.h>
+#include <asm/io.h>
+
+
+#define mdelay(n) ({unsigned long msec=(n); while (msec--) udelay(1000);})
+
+
+#if defined(CONFIG_SH_STB7100)
+extern void stb7100_usb_init(void);
+#elif defined(CONFIG_SH_STX5197)
+extern void stx5197_usb_init(void);
+#elif defined(CONFIG_SH_STX7105)
+extern int stx7105_usb_init(int port, int over_current, int power_ctrl);
+#elif defined(CONFIG_SH_STX7111)
+extern void stx7111_usb_init(void);
+#elif defined(CONFIG_SH_STX7141)
+extern void stx7141_usb_init(void);
+#elif defined(CONFIG_SH_STX7200)
+extern void stx7200_usb_init(void);
+#else
+#error Missing Device Definitions!
+#endif
+
+#if defined(CONFIG_USB_OHCI_NEW) && defined(CFG_USB_OHCI_CPU_INIT)
+
+extern int usb_cpu_init(void)
+{
+#if defined(CONFIG_SH_STB7100)
+	stb7100_usb_init();
+#elif defined(CONFIG_SH_STX5197)
+	stx5197_usb_init();
+#elif defined(CONFIG_SH_STX7105)
+#ifdef CONFIG_SH_STX_STX7105_USB_PORT0
+	stx7105_usb_init(0,
+			 CONFIG_SH_STX_STX7105_USB_OC,
+			 CONFIG_SH_STX_STX7105_USB_PW);
+#endif
+#ifdef CONFIG_SH_STX_STX7105_USB_PORT1
+	stx7105_usb_init(1,
+			 CONFIG_SH_STX_STX7105_USB_OC,
+			 CONFIG_SH_STX_STX7105_USB_PW);
+#endif
+#elif defined(CONFIG_SH_STX7111)
+	stx7111_usb_init();
+#elif defined(CONFIG_SH_STX7141)
+	stx7141_usb_init();
+#elif defined(CONFIG_SH_STX7200)
+	stx7200_usb_init();
+#endif
+	return 0;
+}
+
+extern int usb_cpu_stop(void)
+{
+	return 0;
+}
+
+extern int usb_cpu_init_fail(void)
+{
+	return 0;
+}
+
+extern int ST40_start_host_control(unsigned int flags)
+{
+	static int initialized = 0;
+	unsigned long reg, req_reg;
+
+	if (initialized)
+		return 0;	/* already initialized */
+
+	if (flags &
+	    (USB_FLAGS_STRAP_8BIT | USB_FLAGS_STRAP_16BIT)) {
+		/* Set strap mode */
+		reg = readl(AHB2STBUS_STRAP);
+		if (flags & USB_FLAGS_STRAP_16BIT)
+			reg |= AHB2STBUS_STRAP_16_BIT;
+		else
+			reg &= ~AHB2STBUS_STRAP_16_BIT;
+		writel(reg, AHB2STBUS_STRAP);
+	}
+
+	if (flags & USB_FLAGS_STRAP_PLL) {
+		/* Start PLL */
+		reg = readl(AHB2STBUS_STRAP);
+		writel(reg | AHB2STBUS_STRAP_PLL, AHB2STBUS_STRAP);
+		mdelay(30);
+		writel(reg & (~AHB2STBUS_STRAP_PLL), AHB2STBUS_STRAP);
+		mdelay(30);
+	}
+
+	if (flags & USB_FLAGS_OPC_MSGSIZE_CHUNKSIZE) {
+		/* Set the STBus Opcode Config for load/store 32 */
+		writel(AHB2STBUS_STBUS_OPC_32BIT, AHB2STBUS_STBUS_OPC);
+
+		/* Set the Message Size Config to n packets per message */
+		writel(AHB2STBUS_MSGSIZE_4, AHB2STBUS_MSGSIZE);
+
+		/* Set the chunksize to n packets */
+		writel(AHB2STBUS_CHUNKSIZE_4, AHB2STBUS_CHUNKSIZE);
+	}
+
+	if (flags &
+	    (USB_FLAGS_STBUS_CONFIG_THRESHOLD128 |
+	     USB_FLAGS_STBUS_CONFIG_THRESHOLD256)) {
+
+		if (flags & USB_FLAGS_STBUS_CONFIG_THRESHOLD128)
+			req_reg =
+				(1<<21) |  /* Turn on read-ahead */
+				(5<<16) |  /* Opcode is store/load 32 */
+				(0<<15) |  /* Turn off write posting */
+				(1<<14) |  /* Enable threshold */
+				(3<<9)  |  /* 2**3 Packets in a chunk */
+				(0<<4)  |  /* No messages */
+				7;         /* Threshold is 128 */
+		else
+			req_reg =
+				(1<<21) |  /* Turn on read-ahead */
+				(5<<16) |  /* Opcode is store/load 32 */
+				(0<<15) |  /* Turn off write posting */
+				(1<<14) |  /* Enable threshold */
+				(3<<9)  |  /* 2**3 Packets in a chunk */
+				(0<<4)  |  /* No messages */
+				(8<<0);    /* Threshold is 256 */
+
+		do {
+			writel(req_reg, AHB2STBUS_STBUS_CONFIG);
+			reg = readl(AHB2STBUS_STBUS_CONFIG);
+		} while ((reg & 0x7FFFFFFF) != req_reg);
+	}
+
+	initialized = 1;
+
+	return 0;
+}
+
+#endif /* defined(CONFIG_USB_OHCI_NEW) && defined(CFG_USB_OHCI_CPU_INIT) */
+
diff --git a/disk/part.c b/disk/part.c
index 56b9427c26..76208be262 100644
--- a/disk/part.c
+++ b/disk/part.c
@@ -145,7 +145,7 @@ void dev_print (block_dev_desc_t *dev_desc)
 		lba = dev_desc->lba;
 
 		lba512 = (lba * (dev_desc->blksz/512));
-		mb = (10 * lba512) / 2048;	/* 2048 = (1024 * 1024) / 512 MB */
+		mb = (10 * lba512) / 2048;	/* 2048 = (1024 * 1024) / 512 MiB */
 		/* round to 1 digit */
 		mb_quot	= mb / 10;
 		mb_rem	= mb - (10 * mb_quot);
@@ -158,13 +158,13 @@ void dev_print (block_dev_desc_t *dev_desc)
 			printf ("            Supports 48-bit addressing\n");
 #endif
 #if defined(CFG_64BIT_LBA) && defined(CFG_64BIT_VSPRINTF)
-		printf ("            Capacity: %ld.%ld MB = %ld.%ld GB (%qd x %ld)\n",
+		printf ("            Capacity: %ld.%ld MiB = %ld.%ld GiB (%qd x %ld)\n",
 			mb_quot, mb_rem,
 			gb_quot, gb_rem,
 			lba,
 			dev_desc->blksz);
 #else
-		printf ("            Capacity: %ld.%ld MB = %ld.%ld GB (%ld x %ld)\n",
+		printf ("            Capacity: %ld.%ld MiB = %ld.%ld GiB (%ld x %ld)\n",
 			mb_quot, mb_rem,
 			gb_quot, gb_rem,
 			(ulong)lba,
diff --git a/disk/part_mac.c b/disk/part_mac.c
index d303a73f29..e85d1c27fc 100644
--- a/disk/part_mac.c
+++ b/disk/part_mac.c
@@ -95,7 +95,7 @@ void print_part_mac (block_dev_desc_t *dev_desc)
 
 	n  = ddesc.blk_count;
 
-	mb = ldiv(n, ((1024 * 1024) / ddesc.blk_size)); /* MB */
+	mb = ldiv(n, ((1024 * 1024) / ddesc.blk_size)); /* MiB */
 	/* round to 1 digit */
 	mb.rem *= 10 * ddesc.blk_size;
 	mb.rem += 512 * 1024;
@@ -107,7 +107,7 @@ void print_part_mac (block_dev_desc_t *dev_desc)
 
 
 	printf ("Block Size=%d, Number of Blocks=%d, "
-		"Total Capacity: %ld.%ld MB = %ld.%ld GB\n"
+		"Total Capacity: %ld.%ld MiB = %ld.%ld GiB\n"
 		"DeviceType=0x%x, DeviceId=0x%x\n\n"
 		"   #:                 type name"
 		"                   length   base       (size)\n",
@@ -139,7 +139,7 @@ void print_part_mac (block_dev_desc_t *dev_desc)
 		/* update partition count */
 		n = mpart.map_count;
 
-		c      = 'k';
+		c      = 'K';
 		bytes  = mpart.block_count;
 		bytes /= (1024 / ddesc.blk_size);  /* kB; assumes blk_size == 512 */
 		if (bytes >= 1024) {
@@ -151,7 +151,7 @@ void print_part_mac (block_dev_desc_t *dev_desc)
 			c = 'G';
 		}
 
-		printf ("%20.32s %-18.32s %10u @ %-10u (%3ld%c)\n",
+		printf ("%20.32s %-18.32s %10u @ %-10u (%3ld%ciB)\n",
 			mpart.type,
 			mpart.name,
 			mpart.block_count,
diff --git a/drivers/mtd/cfi_flash.c b/drivers/mtd/cfi_flash.c
index 5579a1efc1..4dbeb03a12 100644
--- a/drivers/mtd/cfi_flash.c
+++ b/drivers/mtd/cfi_flash.c
@@ -348,7 +348,7 @@ unsigned long flash_init (void)
 		size += flash_info[i].size = flash_get_size (bank_base[i], i);
 		if (flash_info[i].flash_id == FLASH_UNKNOWN) {
 #ifndef CFG_FLASH_QUIET_TEST
-			printf ("## Unknown FLASH on Bank %d - Size = 0x%08lx = %ld MB\n",
+			printf ("## Unknown FLASH on Bank %d - Size = 0x%08lx = %ld MiB\n",
 				i+1, flash_info[i].size, flash_info[i].size << 20);
 #endif /* CFG_FLASH_QUIET_TEST */
 		}
@@ -497,8 +497,10 @@ int flash_erase (flash_info_t * info, int s_first, int s_last)
 			if (flash_full_status_check
 			    (info, sect, info->erase_blk_tout, "erase")) {
 				rcode = 1;
-			} else
+			} else {
+				flash_write_cmd (info, sect, 0, info->cmd_reset);
 				putc ('.');
+			}
 		}
 	}
 	puts (" done\n");
@@ -518,7 +520,7 @@ void flash_print_info (flash_info_t * info)
 
 	printf ("CFI conformant FLASH (%d x %d)",
 		(info->portwidth << 3), (info->chipwidth << 3));
-	printf ("  Size: %ld MB in %d Sectors\n",
+	printf ("  Size: %ld MiB in %d Sectors\n",
 		info->size >> 20, info->sector_count);
 	printf ("  ");
 	switch (info->vendor) {
@@ -562,6 +564,9 @@ void flash_print_info (flash_info_t * info)
 		int erased;
 		volatile unsigned long *flash;
 
+		/* make sure the sector is in read mode first */
+		flash_write_cmd (info, i, 0, info->cmd_reset);
+
 		/*
 		 * Check if whole sector is erased
 		 */
@@ -607,6 +612,7 @@ int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
 	int aln;
 	cfiword_t cword;
 	int i, rc;
+	const ulong dot_stride = 16ul << 10;	/* 16 KiB */
 
 #ifdef CFG_FLASH_USE_BUFFER_WRITE
 	int buffered_size;
@@ -672,6 +678,10 @@ int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
 			return rc;
 		wp += info->portwidth;
 		cnt -= info->portwidth;
+		/* print a dot every 'dot_stride' bytes */
+		/* Note: dependant on alignment may print one too many */
+		if ((wp % dot_stride) == 0x0ul)
+			putc ('.');
 	}
 #endif /* CFG_FLASH_USE_BUFFER_WRITE */
 	if (cnt == 0) {
@@ -727,6 +737,7 @@ int flash_real_protect (flash_info_t * info, long sector, int prot)
 			}
 		}
 	}
+	flash_write_cmd (info, sector, 0, info->cmd_reset);
 	return retcode;
 }
 
@@ -925,6 +936,19 @@ static void flash_write_cmd (flash_info_t * info, flash_sect_t sect, uint offset
 	volatile cfiptr_t addr;
 	cfiword_t cword;
 
+	/*
+	 *	We need to ensure that sizeof(cword) >= info->portwidth,
+	 *	otherwise, flash_make_cmd() will scribble over memory
+	 *	it should not! This results in a stack corruption,
+	 *	and madness follows...	Sean McGoogan 2009-08-20.
+	 */
+	if ( info->portwidth > sizeof(cword) ) {
+		printf("ERROR: %s() ignoring write request (info->portwidth=%u)\n",
+			__FUNCTION__,
+			info->portwidth);
+		return;
+	}
+
 	addr.cp = flash_make_addr (info, sect, offset);
 	flash_make_cmd (info, cmd, &cword);
 	switch (info->portwidth) {
@@ -1141,7 +1165,7 @@ static int flash_detect_cfi (flash_info_t * info)
 		for (info->chipwidth = FLASH_CFI_BY8;
 		     info->chipwidth <= info->portwidth;
 		     info->chipwidth <<= 1) {
-			flash_write_cmd (info, 0, 0, info->cmd_reset);
+			flash_write_cmd (info, 0, 0, FLASH_CMD_RESET);
 			for (cfi_offset=0; cfi_offset < sizeof(flash_offset_cfi)/sizeof(uint); cfi_offset++) {
 				flash_write_cmd (info, 0, flash_offset_cfi[cfi_offset], FLASH_CMD_CFI);
 				if (flash_isequal (info, 0, FLASH_OFFSET_CFI_RESP, 'Q')
@@ -1267,6 +1291,7 @@ ulong flash_get_size (ulong base, int banknum)
 					num_erase_regions, NUM_ERASE_REGIONS);
 				break;
 			}
+
 			if (geometry_reversed)
 				tmp = flash_read_long (info, 0,
 					       FLASH_OFFSET_ERASE_REGIONS +
@@ -1281,6 +1306,20 @@ ulong flash_get_size (ulong base, int banknum)
 			erase_region_count = (tmp & 0xffff) + 1;
 			debug ("erase_region_count = %d erase_region_size = %d\n",
 				erase_region_count, erase_region_size);
+
+				/*
+				 * ensure we do not violate array bounds, specifically:
+				 *	flash_info_t.start[CFG_MAX_FLASH_SECT];
+				 *	flash_info_t.protect[CFG_MAX_FLASH_SECT];
+				 */
+			if (erase_region_count > CFG_MAX_FLASH_SECT) {
+				printf ("Error: Number of Sectors (%d) > CFG_MAX_FLASH_SECT (%d)\n",
+					erase_region_count,
+					CFG_MAX_FLASH_SECT);
+				flash_write_cmd (info, 0, 0, info->cmd_reset);
+				return 0;	/* return, to avoid corrupting any memory */
+			}
+
 			for (j = 0; j < erase_region_count; j++) {
 				info->start[sect_cnt] = sector;
 				sector += (erase_region_size * size_ratio);
@@ -1291,10 +1330,20 @@ ulong flash_get_size (ulong base, int banknum)
 				switch (info->vendor) {
 				case CFI_CMDSET_INTEL_EXTENDED:
 				case CFI_CMDSET_INTEL_STANDARD:
+					/* for multi-bank devices, the READ_ID command
+					 * must be issued on a per sector basis */
+					flash_write_cmd (info, sect_cnt,
+                                                         info->cfi_offset,
+                                                         FLASH_CMD_READ_ID);
 					info->protect[sect_cnt] =
 						flash_isset (info, sect_cnt,
 							     FLASH_OFFSET_PROTECT,
 							     FLASH_STATUS_PROTECT);
+					/* for multi-bank devices, the RESET command
+					 * must be issued on a per sector basis */
+					flash_write_cmd (info, sect_cnt,
+                                                         info->cfi_offset,
+                                                         FLASH_CMD_RESET);
 					break;
 				default:
 					info->protect[sect_cnt] = 0; /* default: not protected */
@@ -1302,6 +1351,11 @@ ulong flash_get_size (ulong base, int banknum)
 
 				sect_cnt++;
 			}
+                        switch (info->vendor) {
+                        case CFI_CMDSET_INTEL_EXTENDED:
+                        case CFI_CMDSET_INTEL_STANDARD:
+                            flash_write_cmd (info, 0, info->cfi_offset, FLASH_CMD_CFI);
+                        }
 		}
 
 		info->sector_count = sect_cnt;
@@ -1346,13 +1400,18 @@ static flash_sect_t find_sector (flash_info_t * info, ulong addr)
 static int flash_write_cfiword (flash_info_t * info, ulong dest,
 				cfiword_t cword)
 {
+	flash_sect_t sector;
 	cfiptr_t ctladdr;
 	cfiptr_t cptr;
-	int flag;
+	int flag, retcode;
 
 	ctladdr.cp = flash_make_addr (info, 0, 0);
 	cptr.cp = (uchar *) dest;
 
+	/* put the flash in read mode */
+	sector = find_sector (info, dest);
+	flash_write_cmd (info, sector, 0, info->cmd_reset);
+
 	/* Check if Flash is (sufficiently) erased */
 	switch (info->portwidth) {
 	case FLASH_CFI_8BIT:
@@ -1379,8 +1438,8 @@ static int flash_write_cfiword (flash_info_t * info, ulong dest,
 	switch (info->vendor) {
 	case CFI_CMDSET_INTEL_EXTENDED:
 	case CFI_CMDSET_INTEL_STANDARD:
-		flash_write_cmd (info, 0, 0, FLASH_CMD_CLEAR_STATUS);
-		flash_write_cmd (info, 0, 0, FLASH_CMD_WRITE);
+		flash_write_cmd (info, sector, 0, FLASH_CMD_CLEAR_STATUS);
+		flash_write_cmd (info, sector, 0, FLASH_CMD_WRITE);
 		break;
 	case CFI_CMDSET_AMD_EXTENDED:
 	case CFI_CMDSET_AMD_STANDARD:
@@ -1408,8 +1467,10 @@ static int flash_write_cfiword (flash_info_t * info, ulong dest,
 	if (flag)
 		enable_interrupts ();
 
-	return flash_full_status_check (info, find_sector (info, dest),
+	retcode = flash_full_status_check (info, sector,
 					info->write_tout, "write");
+	flash_write_cmd (info, sector, 0, info->cmd_reset);
+	return retcode;
 }
 
 #ifdef CFG_FLASH_USE_BUFFER_WRITE
@@ -1429,6 +1490,7 @@ static int flash_write_cfibuffer (flash_info_t * info, ulong dest, uchar * cp,
 		src.cp = cp;
 		dst.cp = (uchar *) dest;
 		sector = find_sector (info, dest);
+		flash_write_cmd (info, sector, 0, FLASH_CMD_RESET);
 		flash_write_cmd (info, sector, 0, FLASH_CMD_CLEAR_STATUS);
 		flash_write_cmd (info, sector, 0, FLASH_CMD_WRITE_TO_BUFFER);
 		if ((retcode = flash_status_check (info, sector, info->buffer_write_tout,
@@ -1477,6 +1539,7 @@ static int flash_write_cfibuffer (flash_info_t * info, ulong dest, uchar * cp,
 							   info->buffer_write_tout,
 							   "buffer write");
 		}
+		flash_write_cmd (info, sector, 0, FLASH_CMD_RESET);
 		return retcode;
 
 	case CFI_CMDSET_AMD_STANDARD:
diff --git a/drivers/mtd/nand/diskonchip.c b/drivers/mtd/nand/diskonchip.c
index e17af70d07..4453cb8c2b 100644
--- a/drivers/mtd/nand/diskonchip.c
+++ b/drivers/mtd/nand/diskonchip.c
@@ -1576,7 +1576,7 @@ static inline int __init doc_probe(unsigned long physadr)
 			reg = DoC_Mplus_Toggle;
 			break;
 		case DOC_ChipID_DocMilPlus32:
-			printk(KERN_ERR "DiskOnChip Millennium Plus 32MB is not supported, ignoring.\n");
+			printk(KERN_ERR "DiskOnChip Millennium Plus 32MiB is not supported, ignoring.\n");
 		default:
 			ret = -ENODEV;
 			goto notfound;
diff --git a/drivers/mtd/nand/nand.c b/drivers/mtd/nand/nand.c
index 27b5792bcc..195a7250f9 100644
--- a/drivers/mtd/nand/nand.c
+++ b/drivers/mtd/nand/nand.c
@@ -32,7 +32,7 @@
 #endif
 
 int nand_curr_device = -1;
-nand_info_t nand_info[CFG_MAX_NAND_DEVICE];
+nand_info_t nand_info[CFG_MAX_NAND_DEVICE] = {{0}};
 
 static struct nand_chip nand_chip[CFG_MAX_NAND_DEVICE];
 static ulong base_address[CFG_MAX_NAND_DEVICE] = CFG_NAND_BASE_LIST;
@@ -70,7 +70,7 @@ void nand_init(void)
 		if (nand_curr_device == -1)
 			nand_curr_device = i;
 	}
-	printf("%lu MiB\n", size / (1024 * 1024));
+	print_size (size, "\n");
 
 #ifdef CFG_NAND_SELECT_DEVICE
 	/*
diff --git a/drivers/mtd/nand/nand_base.c b/drivers/mtd/nand/nand_base.c
index 151f535c58..810f92efb4 100644
--- a/drivers/mtd/nand/nand_base.c
+++ b/drivers/mtd/nand/nand_base.c
@@ -11,6 +11,10 @@
  *
  *  Copyright (C) 2000 Steven J. Hill (sjhill@realitydiluted.com)
  * 		  2002 Thomas Gleixner (tglx@linutronix.de)
+ *		  2009 STMicroelectronics. (Sean McGoogan <Sean.McGoogan@st.com>)
+ *
+ *
+ *  02-06-2009  SMG: added support for 3 bytes of ECC per 128 byte record.
  *
  *  02-08-2004  tglx: support for strange chips, which cannot auto increment
  *		pages on read / read_oob
@@ -133,13 +137,8 @@ static void nand_read_buf(struct mtd_info *mtd, u_char *buf, int len);
 static int nand_verify_buf(struct mtd_info *mtd, const u_char *buf, int len);
 
 static int nand_read (struct mtd_info *mtd, loff_t from, size_t len, size_t * retlen, u_char * buf);
-static int nand_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
-			  size_t * retlen, u_char * buf, u_char * eccbuf, struct nand_oobinfo *oobsel);
-static int nand_read_oob (struct mtd_info *mtd, loff_t from, size_t len, size_t * retlen, u_char * buf);
 static int nand_write (struct mtd_info *mtd, loff_t to, size_t len, size_t * retlen, const u_char * buf);
-static int nand_write_ecc (struct mtd_info *mtd, loff_t to, size_t len,
-			   size_t * retlen, const u_char * buf, u_char * eccbuf, struct nand_oobinfo *oobsel);
-static int nand_write_oob (struct mtd_info *mtd, loff_t to, size_t len, size_t * retlen, const u_char *buf);
+
 /* XXX U-BOOT XXX */
 #if 0
 static int nand_writev (struct mtd_info *mtd, const struct kvec *vecs,
@@ -538,6 +537,11 @@ static void nand_command (struct mtd_info *mtd, unsigned command, int column, in
 {
 	register struct nand_chip *this = mtd->priv;
 
+#if 0									/* QQQ - DELETE */
+	printf("QQQ: %s( command=0x%02x,  column=0x%x,  page=0x%x\n",	/* QQQ - DELETE */
+		__FUNCTION__, command, column, page_addr);		/* QQQ - DELETE */
+#endif									/* QQQ - DELETE */
+
 	/* Begin command latch cycle */
 	this->hwcontrol(mtd, NAND_CTL_SETCLE);
 	/*
@@ -643,6 +647,11 @@ static void nand_command_lp (struct mtd_info *mtd, unsigned command, int column,
 {
 	register struct nand_chip *this = mtd->priv;
 
+#if 0									/* QQQ - DELETE */
+	printf("QQQ: %s( command=0x%02x,  column=0x%x,  page=0x%x\n",	/* QQQ - DELETE */
+		__FUNCTION__, command, column, page_addr);		/* QQQ - DELETE */
+#endif									/* QQQ - DELETE */
+
 	/* Emulate NAND_CMD_READOOB */
 	if (command == NAND_CMD_READOOB) {
 		column += mtd->oobblock;
@@ -891,7 +900,7 @@ static int nand_write_page (struct mtd_info *mtd, struct nand_chip *this, int pa
 	u_char *oob_buf,  struct nand_oobinfo *oobsel, int cached)
 {
 	int 	i, status;
-	u_char	ecc_code[32];
+	u_char	ecc_code[MTD_NANDECC_MAX_ECCPOS];
 	int	eccmode = oobsel->useecc ? this->eccmode : NAND_ECC_NONE;
 	uint  	*oob_config = oobsel->eccpos;
 	int	datidx = 0, eccidx = 0, eccsteps = this->eccsteps;
@@ -1105,15 +1114,15 @@ static int nand_read (struct mtd_info *mtd, loff_t from, size_t len, size_t * re
  *
  * NAND read with ECC
  */
-static int nand_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
+extern int nand_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
 			  size_t * retlen, u_char * buf, u_char * oob_buf, struct nand_oobinfo *oobsel)
 {
 	int i, j, col, realpage, page, end, ecc, chipnr, sndcmd = 1;
 	int read = 0, oob = 0, ecc_status = 0, ecc_failed = 0;
 	struct nand_chip *this = mtd->priv;
 	u_char *data_poi, *oob_data = oob_buf;
-	u_char ecc_calc[32];
-	u_char ecc_code[32];
+	u_char ecc_calc[MTD_NANDECC_MAX_ECCPOS];
+	u_char ecc_code[MTD_NANDECC_MAX_ECCPOS];
 	int eccmode, eccsteps;
 	unsigned *oob_config;
 	int	datidx;
@@ -1122,7 +1131,6 @@ static int nand_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
 	int	compareecc = 1;
 	int	oobreadlen;
 
-
 	DEBUG (MTD_DEBUG_LEVEL3, "nand_read_ecc: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);
 
 	/* Do not allow reads past end of device */
@@ -1374,7 +1382,7 @@ static int nand_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
  *
  * NAND read out-of-band data from the spare area
  */
-static int nand_read_oob (struct mtd_info *mtd, loff_t from, size_t len, size_t * retlen, u_char * buf)
+extern int nand_read_oob (struct mtd_info *mtd, loff_t from, size_t len, size_t * retlen, u_char * buf)
 {
 	int i, col, page, chipnr;
 	struct nand_chip *this = mtd->priv;
@@ -1609,7 +1617,7 @@ static int nand_write (struct mtd_info *mtd, loff_t to, size_t len, size_t * ret
  *
  * NAND write with ECC
  */
-static int nand_write_ecc (struct mtd_info *mtd, loff_t to, size_t len,
+extern int nand_write_ecc (struct mtd_info *mtd, loff_t to, size_t len,
 			   size_t * retlen, const u_char * buf, u_char * eccbuf, struct nand_oobinfo *oobsel)
 {
 	int startpage, page, ret = -EIO, oob = 0, written = 0, chipnr;
@@ -1762,7 +1770,7 @@ out:
  *
  * NAND write out-of-band
  */
-static int nand_write_oob (struct mtd_info *mtd, loff_t to, size_t len, size_t * retlen, const u_char * buf)
+extern int nand_write_oob (struct mtd_info *mtd, loff_t to, size_t len, size_t * retlen, const u_char * buf)
 {
 	int column, page, status, ret = -EIO, chipnr;
 	struct nand_chip *this = mtd->priv;
@@ -2528,6 +2536,10 @@ int nand_scan (struct mtd_info *mtd, int maxchips)
 	case NAND_ECC_HW3_256:
 		break;
 
+	case NAND_ECC_HW3_128:
+		this->eccsize = 128;	/* set eccsize to 128 bytes/record */
+		break;
+
 	case NAND_ECC_NONE:
 		printk (KERN_WARNING "NAND_ECC_NONE selected by board driver. This is not recommended !!\n");
 		this->eccmode = NAND_ECC_NONE;
@@ -2555,6 +2567,7 @@ int nand_scan (struct mtd_info *mtd, int maxchips)
 		this->eccbytes += 3;
 	case NAND_ECC_HW3_512:
 	case NAND_ECC_HW3_256:
+	case NAND_ECC_HW3_128:
 		if (this->calculate_ecc && this->correct_data && this->enable_hwecc)
 			break;
 		printk (KERN_WARNING "No ECC functions supplied, Hardware ECC not possible\n");
@@ -2578,6 +2591,10 @@ int nand_scan (struct mtd_info *mtd, int maxchips)
 		this->eccsteps = mtd->oobblock / 256;
 		break;
 
+	case NAND_ECC_HW3_128:
+		this->eccsteps = mtd->oobblock / 128;
+		break;
+
 	case NAND_ECC_NONE:
 		this->eccsteps = 1;
 		break;
@@ -2604,12 +2621,20 @@ int nand_scan (struct mtd_info *mtd, int maxchips)
 	mtd->erase = nand_erase;
 	mtd->point = NULL;
 	mtd->unpoint = NULL;
-	mtd->read = nand_read;
-	mtd->write = nand_write;
-	mtd->read_ecc = nand_read_ecc;
-	mtd->write_ecc = nand_write_ecc;
-	mtd->read_oob = nand_read_oob;
-	mtd->write_oob = nand_write_oob;
+	/* allow board-specific init to overwrite some MTD functions */
+	if (!mtd->read)
+		mtd->read = nand_read;
+	if (!mtd->write)
+		mtd->write = nand_write;
+	if (!mtd->read_ecc)
+		mtd->read_ecc = nand_read_ecc;
+	if (!mtd->write_ecc)
+		mtd->write_ecc = nand_write_ecc;
+	if (!mtd->read_oob)
+		mtd->read_oob = nand_read_oob;
+	if (!mtd->write_oob)
+		mtd->write_oob = nand_write_oob;
+
 /* XXX U-BOOT XXX */
 #if 0
 	mtd->readv = NULL;
@@ -2633,6 +2658,7 @@ int nand_scan (struct mtd_info *mtd, int maxchips)
 #if 0
 	mtd->owner = THIS_MODULE;
 #endif
+
 	/* Build bad block table */
 	return this->scan_bbt (mtd);
 }
diff --git a/drivers/mtd/nand/nand_util.c b/drivers/mtd/nand/nand_util.c
index 4fd4e166e6..7b5cf2eda3 100644
--- a/drivers/mtd/nand/nand_util.c
+++ b/drivers/mtd/nand/nand_util.c
@@ -41,6 +41,8 @@
 
 #include <nand.h>
 #include <jffs2/jffs2.h>
+#include <asm/io.h>
+#include <asm/pio.h>
 
 typedef struct erase_info erase_info_t;
 typedef struct mtd_info	  mtd_info_t;
@@ -159,6 +161,18 @@ int nand_erase_opts(nand_info_t *meminfo, const nand_erase_options_t *opts)
 
 		WATCHDOG_RESET ();
 
+		/* over address space */
+		if((erase.addr + 0x80000) > 0x10000000) {
+			printf("Erase addr is over Nand flash address space(256MB)!!!\n");
+			break;
+		}
+
+		/* up to push update filesystem */
+		if(((erase.addr + 0x20000) > 0x9b00000) && (erase_length == 0x9a00000)) {
+			printf("Erase addr is up to push update fs address space!erase_length=0x%x\n", erase_length);
+			break;
+		}
+
 		if (!opts->scrub && bbtest) {
 			int ret = meminfo->block_isbad(meminfo, erase.addr);
 			if (ret > 0) {
@@ -209,7 +223,7 @@ int nand_erase_opts(nand_info_t *meminfo, const nand_erase_options_t *opts)
 		}
 
 		if (!opts->quiet) {
-			unsigned long long n =(unsigned long long)
+			unsigned long long n = (unsigned long long)
 				(erase.addr + meminfo->erasesize - opts->offset)
 				* 100;
 			int percent;
@@ -224,11 +238,11 @@ int nand_erase_opts(nand_info_t *meminfo, const nand_erase_options_t *opts)
 			if (percent != percent_complete) {
 				percent_complete = percent;
 
-				printf("\rErasing at 0x%x -- %3d%% complete.",
+				printf("\rErasing at 0x%x -- %3d%% complete.\n",
 				       erase.addr, percent);
 
 				if (opts->jffs2 && result == 0)
-					printf(" Cleanmarker written at 0x%x.",
+					printf(" Cleanmarker written at 0x%x.\n",
 					       erase.addr);
 			}
 		}
@@ -346,6 +360,10 @@ int nand_write_opts(nand_info_t *meminfo, const nand_write_options_t *opts)
 	if (opts->forcejffs2 || opts->forceyaffs) {
 		struct nand_oobinfo *oobsel =
 			opts->forcejffs2 ? &jffs2_oobinfo : &yaffs_oobinfo;
+#ifdef CFG_NAND_YAFFS1_NEW_OOB_LAYOUT
+		/* jffs2_oobinfo matches 2.6.18+ MTD nand_oob_16 ecclayout */
+		oobsel = &jffs2_oobinfo;
+#endif
 
 		if (meminfo->oobsize == 8) {
 			if (opts->forceyaffs) {
@@ -367,7 +385,7 @@ int nand_write_opts(nand_info_t *meminfo, const nand_write_options_t *opts)
 
 	/* check, if file is pagealigned */
 	if ((!opts->pad) && ((imglen % pagelen) != 0)) {
-		printf("Input block length is not page aligned\n");
+		printf("Input block length is not page aligned, imglen=%d, pagelen=%d\n", imglen, pagelen);
 		goto restoreoob;
 	}
 
@@ -425,7 +443,7 @@ int nand_write_opts(nand_info_t *meminfo, const nand_write_options_t *opts)
 					mtdoffset = blockstart
 						+ erasesize_blockalign;
 				}
-				offs +=	 erasesize_blockalign
+				offs += erasesize_blockalign
 					/ opts->blockalign;
 			} while (offs < blockstart + erasesize_blockalign);
 		}
@@ -447,6 +465,28 @@ int nand_write_opts(nand_info_t *meminfo, const nand_write_options_t *opts)
 			memcpy(oob_buf, buffer, meminfo->oobsize);
 			buffer += meminfo->oobsize;
 
+			if (opts->forceyaffs) {
+#ifdef CFG_NAND_YAFFS1_NEW_OOB_LAYOUT
+				/* translate OOB for yaffs1 on Linux 2.6.18+ */
+				oob_buf[15] = oob_buf[12];
+				oob_buf[14] = oob_buf[11];
+				oob_buf[13] = (oob_buf[7] & 0x3f)
+					| (oob_buf[5] == 'Y' ? 0 : 0x80)
+					| (oob_buf[4] == 0 ? 0 : 0x40);
+				oob_buf[12] = oob_buf[6];
+				oob_buf[11] = oob_buf[3];
+				oob_buf[10] = oob_buf[2];
+				oob_buf[9]  = oob_buf[1];
+				oob_buf[8]  = oob_buf[0];
+				memset(oob_buf, 0xff, 8);
+#else
+				/* set the ECC bytes to 0xff so MTD will
+				   calculate it */
+				int i;
+				for (i = 0; i < meminfo->oobinfo.eccbytes; i++)
+					oob_buf[meminfo->oobinfo.eccpos[i]] = 0xff;
+#endif
+			}
 			/* write OOB data first, as ecc will be placed
 			 * in there*/
 			result = meminfo->write_oob(meminfo,
@@ -491,14 +531,24 @@ int nand_write_opts(nand_info_t *meminfo, const nand_write_options_t *opts)
 			 * on (slow) serial consoles
 			 */
 			if (percent != percent_complete) {
+#if 0
 				printf("\rWriting data at 0x%x "
 				       "-- %3d%% complete.",
 				       mtdoffset, percent);
+#endif
 				percent_complete = percent;
 			}
 		}
 
 		mtdoffset += meminfo->oobblock;
+
+		/* write.yaffs, not write.jffs2 */
+		if(opts->pad == 0 && (mtdoffset+0x800) > 0x9b00000) {
+			printf("Write yaffs fs is  up to push fs!!mtdoffset=0x%x, opts->pad=%d\n", mtdoffset,opts->pad);
+
+			/* return happy */
+			return 0;
+		}
 	}
 
 	if (!opts->quiet)
diff --git a/drivers/mtd/nand_legacy/nand_legacy.c b/drivers/mtd/nand_legacy/nand_legacy.c
index 49d2ebb67d..b8d1f58f69 100644
--- a/drivers/mtd/nand_legacy/nand_legacy.c
+++ b/drivers/mtd/nand_legacy/nand_legacy.c
@@ -242,8 +242,8 @@ void nand_print(struct nand_chip *nand)
 {
 	if (nand->numchips > 1) {
 		printf("%s at 0x%lx,\n"
-		       "\t  %d chips %s, size %d MB, \n"
-		       "\t  total size %ld MB, sector size %ld kB\n",
+		       "\t  %d chips %s, size %d MiB, \n"
+		       "\t  total size %ld MiB, sector size %ld KiB\n",
 		       nand->name, nand->IO_ADDR, nand->numchips,
 		       nand->chips_name, 1 << (nand->chipshift - 20),
 		       nand->totlen >> 20, nand->erasesize >> 10);
@@ -515,7 +515,7 @@ static void NanD_ScanChips(struct nand_chip *nand)
 	nand->totlen = nand->numchips * (1 << nand->chipshift);
 
 #ifdef NAND_DEBUG
-	printf("%d flash chips found. Total nand_chip size: %ld MB\n",
+	printf("%d flash chips found. Total nand_chip size: %ld MiB\n",
 	       nand->numchips, nand->totlen >> 20);
 #endif
 }
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
index 41e1bdeb3b..b9f9bb6d0f 100644
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -52,6 +52,8 @@ COBJS-y += rtl8139.o
 COBJS-y += rtl8169.o
 COBJS-y += s3c4510b_eth.o
 COBJS-y += smc91111.o
+COBJS-y += smc911x.o
+COBJS-y += stm-stmac.o
 COBJS-y += tigon3.o
 COBJS-y += tsec.o
 COBJS-y += tsi108_eth.o
diff --git a/drivers/net/smc911x.c b/drivers/net/smc911x.c
new file mode 100644
index 0000000000..c1a689f8cd
--- /dev/null
+++ b/drivers/net/smc911x.c
@@ -0,0 +1,1383 @@
+/*------------------------------------------------------------------------
+ . smc9111x.c
+ . This is a driver for SMSC's LAN911X single-chip Ethernet device.
+ . based on the SMC91111 driver from U-boot, sim911x.c of smsc and
+ . datsheet.
+
+ . (C) Copyright 2005
+ . Andy Sturges, STMicrolectronics <andy.sturges@st.com>
+
+ . (C) Copyright 2002
+ . Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ . Rolf Offermanns <rof@sysgo.de>
+ .
+ . Copyright (C) 2001 Standard Microsystems Corporation (SMSC)
+ .	 Developed by Simple Network Magic Corporation (SNMC)
+ . Copyright (C) 1996 by Erik Stahlman (ES)
+ .
+ . This program is free software; you can redistribute it and/or modify
+ . it under the terms of the GNU General Public License as published by
+ . the Free Software Foundation; either version 2 of the License, or
+ . (at your option) any later version.
+ .
+ . This program is distributed in the hope that it will be useful,
+ . but WITHOUT ANY WARRANTY; without even the implied warranty of
+ . MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ . GNU General Public License for more details.
+ .
+ . You should have received a copy of the GNU General Public License
+ . along with this program; if not, write to the Free Software
+ . Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307	 USA
+ .
+ . Information contained in this file was obtained from the LAN9111x
+ . manual from SMC.  To get a copy, if you really want one, you can find
+ . information under www.smsc.com.
+ .
+
+  ----------------------------------------------------------------------------*/
+
+#include <common.h>
+#include <command.h>
+#include <config.h>
+#include "smc911x.h"
+#include <net.h>
+
+#ifdef CONFIG_DRIVER_SMC911X
+
+#define SMC_DEBUG 0
+
+#if SMC_DEBUG > 1
+
+#define USE_TRACE 1
+#define USE_WARNING 1
+
+#endif
+
+#ifdef USE_TRACE
+#ifndef USE_WARNING
+#define USE_WARNING
+#endif
+#	define SMSC_TRACE(msg,args...)			\
+		printf("SMSC: " msg "\n", ## args);
+#else
+#	define SMSC_TRACE(msg,args...)
+#endif
+
+#ifdef USE_WARNING
+#define SMSC_WARNING(msg, args...)				\
+		printf("SMSC_WARNING: " msg "\n",## args);
+#else
+#	define SMSC_WARNING(msg, args...)
+#endif
+
+/* Autonegotiation timeout in seconds */
+#ifndef CONFIG_SMC_AUTONEG_TIMEOUT
+#define CONFIG_SMC_AUTONEG_TIMEOUT 10
+#endif
+
+#if (SMC_DEBUG > 2 )
+#define PRINTK3(args...) printf(args)
+#else
+#define PRINTK3(args...)
+#endif
+
+#if SMC_DEBUG > 1
+#define PRINTK2(args...) printf(args)
+#else
+#define PRINTK2(args...)
+#endif
+
+#ifdef SMC_DEBUG
+#define PRINTK(args...) printf(args)
+#else
+#define PRINTK(args...)
+#endif
+
+
+/*------------------------------------------------------------------------
+ .
+ . The internal workings of the driver.	 If you are changing anything
+ . here with the SMC stuff, you should have the datasheet and know
+ . what you are doing.
+ .
+ -------------------------------------------------------------------------*/
+
+static dword dwIdRev;
+static dword dwPhyAddress;
+static dword dwLinkSpeed;
+static dword dwLinkSettings;
+
+#define CARDNAME "LAN911X"
+
+#ifndef CONFIG_SMC911X_BASE
+#error Must define memory base address fpr SMC911X
+#endif
+
+#define SMC_BASE_ADDRESS CONFIG_SMC911X_BASE
+
+#define SMC_DEV_NAME "SMC911X"
+#define SMC_PHY_ADDR 0xFFFFFFFFUL
+
+#define SMC_TX_TIMEOUT 30
+
+#define ETH_ZLEN 60
+
+/* static functions */
+
+static void Phy_SetLink(void);
+static word Phy_GetRegW(dword dwRegIndex);
+static void Phy_SetRegW(dword dwRegIndex, word wVal);
+static void Phy_UpdateLinkMode(void);
+static void Phy_GetLinkMode(void);
+static void Phy_CheckLink(void);
+
+static void Tx_WriteFifo(dword *pdwBuf, dword dwDwordCount);
+static dword Tx_GetTxStatusCount(void);
+static dword Tx_CompleteTx(void);
+static void Tx_UpdateTxCounters(void);
+
+static void Rx_ReadFifo(dword *pdwBuf,dword dwDwordCount);
+static dword Rx_PopRxStatus(void);
+static void Rx_FastForward(dword dwDwordCount);
+
+/*-----------------------------------------------------------------
+ .
+ .  The driver can be entered at any of the following entry points.
+ .
+ .------------------------------------------------------------------  */
+
+extern int eth_init(bd_t *bd);
+extern void eth_halt(void);
+extern int eth_rx(void);
+extern int eth_send(volatile void *packet, int length);
+
+static BOOLEAN MacNotBusy(void)
+{
+	int i=0;
+
+	/*  wait for MAC not busy, w/ timeout */
+	for(i=0;i<40;i++)
+	{
+		if((Lan_GetRegDW(MAC_CSR_CMD) & MAC_CSR_CMD_CSR_BUSY_)==(0UL)) {
+			return TRUE;
+		}
+	}
+	SMSC_WARNING("timeout waiting for MAC not BUSY. MAC_CSR_CMD = 0x%08lX",
+		Lan_GetRegDW(MAC_CSR_CMD));
+	return FALSE;
+}
+
+/* Gets a mac register value */
+dword Mac_GetRegDW(dword dwRegOffset)
+{
+	dword result=0xFFFFFFFFUL;
+	dword dwTemp=0;
+
+	/*  wait until not busy */
+	if (Lan_GetRegDW(MAC_CSR_CMD) & MAC_CSR_CMD_CSR_BUSY_)
+	{
+		SMSC_WARNING("Mac_GetRegDW() failed, MAC already busy at entry");
+		goto DONE;
+	}
+
+	/*  send the MAC Cmd w/ offset */
+	Lan_SetRegDW(MAC_CSR_CMD,
+		((dwRegOffset & 0x000000FFUL) | MAC_CSR_CMD_CSR_BUSY_ | MAC_CSR_CMD_R_NOT_W_));
+	dwTemp=Lan_GetRegDW(BYTE_TEST);/* to flush previous write */
+	dwTemp=dwTemp;
+
+	/*  wait for the read to happen, w/ timeout */
+	if (!MacNotBusy())
+	{
+		SMSC_WARNING("Mac_GetRegDW() failed, waiting for MAC not busy after read");
+		goto DONE;
+	} else {
+		/*  finally, return the read data */
+		result=Lan_GetRegDW(MAC_CSR_DATA);
+	}
+DONE:
+	return result;
+}
+
+/* Sets a Mac register */
+void Mac_SetRegDW(dword dwRegOffset,dword dwVal)
+{
+	dword dwTemp=0;
+
+	if (Lan_GetRegDW(MAC_CSR_CMD) & MAC_CSR_CMD_CSR_BUSY_)
+	{
+		SMSC_WARNING("Mac_SetRegDW() failed, MAC already busy at entry");
+		goto DONE;
+	}
+
+	/*  send the data to write */
+	Lan_SetRegDW(MAC_CSR_DATA,dwVal);
+
+	/*  do the actual write */
+	Lan_SetRegDW(MAC_CSR_CMD,((dwRegOffset & 0x000000FFUL) | MAC_CSR_CMD_CSR_BUSY_));
+	dwTemp=Lan_GetRegDW(BYTE_TEST);/* force flush of previous write */
+	dwTemp=dwTemp;
+
+	/*  wait for the write to complete, w/ timeout */
+	if (!MacNotBusy())
+	{
+		SMSC_WARNING("Mac_SetRegDW() failed, waiting for MAC not busy after write");
+	}
+DONE:
+	return;
+}
+
+/* Gets a phy register */
+word Phy_GetRegW(
+	dword dwRegIndex)
+{
+	dword dwAddr=0;
+	int i=0;
+	word result=0xFFFFU;
+
+	/*  confirm MII not busy */
+	if ((Mac_GetRegDW(MII_ACC) & MII_ACC_MII_BUSY_) != 0UL)
+	{
+		SMSC_WARNING("MII is busy in Phy_GetRegW???");
+		result=0;
+		goto DONE;
+	}
+
+	/*  set the address, index & direction (read from PHY) */
+	dwAddr = (((dwPhyAddress) & 0x1FUL)<<11) | ((dwRegIndex & 0x1FUL)<<6);
+	Mac_SetRegDW(MII_ACC, dwAddr);
+
+	/*  wait for read to complete w/ timeout */
+	for(i=0;i<100;i++) {
+		/*  see if MII is finished yet */
+		if ((Mac_GetRegDW(MII_ACC) & MII_ACC_MII_BUSY_) == 0UL)
+		{
+			/*  get the read data from the MAC & return i */
+			result=((word)Mac_GetRegDW(MII_DATA));
+			goto DONE;
+		}
+	}
+	SMSC_WARNING("timeout waiting for MII write to finish");
+
+DONE:
+	return result;
+}
+
+/* Sets a phy register */
+void Phy_SetRegW(
+	dword dwRegIndex,word wVal)
+{
+	dword dwAddr=0;
+	int i=0;
+
+	/*  confirm MII not busy */
+	if ((Mac_GetRegDW(MII_ACC) & MII_ACC_MII_BUSY_) != 0UL)
+	{
+		SMSC_WARNING("MII is busy in Phy_SetRegW???");
+		goto DONE;
+	}
+
+	/*  put the data to write in the MAC */
+	Mac_SetRegDW(MII_DATA, (dword)wVal);
+
+	/*  set the address, index & direction (write to PHY) */
+	dwAddr = (((dwPhyAddress) & 0x1FUL)<<11) | ((dwRegIndex & 0x1FUL)<<6) | MII_ACC_MII_WRITE_;
+	Mac_SetRegDW(MII_ACC, dwAddr);
+
+	/*  wait for write to complete w/ timeout */
+	for(i=0;i<100;i++) {
+		/*  see if MII is finished yet */
+		if ((Mac_GetRegDW(MII_ACC) & MII_ACC_MII_BUSY_) == 0UL)
+		{
+			goto DONE;
+		}
+	}
+	SMSC_WARNING("timeout waiting for MII write to finish");
+DONE:
+	return;
+}
+
+/* Update link mode if any thing has changed */
+void Phy_UpdateLinkMode()
+{
+	dword dwOldLinkSpeed=dwLinkSpeed;
+
+	SMSC_TRACE("Update Link mode");
+
+	Phy_GetLinkMode();
+
+	switch(dwLinkSpeed) {
+	case LINK_OFF:
+	  SMSC_TRACE("Link is now down");
+	  break;
+	case LINK_SPEED_10HD:
+	  SMSC_TRACE("Link is now UP at 10Mbps HD");
+	  break;
+	case LINK_SPEED_10FD:
+	  SMSC_TRACE("Link is now UP at 10Mbps FD");
+	  break;
+	case LINK_SPEED_100HD:
+	  SMSC_TRACE("Link is now UP at 100Mbps HD");
+	  break;
+	case LINK_SPEED_100FD:
+	  SMSC_TRACE("Link is now UP at 100Mbps FD");
+	  break;
+	default:
+	  SMSC_WARNING("Link is now UP at Unknown Link Speed, dwLinkSpeed=0x%08lX",
+					dwLinkSpeed);
+	  break;
+	}
+
+	if(dwOldLinkSpeed!=(dwLinkSpeed)) {
+		if(dwLinkSpeed!=LINK_OFF) {
+			dword dwRegVal=0;
+			switch(dwLinkSpeed) {
+			case LINK_SPEED_10HD:
+				SMSC_TRACE("Link is now UP at 10Mbps HD");
+				break;
+			case LINK_SPEED_10FD:
+				SMSC_TRACE("Link is now UP at 10Mbps FD");
+				break;
+			case LINK_SPEED_100HD:
+				SMSC_TRACE("Link is now UP at 100Mbps HD");
+				break;
+			case LINK_SPEED_100FD:
+				SMSC_TRACE("Link is now UP at 100Mbps FD");
+				break;
+			default:
+				SMSC_WARNING("Link is now UP at Unknown Link Speed, dwLinkSpeed=0x%08lX",
+					dwLinkSpeed);
+				break;
+			}
+
+			dwRegVal=Mac_GetRegDW(MAC_CR);
+			dwRegVal&=~(MAC_CR_FDPX_|MAC_CR_RCVOWN_);
+			switch(dwLinkSpeed) {
+			case LINK_SPEED_10HD:
+			case LINK_SPEED_100HD:
+				dwRegVal|=MAC_CR_RCVOWN_;
+				break;
+			case LINK_SPEED_10FD:
+			case LINK_SPEED_100FD:
+				dwRegVal|=MAC_CR_FDPX_;
+				break;
+			default:
+				SMSC_WARNING("Unknown Link Speed, dwLinkSpeed=0x%08lX",
+					dwLinkSpeed);
+				break;
+			}
+
+			Mac_SetRegDW(
+				MAC_CR,dwRegVal);
+
+			if(dwLinkSettings&LINK_AUTO_NEGOTIATE) {
+				word linkPartner=0;
+				word localLink=0;
+				localLink=Phy_GetRegW(4);
+				linkPartner=Phy_GetRegW(5);
+				switch(dwLinkSpeed) {
+				case LINK_SPEED_10FD:
+				case LINK_SPEED_100FD:
+					if(((localLink&linkPartner)&((word)0x0400U)) != ((word)0U)) {
+						/* Enable PAUSE receive and transmit */
+						Mac_SetRegDW(FLOW,0xFFFF0002UL);
+						Lan_SetBitsDW(AFC_CFG,0x0000000FUL);
+					} else if(((localLink&((word)0x0C00U))==((word)0x0C00U)) &&
+							((linkPartner&((word)0x0C00U))==((word)0x0800U)))
+					{
+						/* Enable PAUSE receive, disable PAUSE transmit */
+						Mac_SetRegDW(FLOW,0xFFFF0002UL);
+						Lan_ClrBitsDW(AFC_CFG,0x0000000FUL);
+					} else {
+						/* Disable PAUSE receive and transmit */
+						Mac_SetRegDW(FLOW,0UL);
+						Lan_ClrBitsDW(AFC_CFG,0x0000000FUL);
+					};break;
+				case LINK_SPEED_10HD:
+				case LINK_SPEED_100HD:
+					Mac_SetRegDW(FLOW,0UL);
+					Lan_SetBitsDW(AFC_CFG,0x0000000FUL);
+					break;
+				default:
+					SMSC_WARNING("Unknown Link Speed, dwLinkSpeed=0x%08lX\n",dwLinkSpeed);
+					break;
+				}
+				SMSC_TRACE("LAN911x: %s,%s,%s,%s,%s,%s",
+					(localLink&PHY_ANEG_ADV_ASYMP_)?"ASYMP":"     ",
+					(localLink&PHY_ANEG_ADV_SYMP_)?"SYMP ":"     ",
+					(localLink&PHY_ANEG_ADV_100F_)?"100FD":"     ",
+					(localLink&PHY_ANEG_ADV_100H_)?"100HD":"     ",
+					(localLink&PHY_ANEG_ADV_10F_)?"10FD ":"     ",
+					(localLink&PHY_ANEG_ADV_10H_)?"10HD ":"     ");
+
+				SMSC_TRACE("Partner: %s,%s,%s,%s,%s,%s",
+					(linkPartner&PHY_ANEG_LPA_ASYMP_)?"ASYMP":"     ",
+					(linkPartner&PHY_ANEG_LPA_SYMP_)?"SYMP ":"     ",
+					(linkPartner&PHY_ANEG_LPA_100FDX_)?"100FD":"     ",
+					(linkPartner&PHY_ANEG_LPA_100HDX_)?"100HD":"     ",
+					(linkPartner&PHY_ANEG_LPA_10FDX_)?"10FD ":"     ",
+					(linkPartner&PHY_ANEG_LPA_10HDX_)?"10HD ":"     ");
+			} else {
+				switch(dwLinkSpeed) {
+				case LINK_SPEED_10HD:
+				case LINK_SPEED_100HD:
+					Mac_SetRegDW(FLOW,0x0UL);
+					Lan_SetBitsDW(AFC_CFG,0x0000000FUL);
+					break;
+				default:
+					Mac_SetRegDW(FLOW,0x0UL);
+					Lan_ClrBitsDW(AFC_CFG,0x0000000FUL);
+					break;
+				}
+			}
+		} else {
+			SMSC_TRACE("Link is now DOWN");
+			Mac_SetRegDW(FLOW,0UL);
+			Lan_ClrBitsDW(AFC_CFG,0x0000000FUL);
+		}
+	}
+}
+
+/* entry point for the link poller */
+void Phy_CheckLink()
+{
+	/* must call this twice */
+	Phy_UpdateLinkMode();
+	Phy_UpdateLinkMode();
+
+}
+
+/* gets the current link mode */
+void Phy_GetLinkMode()
+{
+	dword result=LINK_OFF;
+	word wRegVal=0;
+	word wRegBSR=0;
+
+	/* Assuming MacPhyAccessLock has already been acquired */
+
+	wRegBSR=Phy_GetRegW(PHY_BSR);
+	dwLinkSettings=LINK_OFF;
+
+	if(wRegBSR&PHY_BSR_LINK_STATUS_) {
+		wRegVal=Phy_GetRegW(PHY_BCR);
+		if(wRegVal&PHY_BCR_AUTO_NEG_ENABLE_) {
+			dword linkSettings=LINK_AUTO_NEGOTIATE;
+			word wRegADV=Phy_GetRegW(PHY_ANEG_ADV);
+			word wRegLPA=Phy_GetRegW(PHY_ANEG_LPA);
+
+			if(wRegADV&PHY_ANEG_ADV_ASYMP_) {
+				linkSettings|=LINK_ASYMMETRIC_PAUSE;
+			}
+			if(wRegADV&PHY_ANEG_ADV_SYMP_) {
+				linkSettings|=LINK_SYMMETRIC_PAUSE;
+			}
+			if(wRegADV&PHY_ANEG_LPA_100FDX_) {
+				linkSettings|=LINK_SPEED_100FD;
+			}
+			if(wRegADV&PHY_ANEG_LPA_100HDX_) {
+				linkSettings|=LINK_SPEED_100HD;
+			}
+			if(wRegADV&PHY_ANEG_LPA_10FDX_) {
+				linkSettings|=LINK_SPEED_10FD;
+			}
+			if(wRegADV&PHY_ANEG_LPA_10HDX_) {
+				linkSettings|=LINK_SPEED_10HD;
+			}
+			dwLinkSettings=linkSettings;
+			wRegLPA&=wRegADV;
+			if(wRegLPA&PHY_ANEG_LPA_100FDX_) {
+				result=LINK_SPEED_100FD;
+			} else if(wRegLPA&PHY_ANEG_LPA_100HDX_) {
+				result=LINK_SPEED_100HD;
+			} else if(wRegLPA&PHY_ANEG_LPA_10FDX_) {
+				result=LINK_SPEED_10FD;
+			} else if(wRegLPA&PHY_ANEG_LPA_10HDX_) {
+				result=LINK_SPEED_10HD;
+			}
+		} else {
+			if(wRegVal&PHY_BCR_SPEED_SELECT_) {
+				if(wRegVal&PHY_BCR_DUPLEX_MODE_) {
+					dwLinkSettings=result=LINK_SPEED_100FD;
+				} else {
+					dwLinkSettings=result=LINK_SPEED_100HD;
+				}
+			} else {
+				if(wRegVal&PHY_BCR_DUPLEX_MODE_) {
+					dwLinkSettings=result=LINK_SPEED_10FD;
+				} else {
+					dwLinkSettings=result=LINK_SPEED_10HD;
+				}
+			}
+		}
+	}
+	dwLinkSpeed=result;
+}
+
+int smc_init(void);
+void smc_destructor(void);
+static int smc_open(bd_t *bd);
+static int smc_close(void);
+
+/*
+ . Configures the PHY through the MII Management interface
+*/
+#ifndef CONFIG_SMC911X_EXT_PHY
+static void smc_phy_configure(void);
+#endif /* !CONFIG_SMC91111_EXT_PHY */
+
+/*
+ . This is a separate procedure to handle the receipt of a packet, to
+ . leave the interrupt code looking slightly cleaner
+*/
+static int smc_rcv(void);
+
+/* See if a MAC address is defined in the current environment. If so use it. If not
+ . print a warning and set the environment and other globals with the default.
+ . If an EEPROM is present it really should be consulted.
+*/
+
+int smc_get_ethaddr(bd_t *bd);
+static int get_rom_mac(unsigned char *v_rom_mac);
+
+/*
+ ------------------------------------------------------------
+ .
+ . Internal routines
+ .
+ ------------------------------------------------------------
+*/
+
+static char unsigned smc_mac_addr[6] = {0x02, 0x80, 0xad, 0x20, 0x31, 0xb8};
+
+/*
+ * This function must be called before smc_open() if you want to override
+ * the default mac address.
+ */
+
+void smc_set_mac_addr(const char *addr) {
+	int i;
+
+	for (i=0; i < sizeof(smc_mac_addr); i++){
+		smc_mac_addr[i] = addr[i];
+	}
+}
+
+/*
+ * smc_get_macaddr is no longer used. If you want to override the default
+ * mac address, call smc_get_mac_addr as a part of the board initialization.
+ */
+
+/*
+ . A rather simple routine to print out a packet for debugging purposes.
+*/
+
+#if SMC_DEBUG > 2
+static void print_packet( byte *, int );
+#endif
+
+/* this does a soft reset on the device */
+static void smc_reset( void );
+
+/* Enable Interrupts, Receive, and Transmit */
+static void smc_enable( void );
+
+/* this puts the device in an inactive state */
+static void smc_shutdown( void );
+
+/*
+ . Function: smc_reset
+ . Method:
+ .      Init the device
+*/
+
+static void smc_reset (void)
+{
+	dword dwTimeOut=0;
+	dword dwTemp=0;
+
+	PRINTK2 ("%s: smc_reset\n", SMC_DEV_NAME);
+
+	/* Reset the LAN911x */
+	Lan_SetRegDW(HW_CFG,HW_CFG_SRST_);
+	dwTimeOut=10;
+	do {
+		udelay(10);
+		dwTemp=Lan_GetRegDW(HW_CFG);
+		dwTimeOut--;
+	} while((dwTimeOut>0)&&(dwTemp&HW_CFG_SRST_));
+	if(dwTemp&HW_CFG_SRST_) {
+		SMSC_WARNING("  Failed to complete reset.");
+		goto DONE;
+	}
+
+	Lan_SetRegDW(HW_CFG,0x00050000UL);
+	Lan_SetRegDW(AFC_CFG,0x006E3740UL);
+
+	/* make sure EEPROM has finished loading before setting GPIO_CFG */
+	dwTimeOut=50;
+	while((dwTimeOut>0)&&(Lan_GetRegDW(E2P_CMD)&E2P_CMD_EPC_BUSY_)) {
+		udelay(10);
+		dwTimeOut--;
+	}
+	if(dwTimeOut==0) {
+		SMSC_WARNING("Lan_Initialize: Timed out waiting for EEPROM busy bit to clear\n");
+	}
+
+	Lan_SetRegDW(GPIO_CFG,0x70070000UL);
+
+	/* initialize interrupts */
+	Lan_SetRegDW(INT_EN,0);
+	Lan_SetRegDW(INT_STS,0xFFFFFFFFUL);
+	Lan_SetRegDW(INT_CFG,0);
+
+DONE:
+	SMSC_TRACE("<--Lan_Initialize");
+}
+
+/*
+ . Function: smc_enable
+ . Purpose: let the chip talk to the outside work
+ . Method:
+ .	Enable the transmitter
+ .	Enable the receiver
+ .	Enable interrupts
+*/
+
+static void smc_enable()
+{
+	dword dwRegVal=0;
+
+	/* Init Tx */
+
+	dwRegVal=Lan_GetRegDW(HW_CFG);
+	dwRegVal&=HW_CFG_TX_FIF_SZ_;
+	dwRegVal|=HW_CFG_SF_;
+	Lan_SetRegDW(HW_CFG,dwRegVal);
+
+	Lan_SetBitsDW(FIFO_INT,0xFF000000UL);
+
+	{
+	  dword dwMacCr=Mac_GetRegDW(MAC_CR);
+	  dwMacCr|=(MAC_CR_TXEN_|MAC_CR_HBDIS_);
+	  Mac_SetRegDW(MAC_CR,dwMacCr);
+	  Lan_SetRegDW(TX_CFG,TX_CFG_TX_ON_);
+	}
+
+	/* Init Rx */
+
+	Lan_SetRegDW(RX_CFG,0x00000200UL);
+
+	{
+	  dword dwMacCr=Mac_GetRegDW(MAC_CR);
+	  dwMacCr|=MAC_CR_RXEN_;
+	  Mac_SetRegDW(MAC_CR,dwMacCr);
+	}
+
+	Lan_ClrBitsDW(FIFO_INT,0x000000FFUL);
+
+	/* Disable all interrupts */
+
+	Lan_SetBitsDW(INT_EN, 0);
+}
+
+/*
+ . Function: smc_shutdown
+ . Purpose:  closes down the SMC91xxx chip.
+ . Method:
+ .	1. zero the interrupt mask
+ .	2. clear the enable receive flag
+ .	3. clear the enable xmit flags
+ .
+ . TODO:
+ .   (1) maybe utilize power down mode.
+ .	Why not yet?  Because while the chip will go into power down mode,
+ .	the manual says that it will wake up in response to any I/O requests
+ .	in the register space.	 Empirical results do not show this working.
+*/
+static void smc_shutdown()
+{
+	PRINTK2(CARDNAME ": smc_shutdown\n");
+}
+
+/* Writes a packet to the TX_DATA_FIFO */
+static void Tx_WriteFifo(
+	dword *pdwBuf,
+	dword dwDwordCount)
+{
+	volatile dword *pdwReg;
+	pdwReg = (volatile dword *)(SMC_BASE_ADDRESS+TX_DATA_FIFO);
+	while(dwDwordCount)
+	{
+		*pdwReg = *pdwBuf++;
+		dwDwordCount--;
+	}
+}
+
+/* Gets the number of Tx Statuses in the fifo */
+static dword Tx_GetTxStatusCount()
+{
+	dword result=0;
+	result=Lan_GetRegDW(TX_FIFO_INF);
+	result&=TX_FIFO_INF_TSUSED_;
+	result>>=16;
+	return result;
+}
+
+/* gets a tx status out of the status fifo */
+static dword Tx_CompleteTx()
+{
+	dword result=0;
+	result=Lan_GetRegDW(TX_FIFO_INF);
+
+	result&=TX_FIFO_INF_TSUSED_;
+	if(result!=0x00000000UL) {
+		result=Lan_GetRegDW(TX_STATUS_FIFO);
+	} else {
+		result=0;
+	}
+
+	return result;
+}
+
+/* reads tx statuses and increments counters where necessary */
+void Tx_UpdateTxCounters()
+{
+	dword dwTxStatus=0;
+	while((dwTxStatus=Tx_CompleteTx())!=0)
+	{
+		if(dwTxStatus&0x80000000UL) {
+			SMSC_WARNING("Packet tag reserved bit is high");
+			/* In this driver the packet tag is used as the packet */
+			/*   length. Since a packet length can never reach */
+			/*   the size of 0x8000, I made this bit reserved */
+			/*   so if I ever decided to use packet tracking  */
+			/*   tags then those tracking tags would set the  */
+			/*   reserved bit. And I would use this control path */
+			/*   to look up the packet and perhaps free it. */
+			/*   As you can see I never persued this idea. */
+			/*   because it never provided any benefit in this */
+			/*   linux environment. */
+			/* But it is worth noting that the "reserved bit" */
+			/*   in the warning above does not reference a */
+			/*   hardware defined reserved bit but rather a  */
+			/*   driver defined reserved bit.  */
+		} else {
+			if(dwTxStatus&0x00008000UL) {
+			  SMSC_WARNING("Tx error sending packet");
+			}
+		}
+	}
+}
+
+/*
+ .	This sends the actual packet to the SMC911x chip.
+*/
+
+static int smc_send_packet (volatile void *packet, int packet_length)
+{
+	int length;
+	dword dwFreeSpace=0;
+	dword dwTxCmdA=0;
+	dword dwTxCmdB=0;
+
+	PRINTK3 ("%s: smc_hardware_send_packet\n", SMC_DEV_NAME);
+
+	length = ETH_ZLEN < packet_length ? packet_length : ETH_ZLEN;
+
+	/* I can send the packet now.. */
+
+#if SMC_DEBUG > 2
+	printf ("Transmitting Packet\n");
+	print_packet ((byte*)packet, length);
+#endif
+
+	dwFreeSpace=Lan_GetRegDW(TX_FIFO_INF);
+	dwFreeSpace&=TX_FIFO_INF_TDFREE_;
+	if(dwFreeSpace<TX_FIFO_LOW_THRESHOLD) {
+		SMSC_WARNING("Tx Data Fifo Low, space available = %ld",dwFreeSpace);
+	}
+	dwTxCmdA=
+		((((dword)(packet))&0x03UL)<<16) | /* dword alignment adjustment */
+		TX_CMD_A_FIRST_SEG_ | TX_CMD_A_LAST_SEG_ |
+		((dword)(length));
+	dwTxCmdB=
+		(((dword)(length))<<16) |
+		((dword)(length));
+	Lan_SetRegDW(TX_DATA_FIFO,dwTxCmdA);
+	Lan_SetRegDW(TX_DATA_FIFO,dwTxCmdB);
+	Tx_WriteFifo(
+		(dword *)(((dword)(packet))&0xFFFFFFFCUL),
+		(((dword)(length))+3+
+		(((dword)(packet))&0x03UL))>>2);
+
+	dwFreeSpace-=(length+32);
+
+	if(Tx_GetTxStatusCount()>=30)
+	{
+		Tx_UpdateTxCounters();
+	}
+
+	if(dwFreeSpace<TX_FIFO_LOW_THRESHOLD) {
+		dword temp=Lan_GetRegDW(FIFO_INT);
+		temp&=0x00FFFFFFUL;
+		temp|=0x32000000UL;
+		Lan_SetRegDW(FIFO_INT,temp);
+	}
+
+	return length;
+
+}
+
+/*-------------------------------------------------------------------------
+ |
+ | smc_destructor( struct net_device * dev )
+ |   Input parameters:
+ |	dev, pointer to the device structure
+ |
+ |   Output:
+ |	None.
+ |
+ ---------------------------------------------------------------------------
+*/
+void smc_destructor()
+{
+	PRINTK2(CARDNAME ": smc_destructor\n");
+}
+
+
+/*
+ * Open and Initialize the board
+ *
+ * Set up everything, reset the card, etc ..
+ *
+ */
+static int smc_open (bd_t * bd)
+{
+	int err;
+
+	err = 0;
+
+	PRINTK2 ("%s: smc_open\n", SMC_DEV_NAME);
+
+	/* Detect if smc_chip type */
+
+	dwIdRev=Lan_GetRegDW(ID_REV);
+	if(HIWORD(dwIdRev)==LOWORD(dwIdRev)) {
+		/* this may mean the chip is set for 32 bit  */
+		/*   while the bus is reading as 16 bit */
+UNKNOWN_CHIP:
+		SMSC_WARNING("LAN911x NOT Identified, dwIdRev==0x%08lX",dwIdRev);
+		err = 1;
+		goto DONE;
+	}
+	switch(dwIdRev&0xFFFF0000UL) {
+	case 0x01180000UL:
+		SMSC_TRACE("LAN9118 identified, dwIdRev==0x%08lX",dwIdRev);break;
+	case 0x01170000UL:
+		SMSC_TRACE("LAN9117 identified, dwIdRev==0x%08lX",dwIdRev);break;
+	case 0x01160000UL:
+		SMSC_TRACE("LAN9116 identified, dwIdRev==0x%08lX",dwIdRev);break;
+	case 0x01150000UL:
+		SMSC_TRACE("LAN9115 identified, dwIdRev==0x%08lX",dwIdRev);break;
+	default:
+		goto UNKNOWN_CHIP;
+	}
+
+	/* reset the hardware */
+	smc_reset ();
+	smc_enable();
+
+	/* Configure the PHY */
+#ifndef CONFIG_SMC911X_EXT_PHY
+	smc_phy_configure ();
+#endif
+
+	err = smc_get_ethaddr (bd);	/* set smc_mac_addr, and sync it with u-boot globals */
+
+	if (err < 0) {
+		memset (bd->bi_enetaddr, 0, 6); /* hack to make error stick! upper code will abort if not set */
+		return (-1);	/* upper code ignores this, but NOT bi_enetaddr */
+	}
+
+	/* Set Mac address */
+	{
+	  dword dwHigh16, dwLow32;
+
+	  dwLow32  = smc_mac_addr[0]|(smc_mac_addr[1] << 8)|(smc_mac_addr[2] << 16)|(smc_mac_addr[3] << 24);
+	  dwHigh16 = smc_mac_addr[4]|(smc_mac_addr[5] << 8);
+
+	  Mac_SetRegDW(ADDRH,dwHigh16);
+	  Mac_SetRegDW(ADDRL,dwLow32);
+	}
+
+	Phy_CheckLink();
+
+DONE:
+	return err;
+}
+
+static void Rx_ReadFifo(
+	dword *pdwBuf,
+	dword dwDwordCount)
+{
+	const volatile dword * const pdwReg =
+		(const volatile dword * const)(SMC_BASE_ADDRESS+RX_DATA_FIFO);
+
+	while (dwDwordCount)
+	{
+		*pdwBuf++ = *pdwReg;
+		dwDwordCount--;
+	}
+}
+
+/* Gets the next rx status */
+static dword Rx_PopRxStatus()
+{
+	dword result=Lan_GetRegDW(RX_FIFO_INF);
+	if(result&0x00FF0000UL) {
+		/* Rx status is available, read it */
+		result=Lan_GetRegDW(RX_STATUS_FIFO);
+	} else {
+		result=0;
+	}
+	return result;
+}
+
+/* This function is used to quickly dump bad packets */
+void Rx_FastForward(dword dwDwordCount)
+{
+	if(dwDwordCount>=4)
+	{
+		dword dwTimeOut=500;
+		Lan_SetRegDW(RX_DP_CTRL,RX_DP_CTRL_RX_FFWD_);
+		while((dwTimeOut)&&(Lan_GetRegDW(RX_DP_CTRL)&RX_DP_CTRL_RX_FFWD_))
+		{
+			udelay(1);
+			dwTimeOut--;
+		}
+		if(dwTimeOut==0) {
+			SMSC_WARNING("timed out waiting for RX FFWD to finish, RX_DP_CTRL=0x%08lX",
+				Lan_GetRegDW(RX_DP_CTRL));
+		}
+	} else {
+		while(dwDwordCount) {
+			dword dwTemp=Lan_GetRegDW(RX_DATA_FIFO);
+			dwTemp=dwTemp;
+			dwDwordCount--;
+		}
+	}
+}
+
+/*-------------------------------------------------------------
+ .
+ . smc_rcv -  receive a packet from the card
+ .
+ . There is ( at least ) a packet waiting to be read from
+ . chip-memory.
+ .
+ . o Read the status
+ . o If an error, record it
+ . o otherwise, read in the packet
+ --------------------------------------------------------------
+*/
+
+static int smc_rcv()
+{
+	dword dwRxStatus=0;
+
+	if ((dwRxStatus=Rx_PopRxStatus())!=0)
+	{
+		dword dwPacketLength=((dwRxStatus&0x3FFF0000UL)>>16);
+		if((dwRxStatus&RX_STS_ES_)==0) {
+			Rx_ReadFifo(
+			  ((dword *)NetRxPackets[0]),
+			  (dwPacketLength+2+3)>>2);
+
+#if	SMC_DEBUG > 2
+			printf("Receiving Packet\n");
+			print_packet( NetRxPackets[0], dwPacketLength );
+#endif
+			NetReceive(NetRxPackets[0]+2, dwPacketLength-2);
+			return dwPacketLength;
+		}
+
+		/* if we get here then the packet is to be read */
+		/*   out of the fifo and discarded */
+		dwPacketLength+=(2+3);
+		dwPacketLength>>=2;
+		Rx_FastForward(dwPacketLength);
+	}
+
+	return 0;
+}
+
+
+/*----------------------------------------------------
+ . smc_close
+ .
+ . this makes the board clean up everything that it can
+ . and not talk to the outside world.	Caused by
+ . an 'ifconfig ethX down'
+ .
+ -----------------------------------------------------*/
+static int smc_close()
+{
+	PRINTK2("%s: smc_close\n", SMC_DEV_NAME);
+
+	/* clear everything */
+	smc_shutdown();
+
+	return 0;
+}
+
+/*------------------------------------------------------------
+ . Configures the specified PHY using Autonegotiation. Calls
+ . smc_phy_fixed() if the user has requested a certain config.
+ .-------------------------------------------------------------*/
+
+#ifndef CONFIG_SMC91111_EXT_PHY
+
+static void Phy_SetLink()
+{
+	word wTemp;
+	word status;
+	int timeout;
+
+	SMSC_TRACE("-->Phy_SetLink");
+
+	/* Because this is part of the single threaded initialization */
+	/*   path there is no need to acquire the MacPhyAccessLock */
+
+	wTemp=Phy_GetRegW(PHY_ANEG_ADV);
+	/* Advertise all speeds and pause capabilities */
+	wTemp|=(PHY_ANEG_ADV_PAUSE_|PHY_ANEG_ADV_SPEED_);
+	Phy_SetRegW(PHY_ANEG_ADV,wTemp);
+
+	/*  begin to establish link */
+	Phy_SetRegW(PHY_BCR,
+		PHY_BCR_AUTO_NEG_ENABLE_|
+		PHY_BCR_RESTART_AUTO_NEG_);
+
+	/* Wait for autoneg to complete */
+	timeout = CONFIG_SMC_AUTONEG_TIMEOUT * 100;
+	do {
+
+		status = Phy_GetRegW(PHY_BSR);
+		if (status & PHY_BSR_AUTO_NEG_COMP_) {
+	SMSC_TRACE("-->Phy_SetLink autoneg complete");
+			/* auto-negotiate complete */
+			break;
+		}
+
+		udelay(5000);	/* wait 500 millisecs */
+
+		/* Restart auto-negotiation if remote fault */
+		if (status & PHY_BSR_REMOTE_FAULT_) {
+			printf ("%s: PHY remote fault detected\n",
+				SMC_DEV_NAME);
+
+			/* Restart auto-negotiation */
+			printf ("%s: PHY restarting auto-negotiation\n",SMC_DEV_NAME);
+			Phy_SetRegW(PHY_BCR,
+				    PHY_BCR_AUTO_NEG_ENABLE_|
+				    PHY_BCR_RESTART_AUTO_NEG_);
+		}
+	} while (timeout--);
+
+	if (timeout < 1) {
+		printf ("%s: PHY auto-negotiate timed out\n", SMC_DEV_NAME);
+	}
+
+	if (status & PHY_BSR_REMOTE_FAULT_) {
+		printf ("%s: PHY remote fault detected\n", SMC_DEV_NAME);
+	}
+}
+
+static void smc_phy_configure ()
+{
+	word wTemp=0;
+	word wPhyId1=0;
+	dword wPhyId2=0;
+	dword dwLoopCount=0;
+	dword dwPhyAddr = SMC_PHY_ADDR;
+
+	SMSC_TRACE("-->Phy_Initialize");
+
+	if(dwPhyAddr!=0xFFFFFFFFUL) {
+		switch(dwIdRev&0xFFFF0000) {
+		case 0x01170000UL:
+		case 0x01150000UL:
+			{
+				dword dwHwCfg=Lan_GetRegDW(HW_CFG);
+				if(dwHwCfg&HW_CFG_EXT_PHY_DET_) {
+		    /* External phy is requested, supported, and detected */
+					/* Attempt to switch */
+					/* NOTE: Assuming Rx and Tx are stopped */
+					/*   because Phy_Initialize is called before  */
+					/*   Rx_Initialize and Tx_Initialize */
+
+					/* Disable phy clocks to the mac */
+					dwHwCfg&= (~HW_CFG_PHY_CLK_SEL_);
+					dwHwCfg|= HW_CFG_PHY_CLK_SEL_CLK_DIS_;
+					Lan_SetRegDW(HW_CFG,dwHwCfg);
+					udelay(10);/* wait for clocks to acutally stop */
+
+					/* switch to external phy */
+					dwHwCfg|=HW_CFG_EXT_PHY_EN_;
+					Lan_SetRegDW(HW_CFG,dwHwCfg);
+
+					/* Enable phy clocks to the mac */
+					dwHwCfg&= (~HW_CFG_PHY_CLK_SEL_);
+					dwHwCfg|= HW_CFG_PHY_CLK_SEL_EXT_PHY_;
+					Lan_SetRegDW(HW_CFG,dwHwCfg);
+					udelay(10);/* wait for clocks to actually start */
+
+					dwHwCfg|=HW_CFG_SMI_SEL_;
+					Lan_SetRegDW(HW_CFG,dwHwCfg);
+
+					/* Because this is part of the single threaded initialization */
+					/*   path there is no need to acquire the MacPhyAccessLock */
+					if(dwPhyAddr<=31) {
+						/* only check the phy address specified */
+						dwPhyAddress=dwPhyAddr;
+						wPhyId1=Phy_GetRegW(PHY_ID_1);
+						wPhyId2=Phy_GetRegW(PHY_ID_2);
+					} else {
+						/* auto detect phy */
+						dword address=0;
+						for(address=0;address<=31;address++) {
+							dwPhyAddress=address;
+							wPhyId1=Phy_GetRegW(PHY_ID_1);
+							wPhyId2=Phy_GetRegW(PHY_ID_2);
+							if((wPhyId1!=0xFFFFU)||(wPhyId2!=0xFFFFU)) {
+								SMSC_TRACE("Detected Phy at address = 0x%02lX = %ld",
+									address,address);
+								break;
+							}
+						}
+						if(address>=32) {
+							SMSC_WARNING("Failed to auto detect external phy");
+						}
+					}
+					if((wPhyId1==0xFFFFU)&&(wPhyId2==0xFFFFU)) {
+						SMSC_WARNING("External Phy is not accessable");
+						SMSC_WARNING("  using internal phy instead");
+						/* revert back to interal phy settings. */
+
+						/* Disable phy clocks to the mac */
+						dwHwCfg&= (~HW_CFG_PHY_CLK_SEL_);
+						dwHwCfg|= HW_CFG_PHY_CLK_SEL_CLK_DIS_;
+						Lan_SetRegDW(HW_CFG,dwHwCfg);
+						udelay(10);/* wait for clocks to actually stop */
+
+						/* switch to internal phy */
+						dwHwCfg&=(~HW_CFG_EXT_PHY_EN_);
+						Lan_SetRegDW(HW_CFG,dwHwCfg);
+
+						/* Enable phy clocks to the mac */
+						dwHwCfg&= (~HW_CFG_PHY_CLK_SEL_);
+						dwHwCfg|= HW_CFG_PHY_CLK_SEL_INT_PHY_;
+						Lan_SetRegDW(HW_CFG,dwHwCfg);
+						udelay(10);/* wait for clocks to actually start */
+
+						dwHwCfg&=(~HW_CFG_SMI_SEL_);
+						Lan_SetRegDW(HW_CFG,dwHwCfg);
+						goto USE_INTERNAL_PHY;
+					} else {
+						SMSC_TRACE("Successfully switched to external phy");
+					}
+				} else {
+					SMSC_WARNING("No External Phy Detected");
+					SMSC_WARNING("  using internal phy instead");
+					goto USE_INTERNAL_PHY;
+				}
+			};break;
+		default:
+			SMSC_WARNING("External Phy is not supported");
+			SMSC_WARNING("  using internal phy instead");
+			goto USE_INTERNAL_PHY;
+		}
+	} else {
+USE_INTERNAL_PHY:
+		SMSC_TRACE("Using internal phy");
+		dwPhyAddress=1;
+	}
+
+	wPhyId1=Phy_GetRegW(PHY_ID_1);
+	wPhyId2=Phy_GetRegW(PHY_ID_2);
+	if((wPhyId1==0xFFFFU)&&(wPhyId2==0xFFFFU)) {
+		SMSC_WARNING("Phy Not detected");
+		goto DONE;
+	}
+
+	dwLinkSpeed=LINK_OFF;
+	dwLinkSettings=LINK_OFF;
+	/* reset the PHY */
+	Phy_SetRegW(PHY_BCR,PHY_BCR_RESET_);
+	dwLoopCount=100000;
+	do {
+		udelay(10);
+		wTemp=Phy_GetRegW(PHY_BCR);
+		dwLoopCount--;
+	} while((dwLoopCount>0) && (wTemp&PHY_BCR_RESET_));
+	if(wTemp&PHY_BCR_RESET_) {
+		SMSC_WARNING("PHY reset failed to complete.");
+		goto DONE;
+	}
+
+	Phy_SetLink();
+
+	/*
+	init_timer(&(LinkPollingTimer));
+	LinkPollingTimer.function=Phy_CheckLink;
+	LinkPollingTimer.data=(unsigned long)privateData;
+	LinkPollingTimer.expires=jiffies+HZ;
+	add_timer(&(LinkPollingTimer));
+	*/
+
+
+DONE:
+	SMSC_TRACE("<--Phy_Initialize");
+}
+#endif /* !CONFIG_SMC91111_EXT_PHY */
+
+
+#if SMC_DEBUG > 2
+static void print_packet( byte * buf, int length )
+{
+	int i;
+	int remainder;
+	int lines;
+
+	printf("Packet of length %d \n", length );
+
+#if SMC_DEBUG > 3
+	lines = length / 16;
+	remainder = length % 16;
+
+	for ( i = 0; i < lines ; i ++ ) {
+		int cur;
+
+		for ( cur = 0; cur < 8; cur ++ ) {
+			byte a, b;
+
+			a = *(buf ++ );
+			b = *(buf ++ );
+			printf("%02x%02x ", a, b );
+		}
+		printf("\n");
+	}
+	for ( i = 0; i < remainder/2 ; i++ ) {
+		byte a, b;
+
+		a = *(buf ++ );
+		b = *(buf ++ );
+		printf("%02x%02x ", a, b );
+	}
+	printf("\n");
+#endif
+}
+#endif
+
+int eth_init(bd_t *bd) {
+	return (smc_open(bd));
+}
+
+void eth_halt() {
+	smc_close();
+}
+
+int eth_rx() {
+	return smc_rcv();
+}
+
+int eth_send(volatile void *packet, int length) {
+	return smc_send_packet(packet, length);
+}
+
+int smc_get_ethaddr (bd_t * bd)
+{
+	int env_size, rom_valid, env_present = 0, reg;
+	char *s = NULL, *e,  es[] = "11:22:33:44:55:66";
+	char s_env_mac[64];
+	uchar v_env_mac[6], v_rom_mac[6], *v_mac;
+
+	env_size = getenv_r ("ethaddr", s_env_mac, sizeof (s_env_mac));
+	if ((env_size > 0) && (env_size < sizeof (es))) {	/* exit if env is bad */
+		printf ("\n*** ERROR: ethaddr is not set properly!!\n");
+		return (-1);
+	}
+
+	if (env_size > 0) {
+		env_present = 1;
+		s = s_env_mac;
+	}
+
+	for (reg = 0; reg < 6; ++reg) { /* turn string into mac value */
+		v_env_mac[reg] = s ? simple_strtoul (s, &e, 16) : 0;
+		if (s)
+			s = (*e) ? e + 1 : e;
+	}
+
+	rom_valid = get_rom_mac (v_rom_mac);	/* get ROM mac value if any */
+
+	if (!env_present) {	/* if NO env */
+		if (rom_valid) {	/* but ROM is valid */
+			v_mac = v_rom_mac;
+			sprintf (s_env_mac, "%02X:%02X:%02X:%02X:%02X:%02X",
+				 v_mac[0], v_mac[1], v_mac[2], v_mac[3],
+				 v_mac[4], v_mac[5]);
+			setenv ("ethaddr", s_env_mac);
+		} else {	/* no env, bad ROM */
+			printf ("\n*** ERROR: ethaddr is NOT set !!\n");
+			return (-1);
+		}
+	} else {		/* good env, don't care ROM */
+		v_mac = v_env_mac;	/* always use a good env over a ROM */
+	}
+
+	if (env_present && rom_valid) { /* if both env and ROM are good */
+		if (memcmp (v_env_mac, v_rom_mac, 6) != 0) {
+			printf ("\nWarning: MAC addresses don't match:\n");
+			printf ("\tHW MAC address:  "
+				"%02X:%02X:%02X:%02X:%02X:%02X\n",
+				v_rom_mac[0], v_rom_mac[1],
+				v_rom_mac[2], v_rom_mac[3],
+				v_rom_mac[4], v_rom_mac[5] );
+			printf ("\t\"ethaddr\" value: "
+				"%02X:%02X:%02X:%02X:%02X:%02X\n",
+				v_env_mac[0], v_env_mac[1],
+				v_env_mac[2], v_env_mac[3],
+				v_env_mac[4], v_env_mac[5]) ;
+			debug ("### Set MAC addr from environment\n");
+		}
+	}
+	memcpy (bd->bi_enetaddr, v_mac, 6);	/* update global address to match env (allows env changing) */
+	smc_set_mac_addr ((char*)v_mac);        /* use old function to update smc default */
+	PRINTK("Using MAC Address %02X:%02X:%02X:%02X:%02X:%02X\n", v_mac[0], v_mac[1],
+		v_mac[2], v_mac[3], v_mac[4], v_mac[5]);
+	return (0);
+}
+
+static int get_rom_mac (unsigned char *v_rom_mac)
+{
+	dword dwHigh16=0;
+	dword dwLow32=0;
+
+	dwHigh16=Mac_GetRegDW(ADDRH);
+	dwLow32=Mac_GetRegDW(ADDRL);
+
+	if((dwHigh16==0x0000FFFFUL)&&(dwLow32==0xFFFFFFFF))
+	  return 0;
+
+	v_rom_mac[0]=LOBYTE(LOWORD(dwLow32));
+	v_rom_mac[1]=HIBYTE(LOWORD(dwLow32));
+	v_rom_mac[2]=LOBYTE(HIWORD(dwLow32));
+	v_rom_mac[3]=HIBYTE(HIWORD(dwLow32));
+	v_rom_mac[4]=LOBYTE(LOWORD(dwHigh16));
+	v_rom_mac[5]=HIBYTE(LOWORD(dwHigh16));
+
+	return 1;
+}
+#endif /* CONFIG_DRIVER_SMC911X */
diff --git a/drivers/net/smc911x.h b/drivers/net/smc911x.h
new file mode 100644
index 0000000000..26e1435f6b
--- /dev/null
+++ b/drivers/net/smc911x.h
@@ -0,0 +1,488 @@
+/*------------------------------------------------------------------------
+ . smc911x.h - macros for the LAN911X Ethernet Driver
+ .
+ . (C) Copyright 2002
+ . Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ . Rolf Offermanns <rof@sysgo.de>
+ . Copyright (C) 2001 Standard Microsystems Corporation (SMSC)
+ .       Developed by Simple Network Magic Corporation (SNMC)
+ . Copyright (C) 1996 by Erik Stahlman (ES)
+ .
+ . This program is free software; you can redistribute it and/or modify
+ . it under the terms of the GNU General Public License as published by
+ . the Free Software Foundation; either version 2 of the License, or
+ . (at your option) any later version.
+ .
+ . This program is distributed in the hope that it will be useful,
+ . but WITHOUT ANY WARRANTY; without even the implied warranty of
+ . MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ . GNU General Public License for more details.
+ .
+ . You should have received a copy of the GNU General Public License
+ . along with this program; if not, write to the Free Software
+ . Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ .
+ . This file contains register information and access macros for
+ . the LAN91C111 single chip ethernet controller.  It is a modified
+ . version of the smc9194.h file.
+ .
+ . Information contained in this file was obtained from the LAN91C111
+ . manual from SMC.  To get a copy, if you really want one, you can find
+ . information under www.smsc.com.
+ .
+ . Authors
+ . 	Erik Stahlman				( erik@vt.edu )
+ .	Daris A Nevil				( dnevil@snmc.com )
+ .
+ . History
+ . 03/16/01		Daris A Nevil	Modified for use with LAN91C111 device
+ .
+ ---------------------------------------------------------------------------*/
+#ifndef _SMC911X_H_
+#define _SMC911X_H_
+
+#include <asm/types.h>
+#include <config.h>
+
+/*
+ * This function may be called by the board specific initialisation code
+ * in order to override the default mac address.
+ */
+
+void smc_set_mac_addr(const char *addr);
+
+
+/* I want some simple types */
+
+typedef unsigned char			byte;
+typedef unsigned short			word;
+typedef unsigned long int 		dword;
+
+/*
+ . DEBUGGING LEVELS
+ .
+ . 0 for normal operation
+ . 1 for slightly more details
+ . >2 for various levels of increasingly useless information
+ .    2 for interrupt tracking, status flags
+ .    3 for packet info
+ .    4 for complete packet dumps
+*/
+/*#define SMC_DEBUG 0 */
+
+
+typedef unsigned char BOOLEAN;
+
+#define TRUE	((BOOLEAN)1)
+#define FALSE	((BOOLEAN)0)
+
+#define HIBYTE(w)  ((byte)(((word)(w))>>8))
+#define LOBYTE(w)  ((byte)(((word)(w))&0x00FFU))
+#define HIWORD(dW) ((word)(((dword)(dW))>>16))
+#define LOWORD(dW) ((word)(((dword)(dW))&0x0000FFFFUL))
+
+
+
+#define Lan_GetRegDW(dwOffset) \
+	((*(volatile dword *)(SMC_BASE_ADDRESS+dwOffset)))
+#define Lan_SetRegDW(dwOffset,dwVal) \
+	((*(volatile dword *)(SMC_BASE_ADDRESS+dwOffset))=(dwVal))
+#define Lan_ClrBitsDW(dwOffset,dwBits) \
+	((*(volatile dword *)(SMC_BASE_ADDRESS+dwOffset))&=(~dwBits))
+#define Lan_SetBitsDW(dwOffset,dwBits) \
+	((*(volatile dword *)(SMC_BASE_ADDRESS+dwOffset))|=(dwBits))
+
+
+//Below are the register offsets and bit definitions
+//  of the Lan911x memory space
+#define RX_DATA_FIFO	    (0x00UL)
+
+#define TX_DATA_FIFO        (0x20UL)
+#define		TX_CMD_A_ON_COMP_			(0x80000000UL)
+#define		TX_CMD_A_BUF_END_ALGN_		(0x03000000UL)
+#define		TX_CMD_A_4_BYTE_ALGN_		(0x00000000UL)
+#define		TX_CMD_A_16_BYTE_ALGN_		(0x01000000UL)
+#define		TX_CMD_A_32_BYTE_ALGN_		(0x02000000UL)
+#define		TX_CMD_A_DATA_OFFSET_		(0x001F0000UL)
+#define		TX_CMD_A_FIRST_SEG_			(0x00002000UL)
+#define		TX_CMD_A_LAST_SEG_			(0x00001000UL)
+#define		TX_CMD_A_BUF_SIZE_			(0x000007FFUL)
+#define		TX_CMD_B_PKT_TAG_			(0xFFFF0000UL)
+#define		TX_CMD_B_ADD_CRC_DISABLE_	(0x00002000UL)
+#define		TX_CMD_B_DISABLE_PADDING_	(0x00001000UL)
+#define		TX_CMD_B_PKT_BYTE_LENGTH_	(0x000007FFUL)
+
+#define RX_STATUS_FIFO      (0x40UL)
+#define		RX_STS_ES_			(0x00008000UL)
+#define		RX_STS_MCAST_		(0x00000400UL)
+#define RX_STATUS_FIFO_PEEK (0x44UL)
+#define TX_STATUS_FIFO		(0x48UL)
+#define TX_STATUS_FIFO_PEEK (0x4CUL)
+#define ID_REV              (0x50UL)
+#define		ID_REV_CHIP_ID_		(0xFFFF0000UL)	// RO
+#define		ID_REV_REV_ID_		(0x0000FFFFUL)	// RO
+
+#define INT_CFG				(0x54UL)
+#define		INT_CFG_INT_DEAS_		(0xFF000000UL)	// R/W
+#define     INT_CFG_INT_DEAS_CLR_	(0x00004000UL)  // SC
+#define     INT_CFG_INT_DEAS_STS_	(0x00002000UL)  // SC
+#define		INT_CFG_IRQ_INT_		(0x00001000UL)	// RO
+#define		INT_CFG_IRQ_EN_			(0x00000100UL)	// R/W
+#define		INT_CFG_IRQ_POL_		(0x00000010UL)	// R/W Not Affected by SW Reset
+#define		INT_CFG_IRQ_TYPE_		(0x00000001UL)	// R/W Not Affected by SW Reset
+
+#define INT_STS				(0x58UL)
+#define		INT_STS_SW_INT_		(0x80000000UL)	// R/WC
+#define		INT_STS_TXSTOP_INT_	(0x02000000UL)	// R/WC
+#define		INT_STS_RXSTOP_INT_	(0x01000000UL)	// R/WC
+#define		INT_STS_RXDFH_INT_	(0x00800000UL)	// R/WC
+#define		INT_STS_RXDF_INT_	(0x00400000UL)	// R/WC
+#define		INT_STS_TX_IOC_		(0x00200000UL)	// R/WC
+#define		INT_STS_RXD_INT_	(0x00100000UL)	// R/WC
+#define		INT_STS_GPT_INT_	(0x00080000UL)	// R/WC
+#define		INT_STS_PHY_INT_	(0x00040000UL)	// RO
+#define		INT_STS_PME_INT_	(0x00020000UL)	// R/WC
+#define		INT_STS_TXSO_		(0x00010000UL)	// R/WC
+#define		INT_STS_RWT_		(0x00008000UL)	// R/WC
+#define		INT_STS_RXE_		(0x00004000UL)	// R/WC
+#define		INT_STS_TXE_		(0x00002000UL)	// R/WC
+#define		INT_STS_TDFU_		(0x00000800UL)	// R/WC
+#define		INT_STS_TDFO_		(0x00000400UL)	// R/WC
+#define		INT_STS_TDFA_		(0x00000200UL)	// R/WC
+#define		INT_STS_TSFF_		(0x00000100UL)	// R/WC
+#define		INT_STS_TSFL_		(0x00000080UL)	// R/WC
+#define		INT_STS_RXDF_		(0x00000040UL)	// R/WC
+#define		INT_STS_RDFL_		(0x00000020UL)	// R/WC
+#define		INT_STS_RSFF_		(0x00000010UL)	// R/WC
+#define		INT_STS_RSFL_		(0x00000008UL)	// R/WC
+#define		INT_STS_GPIO2_INT_	(0x00000004UL)	// R/WC
+#define		INT_STS_GPIO1_INT_	(0x00000002UL)	// R/WC
+#define		INT_STS_GPIO0_INT_	(0x00000001UL)	// R/WC
+
+#define INT_EN				(0x5CUL)
+#define		INT_EN_SW_INT_EN_		(0x80000000UL)	// R/W
+#define		INT_EN_TXSTOP_INT_EN_	(0x02000000UL)	// R/W
+#define		INT_EN_RXSTOP_INT_EN_	(0x01000000UL)	// R/W
+#define		INT_EN_RXDFH_INT_EN_	(0x00800000UL)	// R/W
+#define		INT_EN_TIOC_INT_EN_		(0x00200000UL)	// R/W
+#define		INT_EN_RXD_INT_EN_		(0x00100000UL)	// R/W
+#define		INT_EN_GPT_INT_EN_		(0x00080000UL)	// R/W
+#define		INT_EN_PHY_INT_EN_		(0x00040000UL)	// R/W
+#define		INT_EN_PME_INT_EN_		(0x00020000UL)	// R/W
+#define		INT_EN_TXSO_EN_			(0x00010000UL)	// R/W
+#define		INT_EN_RWT_EN_			(0x00008000UL)	// R/W
+#define		INT_EN_RXE_EN_			(0x00004000UL)	// R/W
+#define		INT_EN_TXE_EN_			(0x00002000UL)	// R/W
+#define		INT_EN_TDFU_EN_			(0x00000800UL)	// R/W
+#define		INT_EN_TDFO_EN_			(0x00000400UL)	// R/W
+#define		INT_EN_TDFA_EN_			(0x00000200UL)	// R/W
+#define		INT_EN_TSFF_EN_			(0x00000100UL)	// R/W
+#define		INT_EN_TSFL_EN_			(0x00000080UL)	// R/W
+#define		INT_EN_RXDF_EN_			(0x00000040UL)	// R/W
+#define		INT_EN_RDFL_EN_			(0x00000020UL)	// R/W
+#define		INT_EN_RSFF_EN_			(0x00000010UL)	// R/W
+#define		INT_EN_RSFL_EN_			(0x00000008UL)	// R/W
+#define		INT_EN_GPIO2_INT_		(0x00000004UL)	// R/W
+#define		INT_EN_GPIO1_INT_		(0x00000002UL)	// R/W
+#define		INT_EN_GPIO0_INT_		(0x00000001UL)	// R/W
+
+#define BYTE_TEST				(0x64UL)
+#define FIFO_INT				(0x68UL)
+#define		FIFO_INT_TX_AVAIL_LEVEL_	(0xFF000000UL)	// R/W
+#define		FIFO_INT_TX_STS_LEVEL_		(0x00FF0000UL)	// R/W
+#define		FIFO_INT_RX_AVAIL_LEVEL_	(0x0000FF00UL)	// R/W
+#define		FIFO_INT_RX_STS_LEVEL_		(0x000000FFUL)	// R/W
+
+#define RX_CFG					(0x6CUL)
+#define		RX_CFG_RX_END_ALGN_		(0xC0000000UL)	// R/W
+#define			RX_CFG_RX_END_ALGN4_		(0x00000000UL)	// R/W
+#define			RX_CFG_RX_END_ALGN16_		(0x40000000UL)	// R/W
+#define			RX_CFG_RX_END_ALGN32_		(0x80000000UL)	// R/W
+#define		RX_CFG_RX_DMA_CNT_		(0x0FFF0000UL)	// R/W
+#define		RX_CFG_RX_DUMP_			(0x00008000UL)	// R/W
+#define		RX_CFG_RXDOFF_			(0x00001F00UL)	// R/W
+
+#define TX_CFG					(0x70UL)
+#define		TX_CFG_TXS_DUMP_		(0x00008000UL)	// Self Clearing
+#define		TX_CFG_TXD_DUMP_		(0x00004000UL)	// Self Clearing
+#define		TX_CFG_TXSAO_			(0x00000004UL)	// R/W
+#define		TX_CFG_TX_ON_			(0x00000002UL)	// R/W
+#define		TX_CFG_STOP_TX_			(0x00000001UL)	// Self Clearing
+
+#define HW_CFG					(0x74UL)
+#define		HW_CFG_TTM_				(0x00200000UL)	// R/W
+#define		HW_CFG_SF_				(0x00100000UL)	// R/W
+#define		HW_CFG_TX_FIF_SZ_		(0x000F0000UL)	// R/W
+#define		HW_CFG_TR_				(0x00003000UL)	// R/W
+#define     HW_CFG_PHY_CLK_SEL_		(0x00000060UL)  // R/W //only available on 115/117
+#define         HW_CFG_PHY_CLK_SEL_INT_PHY_	(0x00000000UL) //R/W //only available on 115/117
+#define         HW_CFG_PHY_CLK_SEL_EXT_PHY_	(0x00000020UL) //R/W //only available on 115/117
+#define         HW_CFG_PHY_CLK_SEL_CLK_DIS_	(0x00000040UL) //R/W //only available on 115/117
+#define     HW_CFG_SMI_SEL_			(0x00000010UL)  // R/W //only available on 115/117
+#define     HW_CFG_EXT_PHY_DET_		(0x00000008UL)  // RO  //only available on 115/117
+#define     HW_CFG_EXT_PHY_EN_		(0x00000004UL)  // R/W //only available on 115/117
+#define		HW_CFG_32_16_BIT_MODE_	(0x00000004UL)	// RO  //only available on 116/118
+#define     HW_CFG_SRST_TO_			(0x00000002UL)  // RO  //only available on 115/117
+#define		HW_CFG_SRST_			(0x00000001UL)	// Self Clearing
+
+#define RX_DP_CTRL				(0x78UL)
+#define		RX_DP_CTRL_RX_FFWD_		(0x80000000UL)	// RO
+
+#define RX_FIFO_INF				(0x7CUL)
+#define		RX_FIFO_INF_RXSUSED_	(0x00FF0000UL)	// RO
+#define		RX_FIFO_INF_RXDUSED_	(0x0000FFFFUL)	// RO
+
+#define TX_FIFO_INF				(0x80UL)
+#define		TX_FIFO_INF_TSUSED_		(0x00FF0000UL)  // RO
+#define		TX_FIFO_INF_TDFREE_		(0x0000FFFFUL)	// RO
+
+#define PMT_CTRL				(0x84UL)
+#define		PMT_CTRL_PM_MODE_			(0x00003000UL)	// Self Clearing
+#define	        PMT_CTRL_PM_MODE_D0_	(0x00000000UL)  // Self Clearing
+#define         PMT_CTRL_PM_MODE_D1_	(0x00001000UL)  // Self Clearing
+#define         PMT_CTRL_PM_MODE_D2_	(0x00002000UL)  // Self Clearing
+#define         PMT_CTRL_PM_MODE_D3_	(0x00003000UL)  // Self Clearing
+#define		PMT_CTRL_PHY_RST_			(0x00000400UL)	// Self Clearing
+#define		PMT_CTRL_WOL_EN_			(0x00000200UL)	// R/W
+#define		PMT_CTRL_ED_EN_				(0x00000100UL)	// R/W
+#define		PMT_CTRL_PME_TYPE_			(0x00000040UL)	// R/W Not Affected by SW Reset
+#define		PMT_CTRL_WUPS_				(0x00000030UL)	// R/WC
+#define			PMT_CTRL_WUPS_NOWAKE_		(0x00000000UL)	// R/WC
+#define			PMT_CTRL_WUPS_ED_			(0x00000010UL)	// R/WC
+#define			PMT_CTRL_WUPS_WOL_			(0x00000020UL)	// R/WC
+#define			PMT_CTRL_WUPS_MULTI_		(0x00000030UL)	// R/WC
+#define		PMT_CTRL_PME_IND_		(0x00000008UL)	// R/W
+#define		PMT_CTRL_PME_POL_		(0x00000004UL)	// R/W
+#define		PMT_CTRL_PME_EN_		(0x00000002UL)	// R/W Not Affected by SW Reset
+#define		PMT_CTRL_READY_			(0x00000001UL)	// RO
+
+#define GPIO_CFG				(0x88UL)
+#define		GPIO_CFG_LED3_EN_		(0x40000000UL)	// R/W
+#define		GPIO_CFG_LED2_EN_		(0x20000000UL)	// R/W
+#define		GPIO_CFG_LED1_EN_		(0x10000000UL)	// R/W
+#define		GPIO_CFG_GPIO2_INT_POL_	(0x04000000UL)	// R/W
+#define		GPIO_CFG_GPIO1_INT_POL_	(0x02000000UL)	// R/W
+#define		GPIO_CFG_GPIO0_INT_POL_	(0x01000000UL)	// R/W
+#define		GPIO_CFG_EEPR_EN_		(0x00700000UL)	// R/W
+#define		GPIO_CFG_GPIOBUF2_		(0x00040000UL)	// R/W
+#define		GPIO_CFG_GPIOBUF1_		(0x00020000UL)	// R/W
+#define		GPIO_CFG_GPIOBUF0_		(0x00010000UL)	// R/W
+#define		GPIO_CFG_GPIODIR2_		(0x00000400UL)	// R/W
+#define		GPIO_CFG_GPIODIR1_		(0x00000200UL)	// R/W
+#define		GPIO_CFG_GPIODIR0_		(0x00000100UL)	// R/W
+#define		GPIO_CFG_GPIOD4_		(0x00000020UL)	// R/W
+#define		GPIO_CFG_GPIOD3_		(0x00000010UL)	// R/W
+#define		GPIO_CFG_GPIOD2_		(0x00000004UL)	// R/W
+#define		GPIO_CFG_GPIOD1_		(0x00000002UL)	// R/W
+#define		GPIO_CFG_GPIOD0_		(0x00000001UL)	// R/W
+
+#define GPT_CFG					(0x8CUL)
+#define		GPT_CFG_TIMER_EN_		(0x20000000UL)	// R/W
+#define		GPT_CFG_GPT_LOAD_		(0x0000FFFFUL)	// R/W
+
+#define GPT_CNT					(0x90UL)
+#define		GPT_CNT_GPT_CNT_		(0x0000FFFFUL)	// RO
+
+#define ENDIAN					(0x98UL)
+#define FREE_RUN				(0x9CUL)
+#define RX_DROP					(0xA0UL)
+#define MAC_CSR_CMD				(0xA4UL)
+#define		MAC_CSR_CMD_CSR_BUSY_	(0x80000000UL)	// Self Clearing
+#define		MAC_CSR_CMD_R_NOT_W_	(0x40000000UL)	// R/W
+#define		MAC_CSR_CMD_CSR_ADDR_	(0x000000FFUL)	// R/W
+
+#define MAC_CSR_DATA			(0xA8UL)
+#define AFC_CFG					(0xACUL)
+#define		AFC_CFG_AFC_HI_			(0x00FF0000UL)	// R/W
+#define		AFC_CFG_AFC_LO_			(0x0000FF00UL)	// R/W
+#define		AFC_CFG_BACK_DUR_		(0x000000F0UL)	// R/W
+#define		AFC_CFG_FCMULT_			(0x00000008UL)	// R/W
+#define		AFC_CFG_FCBRD_			(0x00000004UL)	// R/W
+#define		AFC_CFG_FCADD_			(0x00000002UL)	// R/W
+#define		AFC_CFG_FCANY_			(0x00000001UL)	// R/W
+
+#define E2P_CMD					(0xB0UL)
+#define		E2P_CMD_EPC_BUSY_		(0x80000000UL)	// Self Clearing
+#define		E2P_CMD_EPC_CMD_		(0x70000000UL)	// R/W
+#define			E2P_CMD_EPC_CMD_READ_	(0x00000000UL)	// R/W
+#define			E2P_CMD_EPC_CMD_EWDS_	(0x10000000UL)	// R/W
+#define			E2P_CMD_EPC_CMD_EWEN_	(0x20000000UL)	// R/W
+#define			E2P_CMD_EPC_CMD_WRITE_	(0x30000000UL)	// R/W
+#define			E2P_CMD_EPC_CMD_WRAL_	(0x40000000UL)	// R/W
+#define			E2P_CMD_EPC_CMD_ERASE_	(0x50000000UL)	// R/W
+#define			E2P_CMD_EPC_CMD_ERAL_	(0x60000000UL)	// R/W
+#define			E2P_CMD_EPC_CMD_RELOAD_	(0x70000000UL)  // R/W
+#define		E2P_CMD_EPC_TIMEOUT_	(0x00000200UL)	// R
+#define		E2P_CMD_MAC_ADDR_LOADED_	(0x00000100UL)	// RO
+#define		E2P_CMD_EPC_ADDR_		(0x000000FFUL)	// R/W
+
+#define E2P_DATA				(0xB4UL)
+#define		E2P_DATA_EEPROM_DATA_	(0x000000FFUL)	// R/W
+//end of lan register offsets and bit definitions
+#define LAN_REGISTER_EXTENT		(0x00000100UL)
+
+#define LINK_OFF				(0x00UL)
+#define LINK_SPEED_10HD			(0x01UL)
+#define LINK_SPEED_10FD			(0x02UL)
+#define LINK_SPEED_100HD		(0x04UL)
+#define LINK_SPEED_100FD		(0x08UL)
+#define LINK_SYMMETRIC_PAUSE	(0x10UL)
+#define LINK_ASYMMETRIC_PAUSE	(0x20UL)
+#define LINK_AUTO_NEGOTIATE		(0x40UL)
+
+
+
+/*
+ ****************************************************************************
+ ****************************************************************************
+ *	MAC Control and Status Register (Indirect Address)
+ *	Offset (through the MAC_CSR CMD and DATA port)
+ ****************************************************************************
+ ****************************************************************************
+ *
+ */
+#define MAC_CR				(0x01UL)	// R/W
+
+	/* MAC_CR - MAC Control Register */
+	#define MAC_CR_RXALL_		(0x80000000UL)
+	#define MAC_CR_HBDIS_		(0x10000000UL)
+	#define MAC_CR_RCVOWN_		(0x00800000UL)
+	#define MAC_CR_LOOPBK_		(0x00200000UL)
+	#define MAC_CR_FDPX_		(0x00100000UL)
+	#define MAC_CR_MCPAS_		(0x00080000UL)
+	#define MAC_CR_PRMS_		(0x00040000UL)
+	#define MAC_CR_INVFILT_		(0x00020000UL)
+	#define MAC_CR_PASSBAD_		(0x00010000UL)
+	#define MAC_CR_HFILT_		(0x00008000UL)
+	#define MAC_CR_HPFILT_		(0x00002000UL)
+	#define MAC_CR_LCOLL_		(0x00001000UL)
+	#define MAC_CR_BCAST_		(0x00000800UL)
+	#define MAC_CR_DISRTY_		(0x00000400UL)
+	#define MAC_CR_PADSTR_		(0x00000100UL)
+	#define MAC_CR_BOLMT_MASK_	(0x000000C0UL)
+	#define MAC_CR_DFCHK_		(0x00000020UL)
+	#define MAC_CR_TXEN_		(0x00000008UL)
+	#define MAC_CR_RXEN_		(0x00000004UL)
+
+#define ADDRH				(0x02UL)	// R/W mask 0x0000FFFFUL
+#define ADDRL				(0x03UL)	// R/W mask 0xFFFFFFFFUL
+#define HASHH				(0x04UL)	// R/W
+#define HASHL				(0x05UL)	// R/W
+
+#define MII_ACC				(0x06UL)	// R/W
+	#define MII_ACC_PHY_ADDR_	(0x0000F800UL)
+	#define MII_ACC_MIIRINDA_	(0x000007C0UL)
+	#define MII_ACC_MII_WRITE_	(0x00000002UL)
+	#define MII_ACC_MII_BUSY_	(0x00000001UL)
+
+#define MII_DATA			(0x07UL)	// R/W mask 0x0000FFFFUL
+
+#define FLOW				(0x08UL)	// R/W
+	#define FLOW_FCPT_			(0xFFFF0000UL)
+	#define FLOW_FCPASS_		(0x00000004UL)
+	#define FLOW_FCEN_			(0x00000002UL)
+	#define FLOW_FCBSY_			(0x00000001UL)
+
+#define VLAN1				(0x09UL)	// R/W mask 0x0000FFFFUL
+#define VLAN2				(0x0AUL)	// R/W mask 0x0000FFFFUL
+
+#define WUFF				(0x0BUL)	// WO
+
+#define WUCSR				(0x0CUL)	// R/W
+	#define WUCSR_GUE_			(0x00000200UL)
+	#define WUCSR_WUFR_			(0x00000040UL)
+	#define WUCSR_MPR_			(0x00000020UL)
+	#define WUCSR_WAKE_EN_		(0x00000004UL)
+	#define WUCSR_MPEN_			(0x00000002UL)
+
+
+/*
+ ****************************************************************************
+ *	Chip Specific MII Defines
+ ****************************************************************************
+ *
+ *	Phy register offsets and bit definitions
+ *
+ */
+#define LAN9118_PHY_ID	(0x00C0001C)
+
+#define PHY_BCR		((dword)0U)
+#define PHY_BCR_RESET_					((word)0x8000U)
+#define PHY_BCR_SPEED_SELECT_		((word)0x2000U)
+#define PHY_BCR_AUTO_NEG_ENABLE_	((word)0x1000U)
+#define PHY_BCR_RESTART_AUTO_NEG_	((word)0x0200U)
+#define PHY_BCR_DUPLEX_MODE_		((word)0x0100U)
+
+#define PHY_BSR		((dword)1U)
+	#define PHY_BSR_LINK_STATUS_	((word)0x0004U)
+	#define PHY_BSR_REMOTE_FAULT_	((word)0x0010U)
+	#define PHY_BSR_AUTO_NEG_COMP_	((word)0x0020U)
+
+#define PHY_ID_1	((dword)2U)
+#define PHY_ID_2	((dword)3U)
+
+#define PHY_ANEG_ADV    ((dword)4U)
+#define PHY_ANEG_ADV_PAUSE_ ((word)0x0C00)
+#define PHY_ANEG_ADV_ASYMP_	((word)0x0800)
+#define PHY_ANEG_ADV_SYMP_	((word)0x0400)
+#define PHY_ANEG_ADV_10H_	((word)0x020)
+#define PHY_ANEG_ADV_10F_	((word)0x040)
+#define PHY_ANEG_ADV_100H_	((word)0x080)
+#define PHY_ANEG_ADV_100F_	((word)0x100)
+#define PHY_ANEG_ADV_SPEED_	((word)0x1E0)
+
+#define PHY_ANEG_LPA	((dword)5U)
+#define PHY_ANEG_LPA_ASYMP_		((word)0x0800)
+#define PHY_ANEG_LPA_SYMP_		((word)0x0400)
+#define PHY_ANEG_LPA_100FDX_	((word)0x0100)
+#define PHY_ANEG_LPA_100HDX_	((word)0x0080)
+#define PHY_ANEG_LPA_10FDX_		((word)0x0040)
+#define PHY_ANEG_LPA_10HDX_		((word)0x0020)
+
+#define PHY_MODE_CTRL_STS		((dword)17)	// Mode Control/Status Register
+	#define MODE_CTRL_STS_EDPWRDOWN_	((word)0x2000U)
+	#define MODE_CTRL_STS_ENERGYON_		((word)0x0002U)
+
+#define PHY_INT_SRC			((dword)29)
+#define PHY_INT_SRC_ENERGY_ON_			((word)0x0080U)
+#define PHY_INT_SRC_ANEG_COMP_			((word)0x0040U)
+#define PHY_INT_SRC_REMOTE_FAULT_		((word)0x0020U)
+#define PHY_INT_SRC_LINK_DOWN_			((word)0x0010U)
+
+#define PHY_INT_MASK		((dword)30)
+#define PHY_INT_MASK_ENERGY_ON_		((word)0x0080U)
+#define PHY_INT_MASK_ANEG_COMP_		((word)0x0040U)
+#define PHY_INT_MASK_REMOTE_FAULT_	((word)0x0020U)
+#define PHY_INT_MASK_LINK_DOWN_		((word)0x0010U)
+
+#define PHY_SPECIAL			((dword)31)
+#define PHY_SPECIAL_SPD_	((word)0x001CU)
+#define PHY_SPECIAL_SPD_10HALF_		((word)0x0004U)
+#define PHY_SPECIAL_SPD_10FULL_		((word)0x0014U)
+#define PHY_SPECIAL_SPD_100HALF_	((word)0x0008U)
+#define PHY_SPECIAL_SPD_100FULL_	((word)0x0018U)
+
+#define LINK_OFF				(0x00UL)
+#define LINK_SPEED_10HD			(0x01UL)
+#define LINK_SPEED_10FD			(0x02UL)
+#define LINK_SPEED_100HD		(0x04UL)
+#define LINK_SPEED_100FD		(0x08UL)
+#define LINK_SYMMETRIC_PAUSE	(0x10UL)
+#define LINK_ASYMMETRIC_PAUSE	(0x20UL)
+#define LINK_AUTO_NEGOTIATE		(0x40UL)
+
+/*-------------------------------------------------------------------------
+ .  I define some macros to make it easier to do somewhat common
+ . or slightly complicated, repeated tasks.
+ --------------------------------------------------------------------------*/
+
+/* this enables an interrupt in the interrupt mask register */
+#define SMC_ENABLE_INT(x) {;}
+
+/* this disables an interrupt from the interrupt mask register */
+
+#define SMC_DISABLE_INT(x) {;}
+
+#define TX_FIFO_LOW_THRESHOLD	(1600)
+
+#endif  /* _SMC_911X_H_ */
diff --git a/drivers/net/stm-stmac.c b/drivers/net/stm-stmac.c
new file mode 100644
index 0000000000..d3b3190ebf
--- /dev/null
+++ b/drivers/net/stm-stmac.c
@@ -0,0 +1,1298 @@
+/*
+ *  Copyright (c) 2006-2009 STMicroelectronics Limited
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ * author(s): Andy Sturges (andy.sturges@st.com)
+ *            Sean McGoogan <Sean.McGoogan@st.com>
+ */
+
+#include <common.h>
+
+#if defined(CONFIG_DRIVER_NETSTMAC) || defined(CONFIG_DRIVER_NET_STM_GMAC)
+
+#include <command.h>
+#include <asm/soc.h>
+#include <asm/addrspace.h>
+#include <asm/io.h>
+#include <net.h>
+#include <malloc.h>
+#include <miiphy.h>
+#include "stm-stmac.h"
+
+#if defined(CONFIG_CMD_NET)
+
+/* #define DEBUG */
+#ifdef DEBUG
+#	define PRINTK(args...) printf(args)
+#else
+#	define PRINTK(args...)
+#endif
+
+/* do we want to put the PHY in loop-back mode ? */
+/* #define CONFIG_PHY_LOOPBACK */
+
+/* prefix to use for diagnostics */
+#ifdef CONFIG_DRIVER_NETSTMAC
+#	define STMAC	"STM-MAC: "
+#else
+#	define STMAC	"STM-GMAC: "
+#endif /* CONFIG_DRIVER_NETSTMAC */
+
+#define CONFIG_DMA_RX_SIZE 8
+#define CONFIG_DMA_TX_SIZE 1	/* Only ever use 1 tx buffer */
+
+static volatile stmac_dma_des *dma_tx;
+static volatile stmac_dma_des *dma_rx;
+static int cur_rx;
+static int eth_phy_addr;
+static char miidevice[] = "stmacphy";
+
+#define MAX_ETH_FRAME_SIZE      1536
+#define MAX_PAUSE_TIME (MAC_FLOW_CONTROL_PT_MASK>>MAC_FLOW_CONTROL_PT_SHIFT)
+
+static void stmac_mii_write (int phy_addr, int reg, int value);
+static unsigned int stmac_mii_read (int phy_addr, int reg);
+static void stmac_set_mac_mii_cap (int full_duplex, unsigned int speed);
+
+/* DMA structure */
+struct dma_t
+{
+	stmac_dma_des desc_rx[CONFIG_DMA_RX_SIZE];
+	stmac_dma_des desc_tx[CONFIG_DMA_TX_SIZE];
+	uchar rx_buff[CONFIG_DMA_RX_SIZE * (PKTSIZE_ALIGN)];
+	uchar _dummy[L1_CACHE_BYTES];
+} __attribute__ ((aligned (L1_CACHE_BYTES))) dma;
+
+static void *rx_packets[CONFIG_DMA_RX_SIZE];
+
+#define likely(x)	__builtin_expect(!!(x), 1)
+#define unlikely(x)	__builtin_expect(!!(x), 0)
+
+/* ----------------------------------------------------------------------------
+				 Phy interface
+   ---------------------------------------------------------------------------*/
+
+#if defined(CONFIG_STMAC_STE10XP)	/* ST STe10xp */
+
+/* STe100p phy identifier values */
+#define STE100P_PHY_ID		0x181b8a01u
+#define STE100P_PHY_ID_MASK	0xffffffffu
+
+/* STe101p phy identifier values */
+//#define STE101P_PHY_ID		0x181b8a0lu        //9161
+#define STE101P_PHY_ID		0x01018f2du            //6103
+#define STE101P_PHY_ID_MASK	0xffffffffu
+
+/******************************************************************************
+ * IEEE Standard 802.3-2002 vendor specific registers (0x10-0x1e) STe10xP
+ *****************************************************************************/
+#define MII_XCIIS                0x11	/* Config info & int status register */
+#define MII_XIE                  0x12	/* Interrupt enable register */
+#define MII_100CTR               0x13	/* 100BaseX control register */
+#define MII_XMC                  0x14	/* Mode control register */
+
+/******************************************************************************
+ * 100BaseX Auxiliary Status register defines
+ *****************************************************************************/
+#define XCIIS_FIFO_OVR           0x0800	/* FIFO Overrun */
+#define XCIIS_SPEED              0x0200	/* Speed */
+#define XCIIS_DUPLEX             0x0100	/* Duplex */
+#define XCIIS_PAUSE              0x0080	/* Pause */
+#define XCIIS_ANEG_INT           0x0040	/* Auto Negotiation Interrupt */
+#define XCIIS_RFAULT             0x0020	/* Remote Fault Interrupt */
+#define XCIIS_LDOWN              0x0010	/* Link Down Interrupt */
+#define XCIIS_LCWR               0x0008	/* Link Code Word Received Interrupt */
+#define XCIIS_PFAULT             0x0004	/* Parallel Detection Fault */
+#define XCIIS_ANEG_PAGE          0x0002	/* Auto Negotiation Page Rec Intr */
+#define XCIIS_REF_INTR           0x0001	/* Ref Interrupt */
+
+/******************************************************************************
+ * XCVR Mode Control register defines
+ *****************************************************************************/
+#define XMC_LDETECT              0x0800	/* Link Detect */
+#define XMC_PHY_ADDR_MSK         0x00f8	/* PHY Address Mask */
+#define XMC_PHY_ADDR_SHIFT       3	/* PHY Address Mask */
+#define XMC_PRE_SUP              0x0002	/* Preamble Suppression */
+#define PHY_ADDR_MSK		XMC_PHY_ADDR_MSK	/* PHY Address Mask */
+#define PHY_ADDR_SHIFT		XMC_PHY_ADDR_SHIFT	/* PHY Address Mask */
+
+/* MII mode */
+#define MII_TSTAT_SMII  0x1000
+#define MII_TSTAT_RMII  0x0800
+#define MII_TSTAT_MII   0x0400
+
+#elif defined(CONFIG_STMAC_LAN8700)	/* SMSC LAN8700 */
+
+/* SMSC LAN8700 phy identifier values */
+#define LAN8700_PHY_ID		0x0007c0c0u
+#define LAN8700_PHY_ID_MASK	0xfffffff0u
+
+#define SPECIAL_MODE_REG	0x12	/* Special Modes Register */
+#define PHY_ADDR_MSK		0x001f	/* PHY Address Mask */
+#define PHY_ADDR_SHIFT		0	/* PHY Address Mask */
+
+#elif defined(CONFIG_STMAC_DP83865)	/* Nat Semi DP83865 */
+
+/* Nat Semi DP83865 phy identifier values */
+#define DP83865_PHY_ID		0x20005c70u
+#define DP83865_PHY_ID_MASK	0xfffffff0u
+
+#define PHY_SUP_REG		0x1f	/* PHY Support Register */
+#define PHY_ADDR_MSK		0x001f	/* PHY Address Mask */
+#define PHY_ADDR_SHIFT		0	/* PHY Address Mask */
+
+#elif defined(CONFIG_STMAC_KSZ8041FTL)	/* Micrel KSZ8041FTL */
+
+/* Micrel KSZ8041FTL phy identifier values */
+#define KSZ8041FTL_PHY_ID	0x00221512u
+#define KSZ8041FTL_PHY_ID_MASK	0x01ffffffu
+
+#else
+#error Need to define which PHY to use
+#endif
+
+#define PHY_DSCSR_REG		0x11
+#define PHY_ADDR_MSK		0x01f0
+#define PHY_ADDR_SHIFT		4
+
+/* MII mode */
+#define MII_ADVERTISE_PAUSE 0x0400	/* supports the pause command */
+
+
+static int stmac_phy_negotiate (int phy_addr)
+{
+	uint now, tmp, status;
+
+	status = 0;
+
+	tmp = stmac_mii_read (phy_addr, MII_BMCR);
+	tmp |= (BMCR_ANENABLE | BMCR_ANRESTART);
+	stmac_mii_write (phy_addr, MII_BMCR, tmp);
+
+	now = get_timer (0);
+	while (get_timer (now) < CONFIG_STMAC_AUTONEG_TIMEOUT) {
+		status = stmac_mii_read (phy_addr, MII_BMSR);
+		if (status & BMSR_ANEGCOMPLETE) {
+			break;
+		}
+
+		/* Restart auto-negotiation if remote fault */
+		if (status & BMSR_RFAULT) {
+			printf (STMAC "PHY remote fault detected\n");
+			/* Restart auto-negotiation */
+			printf (STMAC "PHY restarting auto-negotiation\n");
+			stmac_mii_write (phy_addr, MII_BMCR,
+					 BMCR_ANENABLE | BMCR_ANRESTART);
+		}
+	}
+
+	if (!(status & BMSR_ANEGCOMPLETE)) {
+		printf (STMAC "PHY auto-negotiate timed out\n");
+	}
+
+	if (status & BMSR_RFAULT) {
+		printf (STMAC "PHY remote fault detected\n");
+	}
+
+	return (1);
+}
+
+static unsigned int stmac_phy_check_speed (int phy_addr)
+{
+	unsigned int status;
+	int full_duplex = 0;
+	int speed = 0;
+
+	/* Read Status register */
+	status = stmac_mii_read (phy_addr, MII_BMSR);
+	udelay(100000);  //0.1S gongjia add
+	status = stmac_mii_read (phy_addr, MII_BMSR);
+
+	printf (STMAC);
+
+	/* Check link status.  If 0, default to 100 Mbps. */
+	if ((status & BMSR_LSTATUS) == 0) {
+		printf ("*Warning* no link detected\n");
+		return 1;
+	} else {
+		int negotiated = stmac_mii_read (phy_addr, MII_LPA);
+
+		if (negotiated & LPA_100FULL) {
+			printf ("100Mbs full duplex link detected\n");
+			full_duplex = 1;
+			speed = 100;
+		} else if (negotiated & LPA_100HALF) {
+			printf ("100Mbs half duplex link detected\n");
+			full_duplex = 0;
+			speed = 100;
+		} else if (negotiated & LPA_10FULL) {
+			printf ("10Mbs full duplex link detected\n");
+			full_duplex = 1;
+			speed = 10;
+		} else {
+			printf ("10Mbs half duplex link detected\n");
+			full_duplex = 0;
+			speed = 10;
+		}
+	}
+	stmac_set_mac_mii_cap (full_duplex, speed);
+	return 0;
+}
+
+/* Automatically gets and returns the PHY device */
+static unsigned int stmac_phy_get_addr (void)
+{
+	unsigned int i;
+
+	for (i = 0; i < 32; i++) {
+		unsigned int id1, id2, id;
+		unsigned int phyaddr = (i + 1u) % 32u;
+		id1 = stmac_mii_read (phyaddr, MII_PHYSID1);
+		id2 = stmac_mii_read (phyaddr, MII_PHYSID2);
+		id  = (id1 << 16) | (id2);
+		printf(STMAC "id=0x%08x,id1=0x%08x,id2=0x%08x\n",id,id1,id2);
+		/* Make sure it is a valid (known) identifier */
+#if defined(CONFIG_STMAC_STE10XP)
+		if ((id & STE101P_PHY_ID_MASK) == STE101P_PHY_ID) {
+			printf (STMAC "STe101P found\n");
+			return phyaddr;
+		} else if ((id & STE100P_PHY_ID_MASK) == STE100P_PHY_ID) {
+			printf (STMAC "STe100P found\n");
+			return phyaddr;
+		}
+#elif defined(CONFIG_STMAC_LAN8700)
+		if ((id & LAN8700_PHY_ID_MASK) == LAN8700_PHY_ID) {
+			printf (STMAC "SMSC LAN8700 found\n");
+			return phyaddr;
+		}
+#elif defined(CONFIG_STMAC_DP83865)
+		if ((id & DP83865_PHY_ID_MASK) == DP83865_PHY_ID) {
+			printf (STMAC "NS DP83865 found\n");
+			return phyaddr;
+		}
+#elif defined(CONFIG_STMAC_KSZ8041FTL)
+		if ((id & KSZ8041FTL_PHY_ID_MASK) == KSZ8041FTL_PHY_ID) {
+			printf (STMAC "KSZ8041FTL found\n");
+			return phyaddr;
+		}
+#endif	/* CONFIG_STMAC_STE10XP */
+	}
+
+	printf (STMAC "Unable to find a PHY (unknown ID?)\n");
+	return (-1);
+}
+
+static int stmac_phy_init (void)
+{
+	uint advertised_caps, value;
+
+	/* Obtain the PHY's address/id */
+	eth_phy_addr = stmac_phy_get_addr ();
+	if (eth_phy_addr < 0)
+		return -1;
+
+	/* Now reset the PHY we just found */
+	if (miiphy_reset (miidevice, eth_phy_addr)< 0) {
+		PRINTK (STMAC "PHY reset failed!\n");
+		return -1;
+	}
+
+	/* test for H/W address disagreement with the assigned address */
+#if defined(CONFIG_STMAC_STE10XP)
+	value = stmac_mii_read (eth_phy_addr, MII_XMC);
+#elif defined(CONFIG_STMAC_LAN8700)
+	value = stmac_mii_read (eth_phy_addr, SPECIAL_MODE_REG);
+#elif defined(CONFIG_STMAC_DP83865)
+	value = stmac_mii_read (eth_phy_addr, PHY_SUP_REG);
+#elif defined(CONFIG_STMAC_KSZ8041FTL)
+	/* The Micrel KSZ8041FTL does not appear to support
+	 * reading the H/W PHY address from any register.
+	 * So, we bypass the following test.
+	 */
+#else
+#error Need to define PHY
+#endif
+#if !defined(CONFIG_STMAC_KSZ8041FTL)
+	value = (value & PHY_ADDR_MSK) >> PHY_ADDR_SHIFT;
+	if (value != eth_phy_addr) {
+		printf (STMAC "PHY address mismatch with hardware (hw %d != %d)\n",
+			value,
+			eth_phy_addr);
+	}
+#endif
+
+	/* Read the ANE Advertisement register */
+	advertised_caps = stmac_mii_read (eth_phy_addr, MII_ADVERTISE);
+
+	/* Copy our capabilities from MII_BMSR to MII_ADVERTISE */
+	value = stmac_mii_read (eth_phy_addr, MII_BMSR);
+
+	/* Set the advertised capabilities */
+	if (value & BMSR_100BASE4)
+		advertised_caps |= ADVERTISE_100BASE4;
+	if (value & BMSR_100FULL)
+		advertised_caps |= ADVERTISE_100FULL;
+	if (value & BMSR_100HALF)
+		advertised_caps |= ADVERTISE_100HALF;
+	if (value & BMSR_10FULL)
+		advertised_caps |= ADVERTISE_10FULL;
+	if (value & BMSR_10HALF)
+		advertised_caps |= ADVERTISE_10HALF;
+
+#ifdef CONFIG_STMAC_FLOWCTRL
+	advertised_caps |= MII_ADVERTISE_PAUSE;
+#else
+	advertised_caps &= ~MII_ADVERTISE_PAUSE;
+#endif
+
+	/* Update our Auto-Neg Advertisement Register */
+	stmac_mii_write (eth_phy_addr, MII_ADVERTISE, advertised_caps);
+
+	stmac_phy_negotiate (eth_phy_addr);
+	stmac_phy_check_speed (eth_phy_addr);
+
+#ifdef CONFIG_PHY_LOOPBACK
+	/* put the PHY in loop-back mode, if required */
+	value = stmac_mii_read (eth_phy_addr, MII_BMCR);
+	value |= BMCR_LOOPBACK;
+	stmac_mii_write (eth_phy_addr, MII_BMCR, value);
+#endif	/* CONFIG_PHY_LOOPBACK */
+
+	return 0;
+}
+
+
+/* ----------------------------------------------------------------------------
+				 MII Interface
+   ---------------------------------------------------------------------------*/
+
+static int stmac_mii_poll_busy (void)
+{
+	/* arm simple, non interrupt dependent timer */
+	ulong now = get_timer (0);
+	while (get_timer (now) < CONFIG_STMAC_MII_POLL_BUSY_DELAY) {
+		if (!(STMAC_READ (MAC_MII_ADDR) & MAC_MII_ADDR_BUSY)) {
+			return 1;
+		}
+	}
+	printf (STMAC "stmac_mii_busy timeout\n");
+	return (0);
+}
+
+static void stmac_mii_write (int phy_addr, int reg, int value)
+{
+	int mii_addr;
+
+	/* Select register */
+	mii_addr =
+		((phy_addr & MAC_MII_ADDR_PHY_MASK) << MAC_MII_ADDR_PHY_SHIFT)
+		| ((reg & MAC_MII_ADDR_REG_MASK) << MAC_MII_ADDR_REG_SHIFT)
+		| MAC_MII_ADDR_WRITE | MAC_MII_ADDR_BUSY;
+
+	stmac_mii_poll_busy ();
+
+	/* Set the MII address register to write */
+	STMAC_WRITE (value, MAC_MII_DATA);
+	STMAC_WRITE (mii_addr, MAC_MII_ADDR);
+
+	stmac_mii_poll_busy ();
+
+#if defined(CONFIG_STMAC_STE10XP)	/* ST STE10xP PHY */
+	/* QQQ: is the following actually needed ? */
+	(void) stmac_mii_read (phy_addr, reg);
+#endif	/* CONFIG_STMAC_STE10XP */
+}
+
+static unsigned int stmac_mii_read (int phy_addr, int reg)
+{
+	int mii_addr, val;
+
+	mii_addr =
+		((phy_addr & MAC_MII_ADDR_PHY_MASK) << MAC_MII_ADDR_PHY_SHIFT)
+		| ((reg & MAC_MII_ADDR_REG_MASK) << MAC_MII_ADDR_REG_SHIFT)
+		| MAC_MII_ADDR_BUSY;
+
+	/* Select register */
+	stmac_mii_poll_busy ();
+
+	STMAC_WRITE (mii_addr, MAC_MII_ADDR);
+
+	stmac_mii_poll_busy ();
+
+	/* Return read value */
+	val = STMAC_READ (MAC_MII_DATA);
+	return val;
+}
+
+/* define external interface to mii, through miiphy_register() */
+static int stmac_miiphy_read (char *devname, unsigned char addr, unsigned char reg, unsigned short *value)
+{
+	*value = stmac_mii_read (addr, reg);
+	return 0;
+}
+
+static int stmac_miiphy_write (char *devname, unsigned char addr, unsigned char reg, unsigned short value)
+{
+	stmac_mii_write (addr, reg, value);
+	return 0;
+}
+
+/* ----------------------------------------------------------------------------
+				 MAC CORE Interface
+   ---------------------------------------------------------------------------*/
+
+#ifdef DEBUG
+static void gmac_dump_regs(void)
+{
+	int i;
+	const char fmt[] =
+		"\tReg No. %2d (offset 0x%03x): 0x%08x\n";
+	const char header[] =
+		"\t----------------------------------------------\n"
+		"\t  %s registers (base addr = 0x%8x)\n"
+		"\t----------------------------------------------\n";
+
+	printf (header, "MAC CORE", (unsigned int)CFG_STM_STMAC_BASE);
+	for (i = 0; i < 18; i++) {
+		int offset = i * 4;
+		printf(fmt, i, offset, STMAC_READ (offset));
+	}
+
+	printf (header, "MAC DMA", (unsigned int)CFG_STM_STMAC_BASE);
+	for (i = 0; i < 9; i++) {
+		int offset = i * 4;
+		printf (fmt, i, (DMA_BUS_MODE + offset),
+			STMAC_READ (DMA_BUS_MODE + offset));
+	}
+
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+	printf ("\tSTBus bridge register (0x%08x) = 0x%08x\n",
+		(unsigned int)(CFG_STM_STMAC_BASE + STBUS_BRIDGE_OFFSET),
+		STMAC_READ (STBUS_BRIDGE_OFFSET));
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+}
+#endif	/* DEBUG */
+
+static void stmac_set_mac_addr (unsigned char *Addr)
+{
+	unsigned long data;
+
+	data = (Addr[5] << 8) | Addr[4];
+	STMAC_WRITE (data, MAC_ADDR_HIGH);
+	data = (Addr[3] << 24) | (Addr[2] << 16) | (Addr[1] << 8) | Addr[0];
+	STMAC_WRITE (data, MAC_ADDR_LOW);
+}
+
+static int stmac_get_mac_addr (unsigned char *addr)
+{
+	unsigned int hi_addr, lo_addr;
+
+	/* Read the MAC address from the hardware */
+	hi_addr = (unsigned int) STMAC_READ (MAC_ADDR_HIGH);
+	lo_addr = (unsigned int) STMAC_READ (MAC_ADDR_LOW);
+
+	if ((hi_addr == 0x0000FFFFUL) && (lo_addr == 0xFFFFFFFF))
+		return 0;
+
+	/* Extract the MAC address from the high and low words */
+	addr[0] = lo_addr & 0xffu;
+	addr[1] = (lo_addr >> 8) & 0xffu;
+	addr[2] = (lo_addr >> 16) & 0xffu;
+	addr[3] = (lo_addr >> 24) & 0xffu;
+	addr[4] = hi_addr & 0xffu;
+	addr[5] = (hi_addr >> 8) & 0xffu;
+
+	return 1;
+}
+
+static void stmac_mac_enable (void)
+{
+	unsigned int value = (unsigned int) STMAC_READ (MAC_CONTROL);
+
+	PRINTK (STMAC "MAC RX/TX enabled\n");
+
+	/* set: TE (transmitter enable), RE (receive enable) */
+	value |= (MAC_CONTROL_TE | MAC_CONTROL_RE);
+
+#ifdef CONFIG_DRIVER_NETSTMAC
+	/* and RA (receive all mode) */
+//	value |= MAC_CONTROL_RA;	/* QQQ: suspect we can delete this */
+#endif	/* CONFIG_DRIVER_NETSTMAC */
+
+	STMAC_WRITE (value, MAC_CONTROL);
+	return;
+}
+
+static void stmac_mac_disable (void)
+{
+	unsigned int value = (unsigned int) STMAC_READ (MAC_CONTROL);
+
+	PRINTK (STMAC "MAC RX/TX disabled\n");
+
+	value &= ~(MAC_CONTROL_TE | MAC_CONTROL_RE);
+
+#ifdef CONFIG_DRIVER_NETSTMAC
+//	value &= ~MAC_CONTROL_RA;	/* QQQ: suspect we can delete this */
+#endif	/* CONFIG_DRIVER_NETSTMAC */
+
+	STMAC_WRITE (value, MAC_CONTROL);
+	return;
+}
+
+static void stmac_set_rx_mode (void)
+{
+	unsigned int value = (unsigned int) STMAC_READ (MAC_CONTROL);
+
+#ifdef CONFIG_DRIVER_NETSTMAC
+	PRINTK (STMAC "MAC address perfect filtering only mode\n");
+	value &= ~(MAC_CONTROL_PM | MAC_CONTROL_PR | MAC_CONTROL_IF |
+		   MAC_CONTROL_HO | MAC_CONTROL_HP);
+#endif	/* CONFIG_DRIVER_NETSTMAC */
+
+	STMAC_WRITE (0x0, MAC_HASH_HIGH);
+	STMAC_WRITE (0x0, MAC_HASH_LOW);
+
+	STMAC_WRITE (value, MAC_CONTROL);
+
+	return;
+}
+
+static void stmac_set_mac_mii_cap (int full_duplex, unsigned int speed)
+{
+	unsigned int flow = (unsigned int) STMAC_READ (MAC_FLOW_CONTROL);
+	unsigned int ctrl = (unsigned int) STMAC_READ (MAC_CONTROL);
+
+	PRINTK (STMAC "%s(full_duplex=%d, speed=%u)\n", __FUNCTION__, full_duplex, speed);
+
+	if (!(full_duplex)) {	/* Half Duplex */
+#ifdef CONFIG_DRIVER_NETSTMAC
+		flow &= ~(MAC_FLOW_CONTROL_FCE | MAC_FLOW_CONTROL_PT_MASK |
+			  MAC_FLOW_CONTROL_PCF);
+		ctrl &= ~MAC_CONTROL_F;
+		ctrl |= MAC_CONTROL_DRO;
+#endif	/* CONFIG_DRIVER_NETSTMAC */
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+		flow &= ~(MAC_FLOW_CONTROL_TFE | MAC_FLOW_CONTROL_PT_MASK |
+			  MAC_FLOW_CONTROL_RFE);
+		ctrl &= ~MAC_CONTROL_DM;
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+	} else {		/* Full Duplex */
+#ifdef CONFIG_DRIVER_NETSTMAC
+		ctrl |= MAC_CONTROL_F;
+		ctrl &= ~MAC_CONTROL_DRO;
+		flow |= MAC_FLOW_CONTROL_FCE | MAC_FLOW_CONTROL_PCF;
+#endif	/* CONFIG_DRIVER_NETSTMAC */
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+		ctrl |= MAC_CONTROL_DM;
+		flow |= MAC_FLOW_CONTROL_TFE | MAC_FLOW_CONTROL_RFE;
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+		flow |= (MAX_PAUSE_TIME << MAC_FLOW_CONTROL_PT_SHIFT);
+	}
+
+#ifdef CONFIG_DRIVER_NETSTMAC
+	/* use MII */
+	ctrl &= ~MAC_CONTROL_PS;
+#endif	/* CONFIG_DRIVER_NETSTMAC */
+
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+	switch (speed) {
+	case 1000:		/* Gigabit */
+		ctrl &= ~MAC_CONTROL_PS;
+		break;
+	case 100:		/* 100Mbps */
+		ctrl |= MAC_CONTROL_PS | MAC_CONTROL_FES;
+		break;
+	case 10:		/* 10Mbps */
+		ctrl |= MAC_CONTROL_PS;
+		ctrl &= ~MAC_CONTROL_FES;
+		break;
+	}
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+	STMAC_WRITE (flow, MAC_FLOW_CONTROL);
+	STMAC_WRITE (ctrl, MAC_CONTROL);
+	
+	/* ensure the SoC knows the correct speed */
+	stmac_set_mac_speed (speed);
+
+	return;
+}
+
+/* This function provides the initial setup of the MAC controller */
+static void stmac_mac_core_init (void)
+{
+	unsigned int value;
+
+	/* Set the MAC control register with our default value */
+	value = (unsigned int) STMAC_READ (MAC_CONTROL);
+	value |= MAC_CORE_INIT;
+	STMAC_WRITE (value, MAC_CONTROL);
+
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+	/* STBus Bridge Configuration */
+	STMAC_WRITE(STBUS_BRIDGE_MAGIC, STBUS_BRIDGE_OFFSET);
+
+	/* Freeze MMC counters */
+	STMAC_WRITE(MMC_COUNTER_FREEZE, MMC_CONTROL);
+
+	/* Mask all interrupts */
+	STMAC_WRITE(~0u, MAC_INT_MASK);
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+	return;
+}
+
+/* ----------------------------------------------------------------------------
+ *  			DESCRIPTORS functions
+ * ---------------------------------------------------------------------------*/
+
+#ifdef DEBUG
+static void display_dma_desc_ring (volatile const stmac_dma_des * p, int size)
+{
+	int i;
+	for (i = 0; i < size; i++)
+		printf ("\t%d [0x%x]: "
+			"desc0=0x%08x, desc1=0x%08x, buffer1=0x%08x\n",
+			i, (unsigned int) &p[i].des01.u.des0,
+			p[i].des01.u.des0, p[i].des01.u.des1, p[i].des2);
+}
+#endif	/* DEBUG */
+
+static void init_rx_desc (volatile stmac_dma_des * p,
+	unsigned int ring_size, void **buffers)
+{
+	int i;
+
+	for (i = 0; i < ring_size; i++) {
+		p->des01.u.des0 = p->des01.u.des1 = 0;
+		p->des01.rx.own = 1;
+		p->des01.rx.buffer1_size = PKTSIZE_ALIGN;
+		p->des01.rx.disable_ic = 1;
+		if (i == ring_size - 1)
+			p->des01.rx.end_ring = 1;
+		p->des2 = ((void *) (PHYSADDR (buffers[i])));
+		p->des3 = NULL;
+		p++;
+	}
+	return;
+}
+
+static void init_tx_desc (volatile stmac_dma_des * p, unsigned int ring_size)
+{
+	int i;
+
+	for (i = 0; i < ring_size; i++) {
+		p->des01.u.des0 = p->des01.u.des1 = 0;
+		if (i == ring_size - 1)
+			p->des01.tx.end_ring = 1;
+		p->des2 = NULL;
+		p->des3 = NULL;
+		p++;
+	}
+	return;
+}
+
+/* Allocate and init the TX and RX descriptors rings.
+ * The driver uses the 'implicit' scheme for implementing the TX/RX DMA
+ * linked lists. */
+
+static void init_dma_desc_rings (void)
+{
+	int i;
+
+	PRINTK (STMAC "allocate and init the DMA RX/TX lists\n");
+
+	/* Clean out uncached buffers */
+	flush_cache ((unsigned long)&dma, sizeof (struct dma_t));
+
+	/* Allocate memory for the DMA RX/TX buffer descriptors */
+	dma_rx = (volatile stmac_dma_des *) P2SEGADDR (&dma.desc_rx[0]);
+	dma_tx = (volatile stmac_dma_des *) P2SEGADDR (&dma.desc_tx[0]);
+
+	cur_rx = 0;
+
+	if ((dma_rx == NULL) || (dma_tx == NULL) ||
+	    (((u32)dma_rx % L1_CACHE_BYTES) != 0) ||
+	    (((u32)dma_tx % L1_CACHE_BYTES) != 0)) {
+		printf (STMAC "ERROR allocating the DMA Tx/Rx desc\n");
+		return;
+	}
+
+	for (i = 0; i < CONFIG_DMA_RX_SIZE; i++)
+		rx_packets[i] = (void *) P2SEGADDR (dma.rx_buff + (PKTSIZE_ALIGN * i));
+
+	/* Initialize the contents of the DMA buffers */
+	init_rx_desc (dma_rx, CONFIG_DMA_RX_SIZE, rx_packets);
+	init_tx_desc (dma_tx, CONFIG_DMA_TX_SIZE);
+
+#ifdef DEBUG
+	printf (STMAC "RX descriptor ring:\n");
+	display_dma_desc_ring (dma_rx, CONFIG_DMA_RX_SIZE);
+	printf (STMAC "TX descriptor ring:\n");
+	display_dma_desc_ring (dma_tx, CONFIG_DMA_TX_SIZE);
+#endif
+
+	return;
+}
+
+/* Release and free the descriptor resources. */
+static void free_dma_desc_resources (void)
+{
+	dma_tx = NULL;
+	dma_rx = NULL;
+	return;
+}
+
+/* ----------------------------------------------------------------------------
+				DMA FUNCTIONS
+ * ---------------------------------------------------------------------------*/
+
+/* DMA SW reset.
+ *  NOTE1: the MII_TxClk and the MII_RxClk must be active before this
+ *	   SW reset otherwise the MAC core won't exit the reset state.
+ *  NOTE2: after a SW reset all interrupts are disabled */
+
+static void stmac_dma_reset (void)
+{
+	unsigned int value;
+
+	value = (unsigned int) STMAC_READ (DMA_BUS_MODE);
+	value |= DMA_BUS_MODE_SFT_RESET;
+
+	STMAC_WRITE (value, DMA_BUS_MODE);
+
+	while ((STMAC_READ (DMA_BUS_MODE) & DMA_BUS_MODE_SFT_RESET)) {
+	}
+
+	return;
+}
+
+/* START/STOP the DMA TX/RX processes */
+static void stmac_dma_start_tx (void)
+{
+	unsigned int value;
+
+	value = (unsigned int) STMAC_READ (DMA_CONTROL);
+	value |= DMA_CONTROL_ST;
+	STMAC_WRITE (value, DMA_CONTROL);
+
+	return;
+}
+
+static void stmac_dma_stop_tx (void)
+{
+	unsigned int value;
+
+	value = (unsigned int) STMAC_READ (DMA_CONTROL);
+	value &= ~DMA_CONTROL_ST;
+	STMAC_WRITE (value, DMA_CONTROL);
+
+	return;
+}
+static void stmac_dma_start_rx (void)
+{
+	unsigned int value;
+
+	value = (unsigned int) STMAC_READ (DMA_CONTROL);
+	value |= DMA_CONTROL_SR;
+	STMAC_WRITE (value, DMA_CONTROL);
+
+	return;
+}
+
+static void stmac_dma_stop_rx (void)
+{
+	unsigned int value;
+
+	value = (unsigned int) STMAC_READ (DMA_CONTROL);
+	value &= ~DMA_CONTROL_SR;
+	STMAC_WRITE (value, DMA_CONTROL);
+
+	return;
+}
+
+static void stmac_eth_stop_tx (void)
+{
+
+	stmac_dma_stop_tx ();
+
+	return;
+}
+
+/* The DMA init function performs:
+ * - the DMA RX/TX SW descriptors initialization
+ * - the DMA HW controller initialization
+ * NOTE: the DMA TX/RX processes will be started in the 'open' method. */
+
+static int stmac_dma_init (void)
+{
+
+	PRINTK (STMAC "DMA Core setup\n");
+
+	/* Enable Application Access by writing to DMA CSR0 */
+	STMAC_WRITE (DMA_BUS_MODE_DEFAULT |
+		     (stmac_default_pbl () << DMA_BUS_MODE_PBL_SHIFT),
+		     DMA_BUS_MODE);
+
+	/* Disable interrupts */
+	STMAC_WRITE (0, DMA_INTR_ENA);
+
+	/* The base address of the RX/TX descriptor */
+	STMAC_WRITE (PHYSADDR (dma_tx), DMA_TX_BASE_ADDR);
+	STMAC_WRITE (PHYSADDR (dma_rx), DMA_RCV_BASE_ADDR);
+
+	return (0);
+}
+
+static int check_tx_error_summary (const stmac_dma_des * const p)
+{
+	int ret = 0;	/* assume there are no errors */
+
+	if (unlikely(p->des01.tx.error_summary)) {
+		if (unlikely(p->des01.tx.loss_carrier)) {
+			PRINTK(STMAC "TX: loss_carrier error\n");
+		}
+		if (unlikely(p->des01.tx.no_carrier)) {
+			PRINTK(STMAC "TX: no_carrier error\n");
+		}
+		if (unlikely(p->des01.tx.late_collision)) {
+			PRINTK(STMAC "TX: late_collision error\n");
+		}
+		if (unlikely(p->des01.tx.excessive_collisions)) {
+			PRINTK(STMAC "TX: excessive_collisions\n");
+		}
+		if (unlikely(p->des01.tx.excessive_deferral)) {
+			PRINTK(STMAC "TX: excessive_deferral\n");
+		}
+		if (unlikely(p->des01.tx.underflow_error)) {
+			PRINTK(STMAC "TX: underflow error\n");
+		}
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+		if (unlikely(p->des01.tx.jabber_timeout)) {
+			PRINTK(STMAC "TX: jabber_timeout error\n");
+		}
+		if (unlikely(p->des01.tx.frame_flushed)) {
+			PRINTK(STMAC "TX: frame_flushed error\n");
+		}
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+		ret = -1;
+	}
+
+	if (unlikely(p->des01.tx.deferred)) {
+		PRINTK(STMAC "TX: deferred\n");
+		ret = -1;
+	}
+#ifdef CONFIG_DRIVER_NETSTMAC
+	if (unlikely(p->des01.tx.heartbeat_fail)) {
+		PRINTK(STMAC "TX: heartbeat_fail\n");
+		ret = -1;
+	}
+#endif	/* CONFIG_DRIVER_NETSTMAC */
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+	if (unlikely(p->des01.tx.payload_error)) {
+		PRINTK(STMAC "TX Addr/Payload csum error\n");
+		ret = -1;
+	}
+	if (unlikely(p->des01.tx.ip_header_error)) {
+		PRINTK(STMAC "TX IP header csum error\n");
+		ret = -1;
+	}
+	if (p->des01.tx.vlan_frame) {
+		PRINTK(STMAC "TX: VLAN frame\n");
+	}
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+#ifdef DEBUG
+	if (ret != 0) {
+		printf(STMAC "%s() returning %d\n", __FUNCTION__, ret);
+	}
+#endif
+
+	return (ret);
+}
+
+static int check_rx_error_summary (const stmac_dma_des * const p)
+{
+	int ret = 0;	/* assume there are no errors */
+
+	if (unlikely(p->des01.rx.error_summary)) {
+		if (unlikely(p->des01.rx.descriptor_error)) {
+			/* frame doesn't fit within the current descriptor. */
+			PRINTK(STMAC "RX: descriptor error\n");
+		}
+		if (unlikely(p->des01.rx.crc_error)) {
+			PRINTK(STMAC "RX: CRC error\n");
+		}
+#ifdef CONFIG_DRIVER_NETSTMAC
+		if (unlikely(p->des01.rx.partial_frame_error)) {
+			PRINTK(STMAC "RX: partial_frame_error\n");
+		}
+		if (unlikely(p->des01.rx.runt_frame)) {
+			PRINTK(STMAC "RX: runt_frame\n");
+		}
+		if (unlikely(p->des01.rx.frame_too_long)) {
+			PRINTK(STMAC "RX: frame_too_long\n");
+		}
+		if (unlikely(p->des01.rx.collision)) {
+			PRINTK(STMAC "RX: collision\n");
+		}
+#endif	/* CONFIG_DRIVER_NETSTMAC */
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+		if (unlikely(p->des01.rx.overflow_error)) {
+			PRINTK(STMAC "RX: Overflow error\n");
+		}
+		if (unlikely(p->des01.rx.late_collision)) {
+			PRINTK(STMAC "RX: late_collision\n");
+		}
+		if (unlikely(p->des01.rx.receive_watchdog)) {
+			PRINTK(STMAC "RX: receive_watchdog error\n");
+		}
+		if (unlikely(p->des01.rx.error_gmii)) {
+			PRINTK(STMAC "RX: GMII error\n");
+		}
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+		ret = -1;
+	}
+
+	if (unlikely(p->des01.rx.length_error)) {
+		PRINTK(STMAC "RX: length_error error\n");
+		ret = -1;
+	}
+	if (unlikely(p->des01.rx.dribbling)) {
+		PRINTK(STMAC "RX: dribbling error\n");
+		ret = -1;
+	}
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+	if (unlikely(p->des01.rx.filtering_fail)) {
+		PRINTK(STMAC "RX: filtering_fail error\n");
+		ret = -1;
+	}
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+#ifdef CONFIG_DRIVER_NETSTMAC
+	if (unlikely(p->des01.rx.last_descriptor == 0)) {
+		PRINTK(STMAC "RX: Oversized Ethernet "
+			"frame spanned multiple buffers\n");
+		ret = -1;
+	}
+	if (unlikely(p->des01.rx.mii_error)) {
+		PRINTK(STMAC "RX: MII error\n");
+		ret = -1;
+	}
+#endif	/* CONFIG_DRIVER_NETSTMAC */
+
+#ifdef DEBUG
+	if (ret != 0) {
+		printf(STMAC "%s() returning %d\n", __FUNCTION__, ret);
+	}
+#endif
+
+	return (ret);
+}
+
+static int stmac_eth_tx (volatile uchar * data, int len)
+{
+	volatile stmac_dma_des *p = dma_tx;
+	uint now = get_timer (0);
+	uint status = 0;
+	u32 end_ring;
+
+	while (p->des01.tx.own
+	       && (get_timer (now) < CONFIG_STMAC_TX_TIMEOUT)) {
+		;
+	}
+
+	if (p->des01.tx.own) {
+		printf (STMAC "tx timeout - no desc available\n");
+		return -1;
+	}
+
+	/* Make sure data is in real memory */
+	flush_cache ((ulong) data, len);
+	p->des2 = (void *) PHYSADDR (data);
+
+	/* Clean and set the TX descriptor */
+	end_ring = p->des01.tx.end_ring;
+	p->des01.u.des0 = p->des01.u.des1 = 0;
+	p->des01.tx.interrupt = 1;
+	p->des01.tx.first_segment = 1;
+	p->des01.tx.last_segment = 1;
+	p->des01.tx.end_ring = end_ring;
+	p->des01.tx.buffer1_size = len;
+	p->des01.tx.own = 1;
+
+#ifdef DEBUG
+	PRINTK ("\n" STMAC "TX %s(data=0x%08x, len=%d)\n", __FUNCTION__, data, len);
+	display_dma_desc_ring (dma_tx, CONFIG_DMA_TX_SIZE);
+#endif
+
+	/* CSR1 enables the transmit DMA to check for new descriptor */
+	STMAC_WRITE (DMA_STATUS_TI, DMA_STATUS);
+	STMAC_WRITE (1, DMA_XMT_POLL_DEMAND);
+
+	now = get_timer (0);
+	while (get_timer (now) < CONFIG_STMAC_TX_TIMEOUT) {
+		status = STMAC_READ (DMA_STATUS);
+		if (status & DMA_STATUS_TI)
+			break;
+	}
+	if (!(status & DMA_STATUS_TI)) {
+		printf (STMAC "tx timeout\n");
+	}
+
+	return check_tx_error_summary ((stmac_dma_des *)p);
+}
+
+/* Receive function */
+static void stmac_eth_rx (void)
+{
+	int frame_len = 0;
+	volatile stmac_dma_des *drx;
+
+	/* select the RX descriptor to use */
+	drx = dma_rx + cur_rx;
+
+	if ((cur_rx < 0) || (cur_rx >= CONFIG_DMA_RX_SIZE)) {
+		printf (STMAC "%s: [dma drx = 0x%x, cur_rx=%d]\n", __FUNCTION__,
+			(unsigned int) drx, cur_rx);
+#ifdef DEBUG
+		display_dma_desc_ring (dma_rx, CONFIG_DMA_RX_SIZE);
+#endif	/* DEBUG */
+	}
+
+	if (!(drx->des01.rx.own) && (drx->des01.rx.last_descriptor)) {
+#ifdef DEBUG
+		PRINTK (STMAC "RX descriptor ring:\n");
+		display_dma_desc_ring (dma_rx, CONFIG_DMA_RX_SIZE);
+#endif
+
+		/* Check if the frame was not successfully received */
+		if (check_rx_error_summary ((stmac_dma_des *)drx) < 0) {
+			drx->des01.rx.own = 1;
+		} else if (drx->des01.rx.first_descriptor
+			   && drx->des01.rx.last_descriptor) {
+
+			/* FL (frame length) indicates the length in byte including
+			 * the CRC */
+			frame_len = drx->des01.rx.frame_length;
+			if ((frame_len >= 0) && (frame_len <= PKTSIZE_ALIGN)) {
+#if defined(DEBUG) || defined(CONFIG_PHY_LOOPBACK)
+				const unsigned char *p = rx_packets[cur_rx];
+				printf("\nRX[%d]:  0x%08x ", cur_rx, p);
+				printf("DA=%02x:%02x:%02x:%02x:%02x:%02x",
+					p[0], p[1], p[2], p[3], p[4], p[5]);
+				p+=6;
+				printf(" SA=%02x:%02x:%02x:%02x:%02x:%02x",
+					p[0], p[1], p[2], p[3], p[4], p[5]);
+				p+=6;
+				printf(" Type=%04x\n", p[0]<<8|p[1]);
+#endif
+				memcpy ((void*)NetRxPackets[0], rx_packets[cur_rx],
+					frame_len);
+				NetReceive (NetRxPackets[0], frame_len);
+			} else {
+				printf (STMAC "%s: Framelen %d too long\n",
+					__FUNCTION__, frame_len);
+			}
+			drx->des01.rx.own = 1;
+#ifdef DEBUG
+			PRINTK (STMAC "%s: frame received \n", __FUNCTION__);
+#endif
+		} else {
+			printf (STMAC "%s: very long frame received\n",
+				__FUNCTION__);
+		}
+
+		/* advance to the next RX descriptor (for next time) */
+		if (drx->des01.rx.end_ring)
+			cur_rx = 0;	/* wrap, to first */
+		else
+			cur_rx++;	/* advance to next */
+
+	} else {
+		STMAC_WRITE (1, DMA_RCV_POLL_DEMAND);	/* request input */
+	}
+	return;
+}
+
+static int stmac_get_ethaddr (bd_t * bd)
+{
+	int env_size, rom_valid, env_present = 0, reg;
+	char *s = NULL, *e, es[] = "11:22:33:44:55:66";
+	char s_env_mac[64];
+	uchar v_env_mac[6], v_rom_mac[6], *v_mac;
+
+	env_size = getenv_r ("ethaddr", s_env_mac, sizeof (s_env_mac));
+	if ((env_size > 0) && (env_size < sizeof (es))) {	/* exit if env is bad */
+		printf ("\n*** ERROR: ethaddr is not set properly!!\n");
+		return (-1);
+	}
+
+	if (env_size > 0) {
+		env_present = 1;
+		s = s_env_mac;
+	}
+
+	for (reg = 0; reg < 6; ++reg) {	/* turn string into mac value */
+		v_env_mac[reg] = s ? simple_strtoul (s, &e, 16) : 0;
+		if (s)
+			s = (*e) ? e + 1 : e;
+	}
+
+	rom_valid = stmac_get_mac_addr (v_rom_mac);	/* get ROM mac value if any */
+
+	if (!env_present) {	/* if NO env */
+		if (rom_valid) {	/* but ROM is valid */
+			v_mac = v_rom_mac;
+			sprintf (s_env_mac, "%02X:%02X:%02X:%02X:%02X:%02X",
+				 v_mac[0], v_mac[1], v_mac[2], v_mac[3],
+				 v_mac[4], v_mac[5]);
+			setenv ("ethaddr", s_env_mac);
+		} else {	/* no env, bad ROM */
+			printf ("\n*** ERROR: ethaddr is NOT set !!\n");
+			return (-1);
+		}
+	} else {		/* good env, don't care ROM */
+		v_mac = v_env_mac;	/* always use a good env over a ROM */
+	}
+
+	if (env_present && rom_valid) {	/* if both env and ROM are good */
+		if (memcmp (v_env_mac, v_rom_mac, 6) != 0) {
+			printf ("\nWarning: MAC addresses don't match:\n");
+			printf ("\tHW MAC address:  "
+				"%02X:%02X:%02X:%02X:%02X:%02X\n",
+				v_rom_mac[0], v_rom_mac[1],
+				v_rom_mac[2], v_rom_mac[3],
+				v_rom_mac[4], v_rom_mac[5]);
+			printf ("\t\"ethaddr\" value: "
+				"%02X:%02X:%02X:%02X:%02X:%02X\n",
+				v_env_mac[0], v_env_mac[1],
+				v_env_mac[2], v_env_mac[3],
+				v_env_mac[4], v_env_mac[5]);
+		}
+	}
+	memcpy (bd->bi_enetaddr, v_mac, 6);	/* update global address to match env (allows env changing) */
+	stmac_set_mac_addr (v_mac);	/* use old function to update default */
+	printf ("Using MAC Address %02X:%02X:%02X:%02X:%02X:%02X\n", v_mac[0],
+		v_mac[1], v_mac[2], v_mac[3], v_mac[4], v_mac[5]);
+	return (0);
+}
+
+static int stmac_reset_eth (bd_t * bd)
+{
+	int err;
+
+	/* MAC Software reset */
+	stmac_dma_reset ();		/* Must be done early  */
+
+	/* set smc_mac_addr, and sync it with u-boot globals */
+	err = stmac_get_ethaddr (bd);
+
+	if (err < 0) {
+		/* hack to make error stick! upper code will abort if not set */
+		memset (bd->bi_enetaddr, 0, 6);
+		/* upper code ignores return value, but NOT bi_enetaddr */
+		return (-1);
+	}
+
+	if (stmac_phy_init () < 0) {
+		printf (STMAC "Phy not detected\n");
+		printf (STMAC "Phy not detected*******************\n");
+		return -1;
+	}
+
+	init_dma_desc_rings ();
+
+	stmac_mac_core_init ();
+	stmac_dma_init ();
+
+	stmac_set_rx_mode ();
+
+	stmac_mac_enable ();
+
+	stmac_dma_start_rx ();
+	stmac_dma_start_tx ();
+
+#ifdef DEBUG
+	gmac_dump_regs ();
+#endif
+
+	STMAC_WRITE (1, DMA_RCV_POLL_DEMAND);	/* request input */
+
+	return (0);
+}
+
+extern int eth_init (bd_t * bd)
+{
+	PRINTK (STMAC "entering %s()\n", __FUNCTION__);
+	stmac_reset_eth (bd);
+	return 0;
+}
+
+extern void eth_halt (void)
+{
+	PRINTK (STMAC "entering %s()\n", __FUNCTION__);
+
+	/* Reset the TX/RX processes */
+	stmac_dma_stop_rx ();
+	stmac_eth_stop_tx ();
+
+	/* Disable the MAC core */
+	stmac_mac_disable ();
+
+	/* Free buffers */
+	free_dma_desc_resources ();
+}
+
+/* Get a data block via Ethernet */
+extern int eth_rx (void)
+{
+	stmac_eth_rx ();
+	return 1;
+}
+
+/* Send a data block via Ethernet. */
+extern int eth_send (volatile void *packet, int length)
+{
+	PRINTK (STMAC "entering %s()\n", __FUNCTION__);
+#if defined(DEBUG) || defined(CONFIG_PHY_LOOPBACK)
+	const unsigned char * p = (const unsigned char*)packet;
+	printf("TX   :  0x%08x ", p);
+	printf("DA=%02x:%02x:%02x:%02x:%02x:%02x",
+		p[0], p[1], p[2], p[3], p[4], p[5]);
+	p+=6;
+	printf(" SA=%02x:%02x:%02x:%02x:%02x:%02x",
+		p[0], p[1], p[2], p[3], p[4], p[5]);
+	p+=6;
+	printf(" Type=%04x\n", p[0]<<8|p[1]);
+#endif
+
+	return stmac_eth_tx (packet, length);
+}
+
+#endif /* CONFIG_CMD_NET */
+
+extern int stmac_miiphy_initialize(bd_t *bis)
+{
+	PRINTK (STMAC "entering %s()\n", __FUNCTION__);
+#if defined(CONFIG_MII) || defined(CONFIG_CMD_MII)
+	miiphy_register(miidevice, stmac_miiphy_read, stmac_miiphy_write);
+#endif
+	return 0;
+}
+
+#endif /* CONFIG_DRIVER_NETSTMAC || CONFIG_DRIVER_NET_STM_GMAC */
+
diff --git a/drivers/net/stm-stmac.h b/drivers/net/stm-stmac.h
new file mode 100644
index 0000000000..6890f70e02
--- /dev/null
+++ b/drivers/net/stm-stmac.h
@@ -0,0 +1,451 @@
+/*
+ *  Copyright (c) 2006-2008  STMicroelectronics Limited
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ * author(s): Andy Sturges (andy.sturges@st.com)
+ *            Sean McGoogan <Sean.McGoogan@st.com>
+ *            Giuseppe Cavallaro <peppe.cavallaro@st.com>
+ */
+
+
+/*----------------------------------------------------------------------------
+ *			CORE MAC Block
+ *---------------------------------------------------------------------------*/
+
+/* STMAC Control & Status Register (CSR) offsets */
+#ifdef CONFIG_DRIVER_NETSTMAC
+#define MAC_CONTROL			0x00000000	/* MAC Control */
+#define MAC_ADDR_HIGH			0x00000004	/* MAC Address High */
+#define MAC_ADDR_LOW			0x00000008	/* MAC Address Low */
+#define MAC_HASH_HIGH			0x0000000c	/* Multicast Hash Table High */
+#define MAC_HASH_LOW			0x00000010	/* Multicast Hash Table Low */
+#define MAC_MII_ADDR			0x00000014	/* MII Address */
+#define MAC_MII_DATA			0x00000018	/* MII Data */
+#define MAC_FLOW_CONTROL		0x0000001c	/* Flow Control */
+#endif	/* CONFIG_DRIVER_NETSTMAC */
+/* GMAC Control & Status Register (CSR) offsets */
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+#define MAC_CONTROL			0x00000000	/* MAC Configuration */
+//#define MAC_FRAME_FILTER		0x00000004	/* Frame Filter */
+#define MAC_HASH_HIGH			0x00000008	/* Multicast Hash Table High */
+#define MAC_HASH_LOW			0x0000000c	/* Multicast Hash Table Low */
+#define MAC_MII_ADDR			0x00000010	/* MII Address */
+#define MAC_MII_DATA			0x00000014	/* MII Data */
+#define MAC_FLOW_CONTROL		0x00000018	/* Flow Control */
+#define MAC_INT_MASK			0x0000003c	/* Interrupt Mask Register */
+#define MAC_ADDR_HIGH			0x00000040	/* MAC Address 0 High */
+#define MAC_ADDR_LOW			0x00000044	/* MAC Address 0 Low */
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+/* STMAC Control Register defines */
+#ifdef CONFIG_DRIVER_NETSTMAC
+#define MAC_CONTROL_RA			0x80000000	/* Receive All Mode */
+//#define MAC_CONTROL_BLE		0x40000000	/* Endian Mode */
+#define MAC_CONTROL_HBD			0x10000000	/* Heartbeat Disable */
+#define MAC_CONTROL_PS			0x08000000	/* Port Select 0:MIII, 1:ENDEC */
+#define MAC_CONTROL_DRO			0x00800000	/* Disable Receive Own */
+//#define MAC_CONTROL_EXT_LOOPBACK	0x00400000	/* Reserved (ext loopback?) */
+//#define MAC_CONTROL_OM		0x00200000	/* Loopback Operating Mode */
+#define MAC_CONTROL_F			0x00100000	/* Full Duplex Mode */
+#define MAC_CONTROL_PM			0x00080000	/* Pass All Multicast */
+#define MAC_CONTROL_PR			0x00040000	/* Promiscuous Mode */
+#define MAC_CONTROL_IF			0x00020000	/* Inverse Filtering */
+//#define MAC_CONTROL_PB		0x00010000	/* Pass Bad Frames */
+#define MAC_CONTROL_HO			0x00008000	/* Hash Only Filtering Mode */
+#define MAC_CONTROL_HP			0x00002000	/* Hash/Perfect Filtering Mode */
+//#define MAC_CONTROL_LCC		0x00001000	/* Late Collision Control */
+//#define MAC_CONTROL_DBF		0x00000800	/* Disable Broadcast Frames */
+//#define MAC_CONTROL_DRTY		0x00000400	/* Disable Retry */
+//#define MAC_CONTROL_ASTP		0x00000100	/* Automatic Pad Stripping */
+//#define MAC_CONTROL_BOLMT_10		0x00000000	/* Back Off Limit 10 */
+//#define MAC_CONTROL_BOLMT_8		0x00000040	/* Back Off Limit 8 */
+//#define MAC_CONTROL_BOLMT_4		0x00000080	/* Back Off Limit 4 */
+//#define MAC_CONTROL_BOLMT_1		0x000000c0	/* Back Off Limit 1 */
+//#define MAC_CONTROL_DC		0x00000020	/* Deferral Check */
+#define MAC_CONTROL_TE			0x00000008	/* Transmitter Enable */
+#define MAC_CONTROL_RE			0x00000004	/* Receiver Enable */
+#define MAC_CORE_INIT			(MAC_CONTROL_HBD)
+#endif	/* CONFIG_DRIVER_NETSTMAC */
+/* GMAC Control Register defines */
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+//#define MAC_CONTROL_TC		0x01000000	/* Transmit Conf. in RGMII/SGMII */
+//#define MAC_CONTROL_WD		0x00800000	/* Disable Watchdog on Receive */
+#define MAC_CONTROL_JD			0x00400000	/* Jabber disable */
+//#define MAC_CONTROL_BE		0x00200000	/* Frame Burst Enable */
+//#define MAC_CONTROL_JE		0x00100000	/* Jumbo Frame */
+//#define MAC_CONTROL_DCRS		0x00010000	/* Disable Carrier Sense During TX */
+#define MAC_CONTROL_PS			0x00008000	/* Port Select 0:GMI, 1:MII */
+#define MAC_CONTROL_FES			0x00004000	/* Speed 0:10, 1:100 */
+//#define MAC_CONTROL_DO		0x00002000	/* Disable RX Own */
+//#define MAC_CONTROL_LM		0x00001000	/* Loop-back Mode */
+#define MAC_CONTROL_DM			0x00000800	/* Duplex Mode */
+#define MAC_CONTROL_IPC			0x00000400	/* Checksum Offload */
+//#define MAC_CONTROL_DR		0x00000200	/* Disable Retry */
+//#define MAC_CONTROL_LUD		0x00000100	/* Link Up/Down */
+#define MAC_CONTROL_ACS			0x00000080	/* Automatic Pad Stripping */
+//#define MAC_CONTROL_DC		0x00000010	/* Deferral Check */
+#define MAC_CONTROL_TE			0x00000008	/* Transmitter Enable */
+#define MAC_CONTROL_RE			0x00000004	/* Receiver Enable */
+#define MAC_CORE_INIT	(MAC_CONTROL_JD | MAC_CONTROL_PS | MAC_CONTROL_ACS | MAC_CONTROL_IPC)
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+/* MAC Flow Control Register defines */
+#define MAC_FLOW_CONTROL_PT_MASK	0xffff0000	/* Pause Time Mask */
+#define MAC_FLOW_CONTROL_PT_SHIFT	16		/* Pause Time Shift */
+//#define GMAC_FLOW_CTRL_FCB_BPA	0x00000001	/* Flow Control Busy ... */
+/* STMAC Flow Control Register defines */
+#ifdef CONFIG_DRIVER_NETSTMAC
+#define MAC_FLOW_CONTROL_PCF		0x00000004	/* Pass Control Frames */
+#define MAC_FLOW_CONTROL_FCE		0x00000002	/* Flow Control Enable */
+#endif	/* CONFIG_DRIVER_NETSTMAC */
+/* GMAC Flow Control Register defines */
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+#define MAC_FLOW_CONTROL_RFE		0x00000004	/* RX Flow Control Enable */
+#define MAC_FLOW_CONTROL_TFE		0x00000002	/* TX Flow Control Enable */
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+/* MII Address defines */
+#define MAC_MII_ADDR_PHY_MASK		0x0000001f	/* MII PHY Address Mask */
+#define MAC_MII_ADDR_PHY_SHIFT		11		/* MII PHY Address Shift */
+#define MAC_MII_ADDR_REG_MASK		0x0000001f	/* MII Register Mask */
+#define MAC_MII_ADDR_REG_SHIFT		6		/* MII Register Shift */
+#define MAC_MII_ADDR_WRITE		0x00000002	/* MII Write */
+#define MAC_MII_ADDR_BUSY		0x00000001	/* MII Busy */
+
+
+/*----------------------------------------------------------------------------
+ *			MAC Management Counters (MMC) Block
+ *---------------------------------------------------------------------------*/
+
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+/* MAC Management Counters Register offsets */
+#define MMC_CONTROL			0x00000100	/* MMC Control */
+
+/* MAC Management Counters Register defines */
+#define MMC_COUNTER_FREEZE		0x00000008	/* Freeze the Counters */
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+
+/*----------------------------------------------------------------------------
+ *			DMA Block
+ *---------------------------------------------------------------------------*/
+
+/* DMA Control & Status Register (CSR) offsets */
+#define DMA_BUS_MODE			0x00001000	/* Bus Mode */
+#define DMA_XMT_POLL_DEMAND		0x00001004	/* Transmit Poll Demand */
+#define DMA_RCV_POLL_DEMAND		0x00001008	/* Receive Poll Demand */
+#define DMA_RCV_BASE_ADDR		0x0000100c	/* Receive List Base Address */
+#define DMA_TX_BASE_ADDR		0x00001010	/* Transmit List Base Address */
+#define DMA_STATUS			0x00001014	/* Status Register */
+#define DMA_CONTROL			0x00001018	/* Control (Operational Mode) */
+#define DMA_INTR_ENA			0x0000101c	/* Interrupt Enable */
+//#define DMA_CUR_TX_BUF_ADDR		0x00001050	/* Current Host Transmit Buffer */
+//#define DMA_CUR_RX_BUF_ADDR		0x00001054	/* Current Host Receive Buffer */
+
+/* DMA Bus Mode Register defines */
+//#define DMA_BUS_MODE_DBO		0x00100000	/* Descriptor Byte Ordering */
+//#define DMA_BUS_MODE_PBL_MASK		0x00003f00	/* Programmable Burst Length Mask */
+#define DMA_BUS_MODE_PBL_SHIFT		8		/* Programmable Burst Length Shift */
+//#define DMA_BUS_MODE_BLE		0x00000080	/* Big Endian/Little Endian */
+//#define DMA_BUS_MODE_DSL_MASK		0x0000007c	/* Descriptor Skip Length Mask */
+//#define DMA_BUS_MODE_DSL_SHIFT	2		/*       (in DWORDS)           */
+//#define DMA_BUS_MODE_BAR_BUS		0x00000002	/* Bar-Bus Arbitration */
+#define DMA_BUS_MODE_SFT_RESET		0x00000001	/* Software Reset */
+#define DMA_BUS_MODE_DEFAULT		0x00000000
+
+/* DMA Status Register defines */
+//#define DMA_STATUS_EB_MASK		0x00380000	/* Error Bits Mask */
+//#define DMA_STATUS_EB_TX_ABORT	0x00080000	/* Error Bits - TX Abort */
+//#define DMA_STATUS_EB_RX_ABORT	0x00100000	/* Error Bits - RX Abort */
+//#define DMA_STATUS_TS_MASK		0x00700000	/* Transmit Process State */
+//#define DMA_STATUS_TS_SHIFT		20
+//#define DMA_STATUS_RS_MASK		0x000e0000	/* Receive Process State */
+//#define DMA_STATUS_RS_SHIFT		17
+//#define DMA_STATUS_NIS		0x00010000	/* Normal Interrupt Summary */
+//#define DMA_STATUS_AIS		0x00008000	/* Abnormal Interrupt Summary */
+//#define DMA_STATUS_ERI		0x00004000	/* Early Receive Interrupt */
+//#define DMA_STATUS_FBI		0x00002000	/* Fatal Bus Error Interrupt */
+//#define DMA_STATUS_ETI		0x00000400	/* Early Transmit Interrupt */
+//#define DMA_STATUS_RWT		0x00000200	/* Receive Watchdog Timeout */
+//#define DMA_STATUS_RPS		0x00000100	/* Receive Process Stopped */
+//#define DMA_STATUS_RU			0x00000080	/* Receive Buffer Unavailable */
+//#define DMA_STATUS_RI			0x00000040	/* Receive Interrupt */
+//#define DMA_STATUS_UNF		0x00000020	/* Transmit Underflow */
+//#define DMA_STATUS_OVF		0x00000010	/* Receive Overflow */
+//#define DMA_STATUS_TJT		0x00000008	/* Transmit Jabber Timeout */
+//#define DMA_STATUS_TU			0x00000004	/* Transmit Buffer Unavailable */
+//#define DMA_STATUS_TPS		0x00000002	/* Transmit Process Stopped */
+#define DMA_STATUS_TI			0x00000001	/* Transmit Interrupt */
+
+/* DMA Control (Operation Mode) Register defines */
+#define DMA_CONTROL_ST			0x00002000	/* Start/Stop Transmission */
+#define DMA_CONTROL_SR			0x00000002	/* Start/Stop Receive */
+
+
+/*----------------------------------------------------------------------------
+ *			MII defines
+ *---------------------------------------------------------------------------*/
+
+/* MII Register Offsets */
+#define MII_BMCR			0x00		/* Basic Mode Control Register */
+#define MII_BMSR			0x01		/* Basic Mode Status Register */
+#define MII_PHYSID1			0x02		/* PHY Identifier #1 */
+#define MII_PHYSID2			0x03		/* PHY Identifier #2 */
+#define MII_ADVERTISE			0x04		/* AN Advertisement Control Register */
+#define MII_LPA				0x05		/* AN Link Partner Ability Register */
+//#define MII_EXPANSION			0x06		/* AN Expansion Register */
+
+/* Basic Mode Control Register defines */
+//#define BMCR_SPEED1000		0x0040		/* MSB of Speed (1000) */
+//#define BMCR_CTST			0x0080		/* Collision Test */
+//#define BMCR_FULLDPLX			0x0100		/* Full Duplex */
+#define BMCR_ANRESTART			0x0200		/* Auto-Negotiation Restart */
+//#define BMCR_ISOLATE			0x0400		/* Disconnect from the MII */
+//#define BMCR_PDOWN			0x0800		/* Power-down */
+#define BMCR_ANENABLE			0x1000		/* Enable Auto-Negotiation */
+//#define BMCR_SPEED100			0x2000		/* Select 100Mbps */
+#define BMCR_LOOPBACK			0x4000		/* Enable Loop-back Mode */
+//#define BMCR_RESET			0x8000		/* Software Reset */
+
+/* Basic Mode Status Register defines */
+//#define BMSR_ERCAP			0x0001		/* Extended Capabilities Registers */
+//#define BMSR_JCD			0x0002		/* Jabber Detected */
+#define BMSR_LSTATUS			0x0004		/* Link Status */
+//#define BMSR_ANEGCAPABLE		0x0008		/* Able to do Auto-Negotiation */
+#define BMSR_RFAULT			0x0010		/* Remote Fault Detected */
+#define BMSR_ANEGCOMPLETE		0x0020		/* Auto-Negotiation Complete */
+#define BMSR_10HALF			0x0800		/* Can do 10Mbps, Half-Duplex */
+#define BMSR_10FULL			0x1000		/* Can do 10Mbps, Full-Duplex */
+#define BMSR_100HALF			0x2000		/* Can do 100Mbps, Half-Duplex */
+#define BMSR_100FULL			0x4000		/* Can do 100Mbps, Full-Duplex */
+#define BMSR_100BASE4			0x8000		/* Can do 100Mbps, 4k Packets */
+
+/* Auto-Negotiate Advertisement Control Register defines */
+//#define ADVERTISE_SLCT		0x001f		/* Selector Bits */
+//#define ADVERTISE_CSMA		0x0001		/* Only Selector Supported */
+#define ADVERTISE_10HALF		0x0020		/* Try for 10Mbps Half-Duplex */
+#define ADVERTISE_10FULL		0x0040		/* Try for 10Mbps Full-Duplex */
+#define ADVERTISE_100HALF		0x0080		/* Try for 100Mbps Half-Duplex */
+#define ADVERTISE_100FULL		0x0100		/* Try for 100Mbps Full-Duplex */
+#define ADVERTISE_100BASE4		0x0200		/* Try for 100Mbps 4k Packets */
+//#define ADVERTISE_RFAULT		0x2000		/* Say we can Detect Faults */
+//#define ADVERTISE_LPACK		0x4000		/* Ack Link Partners Response */
+//#define ADVERTISE_NPAGE		0x8000		/* Next Page Capable */
+//#define ADVERTISE_FULL (ADVERTISE_100FULL | ADVERTISE_10FULL | ADVERTISE_CSMA)
+//#define ADVERTISE_ALL (ADVERTISE_10HALF | ADVERTISE_10FULL | ADVERTISE_100HALF | ADVERTISE_100FULL)
+
+/* Auto-Negotiate Link Partner Ability Register defines */
+//#define LPA_SLCT			0x001f		/* Same as Advertise Selector */
+//#define LPA_10HALF			0x0020		/* Can do 10Mbps Half-Duplex */
+#define LPA_10FULL			0x0040		/* Can do 10Mbps Full-Duplex */
+#define LPA_100HALF			0x0080		/* Can do 100Mbps Half-Duplex */
+#define LPA_100FULL			0x0100		/* Can do 100Mbps Full-Duplex */
+//#define LPA_100BASE4			0x0200		/* Can do 100Mbps 4k Packets */
+//#define LPA_RFAULT			0x2000		/* Link Partner Faulted */
+//#define LPA_LPACK			0x4000		/* Link Partner Acknowledged */
+//#define LPA_NPAGE			0x8000		/* Next Page Capable */
+//#define LPA_DUPLEX			(LPA_10FULL | LPA_100FULL)
+//#define LPA_100			(LPA_100FULL | LPA_100HALF | LPA_100BASE4)
+
+
+/*----------------------------------------------------------------------------
+ *			Descriptor Structure
+ *---------------------------------------------------------------------------*/
+
+/* This structure is common for both receive and transmit DMA descriptors.
+ * A descriptor should not be used for storing more than one frame.
+ *
+ * NOTE: the 'enhanced' structures are used the GMAC, whereas
+ * the 10/100 STMAC uses the older (non-enhanced) structures.
+ * */
+struct stmac_dma_des_t
+{
+	/* Receive descriptor */
+	union {
+		struct {
+			u32 des0;	/* RDES0 or TDES0 */
+			u32 des1;	/* RDES1 or TDES1 */
+		} u;
+#ifdef CONFIG_DRIVER_NETSTMAC
+		struct {
+			/* RDES0 */
+			u32 reserved1:1;
+			u32 crc_error:1;
+			u32 dribbling:1;
+			u32 mii_error:1;
+			u32 receive_watchdog:1;
+			u32 frame_type:1;
+			u32 collision:1;
+			u32 frame_too_long:1;
+			u32 last_descriptor:1;
+			u32 first_descriptor:1;
+			u32 multicast_frame:1;
+			u32 runt_frame:1;
+			u32 length_error:1;
+			u32 partial_frame_error:1;
+			u32 descriptor_error:1;
+			u32 error_summary:1;
+			u32 frame_length:14;
+			u32 filtering_fail:1;
+			u32 own:1;
+			/* RDES1 */
+			u32 buffer1_size:11;
+			u32 buffer2_size:11;
+			u32 reserved2:2;
+			u32 second_address_chained:1;
+			u32 end_ring:1;
+			u32 reserved3:5;
+			u32 disable_ic:1;
+		} rx;
+#endif	/* CONFIG_DRIVER_NETSTMAC */
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+		struct {
+			/* RDES0 */
+			u32 payload_csum_error:1;
+			u32 crc_error:1;
+			u32 dribbling:1;
+			u32 error_gmii:1;
+			u32 receive_watchdog:1;
+			u32 frame_type:1;
+			u32 late_collision:1;
+			u32 ipc_csum_error:1;
+			u32 last_descriptor:1;
+			u32 first_descriptor:1;
+			u32 vlan_tag:1;
+			u32 overflow_error:1;
+			u32 length_error:1;
+			u32 source_filter_fail:1;
+			u32 descriptor_error:1;
+			u32 error_summary:1;
+			u32 frame_length:14;
+			u32 filtering_fail:1;
+			u32 own:1;
+			/* RDES1 */
+			u32 buffer1_size:13;
+			u32 reserved1:1;
+			u32 second_address_chained:1;
+			u32 end_ring:1;
+			u32 buffer2_size:13;
+			u32 reserved2:2;
+			u32 disable_ic:1;
+		} rx;		/* -- enhanced -- */
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+#ifdef CONFIG_DRIVER_NETSTMAC
+		struct {
+			/* TDES0 */
+			u32 deferred:1;
+			u32 underflow_error:1;
+			u32 excessive_deferral:1;
+			u32 collision_count:4;
+			u32 heartbeat_fail:1;
+			u32 excessive_collisions:1;
+			u32 late_collision:1;
+			u32 no_carrier:1;
+			u32 loss_carrier:1;
+			u32 reserved1:3;
+			u32 error_summary:1;
+			u32 reserved2:15;
+			u32 own:1;
+			/* TDES1 */
+			u32 buffer1_size:11;
+			u32 buffer2_size:11;
+			u32 reserved3:1;
+			u32 disable_padding:1;
+			u32 second_address_chained:1;
+			u32 end_ring:1;
+			u32 crc_disable:1;
+			u32 reserved4:2;
+			u32 first_segment:1;
+			u32 last_segment:1;
+			u32 interrupt:1;
+		} tx;
+#endif	/* CONFIG_DRIVER_NETSTMAC */
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+		struct {
+			/* TDES0 */
+			u32 deferred:1;
+			u32 underflow_error:1;
+			u32 excessive_deferral:1;
+			u32 collision_count:4;
+			u32 vlan_frame:1;
+			u32 excessive_collisions:1;
+			u32 late_collision:1;
+			u32 no_carrier:1;
+			u32 loss_carrier:1;
+			u32 payload_error:1;
+			u32 frame_flushed:1;
+			u32 jabber_timeout:1;
+			u32 error_summary:1;
+			u32 ip_header_error:1;
+			u32 time_stamp_status:1;
+			u32 reserved1:2;
+			u32 second_address_chained:1;
+			u32 end_ring:1;
+			u32 checksum_insertion:2;
+			u32 reserved2:1;
+			u32 time_stamp_enable:1;
+			u32 disable_padding:1;
+			u32 crc_disable:1;
+			u32 first_segment:1;
+			u32 last_segment:1;
+			u32 interrupt:1;
+			u32 own:1;
+			/* TDES1 */
+			u32 buffer1_size:13;
+			u32 reserved3:3;
+			u32 buffer2_size:13;
+			u32 reserved4:3;
+		} tx;		/* -- enhanced -- */
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+	} des01;
+	void * des2;
+	void * des3;
+};
+
+typedef struct stmac_dma_des_t stmac_dma_des;
+
+
+/*----------------------------------------------------------------------------
+ *			Miscellaneous defines
+ *---------------------------------------------------------------------------*/
+
+/* MAC Register Accessors */
+#define STMAC_READ(REG)		readl(CFG_STM_STMAC_BASE+(REG))
+#define STMAC_WRITE(V, REG)	writel((V), CFG_STM_STMAC_BASE+(REG))
+
+/* max delay to wait after performing a MII Register read/write */
+#ifndef CONFIG_STMAC_MII_POLL_BUSY_DELAY
+#define CONFIG_STMAC_MII_POLL_BUSY_DELAY 1000		/* ticks */
+#endif
+
+/* max delay to wait for a PHY Auto-Negotiate to take */
+#ifndef CONFIG_STMAC_AUTONEG_TIMEOUT
+#define CONFIG_STMAC_AUTONEG_TIMEOUT	(10*CFG_HZ)	/* 10 seconds */
+#endif
+
+/* max delay to wait for a TX to take */
+#ifndef CONFIG_STMAC_TX_TIMEOUT
+#define CONFIG_STMAC_TX_TIMEOUT		(5*CFG_HZ)	/* 5 seconds */
+#endif
+
+/* Recommended STBus Bridge Values for GMAC */
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+#define STBUS_BRIDGE_OFFSET		0x00007000
+#define STBUS_BRIDGE_MAGIC		0x25C608	/* from validation */
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+
diff --git a/drivers/serial/Makefile b/drivers/serial/Makefile
index 735c630006..d5b35c68f0 100644
--- a/drivers/serial/Makefile
+++ b/drivers/serial/Makefile
@@ -35,6 +35,9 @@ COBJS-y += serial_max3100.o
 COBJS-y += serial_pl010.o
 COBJS-y += serial_pl011.o
 COBJS-y += serial_xuartlite.o
+COBJS-y += sh-sci.o
+COBJS-y += stm-asc.o
+COBJS-y += stm-dtf.o
 COBJS-y += usbtty.o
 
 COBJS	:= $(COBJS-y)
diff --git a/drivers/serial/sh-sci.c b/drivers/serial/sh-sci.c
new file mode 100644
index 0000000000..47750abb36
--- /dev/null
+++ b/drivers/serial/sh-sci.c
@@ -0,0 +1,235 @@
+/*
+ *  drivers/sh-sci.c
+ *
+ *  SuperH on-chip serial module support.  (SCI with no FIFO / with FIFO)
+ *  Copyright (C) 1999, 2000  Niibe Yutaka
+ *  Copyright (C) 2000  Sugioka Toshinobu
+ *  Modified to support multiple serial ports. Stuart Menefy (May 2000).
+ *  Modified to support SecureEdge. David McCullough (2002)
+ *  Modified to support SH7300 SCIF. Takashi Kusuda (Jun 2003).
+ *  Modified for u-boot Andy Sturges (Nov 2004)
+ *
+ * TTY code is based on sx.c (Specialix SX driver) by:
+ *
+ *   (C) 1998 R.E.Wolff@BitWizard.nl
+ *
+ */
+
+#include "common.h"
+
+#ifdef CONFIG_SH_SCIF_SERIAL
+
+#include "asm/termbits.h"
+#include "asm/io.h"
+#include "sh-sci.h"
+
+static void sci_init_pins_scif (struct sci_port *port, unsigned int cflag);
+static struct sci_port sci_ports[SCI_NPORTS] = SCI_INIT;
+
+static void put_char (struct sci_port *port, char c)
+{
+	unsigned short status;
+
+	do
+		status = sci_in (port, SCxSR);
+	while (!(status & SCxSR_TDxE (port)));
+
+	sci_out (port, SCxTDR, c);
+	sci_in (port, SCxSR);	/* Dummy read */
+	sci_out (port, SCxSR, SCxSR_TDxE_CLEAR (port));
+
+}
+
+static void handle_error (struct sci_port *port)
+{				/* Clear error flags */
+	sci_out (port, SCxSR, SCxSR_ERROR_CLEAR (port));
+}
+
+static int get_char (struct sci_port *port)
+{
+	unsigned short status;
+	int c;
+
+	do {
+		status = sci_in (port, SCxSR);
+		if (status & SCxSR_ERRORS (port)) {
+			handle_error (port);
+			continue;
+		}
+	} while (!(status & SCxSR_RDxF (port)));
+	c = sci_in (port, SCxRDR);
+	sci_in (port, SCxSR);	/* Dummy read */
+	sci_out (port, SCxSR, SCxSR_RDxF_CLEAR (port));
+
+	return c;
+}
+
+#if 0
+static void put_string (struct sci_port *port, const char *buffer, int count)
+{
+	int i;
+	const unsigned char *p = buffer;
+
+	for (i = 0; i < count; i++) {
+		if (*p == 10)
+			put_char (port, '\r');
+		put_char (port, *p++);
+	}
+}
+#endif
+
+static int is_char_ready (struct sci_port *port)
+{
+	unsigned short status = sci_in (port, SCxSR);
+
+	if (status & (SCxSR_ERRORS (port) | SCxSR_BRK (port)))
+		handle_error (port);
+
+	return (status & SCxSR_RDxF (port));
+}
+
+static void sci_init_pins_scif (struct sci_port *port, unsigned int cflag)
+{
+	unsigned int fcr_val = 0;
+
+	if (cflag & CRTSCTS) {
+		fcr_val |= SCFCR_MCE;
+	} else {
+		sci_out (port, SCSPTR, 0x0080);	/* Set RTS = 1 */
+	}
+	sci_out (port, SCFCR, fcr_val);
+}
+
+static void sci_setsignals (struct sci_port *port, int dtr, int rts)
+{
+	/* This routine is used for seting signals of: DTR, DCD, CTS/RTS */
+	/* We use SCIF's hardware for CTS/RTS, so don't need any for that. */
+	/* If you have signals for DTR and DCD, please implement here. */
+}
+
+static void sci_set_baud (struct sci_port *port, int baud)
+{
+	int t;
+	DECLARE_GLOBAL_DATA_PTR;
+	bd_t *bd = gd->bd;
+
+	switch (baud) {
+	case 0:
+		t = -1;
+		break;
+	case 2400:
+		t = BPS_2400;
+		break;
+	case 4800:
+		t = BPS_4800;
+		break;
+	case 9600:
+		t = BPS_9600;
+		break;
+	case 19200:
+		t = BPS_19200;
+		break;
+	case 38400:
+		t = BPS_38400;
+		break;
+	case 57600:
+		t = BPS_57600;
+		break;
+	case 230400:
+		if (BPS_230400 != BPS_115200) {
+			t = BPS_230400;
+			break;
+		}
+	default:
+		printf ("sci: unsupported baud rate: %d, using 115200 instead.\n", baud);
+	case 115200:
+		t = BPS_115200;
+		break;
+	}
+
+	if (t > 0) {
+		sci_setsignals (port, 1, -1);
+		if (t >= 256) {
+			sci_out (port, SCSMR,
+				 (sci_in (port, SCSMR) & ~3) | 1);
+			t >>= 2;
+		} else {
+			sci_out (port, SCSMR, sci_in (port, SCSMR) & ~3);
+		}
+		sci_out (port, SCBRR, t);
+		udelay ((1000000 + (baud - 1)) / baud);	/* Wait one bit interval */
+	} else {
+		sci_setsignals (port, 0, -1);
+	}
+}
+
+static void sci_set_termios_cflag (struct sci_port *port, int cflag, int baud)
+{
+	unsigned int status;
+	unsigned int smr_val;
+
+	do
+		status = sci_in (port, SCxSR);
+	while (!(status & SCxSR_TEND (port)));
+
+	sci_out (port, SCSCR, 0x00);	/* TE=0, RE=0, CKE1=0 */
+
+	if (port->type == PORT_SCIF) {
+		sci_out (port, SCFCR, SCFCR_RFRST | SCFCR_TFRST);
+	}
+
+	smr_val = sci_in (port, SCSMR) & 3;
+	if ((cflag & CSIZE) == CS7)
+		smr_val |= 0x40;
+	if (cflag & PARENB)
+		smr_val |= 0x20;
+	if (cflag & PARODD)
+		smr_val |= 0x30;
+	if (cflag & CSTOPB)
+		smr_val |= 0x08;
+	sci_out (port, SCSMR, smr_val);
+	sci_set_baud (port, baud);
+
+	port->init_pins (port, cflag);
+	sci_out (port, SCSCR, SCSCR_INIT (port));
+}
+
+int serial_init (void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	int cflags = CS8 | CREAD | HUPCL | CLOCAL | CRTSCTS;
+	sci_set_termios_cflag (&sci_ports[CONFIG_CONS_INDEX], cflags,
+			       gd->baudrate);
+	return (0);
+}
+
+void serial_putc (const char c)
+{
+	if (c == 10)
+		put_char (&sci_ports[CONFIG_CONS_INDEX], '\r');
+	put_char (&sci_ports[CONFIG_CONS_INDEX], c);
+}
+
+void serial_puts (const char *s)
+{
+	while (*s) {
+		serial_putc (*s++);
+	}
+}
+
+int serial_getc (void)
+{
+	return get_char (&sci_ports[CONFIG_CONS_INDEX]);
+}
+
+int serial_tstc (void)
+{
+	return is_char_ready (&sci_ports[CONFIG_CONS_INDEX]);
+}
+
+void serial_setbrg (void)
+{
+	/* */
+}
+
+#endif /* CONFIG_SH_SCIF_SERIAL */
diff --git a/drivers/serial/stm-asc.c b/drivers/serial/stm-asc.c
new file mode 100644
index 0000000000..9bf7db55ac
--- /dev/null
+++ b/drivers/serial/stm-asc.c
@@ -0,0 +1,884 @@
+/*
+ * drivers/serial/stm-asc.c
+ *
+ * Support for Serial I/O using STMicroelectronics' on-chip ASC.
+ *
+ *  Copyright (c) 2004,2008  STMicroelectronics Limited
+ *  Sean McGoogan <Sean.McGoogan@st.com>
+ *  Copyright (C) 1999  Takeshi Yaegachi & Niibe Yutaka
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License.  See the file "COPYING.LIB" in the main
+ * directory of this archive for more details.
+ *
+ */
+
+#include "common.h"
+#include <command.h>
+
+#ifdef CONFIG_STM_ASC_SERIAL
+
+#include "asm/termbits.h"
+#include "asm/io.h"
+#include "asm/pio.h"
+#include "asm/socregs.h"
+#include "asm/clk.h"
+#define SYS_CODE1						0X00
+#define SYS_CODE2						0XFF
+
+#define RMT_PS_KEY_VAL			0x0A
+
+#define STA									0X73
+#define KEY									0X6B
+#define RMT									0x72
+#define KEY_CTN							0X4B
+#define RMT_CTN							0X52
+#define GMT0								0x48
+#define GMT1								0x49
+#define GMT2								0x50
+#define GMT3								0x51
+#define GMT_NULL						0x4e
+//----------------------------------
+//09.02.27
+#define	PS_ON_INFO					0x70
+#define	SW_51_VER						0x76
+
+
+#define OK									0XF3
+#define ER									0XF4
+#define RJCT								0xF5
+#define N_PROC							0xF6
+
+#define START_BYTE					0XE0
+
+#define SYS_CODE_TAG				0X01
+#define PS_KEY_VAL_TAG			0X02
+#define SYS_DSPL_INFO_TAG		0X03
+#define WAKE_TIME_TAG				0X04
+#define SYS_TIME_TAG				0X05
+//------------------------------
+//09.02.27//change
+#define HOST_CMD_TAG				0X06
+//------------------------------
+#define GMT_TIME_TAG				0X07
+//------------------------------
+
+#define PS_OFF_CMD					0X55
+#define PS_RST_CMD					0XAA
+//------------------------------
+//09.02.27 add
+#define TX_GMT_CMD					0X03
+#define PS_HOW_ON_CMD				0X04
+//...
+#define GET_VER_CMD					0X05
+#define SHOW_M_H_CMD				0X06
+#define SHOW_S_M_CMD				0X07
+#define SHOW_L_INFO_CMD			0X08
+//09.03.04 add...
+#define ON_USB_LED_CMD			0X09
+#define OFF_USB_LED_CMD			0X0a
+//09.03.06 add...
+#define EN_HBT_USB_LED_CMD	0X0B
+#define DIS_HBT_USB_LED_CMD 0X0C
+
+
+#define PS_AC_ON						0X01
+#define PS_KB_ON						0X02
+#define PS_RMT_ON						0X03
+#define	PS_SCH_ON						0X04
+#define	PS_RST_ON						0X05
+#define PS_TST_ON						0X06
+
+#define FPN_KEY_NULL				0x00
+#define FPN_KEY_POWER				0x01
+#define FPN_KEY_MENU				0x02
+#define FPN_KEY_OK					0x04
+#define FPN_KEY_EXIT				0x08
+#define FPN_KEY_VOLN				0x10
+#define FPN_KEY_VOLP				0x20
+#define FPN_KEY_CHN					0x40
+#define FPN_KEY_CHP					0x80
+
+#define INI_VECTORLo				0x00
+#define INI_VECTORHi				0x00
+#define POLYNOMIALHi				0x80
+#define POLYNOMIALLo				0x05
+
+#define SET_APP_RUN_FLG_CMD	0X0D
+#define CLS_APP_RUN_FLG_CMD	0X0E
+
+#define FPN_ERR_SYMBOL			0xac
+#define CS7		0000040
+#define CS8		0000060
+#define CSIZE		0000060
+#define CSTOPB		0000100
+#define CREAD		0000200
+#define PARENB		0000400
+#define PARODD		0001000
+#define HUPCL		0002000
+#define CLOCAL		0004000
+
+#define BAUDMODE	0x00001000
+#define BAUDMODE_PIO5	0x00000000
+#define CTSENABLE	0x00000800
+#define RXENABLE	0x00000100
+#define RUN		0x00000080
+#define LOOPBACK	0x00000000
+#define STOPBIT		0x00000008
+#define MODE		0x00000001
+#define MODE_7BIT_PAR	0x0003
+#define MODE_8BIT_PAR	0x0007
+#define MODE_8BIT	0x0001
+#define STOP_1BIT	0x0008
+#define PARITYODD	0x0020
+
+#define STA_NKD		0x0400
+#define STA_TF		0x0200
+#define STA_RHF		0x0100
+#define STA_TOI		0x0080
+#define STA_TNE		0x0040
+#define STA_OE		0x0020
+#define STA_FE		0x0010
+#define STA_PE		0x0008
+#define	STA_THE		0x0004
+#define STA_TE		0x0002
+#define STA_RBF		0x0001
+
+
+#define UART_BAUDRATE_OFFSET	0x00
+#define UART_TXBUFFER_OFFSET	0x04
+#define UART_RXBUFFER_OFFSET	0x08
+#define UART_CONTROL_OFFSET	0x0C
+#define UART_INTENABLE_OFFSET	0x10
+#define UART_STATUS_OFFSET	0x14
+#define UART_GUARDTIME_OFFSET	0x18
+#define UART_TIMEOUT_OFFSET	0x1C
+#define UART_TXRESET_OFFSET	0x20
+#define UART_RXRESET_OFFSET	0x24
+#define UART_RETRIES_OFFSET	0x28
+
+#define UART_BAUDRATE_REG	(CFG_STM_ASC_BASE + UART_BAUDRATE_OFFSET)
+#define UART_TXBUFFER_REG	(CFG_STM_ASC_BASE + UART_TXBUFFER_OFFSET)
+#define UART_RXBUFFER_REG	(CFG_STM_ASC_BASE + UART_RXBUFFER_OFFSET)
+#define UART_CONTROL_REG	(CFG_STM_ASC_BASE + UART_CONTROL_OFFSET)
+#define UART_INTENABLE_REG	(CFG_STM_ASC_BASE + UART_INTENABLE_OFFSET)
+#define UART_STATUS_REG		(CFG_STM_ASC_BASE + UART_STATUS_OFFSET)
+#define UART_GUARDTIME_REG	(CFG_STM_ASC_BASE + UART_GUARDTIME_OFFSET)
+#define UART_TIMEOUT_REG	(CFG_STM_ASC_BASE + UART_TIMEOUT_OFFSET)
+#define UART_TXRESET_REG	(CFG_STM_ASC_BASE + UART_TXRESET_OFFSET)
+#define UART_RXRESET_REG	(CFG_STM_ASC_BASE + UART_RXRESET_OFFSET)
+#define UART_RETRIES_REG	(CFG_STM_ASC_BASE + UART_RETRIES_OFFSET)
+
+#define CFG_STM_ASC_BASE_PIO5  0xFD033000
+#define UART_BAUDRATE_REG_PIO5   (CFG_STM_ASC_BASE_PIO5+ UART_BAUDRATE_OFFSET)
+#define UART_TXBUFFER_REG_PIO5   (CFG_STM_ASC_BASE_PIO5+ UART_TXBUFFER_OFFSET)
+#define UART_RXBUFFER_REG_PIO5   (CFG_STM_ASC_BASE_PIO5+ UART_RXBUFFER_OFFSET)
+#define UART_CONTROL_REG_PIO5    (CFG_STM_ASC_BASE_PIO5+ UART_CONTROL_OFFSET)
+#define UART_INTENABLE_REG_PIO5  (CFG_STM_ASC_BASE_PIO5+ UART_INTENABLE_OFFSET)
+#define UART_STATUS_REG_PIO5     (CFG_STM_ASC_BASE_PIO5+ UART_STATUS_OFFSET)
+#define UART_GUARDTIME_REG_PIO5  (CFG_STM_ASC_BASE_PIO5+ UART_GUARDTIME_OFFSET)
+#define UART_TIMEOUT_REG_PIO5    (CFG_STM_ASC_BASE_PIO5+ UART_TIMEOUT_OFFSET)
+#define UART_TXRESET_REG_PIO5    (CFG_STM_ASC_BASE_PIO5+ UART_TXRESET_OFFSET)
+#define UART_RXRESET_REG_PIO5    (CFG_STM_ASC_BASE_PIO5+ UART_RXRESET_OFFSET)
+#define UART_RETRIES_REG_PIO5    (CFG_STM_ASC_BASE_PIO5+ UART_RETRIES_OFFSET)
+
+/*---- Values for the BAUDRATE Register -----------------------*/
+
+#if defined(__SH4__)
+#define PCLK			(get_peripheral_clk_rate())
+#define BAUDRATE_VAL_M0(bps)	(PCLK / (16 * (bps)))
+#define BAUDRATE_VAL_M1(bps)	((((bps * (1 << 14))+ (1<<13)) / (PCLK/(1 << 6))))
+#else	/* !defined(__SH4__) */
+#define PCLK			B_CLOCK_RATE
+#define BAUDRATE_VAL_M0(bps)	(PCLK / (16 * (bps)))
+#define BAUDRATE_VAL_M1(bps)	(int)((((double)bps * (1 << 20))/ PCLK)+0.5)
+#endif	/* defined(__SH4__) */
+
+/*
+ * MODE 0
+ *                       ICCLK
+ * ASCBaudRate =   ----------------
+ *                   baudrate * 16
+ *
+ * MODE 1
+ *                   baudrate * 16 * 2^16
+ * ASCBaudRate =   ------------------------
+ *                          ICCLK
+ *
+ * NOTE:
+ * Mode 1 should be used for baudrates of 19200, and above, as it
+ * has a lower deviation error than Mode 0 for higher frequencies.
+ * Mode 0 should be used for all baudrates below 19200.
+ */
+
+
+#if defined(CONFIG_STM_ST231)
+#define p2_outl(addr,b) writel(b,addr)
+#define p2_inl(addr)    readl(addr)
+#endif
+
+
+#ifdef CONFIG_HWFLOW
+static int hwflow = 0;		/* turned off by default */
+#endif	/* CONFIG_HWFLOW */
+
+
+/* busy wait until it is safe to send a char */
+static inline void TxCharReady (void)
+{
+	unsigned long status;
+
+	do {
+		status = p2_inl (UART_STATUS_REG);
+	} while (status & STA_TF);
+}
+static unsigned int controlReg2 = 0;
+/* initialize the ASC */
+extern int serial_init (void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	const int cflag = CREAD | HUPCL | CLOCAL | CSTOPB | CS8 | PARODD;
+	unsigned long val;
+	int baud = gd->baudrate;
+	int t, mode = 1;
+
+	switch (baud) {
+	case 9600:
+		t = BAUDRATE_VAL_M0(9600);
+		mode = 0;
+		break;
+	case 19200:
+		t = BAUDRATE_VAL_M1(19200);
+		break;
+	case 38400:
+		t = BAUDRATE_VAL_M1(38400);
+		break;
+	case 57600:
+		t = BAUDRATE_VAL_M1(57600);
+		break;
+	default:
+		printf ("ASC: unsupported baud rate: %d, using 115200 instead.\n", baud);
+	case 115200:
+		t = BAUDRATE_VAL_M1(115200);
+		break;
+	}
+
+	/* wait for end of current transmission */
+	TxCharReady ();
+
+	/* disable the baudrate generator */
+	val = p2_inl (UART_CONTROL_REG);
+	p2_outl (UART_CONTROL_REG, (val & ~RUN));
+
+	/* set baud generator reload value */
+	p2_outl (UART_BAUDRATE_REG, t);
+
+	/* reset the RX & TX buffers */
+	p2_outl (UART_TXRESET_REG, 1);
+	p2_outl (UART_RXRESET_REG, 1);
+
+	/* build up the value to be written to CONTROL */
+	val = RXENABLE | RUN;
+
+	/* set character length */
+	if ((cflag & CSIZE) == CS7)
+		val |= MODE_7BIT_PAR;
+	else {
+		if (cflag & PARENB)
+			val |= MODE_8BIT_PAR;
+		else
+			val |= MODE_8BIT;
+	}
+
+	/* set stop bit */
+	/* it seems no '0 stop bits' option is available: by default
+	 * we get 0.5 stop bits */
+	if (cflag & CSTOPB)
+		val |= STOP_1BIT;
+
+	/* odd parity */
+	if (cflag & PARODD)
+		val |= PARITYODD;
+
+#ifdef CONFIG_HWFLOW
+	/*  set flow control */
+	if (hwflow)
+		val |= CTSENABLE;
+#endif	/* CONFIG_HWFLOW */
+
+	/* set baud generator mode */
+	if (mode)
+		val |= BAUDMODE;
+
+	/* finally, write value and enable ASC */
+	p2_outl (UART_CONTROL_REG, val);
+	controlReg2 = val;
+	return 0;
+}
+
+int serial_init_pio5 (void)
+#if 1
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	const int cflag = CREAD | HUPCL | CLOCAL | CSTOPB | CS8 | PARODD;
+	unsigned long val;
+	int baud = gd->baudrate;
+	int t, mode = 1;
+
+
+	baud = 9600;
+
+	switch (baud) {
+	case 9600:
+		t = BAUDRATE_VAL_M0(9600);
+		mode = 0;
+		break;
+	case 19200:
+		t = BAUDRATE_VAL_M1(19200);
+		break;
+	case 38400:
+		t = BAUDRATE_VAL_M1(38400);
+		break;
+	case 57600:
+		t = BAUDRATE_VAL_M1(57600);
+		break;
+	default:
+		printf ("ASC: unsupported baud rate: %d, using 115200 instead.\n", baud);
+	case 115200:
+		t = BAUDRATE_VAL_M1(115200);
+		break;
+	}
+
+	/* wait for end of current transmission */
+	TxCharReady ();
+
+	/* disable the baudrate generator */
+	val = p2_inl (UART_CONTROL_REG_PIO5);
+	p2_outl (UART_CONTROL_REG_PIO5, (val & ~RUN));
+
+	/* set baud generator reload value */
+	p2_outl (UART_BAUDRATE_REG_PIO5, t);
+
+	/* reset the RX & TX buffers */
+	p2_outl (UART_TXRESET_REG_PIO5, 1);
+	p2_outl (UART_RXRESET_REG_PIO5, 1);
+
+	/* build up the value to be written to CONTROL */
+	val = RXENABLE | RUN;
+
+	/* set character length */
+	if ((cflag & CSIZE) == CS7)
+		val |= MODE_7BIT_PAR;
+	else {
+		if (cflag & PARENB)
+			val |= MODE_8BIT_PAR;
+		else
+			val |= MODE_8BIT;
+	}
+
+	/* set stop bit */
+	/* it seems no '0 stop bits' option is available: by default
+	 * we get 0.5 stop bits */
+	if (cflag & CSTOPB)
+		val |= STOP_1BIT;
+
+	/* odd parity */
+	if (cflag & PARODD)
+		val |= PARITYODD;
+
+#ifdef CONFIG_HWFLOW
+	/*  set flow control */
+	if (hwflow)
+		val |= CTSENABLE;
+#endif	/* CONFIG_HWFLOW */
+
+	/* set baud generator mode */
+	if (mode)
+		val |= BAUDMODE;
+
+	/* finally, write value and enable ASC */
+	p2_outl (UART_CONTROL_REG_PIO5, val);
+
+	return 0;
+}
+#endif
+
+/* returns TRUE if a char is available, ready to be read */
+extern int serial_tstc (void)
+{
+	unsigned long status;
+
+	status = p2_inl (UART_STATUS_REG);
+	return (status & STA_RBF);
+}
+
+/* blocking function, that returns next char */
+extern int serial_getc (void)
+{
+	char ch;
+
+	/* polling wait: for a char to be read */
+	while (!serial_tstc ());
+
+	/* read char, now that we know we have one */
+	ch = p2_inl (UART_RXBUFFER_REG);
+
+	/* return consumed char to the caller */
+	return ch;
+}
+
+/* write write out a single char */
+extern void serial_putc (char ch)
+{
+	/* Stream-LF to CR+LF conversion */
+	if (ch == 10)
+		serial_putc ('\r');
+
+	/* wait till safe to write next char */
+	TxCharReady ();
+
+	/* finally, write next char */
+	p2_outl (UART_TXBUFFER_REG, ch);
+}
+
+/* write an entire (NUL-terminated) string */
+extern void serial_puts (const char *s)
+{
+	while (*s) {
+		serial_putc (*s++);
+	}
+}
+
+/* called to adjust baud-rate */
+extern void serial_setbrg (void)
+{
+	/* just re-initialize ASC */
+	serial_init ();
+}
+
+int serial_tstc_pio5 (void)
+{
+	unsigned short status;
+
+	status = p2_inl (UART_STATUS_REG_PIO5);
+	return (status & STA_RBF);
+}
+
+/* This function doesn't correctly work */
+int serial_getc_pio5 (void)
+{
+	char ch;
+
+	while (!serial_tstc_pio5 ());
+
+	ch = p2_inl (UART_RXBUFFER_REG_PIO5);
+
+	return ch;
+}
+
+static inline int putDebugCharReady_pio5 (void)
+{
+	unsigned long status;
+
+	status = p2_inl (UART_STATUS_REG_PIO5);
+	return !(status & STA_TF);
+}
+
+void serial_putc_pio5 (char ch)
+{
+	if (ch == 10)
+		serial_putc_pio5 ('\r');
+	while (!putDebugCharReady_pio5 ());
+	p2_outl (UART_TXBUFFER_REG_PIO5, ch);
+}
+
+void serial_puts_pio5 (const char *s)
+{
+	while (*s) {
+		serial_putc_pio5 (*s++);
+	}
+}
+
+static void send_8byte(unsigned char *buff)
+{
+	unsigned char i;
+	int rc;
+
+	for(i = 0; i < 8; i++)
+	{
+		serial_putc_pio5(buff[i]);
+	}
+}
+
+unsigned char decode(unsigned char ch)
+{
+	unsigned char	code;
+
+	switch(ch)
+	{
+		case '0':
+		case 'O':
+			code = 0xc0;
+			break;
+		case '1':
+		case 'l':
+		case 'I':
+		case 'i':
+			code = 0xf9;
+			break;
+		case '2':
+			code = 0xa4;
+			break;
+		case '3':
+			code = 0xb0;
+			break;
+		case '4':
+			code = 0x99;
+			break;
+		case '5':
+		case 'S':
+		case 's':
+			code = 0x92;
+			break;
+		case '6':
+			code = 0x82;
+			break;
+		case '7':
+			code = 0xF8;
+			break;
+		case '8':
+			code = 0x80;
+			break;
+		case '9':
+		case 'G':
+		case 'g':
+			code = 0x90;
+			break;
+		case 'a':
+		case 'A':
+			code = 0x88;
+			break;
+		case 'b':
+		case 'B':
+			code = 0x83;
+			break;
+		case 'c':
+			code = 0xa7;
+			break;
+		case 'C':
+			code = 0xc6;
+			break;
+		case 'd':
+		case 'D':
+			code = 0xa1;
+			break;
+		case 'E':
+		case 'e':
+			code = 0x86;
+			break;
+		case 'F':
+		case 'f':
+			code = 0x8e;
+			break;
+		case 'P':
+		case 'p':
+			code = 0x8c;
+			break;
+		case 'U':
+		case 'V':
+			code = 0xC1;
+			break;
+		case 'u':
+		case 'v':
+			code = 0xe3;
+			break;
+		case 'q':
+		case 'Q':
+			code = 0x98;
+			break;
+		case 'R':
+		case 'r':
+			code = 0x8f;
+			break;
+		case '.':
+			code = 0x7f;
+			break;
+		case ' ':
+			code = 0xff;
+			break;
+		case 'h':
+			code = 0x8b;
+			break;
+		case 'H':
+			code = 0x89;
+			break;
+		case 'J':
+		case 'j':
+			code = 0xf1;
+			break;
+		case 'L':
+			code = 0xC7;
+			break;
+		case 'n':
+			code = 0xab;
+			break;
+		case 'N':
+			code = 0xC8;
+			break;
+		case 'o':
+			code = 0xa3;
+			break;
+		case 'y':
+		case 'Y':
+			code = 0x91;
+			break;
+		case 't':
+		case 'T':
+			code = 0x87;
+			break;
+		case '?':
+			code = FPN_ERR_SYMBOL;
+			break;
+
+		default:
+			code = 0xff;
+			printf("The [%c] can not display on fpn!\n\r", (char)ch);
+			break;
+	}
+	return code;
+}
+
+/*
+Call this function to set the content to be displayed on the fpn.
+for example, "f.1.08".
+*/
+unsigned char decode_str(unsigned char *fpn_str, unsigned char *decode_buf/*4 bytes*/)
+{
+	unsigned char rc = 0;
+	int	fpn_str_len;
+	int	f, l, i;
+	char	local_str[9];
+	char	local_str2[9];
+
+	for(i = 0; i < 9; i++)
+	{
+		local_str[i] = ' ';
+	}
+	fpn_str_len = strlen(fpn_str);
+
+	for(f = 0, l = 0; f < fpn_str_len && l < 9;)
+	{
+		if('.' == fpn_str[f])
+		{
+			if(f == 0)
+			{
+				local_str[l] = ' ';
+				l++;
+				local_str[l] = '.';
+				l++;
+			}
+			else
+			{
+				if(fpn_str[f - 1] == '.')
+				{
+					local_str[l] = ' ';
+					l++;
+					local_str[l] = '.';
+					l++;
+				}
+				else
+				{
+					local_str[l] = '.';
+					l++;
+				}
+
+			}
+		}
+		else
+		{
+			if(f == (fpn_str_len - 1))
+			{
+				local_str[l] = fpn_str[f];
+				l++;
+				local_str[l] = ' ';
+				l++;
+				break;
+			}
+			else
+			{
+				if(fpn_str[f + 1] == '.')
+				{
+					local_str[l] = fpn_str[f];
+					l++;
+				}
+				else
+				{
+					local_str[l] = fpn_str[f];
+					l++;
+					local_str[l] = ' ';
+					l++;
+				}
+			}
+		}
+
+		f++;
+	}
+
+	local_str[8] = 0;
+	for(i = 0; i < 4; i++)
+	{
+		decode_buf[i] = decode(local_str[2 * i]);
+
+		decode_buf[i] |= 0x80;
+
+		if('.' == local_str[2 * i + 1])
+		decode_buf[i] &= 0x7f;
+
+		if(decode_buf[i] == FPN_ERR_SYMBOL)
+		{
+			rc++;//error increase
+		}
+		local_str2[i] = decode_buf[i];
+	}
+
+	return rc;
+}
+
+unsigned short get_crc16(unsigned char *data_blk_ptr,unsigned char data_blk_size)
+{
+	unsigned short crc_return;
+	unsigned char CRC16Lo=INI_VECTORLo;
+	unsigned char CRC16Hi=INI_VECTORHi;
+	unsigned char SaveHi,SaveLo;
+	unsigned char i, j;
+	for (i = 0; i < data_blk_size; i++)
+	{
+		CRC16Lo = CRC16Lo ^ *data_blk_ptr++;
+		for (j = 0; j < 8; j++ )
+		{
+			SaveHi = CRC16Hi;
+			SaveLo = CRC16Lo;
+			CRC16Hi = CRC16Hi >>1;
+			CRC16Lo = CRC16Lo >>1;
+			if ((SaveHi & 0x1) == 0x1)
+			{
+				CRC16Lo = CRC16Lo | 0x80;
+			}
+			if ((SaveLo & 0x1) == 0x1)
+			{
+				CRC16Hi = CRC16Hi ^ POLYNOMIALHi;
+				CRC16Lo = CRC16Lo ^ POLYNOMIALLo;
+			}
+		}
+	}
+	crc_return = CRC16Hi * 256 + CRC16Lo;
+	return (crc_return);
+}
+
+void send_sys_code(void)
+{
+	unsigned char out[8], in[2];
+	unsigned short crc;
+
+	out[0] = START_BYTE;
+	out[1] = SYS_CODE_TAG;
+
+	out[2] = SYS_CODE1;
+	out[3] = SYS_CODE2;
+	out[4] = 0xff;
+	out[5] = 0xff;
+
+	crc = get_crc16(out, 6);
+
+	out[6] = crc & 0xff;
+	out[7] = (crc >> 8) & 0xff;
+
+	send_8byte(out);
+}
+
+extern void send_dspl_info(unsigned char *str)
+{
+
+}
+
+void F450_enable(void)
+{
+	int		ErrorCode;
+	unsigned char	out[8];
+	unsigned short	crc;
+
+	out[0] = START_BYTE;
+	out[1] = HOST_CMD_TAG;
+
+	out[2] = SET_APP_RUN_FLG_CMD;
+	out[3] = 0xff;
+	out[4] = 0xff;
+	out[5] = 0xff;
+
+	crc = get_crc16(out, 6);
+
+	out[6] = crc & 0xff;
+	out[7] = (crc >> 8) & 0xff;
+
+	send_8byte(out);
+}
+
+void F450_disable(void)
+{
+	int		ErrorCode;
+	unsigned char	out[8];
+	unsigned short	crc;
+
+	out[0] = START_BYTE;
+	out[1] = HOST_CMD_TAG;
+
+	out[2] = CLS_APP_RUN_FLG_CMD;
+	out[3] = 0xff;
+	out[4] = 0xff;
+	out[5] = 0xff;
+
+	crc = get_crc16(out, 6);
+
+	out[6] = crc & 0xff;
+	out[7] = (crc >> 8) & 0xff;
+
+	send_8byte(out);
+}
+
+void do_displayFPN(void)
+{
+	char TestStr[] = "4567";
+	send_dspl_info(TestStr);
+}
+
+U_BOOT_CMD(
+	display_fpn,	1,	1,	do_displayFPN,
+	"do_displayFPN - display fpn\n",
+	NULL
+	);
+
+void serial_setbrg_pio5 (void)
+{
+	serial_init_pio5();
+}
+#ifdef CONFIG_HWFLOW
+extern int hwflow_onoff (int on)
+{
+	switch (on) {
+	case 0:
+	default:
+		break;		/* return current */
+	case 1:
+		hwflow = 1;	/* turn on */
+		serial_init ();
+		break;
+	case -1:
+		hwflow = 0;	/* turn off */
+		serial_init ();
+		break;
+	}
+	return hwflow;
+}
+#endif	/* CONFIG_HWFLOW */
+
+#endif	/* CONFIG_STM_ASC_SERIAL */
diff --git a/drivers/serial/stm-dtf.c b/drivers/serial/stm-dtf.c
new file mode 100644
index 0000000000..700cfeb98b
--- /dev/null
+++ b/drivers/serial/stm-dtf.c
@@ -0,0 +1,187 @@
+/*
+ * drivers/serial/stm-dtf.c
+ *
+ * Support for emulated serial console I/O using STMicroelectronics'
+ * DTF (Data Transfer Format) mechanism, over a JTAG link, to
+ * a remote GDB debugger on a host machine.
+ *
+ *  Copyright (c) 2009  STMicroelectronics Limited
+ *  Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "common.h"
+
+
+#ifdef CONFIG_STM_DTF_SERIAL
+
+
+#ifdef CONFIG_SH_SCIF_SERIAL
+#error Can not define CONFIG_SH_SCIF_SERIAL and CONFIG_STM_DTF_SERIAL at same time!
+#endif
+
+#ifdef CONFIG_STM_ASC_SERIAL
+#error Can not define CONFIG_STM_ASC_SERIAL and CONFIG_STM_DTF_SERIAL at same time!
+#endif
+
+
+static int dtf_transfer(
+	volatile void * const data,
+	volatile int * const numBytes,
+	const size_t maxPacketSize)
+{
+	static unsigned char dtfPacket[8+sizeof(short)] __attribute__((aligned(4)));
+	unsigned short pktSize = *numBytes;
+
+	/* Ensure our DTF packet buffer is big enough */
+	if (pktSize+sizeof(short) > sizeof(dtfPacket))
+	{
+		*numBytes = 0; /* Error */
+		return -1;
+	}
+
+	/* pack the DTF request */
+	*(unsigned short *)dtfPacket = pktSize;
+	memcpy((char*)dtfPacket+sizeof(short), (void*)data, pktSize);
+
+	/*
+	 * Signal to the host that an I/O request is ready. When control returns
+	 * the packet will have been updated with the result of the request.
+	 */
+	__asm__ __volatile__ (
+		"	mov	%0, r8;"
+		".short	0x003b;"
+		".short	0x0000;"
+		"1:	mov.w	@%0, r8;"
+		"	tst	r8, r8;"
+		"	bt	1b"
+		: : "r" (dtfPacket) : "r8", "t");
+
+	/*
+	 * Unpack the DTF response packet.
+	 * Check that the packet size is valid, if not then return immediately.
+	 */
+	pktSize = *(unsigned short *)dtfPacket;
+	if (pktSize > maxPacketSize)
+	{
+		*numBytes = 0; /* Error */
+		return -1;
+	}
+
+	/* Extract results */
+	*numBytes = pktSize;
+	memcpy((void*)data, (char*)dtfPacket+sizeof(short), pktSize);
+
+	return 0;	/* Okay */
+}
+
+
+/*
+ * The following are used to retain results whilst
+ * polling for a key-stroke in tstc() and getc().
+ */
+static int CachedKeyCode;	/* Key-stroke that is cached */
+static int CachedKey = 0;	/* is "CachedKeyCode" valid */
+
+
+/* returns TRUE if a char is available, ready to be read */
+extern int serial_tstc (void)
+{
+	volatile unsigned char buff[8] __attribute__((aligned(4))) = {24};
+	int buffLen = 1;
+
+	/* have we already got one key-stroke cached ? */
+	if (CachedKey)
+	{
+		return 1;	/* cached key ready to be read */
+	}
+
+	/* Send request to and receive reply from host */
+	if (dtf_transfer(buff, &buffLen, sizeof(buff)) == -1)
+	{
+		return 0;	/* Error */
+	}
+
+	/* Extract result */
+	CachedKey     = *(volatile int*)&buff[0];
+	CachedKeyCode = *(volatile unsigned int*)&buff[4];
+
+	/* return TRUE if a char is available, else FALSE */
+	return CachedKey;
+}
+
+
+/* blocking function, that returns next char */
+extern int serial_getc (void)
+{
+	/* have we already got one key-stroke cached ? */
+	if (CachedKey)
+	{
+		CachedKey = 0;		/* empty the cache */
+		return CachedKeyCode;	/* cached key ready to be read */
+	}
+
+	/* polling wait: for a char to be read */
+	while (!serial_tstc ());
+
+	/* return the key just read */
+	CachedKey = 0;			/* empty the cache */
+	return CachedKeyCode;		/* return it */
+}
+
+
+/* write out a single char */
+extern void serial_putc (const char ch)
+{
+	unsigned char buff[6] = { 7, 1, 0, 0, 0 };
+	int buffLen = sizeof(buff);
+
+	/* put the char to write in buffer */
+	buff[5] = ch;
+
+	/* Send DTF request to the host */
+	dtf_transfer (buff, &buffLen, sizeof(buff));
+}
+
+
+/* write an entire (NUL-terminated) string */
+extern void serial_puts (const char *s)
+{
+	while (*s) {
+		serial_putc (*s++);
+	}
+}
+
+/* initialize the serial device */
+extern int serial_init (void)
+{
+	/* do nothing */
+	return 0;
+}
+
+
+/* called to adjust baud-rate */
+extern void serial_setbrg (void)
+{
+	/* do nothing */
+}
+
+
+#endif	/* CONFIG_STM_DTF_SERIAL */
diff --git a/drivers/usb/Makefile b/drivers/usb/Makefile
index f8ea167b12..2b6de5aadb 100644
--- a/drivers/usb/Makefile
+++ b/drivers/usb/Makefile
@@ -50,3 +50,6 @@ include $(SRCTREE)/rules.mk
 sinclude $(obj).depend
 
 #########################################################################
+
+usb_ohci.o:	CFLAGS += -Wno-strict-aliasing
+
diff --git a/drivers/usb/usb_ohci.c b/drivers/usb/usb_ohci.c
index cfa384eff6..043f4400a6 100644
--- a/drivers/usb/usb_ohci.c
+++ b/drivers/usb/usb_ohci.c
@@ -72,6 +72,43 @@
 # define OHCI_USE_NPS		/* force NoPowerSwitching mode */
 #endif
 
+/*
+ * On the SuperH architecture, we need to pass 'physical' addresses
+ * to the on-chip USB hardware, and not use 'virtual' CPU addresses.
+ *
+ * In 29-bit mode, we just zero the top 3 bits of the virtual address.
+ *
+ * In 32-bit mode, we need to honour the PMB mappings.
+ * 	i.e. VA 0x80000000 == PA 0x40000000
+ *
+ * Note: We must not modify at all if the address is 0x00000000.
+ */
+#ifdef __SH4__
+#if defined(CONFIG_SH_SE_MODE)
+#	define PHYSICAL_ADDR(addr)	\
+	((__u32)(addr) ? ((0x1ffffffful&(__u32)(addr))|0x40000000ul) : 0ul)
+#else
+#	define PHYSICAL_ADDR(addr)	( 0x1ffffffful & (__u32)(addr) )
+#endif	/* CONFIG_SH_SE_MODE */
+#else	/* __SH4__ */
+#	define PHYSICAL_ADDR(addr)	(addr)
+#endif	/* __SH4__ */
+
+/* WARNING! WARNING! WARNING! WARNING!
+ * Uncommenting the following line will remove some delays in the USB
+ * sub-system. However, it is possible that some of these removed delays
+ * may be actually necessary on some hardware devices.
+ * So, although this gives a useful performance improvement, it does
+ * so at the potential risk of reliability and stability.  This should be
+ * considered as an experiential configuration, and not at all recommended
+ * for production or deployment code, unless it has been thoroughly
+ * tested for your specific hardware.
+ * Enabling this optimisation makes some assumptions, that may be totally
+ * without any foundation.  If reliability or stability becomes an issue,
+ * then please disable this configuration option, as a first step.
+ * Use it at your own peril - caveat emptor! */
+//#define CONFIG_USB_AGGRESSIVE_MINIMAL_DELAYS
+
 #undef OHCI_VERBOSE_DEBUG	/* not always helpful */
 #undef DEBUG
 #undef SHOW_INFO
@@ -85,11 +122,11 @@
  * e.g. PCI controllers need this
  */
 #ifdef CFG_OHCI_SWAP_REG_ACCESS
-# define readl(a) __swap_32(*((vu_long *)(a)))
-# define writel(a, b) (*((vu_long *)(b)) = __swap_32((vu_long)a))
+# define readl(a) __swap_32(*((volatile u32 *)(a)))
+# define writel(a, b) (*((volatile u32 *)(b)) = __swap_32((volatile u32)a))
 #else
-# define readl(a) (*((vu_long *)(a)))
-# define writel(a, b) (*((vu_long *)(b)) = ((vu_long)a))
+# define readl(a) (*((volatile u32 *)(a)))
+# define writel(a, b) (*((volatile u32 *)(b)) = ((volatile u32)a))
 #endif /* CFG_OHCI_SWAP_REG_ACCESS */
 
 #define min_t(type,x,y) ({ type __x = (x); type __y = (y); __x < __y ? __x: __y; })
@@ -137,6 +174,8 @@ int got_rhsc;
 /* device which was disconnected */
 struct usb_device *devgone;
 
+extern unsigned long cfg_7105_usb_ohci_regs;  //gongjia add
+
 /*-------------------------------------------------------------------------*/
 
 /* AMD-756 (D2 rev) reports corrupt register contents in some cases.
@@ -414,7 +453,7 @@ static void ohci_dump (ohci_t *controller, int verbose)
 		ep_print_int_eds (controller, "hcca");
 	dbg ("hcca frame #%04x", controller->hcca->frame_no);
 	ohci_dump_roothub (controller, 1);
-
+}
 #endif /* DEBUG */
 
 /*-------------------------------------------------------------------------*
@@ -631,9 +670,9 @@ static int ep_link (ohci_t *ohci, ed_t *edi)
 	case PIPE_CONTROL:
 		ed->hwNextED = 0;
 		if (ohci->ed_controltail == NULL) {
-			writel (ed, &ohci->regs->ed_controlhead);
+			writel (PHYSICAL_ADDR(ed), &ohci->regs->ed_controlhead);
 		} else {
-			ohci->ed_controltail->hwNextED = m32_swap ((unsigned long)ed);
+			ohci->ed_controltail->hwNextED = PHYSICAL_ADDR(m32_swap ((unsigned long)ed));
 		}
 		ed->ed_prev = ohci->ed_controltail;
 		if (!ohci->ed_controltail && !ohci->ed_rm_list[0] &&
@@ -647,9 +686,9 @@ static int ep_link (ohci_t *ohci, ed_t *edi)
 	case PIPE_BULK:
 		ed->hwNextED = 0;
 		if (ohci->ed_bulktail == NULL) {
-			writel (ed, &ohci->regs->ed_bulkhead);
+			writel (PHYSICAL_ADDR(ed), &ohci->regs->ed_bulkhead);
 		} else {
-			ohci->ed_bulktail->hwNextED = m32_swap ((unsigned long)ed);
+			ohci->ed_bulktail->hwNextED = PHYSICAL_ADDR(m32_swap ((unsigned long)ed));
 		}
 		ed->ed_prev = ohci->ed_bulktail;
 		if (!ohci->ed_bulktail && !ohci->ed_rm_list[0] &&
@@ -788,7 +827,7 @@ static ed_t * ep_add_ed (struct usb_device *usb_dev, unsigned long pipe,
 		ed->hwINFO = m32_swap (OHCI_ED_SKIP); /* skip ed */
 		/* dummy td; end of td list for ed */
 		td = td_alloc (usb_dev);
-		ed->hwTailP = m32_swap ((unsigned long)td);
+		ed->hwTailP = PHYSICAL_ADDR(m32_swap ((unsigned long)td));
 		ed->hwHeadP = ed->hwTailP;
 		ed->state = ED_UNLINK;
 		ed->type = usb_pipetype (pipe);
@@ -851,12 +890,12 @@ static void td_fill (ohci_t *ohci, unsigned int info,
 		data = 0;
 
 	td->hwINFO = m32_swap (info);
-	td->hwCBP = m32_swap ((unsigned long)data);
+	td->hwCBP = PHYSICAL_ADDR(m32_swap ((unsigned long)data));
 	if (data)
-		td->hwBE = m32_swap ((unsigned long)(data + len - 1));
+		td->hwBE = PHYSICAL_ADDR(m32_swap ((unsigned long)(data + len - 1)));
 	else
 		td->hwBE = 0;
-	td->hwNextTD = m32_swap ((unsigned long)td_pt);
+	td->hwNextTD = PHYSICAL_ADDR(m32_swap ((unsigned long)td_pt));
 
 	/* append to queue */
 	td->ed->hwTailP = td->hwNextTD;
@@ -875,6 +914,7 @@ static void td_submit_job (struct usb_device *dev, unsigned long pipe, void *buf
 	int cnt = 0;
 	__u32 info = 0;
 	unsigned int toggle = 0;
+	volatile struct ed * ed;
 
 	/* OHCI handles the DATA-toggles itself, we just use the USB-toggle bits for reseting */
 	if(usb_gettoggle(dev, usb_pipeendpoint(pipe), usb_pipeout(pipe))) {
@@ -902,6 +942,27 @@ static void td_submit_job (struct usb_device *dev, unsigned long pipe, void *buf
 		td_fill (ohci, info | (cnt? TD_T_TOGGLE:toggle), data, data_len, dev, cnt, urb);
 		cnt++;
 
+		/* check for possible DataToggle errors */
+		ed = urb->td[0]->ed;
+		if ( ((ed->hwHeadP>>1)&0x1) != (toggle ? 0 : 1) )
+		{
+			/*
+			 * If we were now to instruct the HC to process
+			 * the TDs, we would yield a DataToggle error.
+			 * We correct this here, by ensuring the HC
+			 * is back in sync with the device.
+			 */
+#if 0
+			printf ("\n************************************************************\n"
+				"OHCI: Correcting putative DataToggle Error for dev=%u, en=%u-%s\n"
+				"************************************************************\n",
+				usb_pipedevice(pipe),
+				usb_pipeendpoint(pipe),
+				usb_pipeout(pipe) ? "O" : "I");
+#endif
+				/* invert the "toggleCarry" bit in the ED */
+			ed->hwHeadP ^= 0x2;
+		}
 		if (!ohci->sleeping)
 			writel (OHCI_BLF, &ohci->regs->cmdstatus); /* start bulk list */
 		break;
@@ -1032,6 +1093,12 @@ static int dl_done_list (ohci_t *ohci, td_t *td_list)
 			stat = cc_to_error[cc];
 		}
 
+		/* save the toggleCarry bit, for later use */
+		usb_settoggle (lurb_priv->dev,
+			usb_pipeendpoint(lurb_priv->pipe),
+			usb_pipeout(lurb_priv->pipe),
+			(ed->hwHeadP>>1)&0x1);
+
 		/* see if this done list makes for all TD's of current URB,
 		 * and mark the URB finished if so */
 		if (++(lurb_priv->td_cnt) == lurb_priv->length) {
@@ -1231,9 +1298,9 @@ pkt_print(NULL, dev, pipe, buffer, transfer_len, cmd, "SUB(rh)", usb_pipein(pipe
 	}
 
 	bmRType_bReq  = cmd->requesttype | (cmd->request << 8);
-	wValue	      = cpu_to_le16 (cmd->value);
-	wIndex	      = cpu_to_le16 (cmd->index);
-	wLength	      = cpu_to_le16 (cmd->length);
+	wValue        = cpu_to_le16 (cmd->value);
+	wIndex        = cpu_to_le16 (cmd->index);
+	wLength       = cpu_to_le16 (cmd->length);
 
 	info("Root-Hub: adr: %2x cmd(%1x): %08x %04x %04x %04x",
 		dev->devnum, 8, bmRType_bReq, wValue, wIndex, wLength);
@@ -1432,7 +1499,7 @@ int submit_common_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
 {
 	int stat = 0;
 	int maxsize = usb_maxpacket(dev, pipe);
-	int timeout;
+	int timeout, n;
 	urb_priv_t *urb;
 
 	urb = malloc(sizeof(urb_priv_t));
@@ -1454,7 +1521,9 @@ int submit_common_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
 	urb->actual_length = 0;
 	pkt_print(urb, dev, pipe, buffer, transfer_len, setup, "SUB", usb_pipein(pipe));
 #else
+#ifndef CONFIG_USB_AGGRESSIVE_MINIMAL_DELAYS
 	wait_ms(1);
+#endif	/* CONFIG_USB_AGGRESSIVE_MINIMAL_DELAYS */
 #endif
 	if (!maxsize) {
 		err("submit_common_message: pipesize for pipe %lx is zero",
@@ -1478,6 +1547,10 @@ int submit_common_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
 		timeout = BULK_TO;
 	else
 		timeout = 100;
+#ifdef CONFIG_USB_AGGRESSIVE_MINIMAL_DELAYS
+	/* use units of 100us, instead of 1ms */
+	timeout *= 10;
+#endif	/* CONFIG_USB_AGGRESSIVE_MINIMAL_DELAYS */
 
 	/* wait for it to complete */
 	for (;;) {
@@ -1503,12 +1576,17 @@ int submit_common_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
 		}
 
 		if (--timeout) {
+#ifdef CONFIG_USB_AGGRESSIVE_MINIMAL_DELAYS
+			/* use units of 100us, instead of 1ms */
+			udelay(100);
+#else
 			wait_ms(1);
+#endif	/* CONFIG_USB_AGGRESSIVE_MINIMAL_DELAYS */
 			if (!urb->finished)
 				dbg("\%");
 
 		} else {
-			err("CTL:TIMEOUT ");
+			err("[uboot_iptv]:CTL\n");
 			dbg("submit_common_msg: TO status %x\n", stat);
 			urb->finished = 1;
 			stat = USB_ST_CRC_ERR;
@@ -1522,7 +1600,9 @@ int submit_common_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
 #ifdef DEBUG
 	pkt_print(urb, dev, pipe, buffer, transfer_len, setup, "RET(ctlr)", usb_pipein(pipe));
 #else
+#ifndef CONFIG_USB_AGGRESSIVE_MINIMAL_DELAYS
 	wait_ms(1);
+#endif	/* CONFIG_USB_AGGRESSIVE_MINIMAL_DELAYS */
 #endif
 
 	/* free TDs in urb_priv */
@@ -1548,7 +1628,9 @@ int submit_control_msg(struct usb_device *dev, unsigned long pipe, void *buffer,
 #ifdef DEBUG
 	pkt_print(NULL, dev, pipe, buffer, transfer_len, setup, "SUB", usb_pipein(pipe));
 #else
+#ifndef CONFIG_USB_AGGRESSIVE_MINIMAL_DELAYS
 	wait_ms(1);
+#endif	/* CONFIG_USB_AGGRESSIVE_MINIMAL_DELAYS */
 #endif
 	if (!maxsize) {
 		err("submit_control_message: pipesize for pipe %lx is zero",
@@ -1586,6 +1668,8 @@ static int hc_reset (ohci_t *ohci)
 
 	dbg("%s\n", __FUNCTION__);
 
+	// printf("[uboot_iptv]:hc_reset\n");
+
 	if (readl (&ohci->regs->control) & OHCI_CTRL_IR) { /* SMM owns the HC */
 		writel (OHCI_OCR, &ohci->regs->cmdstatus); /* request ownership */
 		info("USB HC TakeOver from SMM");
@@ -1640,7 +1724,7 @@ static int hc_start (ohci_t * ohci)
 	writel (0, &ohci->regs->ed_controlhead);
 	writel (0, &ohci->regs->ed_bulkhead);
 
-	writel ((__u32)ohci->hcca, &ohci->regs->hcca); /* a reset clears this */
+	writel (PHYSICAL_ADDR((__u32)ohci->hcca), &ohci->regs->hcca); /* a reset clears this */
 
 	fminterval = 0x2edf;
 	writel ((fminterval * 9) / 10, &ohci->regs->periodicstart);
@@ -1738,7 +1822,9 @@ static int hc_interrupt (void)
 	}
 
 	if (ints & OHCI_INTR_WDH) {
+#ifndef CONFIG_USB_AGGRESSIVE_MINIMAL_DELAYS
 		wait_ms(1);
+#endif	/* CONFIG_USB_AGGRESSIVE_MINIMAL_DELAYS */
 		writel (OHCI_INTR_WDH, &regs->intrdisable);
 		(void)readl (&regs->intrdisable); /* flush */
 		stat = dl_done_list (&gohci, dl_reverse_done_list (&gohci));
@@ -1795,8 +1881,10 @@ int usb_lowlevel_init(void)
 
 #ifdef CFG_USB_OHCI_CPU_INIT
 	/* cpu dependant init */
-	if(usb_cpu_init())
+	if(usb_cpu_init()) {
+		printf("[uboot]:usb_cpu_init faild \n");
 		return -1;
+	}
 #endif
 
 #ifdef CFG_USB_OHCI_BOARD_INIT
@@ -1848,6 +1936,11 @@ int usb_lowlevel_init(void)
 		return -1;
 #else
 	gohci.regs = (struct ohci_regs *)CFG_USB_OHCI_REGS_BASE;
+
+#ifdef CONFIG_SH_STB7100_USB
+	gohci.regs = (struct ohci_regs *)(cfg_7105_usb_ohci_regs);
+#endif
+
 #endif
 
 	gohci.flags = 0;
diff --git a/examples/Makefile b/examples/Makefile
index e9b4974be4..b2d448e739 100644
--- a/examples/Makefile
+++ b/examples/Makefile
@@ -61,6 +61,11 @@ ifeq ($(ARCH),avr32)
 LOAD_ADDR = 0x00000000
 endif
 
+ifeq ($(ARCH),sh)
+include $(OBJTREE)/include/autoconf.mk
+LOAD_ADDR = $(CFG_SDRAM_BASE)
+endif
+
 include $(TOPDIR)/config.mk
 
 ELF	= hello_world
diff --git a/examples/stubs.c b/examples/stubs.c
index 26df6e06a1..7dc686adcd 100644
--- a/examples/stubs.c
+++ b/examples/stubs.c
@@ -151,6 +151,25 @@ gd_t *global_data;
 		:					\
 		: "i"(offsetof(gd_t, jt)), "i"(XF_ ##x)	\
 		: "r8");
+#elif defined(CONFIG_SH4)
+/*
+ * r13 holds the pointer to the global_data (read-only).
+ * r0 & r1 are call-clobbered (clobbered).
+ */
+#define EXPORT_FUNC(x)				\
+	asm volatile (				\
+"	.globl " #x "\n"			\
+#x ":\n"					\
+"	mov	%[jt], r0\n"			\
+"	mov.l	@(r0, r13), r1\n"		\
+"	mov	%[func], r0\n"			\
+"	mov.l	@(r0, r1), r0\n"		\
+"	jmp	@r0\n"				\
+"	  nop\n"				\
+	: /* No outputs */			\
+	: [jt]   "i"(offsetof(gd_t, jt)),	\
+	  [func] "i"(XF_ ## x * sizeof(void *))	\
+	: "r0", "r1");
 #else
 #error stubs definition missing for this architecture
 #endif
@@ -189,3 +208,4 @@ void app_startup(char **argv)
 }
 
 #undef EXPORT_FUNC
+
diff --git a/fs/cramfs/cramfs.c b/fs/cramfs/cramfs.c
index 369d1f1674..cfcd8c9479 100644
--- a/fs/cramfs/cramfs.c
+++ b/fs/cramfs/cramfs.c
@@ -44,8 +44,23 @@ struct cramfs_super super;
 
 /* CPU address space offset calculation macro, struct part_info offset is
  * device address space offset, so we need to shift it by a device start address. */
+/*
+ * FIXME FIXME FIXME FIXME FIXME FIXME FIXME FIXME
+ * if CFG_NO_FLASH is set, then we have probably NOT got any NOR flash
+ * present, hence 'flash_info' will not exist. This will result in
+ * this code faling to link, as the PART_OFFSET macro assumes it
+ * does exist. We bodge this issue, but defining this macro to
+ * just use an arbirary address - however this will BREAK the
+ * CRMAFS code, so it is a quick hack, and not a proper solution.
+ * We will need a proper solution for this, if CRAMFS is required.
+ */
+#ifdef CFG_NO_FLASH
+#warning CRAMFS is BROKEN if CFG_NO_FLASH is defined!
+#define PART_OFFSET(x)	(0x00000000)	/* will at least compile! */
+#else
 extern flash_info_t flash_info[];
 #define PART_OFFSET(x)	(x->offset + flash_info[x->dev->id->num].start[0])
+#endif	/* CFG_NO_FLASH */
 
 static int cramfs_read_super (struct part_info *info)
 {
@@ -331,10 +346,10 @@ int cramfs_check (struct part_info *info)
 {
 	struct cramfs_super *sb;
 
-	if (info->dev->id->type != MTD_DEV_TYPE_NOR)
+	if ((info->dev->id->type != MTD_DEV_TYPE_NOR) ||
+	    !(sb = (struct cramfs_super *) PART_OFFSET(info)))
 		return 0;
 
-	sb = (struct cramfs_super *) PART_OFFSET(info);
 	if (sb->magic != CRAMFS_32 (CRAMFS_MAGIC)) {
 		/* check at 512 byte offset */
 		sb = (struct cramfs_super *) (PART_OFFSET(info) + 512);
diff --git a/fs/cramfs/uncompress.c b/fs/cramfs/uncompress.c
index 2e906eb4cf..fc26f93c4a 100644
--- a/fs/cramfs/uncompress.c
+++ b/fs/cramfs/uncompress.c
@@ -23,7 +23,7 @@
 #include <common.h>
 #include <malloc.h>
 #include <watchdog.h>
-#include <zlib.h>
+#include <u-boot/zlib.h>
 
 #if defined(CONFIG_CMD_JFFS2)
 
diff --git a/fs/ext2/ext2fs.c b/fs/ext2/ext2fs.c
index 513a2f9e32..2fdbec7520 100644
--- a/fs/ext2/ext2fs.c
+++ b/fs/ext2/ext2fs.c
@@ -218,10 +218,8 @@ static int ext2fs_read_inode
 		return (0);
 	}
 	inodes_per_block = EXT2_BLOCK_SIZE (data) / 128;
-	blkno = (ino % __le32_to_cpu (sblock->inodes_per_group)) /
-		inodes_per_block;
-	blkoff = (ino % __le32_to_cpu (sblock->inodes_per_group)) %
-		inodes_per_block;
+	blkno = (ino % __le32_to_cpu (sblock->inodes_per_group)) / inodes_per_block;
+	blkoff = (ino % __le32_to_cpu (sblock->inodes_per_group)) % inodes_per_block;
 #ifdef DEBUG
 	printf ("ext2fs read inode blkno %d blkoff %d\n", blkno, blkoff);
 #endif
@@ -243,7 +241,7 @@ void ext2fs_free_node (ext2fs_node_t node, ext2fs_node_t currroot) {
 	}
 }
 
-
+#if 0
 static int ext2fs_read_block (ext2fs_node_t node, int fileblock) {
 	struct ext2_data *data = node->data;
 	struct ext2_inode *inode = &node->inode;
@@ -397,6 +395,291 @@ int ext2fs_read_file
 	}
 	blockcnt = ((len + pos) + blocksize - 1) / blocksize;
 
+	//printf("Loading vmlinux.ub...\n");
+	for (i = pos / blocksize; i < blockcnt; i++) {
+		int blknr;
+		int blockoff = pos % blocksize;
+		int blockend = blocksize;
+
+		int skipfirst = 0;
+
+		blknr = ext2fs_read_block (node, i);
+		if (blknr < 0) {
+			return (-1);
+		}
+		blknr = blknr << log2blocksize;
+
+		/* Last block.  */
+		if (i == blockcnt - 1) {
+			blockend = (len + pos) % blocksize;
+
+			/* The last portion is exactly blocksize.  */
+			if (!blockend) {
+				blockend = blocksize;
+			}
+		}
+
+		/* First block.  */
+		if (i == pos / blocksize) {
+			skipfirst = blockoff;
+			blockend -= skipfirst;
+		}
+		if(!(i%3))
+		{
+			printf(". ");
+		}
+		/* If the block number is 0 this block is not stored on disk but
+		   is zero filled instead.  */
+		if (blknr) {
+			int status;
+
+			status = ext2fs_devread (blknr, skipfirst, blockend, buf);
+			if (status == 0) {
+				return (-1);
+			}
+		} else {
+			memset (buf, blocksize - skipfirst, 0);
+		}
+		buf += blocksize - skipfirst;
+	}
+	return (len);
+}
+#endif
+
+
+#define CFG_OPTIMIZE_EXT2_READ
+
+#ifdef CFG_OPTIMIZE_EXT2_READ
+static int ext2fs_read_block (ext2fs_node_t node, int fileblock, int *stream) {
+#else
+static int ext2fs_read_block (ext2fs_node_t node, int fileblock) {
+#endif
+	struct ext2_data *data = node->data;
+	struct ext2_inode *inode = &node->inode;
+	int blknr;
+	int blksz = EXT2_BLOCK_SIZE (data);
+	int log2_blksz = LOG2_EXT2_BLOCK_SIZE (data);
+	int status;
+
+#ifdef CFG_OPTIMIZE_EXT2_READ
+	*stream = 1;/* itself */
+#endif
+
+	/* Direct blocks.  */
+	if (fileblock < INDIRECT_BLOCKS) {
+		blknr = __le32_to_cpu (inode->b.blocks.dir_blocks[fileblock]);
+#ifdef CFG_OPTIMIZE_EXT2_READ
+		while(((inode->b.blocks.dir_blocks[fileblock + 1] - \
+			inode->b.blocks.dir_blocks[fileblock]) == 1) && \
+			(fileblock < INDIRECT_BLOCKS - 1)) {
+			fileblock++;
+			*stream += 1;
+		}
+#endif
+	}
+	/* Indirect.  */
+	else if (fileblock < (INDIRECT_BLOCKS + (blksz / 4))) {
+		if (indir1_block == NULL) {
+			indir1_block = (uint32_t *) malloc (blksz);
+			if (indir1_block == NULL) {
+				printf ("** ext2fs read block (indir 1) malloc failed. **\n");
+				return (-1);
+			}
+			indir1_size = blksz;
+			indir1_blkno = -1;
+		}
+		if (blksz != indir1_size) {
+			free (indir1_block);
+			indir1_block = NULL;
+			indir1_size = 0;
+			indir1_blkno = -1;
+			indir1_block = (uint32_t *) malloc (blksz);
+			if (indir1_block == NULL) {
+				printf ("** ext2fs read block (indir 1) malloc failed. **\n");
+				return (-1);
+			}
+			indir1_size = blksz;
+		}
+		if ((__le32_to_cpu (inode->b.blocks.indir_block) << log2_blksz) != indir1_blkno) {
+			status = ext2fs_devread (__le32_to_cpu(inode->b.blocks.indir_block) << log2_blksz,
+						 0, blksz,
+						 (char *) indir1_block);
+			if (status == 0) {
+				printf ("** ext2fs read block (indir 1) failed. **\n");
+				return (0);
+			}
+			indir1_blkno = __le32_to_cpu (inode->b.blocks.indir_block) << log2_blksz;
+		}
+		blknr = __le32_to_cpu (indir1_block[fileblock - INDIRECT_BLOCKS]);
+#ifdef CFG_OPTIMIZE_EXT2_READ
+		while(((__le32_to_cpu (indir1_block[fileblock - INDIRECT_BLOCKS+1]) - \
+		       __le32_to_cpu (indir1_block[fileblock - \
+		       INDIRECT_BLOCKS])) == 1) && \
+		       (fileblock < (blksz - 1))) {
+			fileblock++;
+			*stream += 1;
+		}
+#endif
+	}
+	/* Double indirect.  */
+	else if (fileblock <(INDIRECT_BLOCKS + (blksz / 4 * (blksz / 4 + 1)))) {
+		unsigned int perblock = blksz / 4;
+		unsigned int rblock = fileblock - (INDIRECT_BLOCKS + blksz / 4);
+
+#ifdef CFG_OPTIMIZE_EXT2_READ
+		int rbcnt = 0;
+#endif
+		if (indir1_block == NULL) {
+			indir1_block = (uint32_t *) malloc (blksz);
+			if (indir1_block == NULL) {
+				printf ("** ext2fs read block (indir 2 1) malloc failed. **\n");
+				return (-1);
+			}
+			indir1_size = blksz;
+			indir1_blkno = -1;
+		}
+		if (blksz != indir1_size) {
+			free (indir1_block);
+			indir1_block = NULL;
+			indir1_size = 0;
+			indir1_blkno = -1;
+			indir1_block = (uint32_t *) malloc (blksz);
+			if (indir1_block == NULL) {
+				printf ("** ext2fs read block (indir 2 1) malloc failed. **\n");
+				return (-1);
+			}
+			indir1_size = blksz;
+		}
+		if ((__le32_to_cpu (inode->b.blocks.double_indir_block) << log2_blksz) != indir1_blkno) {
+			status = ext2fs_devread (__le32_to_cpu(inode->b.blocks.double_indir_block) << log2_blksz,
+						0, blksz,
+						(char *) indir1_block);
+			if (status == 0) {
+				printf ("** ext2fs read block (indir 2 1) failed. **\n");
+				return (-1);
+			}
+			indir1_blkno = __le32_to_cpu (inode->b.blocks.double_indir_block) << log2_blksz;
+		}
+
+		if (indir2_block == NULL) {
+			indir2_block = (uint32_t *) malloc (blksz);
+			if (indir2_block == NULL) {
+				printf ("** ext2fs read block (indir 2 2) malloc failed. **\n");
+				return (-1);
+			}
+			indir2_size = blksz;
+			indir2_blkno = -1;
+		}
+		if (blksz != indir2_size) {
+			free (indir2_block);
+			indir2_block = NULL;
+			indir2_size = 0;
+			indir2_blkno = -1;
+			indir2_block = (uint32_t *) malloc (blksz);
+			if (indir2_block == NULL) {
+				printf ("** ext2fs read block (indir 2 2) malloc failed. **\n");
+				return (-1);
+			}
+			indir2_size = blksz;
+		}
+		if ((__le32_to_cpu (indir1_block[rblock / perblock]) <<
+		     log2_blksz) != indir1_blkno) {
+			status = ext2fs_devread (__le32_to_cpu(indir1_block[rblock / perblock]) << log2_blksz,
+						 0, blksz,
+						 (char *) indir2_block);
+			if (status == 0) {
+				printf ("** ext2fs read block (indir 2 2) failed. **\n");
+				return (-1);
+			}
+			indir2_blkno = __le32_to_cpu (indir1_block[rblock / perblock]) << log2_blksz;
+		}
+		blknr = __le32_to_cpu (indir2_block[rblock % perblock]);
+#ifdef CFG_OPTIMIZE_EXT2_READ
+		rbcnt = rblock % perblock;
+		while(((__le32_to_cpu (indir2_block[rbcnt + 1]) - \
+		       __le32_to_cpu (indir2_block[rbcnt])) == 1) \
+		       && (rbcnt < (blksz - 1))) {
+			rbcnt++;
+			*stream += 1;
+		}
+#endif
+	}
+	/* Tripple indirect.  */
+	else {
+		printf ("** ext2fs doesn't support tripple indirect blocks. **\n");
+		return (-1);
+	}
+#ifdef DEBUG
+	printf ("ext2fs_read_block %08x\n", blknr);
+#endif
+	return (blknr);
+}
+#ifdef CFG_OPTIMIZE_EXT2_READ
+int ext2fs_read_file
+	(ext2fs_node_t node, int pos, unsigned int len, char *buf) {
+	int log2blocksize = LOG2_EXT2_BLOCK_SIZE (node->data);
+	int blocksize = 1 << (log2blocksize + DISK_SECTOR_BITS);
+	unsigned int filesize = __le32_to_cpu(node->inode.size);
+	int blknr;
+	int blockend;
+	int status;
+	int remain = len;
+	char *buffer = buf;
+	int stream = 0;
+	int cur = pos / blocksize;
+	int blockoff = pos % blocksize;
+
+	/* Adjust len so it we can't read past the end of the file.  */
+	if (len > filesize) {
+		len = filesize;
+	}
+	while (remain > 0) {
+		blknr = ext2fs_read_block (node, cur, &stream);
+		if (blknr < 0) {
+			return (-1);
+		}
+		blknr = blknr << log2blocksize;
+
+		if(remain < blocksize * stream) {
+			blockend = remain;
+		} else {
+			blockend = blocksize * stream;
+		}
+
+		status = ext2fs_devread (blknr, blockoff, blockend, buffer);
+		if (status == 0) {
+			return (-1);
+		}
+
+		remain -= blockend;
+		buffer += blockend;
+		cur += stream;
+		blockoff = 0;
+
+		if(remain == 0)
+		{
+			return (len);
+		}
+		else if(remain < 0)
+			return (-1);
+	}
+
+	return (len);
+}
+#else
+int ext2fs_read_file(ext2fs_node_t node, int pos, unsigned int len, char *buf) {
+	int i;
+	int blockcnt;
+	int log2blocksize = LOG2_EXT2_BLOCK_SIZE (node->data);
+	int blocksize = 1 << (log2blocksize + DISK_SECTOR_BITS);
+	unsigned int filesize = __le32_to_cpu(node->inode.size);
+
+	/* Adjust len so it we can't read past the end of the file.  */
+	if (len > filesize) {
+		len = filesize;
+	}
+	blockcnt = ((len + pos) + blocksize - 1) / blocksize;
+
 	for (i = pos / blocksize; i < blockcnt; i++) {
 		int blknr;
 		int blockoff = pos % blocksize;
@@ -442,6 +725,7 @@ int ext2fs_read_file
 	}
 	return (len);
 }
+#endif
 
 
 static int ext2fs_iterate_dir (ext2fs_node_t dir, char *name, ext2fs_node_t * fnode, int *ftype)
@@ -612,9 +896,7 @@ static char *ext2fs_read_symlink (ext2fs_node_t node) {
 }
 
 
-int ext2fs_find_file1
-	(const char *currpath,
-	 ext2fs_node_t currroot, ext2fs_node_t * currfound, int *foundtype) {
+int ext2fs_find_file1(const char *currpath,ext2fs_node_t currroot, ext2fs_node_t * currfound, int *foundtype) {
 	char fpath[strlen (currpath) + 1];
 	char *name = fpath;
 	char *next;
@@ -762,6 +1044,23 @@ int ext2fs_ls (char *dirname) {
 	return (0);
 }
 
+int ext2fs_find_dir (char *dirname) {
+	ext2fs_node_t dirnode;
+	int status;
+
+	if (ext2fs_root == NULL) {
+		return (0);
+	}
+
+	status = ext2fs_find_file (dirname, &ext2fs_root->diropen, &dirnode,
+				   FILETYPE_DIRECTORY);
+	if (status != 1) {
+		printf ("[uboot_iptv]:Can not find directory. **\n");
+		return (1);
+	}
+	ext2fs_free_node (dirnode, &ext2fs_root->diropen);
+	return (0);
+}
 
 int ext2fs_open (char *filename) {
 	ext2fs_node_t fdiro = NULL;
diff --git a/fs/jffs2/jffs2_1pass.c b/fs/jffs2/jffs2_1pass.c
index 53166683fd..49c9446058 100644
--- a/fs/jffs2/jffs2_1pass.c
+++ b/fs/jffs2/jffs2_1pass.c
@@ -169,12 +169,14 @@ int read_jffs2_nand(size_t start, size_t len,
 extern nand_info_t nand_info[];
 #endif
 
-#define NAND_PAGE_SIZE 512
+//#define NAND_PAGE_SIZE 512
+#define NAND_PAGE_SIZE 2048
 #define NAND_PAGE_SHIFT 9
 #define NAND_PAGE_MASK (~(NAND_PAGE_SIZE-1))
 
 #ifndef NAND_CACHE_PAGES
 #define NAND_CACHE_PAGES 16
+//#define NAND_CACHE_PAGES 4
 #endif
 #define NAND_CACHE_SIZE (NAND_CACHE_PAGES*NAND_PAGE_SIZE)
 
@@ -185,6 +187,7 @@ static int read_nand_cached(u32 off, u32 size, u_char *buf)
 {
 	struct mtdids *id = current_part->dev->id;
 	u32 bytes_read = 0;
+	int ReadOK = -1;
 #if defined(CFG_NAND_LEGACY)
 	size_t retlen;
 #else
@@ -211,17 +214,16 @@ static int read_nand_cached(u32 off, u32 size, u_char *buf)
 			if (read_jffs2_nand(nand_cache_off, NAND_CACHE_SIZE,
 						&retlen, nand_cache, id->num) < 0 ||
 					retlen != NAND_CACHE_SIZE) {
-				printf("read_nand_cached: error reading nand off %#x size %d bytes\n",
-						nand_cache_off, NAND_CACHE_SIZE);
+				printf("read_nand_cached0: error reading nand off %#x size 0x%x bytes, retlen=0x%x \n",
+						nand_cache_off, NAND_CACHE_SIZE, retlen);
 				return -1;
 			}
 #else
 			retlen = NAND_CACHE_SIZE;
-			if (nand_read(&nand_info[id->num], nand_cache_off,
-						&retlen, nand_cache) != 0 ||
-					retlen != NAND_CACHE_SIZE) {
-				printf("read_nand_cached: error reading nand off %#x size %d bytes\n",
-						nand_cache_off, NAND_CACHE_SIZE);
+			ReadOK = nand_read(&nand_info[id->num], nand_cache_off, &retlen, nand_cache);
+			if (ReadOK != 0 || retlen != NAND_CACHE_SIZE) {
+				printf("read_nand_cached1: error ReadOK=0x%x reading nand off %#x size 0x%x bytes, retlen=0x%x \n",
+						ReadOK, nand_cache_off, NAND_CACHE_SIZE, retlen);
 				return -1;
 			}
 #endif
@@ -666,6 +668,7 @@ jffs2_1pass_read_inode(struct b_lists *pL, u32 inode, char *dest)
 				putLabeledWord("read_inode: dest = ", lDest);
 #endif
 				switch (jNode->compr) {
+					printf("***jNode->compr=%d***\n", jNode->compr);
 				case JFFS2_COMPR_NONE:
 					ret = (unsigned long) ldr_memcpy(lDest, src, jNode->dsize);
 					break;
diff --git a/fs/jffs2/jffs2_nand_1pass.c b/fs/jffs2/jffs2_nand_1pass.c
index 3a4c64985a..01d2e8934d 100644
--- a/fs/jffs2/jffs2_nand_1pass.c
+++ b/fs/jffs2/jffs2_nand_1pass.c
@@ -326,6 +326,7 @@ jffs2_1pass_read_inode(struct b_lists *pL, u32 ino, char *dest,
 			dst = (char *) (dest + inode->offset);
 
 			switch (inode->compr) {
+				printf("###jNode->compr=%d###\n", jNode->compr);
 			case JFFS2_COMPR_NONE:
 				ret = 0;
 				memcpy(dst, src, inode->dsize);
diff --git a/include/asm-sh/addrspace.h b/include/asm-sh/addrspace.h
new file mode 100644
index 0000000000..78c8e540df
--- /dev/null
+++ b/include/asm-sh/addrspace.h
@@ -0,0 +1,77 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1999 by Kaz Kojima
+ *
+ * Defitions for the address spaces of the SH CPUs.
+ */
+#ifndef __ASM_SH_ADDRSPACE_H
+#define __ASM_SH_ADDRSPACE_H
+
+/* Memory segments (32bit Priviledged mode addresses)  */
+#define P0SEG		0x00000000
+#define P1SEG		0x80000000
+#define P2SEG		0xa0000000
+#define P3SEG		0xc0000000
+#define P4SEG		0xe0000000
+
+#if defined(__sh3__)
+/* Should fill here */
+#elif defined(__SH4__)
+/* Detailed P4SEG  */
+#define P4SEG_STORE_QUE	(P4SEG)
+#define P4SEG_IC_ADDR	0xf0000000
+#define P4SEG_IC_DATA	0xf1000000
+#define P4SEG_ITLB_ADDR	0xf2000000
+#define P4SEG_ITLB_DATA	0xf3000000
+#define P4SEG_OC_ADDR	0xf4000000
+#define P4SEG_OC_DATA	0xf5000000
+#define P4SEG_TLB_ADDR	0xf6000000
+#define P4SEG_PMB_ADDR	0xf6100000
+#define P4SEG_TLB_DATA	0xf7000000
+#define P4SEG_PMB_DATA	0xf7100000
+#define P4SEG_REG_BASE	0xff000000
+#endif
+
+
+/* ----------------------------------------------------------------------------
+		29-bit Mode memory alias translations
+   ---------------------------------------------------------------------------*/
+#ifndef CONFIG_SH_SE_MODE
+
+/* Returns the privileged segment base of a given address  */
+#define PXSEG(a)	(((unsigned long)(a)) & 0xe0000000)
+
+/* Returns the physical address of a PnSEG (n=1,2) address   */
+#define PHYSADDR(a)	(((unsigned long)(a)) & 0x1fffffff)
+
+/*
+ * Map an address to a certain privileged segment
+ */
+#define P1SEGADDR(a)	((__typeof__(a))(((unsigned long)(a) & 0x1fffffff) | P1SEG))
+#define P2SEGADDR(a)	((__typeof__(a))(((unsigned long)(a) & 0x1fffffff) | P2SEG))
+#define P3SEGADDR(a)	((__typeof__(a))(((unsigned long)(a) & 0x1fffffff) | P3SEG))
+#define P4SEGADDR(a)	((__typeof__(a))(((unsigned long)(a) & 0x1fffffff) | P4SEG))
+#endif /* CONFIG_SH_SE_MODE */
+
+
+/* ----------------------------------------------------------------------------
+		SE-Mode memory alias translations
+   ---------------------------------------------------------------------------*/
+#ifdef CONFIG_SH_SE_MODE
+#if !defined(CFG_SE_SDRAM_WINDOW) || !defined(CFG_SE_PHYSICAL_BASE) || !defined(CFG_SE_UNACHED_BASE)
+#error	SH-4 SE Memory Mappings needs to be defined!
+#endif
+	/*
+	 *	Convert VIRTUAL (cached) address to a UN-CACHED one.
+	 */
+#define P2SEGADDR(a)	(((unsigned long)(a)&CFG_SE_SDRAM_WINDOW)|CFG_SE_UNACHED_BASE)
+	/*
+	 *	Convert VIRTUAL address to a PHYSICAL one.
+	 */
+#define PHYSADDR(a)	(((unsigned long)(a)&CFG_SE_SDRAM_WINDOW)|CFG_SE_PHYSICAL_BASE)
+#endif	/* CONFIG_SH_SE_MODE */
+
+#endif /* __ASM_SH_ADDRSPACE_H */
diff --git a/include/asm-sh/asmdefs.h b/include/asm-sh/asmdefs.h
new file mode 100644
index 0000000000..3f6385c730
--- /dev/null
+++ b/include/asm-sh/asmdefs.h
@@ -0,0 +1,203 @@
+/*
+ * (C) Copyright 2004, 2007, 2009 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/* Macros to support assembly programing */
+
+
+	/* build up a 32-bit constant into R0 */
+.macro MOV_CONST32_R0 p1:req
+	mov	#(\p1>>24), r0
+	shll8	r0
+	.ifne    ((\p1 >> 16)&0xFF)
+	or	#((\p1 >> 16)&0xFF), r0
+	.endif
+	shll8	r0
+	.ifne    ((\p1 >> 8) &0xFF)
+	or	#((\p1 >> 8) &0xFF), r0
+	.endif
+	shll8	r0
+	.ifne    (\p1 &0xFF)
+	or	#(\p1 &0xFF), r0
+	.endif
+.endm
+
+	/* build up a 16-bit constant into R0 */
+.macro MOV_CONST16_R0 p1:req
+	mov	#((\p1 >> 8) &0xFF), r0
+	shll8	r0
+	.ifne    (\p1 &0xFF)
+	or	#(\p1 &0xFF), r0
+	.endif
+.endm
+
+	/* unset top 3 bits of PC */
+.macro ENTER_P0
+	mova	1f, r0
+	mov	#0xE0, r1
+	shll16	r1
+	shll8	r1
+	not	r1, r1		/* MASK is 0x1fffffff */
+	and	r1, r0		/* unset top 3-bits */
+	jmp	@r0
+	  nop
+.balign 4
+1:
+.endm
+
+	/* OR 0x80 into top byte of PC */
+.macro ENTER_P1
+	mova	1f, r0
+	mov	#0xE0, r1
+	shll16	r1
+	shll8	r1
+	not	r1, r1		/* MASK is 0x1fffffff */
+	and	r1, r0		/* unset top 3-bits */
+	mov	#0x80, r1
+	shll16	r1
+	shll8	r1		/* MASK is 0x80000000 */
+	or	r1, r0		/* put PC in P1 */
+	jmp	@r0
+	  nop
+.balign 4
+1:
+.endm
+
+	/* OR 0xA0 into top byte of PC */
+.macro ENTER_P2
+	mova	1f, r0
+	mov	#0xE0, r1
+	shll16	r1
+	shll8	r1
+	not	r1, r1		/* MASK is 0x1fffffff */
+	and	r1, r0		/* unset top 3-bits */
+	mov	#0xA0, r1
+	shll16	r1
+	shll8	r1		/* MASK is 0xA0000000 */
+	or	r1, r0		/* put PC in P2 */
+	jmp	@r0
+	  nop
+.balign 4
+1:
+.endm
+
+	/* call a routine in another file */
+.macro CALL p1:req
+	mova	\p1, r0
+	mov.l	@r0, r1
+	add	r1, r0
+	jsr	@r0
+	  nop
+.endm
+
+	/* put device id in p1 */
+.macro GETDEVID p1:req
+#ifdef CONFIG_SH_STB7100
+	mov.l	1f, r0
+	mov.l	@r0, \p1
+	mov.l	2f, r0
+	bra	3f
+	  and	r0, \p1
+	.balign 4
+1:	.long STB7100_SYSCONF_DEVICEID_0
+2:	.long (STB7100_DEVID_ID_MASK << STB7100_DEVID_ID_SHIFT) | (STB7100_DEVID_CUT_MASK << STB7100_DEVID_CUT_SHIFT)
+3:
+#endif
+.endm
+
+/* Enable a single PMB entry
+Note: This macro will clobber both r0 and r1.
+Usage: SH4_SET_PMB <index> <virtual> <physical> <size> [<cache>=1 [<wt>=0 [<ub>=0]]]]
+where <index> is the PMB entry
+	<virtual> is the virtual page number	(required)
+	<physical> is the physical page number	(required)
+	<size> is the page size in MBytes	(required)
+	<cache> is optional and is the page cacheability (default: 1 [on])
+	<wt> is optional and is the page cache mode (default: 0 [copy-back])
+	<ub> is optional and is the page buffer mode (default: 0 [buffered]) */
+.macro SH4_SET_PMB i:req, vpn:req, ppn:req, size:req, cache=1, wt=0, ub=0
+	.set pmbdata, 0
+
+	.if (\size==16)		/* PMB[n].SZ */
+		.set pmbdata, pmbdata|0x00000000
+	.elseif (\size==64)
+		.set pmbdata, pmbdata|0x00000010
+	.elseif (\size==128)
+		.set pmbdata, pmbdata|0x00000080
+	.elseif (\size==512)
+		.set pmbdata, pmbdata|0x00000090
+	.else
+		.error "Unsupported page SIZE for a PMB entry"
+	.endif
+
+	.if (\cache)		/* PMB[n].C */
+		.set pmbdata, pmbdata|(SH4_PMB_C)
+	.endif
+
+	.if (\wt)		/* PMB[n].WT */
+		.set pmbdata, pmbdata|(SH4_PMB_WT)
+	.endif
+
+	.if (\ub)		/* PMB[n].UB */
+		.set pmbdata, pmbdata|(SH4_PMB_UB)
+	.endif
+
+	.if ( (\vpn<0x80) || (\vpn>=0xc0) )
+		.error "Invalid Virtual Page Number for PMB entry"
+	.endif
+
+	.if (\i>15)
+		.error "Invalid Index for PMB entry"
+	.endif
+
+		/* poke ADDR_ARRAY entry */
+	MOV_CONST32_R0	(\vpn<<24)
+	mov	r0,r1
+	MOV_CONST32_R0	(P4SEG_PMB_ADDR | (\i<<8))
+	mov.l	r1,@r0
+
+		/* poke DATA_ARRAY entry */
+	MOV_CONST32_R0	((\ppn<<24) | SH4_PMB_V | pmbdata)
+	mov	r0,r1
+	MOV_CONST32_R0	(P4SEG_PMB_DATA | (\i<<8))
+	mov.l	r1,@r0
+.endm
+
+/*
+ * Write out a series of bytes, monotonically increasing
+ * in value from "first" to "last" (inclusive).
+ *
+ * Usage:	BYTES <first> <last>
+ * where <first> is the first byte to generate
+ * where <last>  is the last byte to generate
+ *
+ * Note: this macro uses recursion (one level per byte)
+ */
+.macro BYTES first=0, last=63
+	.byte \first
+	.if \last-\first
+	BYTES "(\first+1)",\last	/* note: recursion */
+	.endif
+.endm
+
diff --git a/include/asm-sh/bitops.h b/include/asm-sh/bitops.h
new file mode 100644
index 0000000000..22b4b1f667
--- /dev/null
+++ b/include/asm-sh/bitops.h
@@ -0,0 +1,378 @@
+/*
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#ifndef __ASM_SH_BITOPS_H
+#define __ASM_SH_BITOPS_H
+
+#ifdef __KERNEL__
+#include <asm/system.h>
+/* For __swab32 */
+#include <asm/byteorder.h>
+
+static __inline__ void set_bit (int nr, volatile void *addr)
+{
+	int mask;
+	volatile unsigned int *a = addr;
+	unsigned long flags;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	save_and_cli (flags);
+	*a |= mask;
+	restore_flags (flags);
+}
+
+static __inline__ void __set_bit (int nr, volatile void *addr)
+{
+	int mask;
+	volatile unsigned int *a = addr;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	*a |= mask;
+}
+
+/*
+ * clear_bit() doesn't provide any barrier for the compiler.
+ */
+#define smp_mb__before_clear_bit()	barrier()
+#define smp_mb__after_clear_bit()	barrier()
+static __inline__ void clear_bit (int nr, volatile void *addr)
+{
+	int mask;
+	volatile unsigned int *a = addr;
+	unsigned long flags;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	save_and_cli (flags);
+	*a &= ~mask;
+	restore_flags (flags);
+}
+
+static __inline__ void __clear_bit (int nr, volatile void *addr)
+{
+	int mask;
+	volatile unsigned int *a = addr;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	*a &= ~mask;
+}
+
+static __inline__ void change_bit (int nr, volatile void *addr)
+{
+	int mask;
+	volatile unsigned int *a = addr;
+	unsigned long flags;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	save_and_cli (flags);
+	*a ^= mask;
+	restore_flags (flags);
+}
+
+static __inline__ void __change_bit (int nr, volatile void *addr)
+{
+	int mask;
+	volatile unsigned int *a = addr;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	*a ^= mask;
+}
+
+static __inline__ int test_and_set_bit (int nr, volatile void *addr)
+{
+	int mask, retval;
+	volatile unsigned int *a = addr;
+	unsigned long flags;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	save_and_cli (flags);
+	retval = (mask & *a) != 0;
+	*a |= mask;
+	restore_flags (flags);
+
+	return retval;
+}
+
+static __inline__ int __test_and_set_bit (int nr, volatile void *addr)
+{
+	int mask, retval;
+	volatile unsigned int *a = addr;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	retval = (mask & *a) != 0;
+	*a |= mask;
+
+	return retval;
+}
+
+static __inline__ int test_and_clear_bit (int nr, volatile void *addr)
+{
+	int mask, retval;
+	volatile unsigned int *a = addr;
+	unsigned long flags;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	save_and_cli (flags);
+	retval = (mask & *a) != 0;
+	*a &= ~mask;
+	restore_flags (flags);
+
+	return retval;
+}
+
+static __inline__ int __test_and_clear_bit (int nr, volatile void *addr)
+{
+	int mask, retval;
+	volatile unsigned int *a = addr;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	retval = (mask & *a) != 0;
+	*a &= ~mask;
+
+	return retval;
+}
+
+static __inline__ int test_and_change_bit (int nr, volatile void *addr)
+{
+	int mask, retval;
+	volatile unsigned int *a = addr;
+	unsigned long flags;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	save_and_cli (flags);
+	retval = (mask & *a) != 0;
+	*a ^= mask;
+	restore_flags (flags);
+
+	return retval;
+}
+
+static __inline__ int __test_and_change_bit (int nr, volatile void *addr)
+{
+	int mask, retval;
+	volatile unsigned int *a = addr;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	retval = (mask & *a) != 0;
+	*a ^= mask;
+
+	return retval;
+}
+
+static __inline__ int test_bit (int nr, const volatile void *addr)
+{
+	return 1UL & (((const volatile unsigned int *) addr)[nr >> 5] >>
+		      (nr & 31));
+}
+
+static __inline__ unsigned long ffz (unsigned long word)
+{
+	unsigned long result;
+
+      __asm__ ("1:\n\t" "shlr	%1\n\t" "bt/s	1b\n\t" " add	#1, %0":"=r" (result),
+		 "=r"
+		 (word)
+      :	 "0" (~0L), "1" (word)
+      :	 "t");
+	return result;
+}
+
+static __inline__ int find_next_zero_bit (void *addr, int size, int offset)
+{
+	unsigned long *p = ((unsigned long *) addr) + (offset >> 5);
+	unsigned long result = offset & ~31UL;
+	unsigned long tmp;
+
+	if (offset >= size)
+		return size;
+	size -= result;
+	offset &= 31UL;
+	if (offset) {
+		tmp = *(p++);
+		tmp |= ~0UL >> (32 - offset);
+		if (size < 32)
+			goto found_first;
+		if (~tmp)
+			goto found_middle;
+		size -= 32;
+		result += 32;
+	}
+	while (size & ~31UL) {
+		if (~(tmp = *(p++)))
+			goto found_middle;
+		result += 32;
+		size -= 32;
+	}
+	if (!size)
+		return result;
+	tmp = *p;
+
+      found_first:
+	tmp |= ~0UL << size;
+      found_middle:
+	return result + ffz (tmp);
+}
+
+#define find_first_zero_bit(addr, size) \
+	find_next_zero_bit((addr), (size), 0)
+
+/*
+ * ffs: find first bit set. This is defined the same way as
+ * the libc and compiler builtin ffs routines, therefore
+ * differs in spirit from the above ffz (man ffs).
+ */
+
+#define ffs(x) generic_ffs(x)
+
+/*
+ * hweightN: returns the hamming weight (i.e. the number
+ * of bits set) of a N-bit word
+ */
+
+#define hweight32(x) generic_hweight32(x)
+#define hweight16(x) generic_hweight16(x)
+#define hweight8(x) generic_hweight8(x)
+
+#ifdef __LITTLE_ENDIAN__
+#define ext2_set_bit(nr, addr) test_and_set_bit((nr), (addr))
+#define ext2_clear_bit(nr, addr) test_and_clear_bit((nr), (addr))
+#define ext2_test_bit(nr, addr) test_bit((nr), (addr))
+#define ext2_find_first_zero_bit(addr, size) find_first_zero_bit((addr), (size))
+#define ext2_find_next_zero_bit(addr, size, offset) \
+		find_next_zero_bit((addr), (size), (offset))
+#else
+static __inline__ int ext2_set_bit (int nr, volatile void *addr)
+{
+	int mask, retval;
+	unsigned long flags;
+	volatile unsigned char *ADDR = (unsigned char *) addr;
+
+	ADDR += nr >> 3;
+	mask = 1 << (nr & 0x07);
+	save_and_cli (flags);
+	retval = (mask & *ADDR) != 0;
+	*ADDR |= mask;
+	restore_flags (flags);
+	return retval;
+}
+
+static __inline__ int ext2_clear_bit (int nr, volatile void *addr)
+{
+	int mask, retval;
+	unsigned long flags;
+	volatile unsigned char *ADDR = (unsigned char *) addr;
+
+	ADDR += nr >> 3;
+	mask = 1 << (nr & 0x07);
+	save_and_cli (flags);
+	retval = (mask & *ADDR) != 0;
+	*ADDR &= ~mask;
+	restore_flags (flags);
+	return retval;
+}
+
+static __inline__ int ext2_test_bit (int nr, const volatile void *addr)
+{
+	int mask;
+	const volatile unsigned char *ADDR = (const unsigned char *) addr;
+
+	ADDR += nr >> 3;
+	mask = 1 << (nr & 0x07);
+	return ((mask & *ADDR) != 0);
+}
+
+#define ext2_find_first_zero_bit(addr, size) \
+	ext2_find_next_zero_bit((addr), (size), 0)
+
+static __inline__ unsigned long ext2_find_next_zero_bit (void *addr,
+							 unsigned long size,
+							 unsigned long offset)
+{
+	unsigned long *p = ((unsigned long *) addr) + (offset >> 5);
+	unsigned long result = offset & ~31UL;
+	unsigned long tmp;
+
+	if (offset >= size)
+		return size;
+	size -= result;
+	offset &= 31UL;
+	if (offset) {
+		/* We hold the little endian value in tmp, but then the
+		 * shift is illegal. So we could keep a big endian value
+		 * in tmp, like this:
+		 *
+		 * tmp = __swab32(*(p++));
+		 * tmp |= ~0UL >> (32-offset);
+		 *
+		 * but this would decrease preformance, so we change the
+		 * shift:
+		 */
+		tmp = *(p++);
+		tmp |= __swab32 (~0UL >> (32 - offset));
+		if (size < 32)
+			goto found_first;
+		if (~tmp)
+			goto found_middle;
+		size -= 32;
+		result += 32;
+	}
+	while (size & ~31UL) {
+		if (~(tmp = *(p++)))
+			goto found_middle;
+		result += 32;
+		size -= 32;
+	}
+	if (!size)
+		return result;
+	tmp = *p;
+
+      found_first:
+	/* tmp is little endian, so we would have to swab the shift,
+	 * see above. But then we have to swab tmp below for ffz, so
+	 * we might as well do this here.
+	 */
+	return result + ffz (__swab32 (tmp) | (~0UL << size));
+      found_middle:
+	return result + ffz (__swab32 (tmp));
+}
+#endif
+
+/* Bitmap functions for the minix filesystem.  */
+#define minix_test_and_set_bit(nr,addr) test_and_set_bit(nr,addr)
+#define minix_set_bit(nr,addr) set_bit(nr,addr)
+#define minix_test_and_clear_bit(nr,addr) test_and_clear_bit(nr,addr)
+#define minix_test_bit(nr,addr) test_bit(nr,addr)
+#define minix_find_first_zero_bit(addr,size) find_first_zero_bit(addr,size)
+
+#endif /* __KERNEL__ */
+
+#endif /* __ASM_SH_BITOPS_H */
diff --git a/include/asm-sh/byteorder.h b/include/asm-sh/byteorder.h
new file mode 100644
index 0000000000..02ebca83be
--- /dev/null
+++ b/include/asm-sh/byteorder.h
@@ -0,0 +1,38 @@
+#ifndef __ASM_SH_BYTEORDER_H
+#define __ASM_SH_BYTEORDER_H
+
+/*
+ * Copyright (C) 1999  Niibe Yutaka
+ */
+
+#include <asm/types.h>
+
+static __inline__ __attribute__((const)) __u32 ___arch__swab32 (__u32 x)
+{
+      __asm__ ("swap.b	%0, %0\n\t" "swap.w %0, %0\n\t" "swap.b %0, %0":"=r" (x)
+      :	 "0" (x));
+	return x;
+}
+
+static __inline__ __attribute__((const)) __u16 ___arch__swab16 (__u16 x)
+{
+      __asm__ ("swap.b %0, %0":"=r" (x)
+      :	 "0" (x));
+	return x;
+}
+
+#define __arch__swab32(x) ___arch__swab32(x)
+#define __arch__swab16(x) ___arch__swab16(x)
+
+#if !defined(__STRICT_ANSI__) || defined(__KERNEL__)
+#  define __BYTEORDER_HAS_U64__
+#  define __SWAB_64_THRU_32__
+#endif
+
+#ifdef __LITTLE_ENDIAN__
+#include <linux/byteorder/little_endian.h>
+#else
+#include <linux/byteorder/big_endian.h>
+#endif
+
+#endif /* __ASM_SH_BYTEORDER_H */
diff --git a/include/asm-sh/cache.h b/include/asm-sh/cache.h
new file mode 100644
index 0000000000..dd269944d1
--- /dev/null
+++ b/include/asm-sh/cache.h
@@ -0,0 +1,46 @@
+/*
+ * include/asm-sh/cache.h
+ *
+ * Copyright 1999 (C) Niibe Yutaka
+ * Copyright 2005 (C) Andy Sturges
+ */
+
+#ifndef __ASM_SH_CACHE_H
+#define __ASM_SH_CACHE_H
+
+#define L1_CACHE_BYTES			32
+
+#define CACHE_IC_ADDRESS_ARRAY		0xf0000000
+#define CACHE_OC_ADDRESS_ARRAY		0xf4000000
+
+#if defined(CONFIG_CPU_SUBTYPE_SH4_1XX)		/* it's an SH4-100 */
+#	define DCACHE_WAY_INCR		(1 << 14)
+#	define DCACHE_ENTRY_SHIFT	5
+#	define DCACHE_ENTRY_MASK	0x3fe0
+#	define DCACHE_SETS		512
+#	define DCACHE_WAYS		1
+#	define DCACHE_LINESZ		L1_CACHE_BYTES
+#elif defined(CONFIG_CPU_SUBTYPE_SH4_2XX)	/* it's an SH4-200 */	\
+   || defined(CONFIG_CPU_SUBTYPE_SH4_3XX)	/* it's an SH4-300 */
+#	define DCACHE_SIZE		32768
+#	define DCACHE_WAY_INCR		(DCACHE_SIZE >> 1)
+#	define DCACHE_ENTRY_SHIFT	5
+#	define DCACHE_ENTRY_MASK	(DCACHE_WAY_INCR - (1 << 5))
+#	define DCACHE_SETS		(DCACHE_SIZE >> 6)
+#	define DCACHE_WAYS		2
+#	define DCACHE_LINESZ		L1_CACHE_BYTES
+#else
+#	error Unknown CPU
+#endif
+
+extern void sh_cache_set_op(unsigned long);
+extern void sh_cache_clear_op(unsigned long);
+
+extern void sh_flush_cache_all(void);
+extern void sh_disable_data_caches(void);
+extern void sh_enable_data_caches(void);
+
+/* following stores if the data caches currently on */
+extern int sh_data_caches_on;
+
+#endif /* __ASM_SH_CACHE_H */
diff --git a/include/asm-sh/clk.h b/include/asm-sh/clk.h
new file mode 100644
index 0000000000..0fbf721209
--- /dev/null
+++ b/include/asm-sh/clk.h
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2009 Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef __ASM_SH_CLK_H__
+#define __ASM_SH_CLK_H__
+
+static inline unsigned long get_peripheral_clk_rate(void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	const bd_t * const bd = gd->bd;
+
+	/* Return Peripheral Clock in Hz. */
+	return bd->bi_emifrq * 1000000;
+}
+
+static inline unsigned long get_tmu0_clk_rate(void)
+{
+
+	/* Return Clock in Hz. */
+	return get_peripheral_clk_rate();
+}
+
+#endif /* __ASM_SH_CLK_H__ */
diff --git a/include/asm-sh/ecc.h b/include/asm-sh/ecc.h
new file mode 100644
index 0000000000..014601c9df
--- /dev/null
+++ b/include/asm-sh/ecc.h
@@ -0,0 +1,168 @@
+/*
+ * Synopsis : Error Correction Codes (ECC) Algorithms.
+ *
+ * Copyright (c) 2008-2009 STMicroelectronics Limited.  All right reserved.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/* An ECC is a 3-byte code which can be used to detect and correct 1-bit
+ * errors (perhaps introduced by NAND flash defects) in a 128, 256, or
+ * 512-byte block of data.
+ *
+ * Features:
+ *   - Correction of any 1-bit error in the data.
+ *   - Detection of any 1-bit error in the ECC and whether the data is OK.
+ *   - Detection of any 2-bit error in the data.
+ *
+ * Limitations:
+ *   - CANNOT correct 2-bit errors.
+ *   - Results for 3-bit errors (or worse) are UNDEFINED.
+ *
+ * This algorithm is only intended for use with data corrupted by a NAND
+ * flash - in which anything more than a 1-bit error is highly unlikely.
+ *
+ * DO NOT attempt to use it where the data may be more seriously corrupted.
+ * The algorithm WILL NOT always correct serious defects and may even report
+ * that the data is good.
+ *
+ * Usage
+ * =====
+ *
+ * Writing flash:
+ *
+ *   1) Prepare the data.
+ *   2) Generate an ECC for each 128, 256, or 512 bytes.
+ *        ecc = ecc_gen (data, ECC_256)
+ *   3) Write both to flash.
+ *
+ * Reading flash:
+ *
+ *   1) Read both data and ECC from flash.
+ *   2) Generate a fresh ECC for the read data.
+ *        new_ecc = ecc_gen (read_data, ECC_256)
+ *   3) Compare the two ECCs and correct the data, if necessary.
+ *        ecc_correct (read_data, read_ecc, new_ecc, ECC_256)
+ *   4) Check the return code:
+ *        E_UN_CHK
+ *            Data cannot be used - too badly corrupted.
+ *        E_NO_CHK
+ *            All is well.
+ *        E_D1_CHK
+ *            Data has been corrected, but the flash block contains an error.
+ *        E_C1_CHK
+ *            Data is OK, but the flash block contains an error in the ECC.
+ *
+ * If a read error occurs then you may want to consider moving the data to
+ * another flash block. If the read error is in the ECC then don't forget
+ * to generate a correct ECC before rewriting.
+ *
+ * ECC Format
+ * ==========
+ *
+ * Basic Format:
+ *
+ *      		byte 0		byte 1		byte2
+ *
+ *      bit 0		LP0		LP8		LP16
+ *      bit 1		LP1		LP9		LP17
+ *      bit 2		LP2		LP10	`	CP0
+ *      bit 3		LP3		LP11		CP1
+ *      bit 4		LP4		LP12		CP2
+ *      bit 5		LP5		LP13		CP3
+ *      bit 6		LP6		LP14		CP4
+ *      bit 7		LP7		LP15		CP5
+ *
+ *      CP = Column parity
+ *      LP = Line parity
+ *
+ * ECC_128:
+ *
+ *      LP14-17 are not used. The unused bits are set to zero.
+ *
+ *      This format is designed to match the format used by the error
+ *      correcting EMI NAND Controller. It may NOT be compatible with other
+ *      128 byte ECCs.
+ *
+ * ECC_256:
+ *
+ *      LP16-17 are not used. The unused bits are set to zero.
+ *
+ * ECC_512:
+ *
+ *      All bits are used.
+ *
+ *      This format is NOT compatible with the 512 byte ECC used by OSPlus.
+ *      (At the time of writing, this can be resolved merely by inverting each
+ *      bit in the ECC, but this may not be the case in future.)
+ *
+ */
+
+#ifndef ECC_H
+#define ECC_H
+
+/* The ECC algorithms support three different data sizes. */
+enum ecc_size
+{
+  ECC_128 = 128,
+  ECC_256 = 256,
+  ECC_512 = 512
+};
+
+/* This type represents a 3-byte ECC. */
+typedef struct ecc
+{
+  unsigned char byte[3];
+} ecc_t;
+
+/* Return values from check function */
+enum ecc_check 
+{
+  E_UN_CHK = -1, /* uncorrectable error. */
+  E_NO_CHK = 0,  /* No Errors. */
+  E_D1_CHK = 1,  /* 1-bit data error. */
+  E_C1_CHK = 2   /* 1-bit code error. */
+};
+
+
+/* Generate 3 byte ECC code for ecc_size block p_data.
+   "p_data" is a pointer to the data and must be 4-byte aligned.
+   "size" gives length of "p_data" - one of enum ecc_size.
+ */
+extern ecc_t ecc_gen(
+	const unsigned char* p_data,
+	const enum ecc_size size);
+
+/* Detect and correct a 1 bit error in a 128, 256 or 512 byte block.
+   "p_data" is a pointer to the data.
+   "old_ecc" is the proper ECC for the data.
+   "new_ecc" is the ECC generated from the (possibly) corrupted data.
+   The size of the block is given in "size".
+
+   Returns whether the data needed correcting, or was not correctable.
+   If the result code is E_D1_CHK, then the data will have been modified.
+ */
+extern enum ecc_check ecc_correct(
+	unsigned char *p_data,
+	ecc_t old_ecc,
+	ecc_t new_ecc,
+	enum ecc_size size);
+
+#endif /* ifndef ECC_H */
+
diff --git a/include/asm-sh/errno.h b/include/asm-sh/errno.h
new file mode 100644
index 0000000000..aafc0e712b
--- /dev/null
+++ b/include/asm-sh/errno.h
@@ -0,0 +1,138 @@
+#ifndef _SH_ERRNO_H
+#define _SH_ERRNO_H
+
+#define	EPERM		 1	/* Operation not permitted */
+#define	ENOENT		 2	/* No such file or directory */
+#define	ESRCH		 3	/* No such process */
+#define	EINTR		 4	/* Interrupted system call */
+#define	EIO		 5	/* I/O error */
+#define	ENXIO		 6	/* No such device or address */
+#define	E2BIG		 7	/* Arg list too long */
+#define	ENOEXEC		 8	/* Exec format error */
+#define	EBADF		 9	/* Bad file number */
+#define	ECHILD		10	/* No child processes */
+#define	EAGAIN		11	/* Try again */
+#define	ENOMEM		12	/* Out of memory */
+#define	EACCES		13	/* Permission denied */
+#define	EFAULT		14	/* Bad address */
+#define	ENOTBLK		15	/* Block device required */
+#define	EBUSY		16	/* Device or resource busy */
+#define	EEXIST		17	/* File exists */
+#define	EXDEV		18	/* Cross-device link */
+#define	ENODEV		19	/* No such device */
+#define	ENOTDIR		20	/* Not a directory */
+#define	EISDIR		21	/* Is a directory */
+#define	EINVAL		22	/* Invalid argument */
+#define	ENFILE		23	/* File table overflow */
+#define	EMFILE		24	/* Too many open files */
+#define	ENOTTY		25	/* Not a typewriter */
+#define	ETXTBSY		26	/* Text file busy */
+#define	EFBIG		27	/* File too large */
+#define	ENOSPC		28	/* No space left on device */
+#define	ESPIPE		29	/* Illegal seek */
+#define	EROFS		30	/* Read-only file system */
+#define	EMLINK		31	/* Too many links */
+#define	EPIPE		32	/* Broken pipe */
+#define	EDOM		33	/* Math argument out of domain of func */
+#define	ERANGE		34	/* Math result not representable */
+#define	EDEADLK		35	/* Resource deadlock would occur */
+#define	ENAMETOOLONG	36	/* File name too long */
+#define	ENOLCK		37	/* No record locks available */
+#define	ENOSYS		38	/* Function not implemented */
+#define	ENOTEMPTY	39	/* Directory not empty */
+#define	ELOOP		40	/* Too many symbolic links encountered */
+#define	EWOULDBLOCK	EAGAIN	/* Operation would block */
+#define	ENOMSG		42	/* No message of desired type */
+#define	EIDRM		43	/* Identifier removed */
+#define	ECHRNG		44	/* Channel number out of range */
+#define	EL2NSYNC	45	/* Level 2 not synchronized */
+#define	EL3HLT		46	/* Level 3 halted */
+#define	EL3RST		47	/* Level 3 reset */
+#define	ELNRNG		48	/* Link number out of range */
+#define	EUNATCH		49	/* Protocol driver not attached */
+#define	ENOCSI		50	/* No CSI structure available */
+#define	EL2HLT		51	/* Level 2 halted */
+#define	EBADE		52	/* Invalid exchange */
+#define	EBADR		53	/* Invalid request descriptor */
+#define	EXFULL		54	/* Exchange full */
+#define	ENOANO		55	/* No anode */
+#define	EBADRQC		56	/* Invalid request code */
+#define	EBADSLT		57	/* Invalid slot */
+#define	EDEADLOCK	58	/* File locking deadlock error */
+#define	EBFONT		59	/* Bad font file format */
+#define	ENOSTR		60	/* Device not a stream */
+#define	ENODATA		61	/* No data available */
+#define	ETIME		62	/* Timer expired */
+#define	ENOSR		63	/* Out of streams resources */
+#define	ENONET		64	/* Machine is not on the network */
+#define	ENOPKG		65	/* Package not installed */
+#define	EREMOTE		66	/* Object is remote */
+#define	ENOLINK		67	/* Link has been severed */
+#define	EADV		68	/* Advertise error */
+#define	ESRMNT		69	/* Srmount error */
+#define	ECOMM		70	/* Communication error on send */
+#define	EPROTO		71	/* Protocol error */
+#define	EMULTIHOP	72	/* Multihop attempted */
+#define	EDOTDOT		73	/* RFS specific error */
+#define	EBADMSG		74	/* Not a data message */
+#define	EOVERFLOW	75	/* Value too large for defined data type */
+#define	ENOTUNIQ	76	/* Name not unique on network */
+#define	EBADFD		77	/* File descriptor in bad state */
+#define	EREMCHG		78	/* Remote address changed */
+#define	ELIBACC		79	/* Can not access a needed shared library */
+#define	ELIBBAD		80	/* Accessing a corrupted shared library */
+#define	ELIBSCN		81	/* .lib section in a.out corrupted */
+#define	ELIBMAX		82	/* Attempting to link in too many shared libraries */
+#define	ELIBEXEC	83	/* Cannot exec a shared library directly */
+#define	EILSEQ		84	/* Illegal byte sequence */
+#define	ERESTART	85	/* Interrupted system call should be restarted */
+#define	ESTRPIPE	86	/* Streams pipe error */
+#define	EUSERS		87	/* Too many users */
+#define	ENOTSOCK	88	/* Socket operation on non-socket */
+#define	EDESTADDRREQ	89	/* Destination address required */
+#define	EMSGSIZE	90	/* Message too long */
+#define	EPROTOTYPE	91	/* Protocol wrong type for socket */
+#define	ENOPROTOOPT	92	/* Protocol not available */
+#define	EPROTONOSUPPORT	93	/* Protocol not supported */
+#define	ESOCKTNOSUPPORT	94	/* Socket type not supported */
+#define	EOPNOTSUPP	95	/* Operation not supported on transport endpoint */
+#define	EPFNOSUPPORT	96	/* Protocol family not supported */
+#define	EAFNOSUPPORT	97	/* Address family not supported by protocol */
+#define	EADDRINUSE	98	/* Address already in use */
+#define	EADDRNOTAVAIL	99	/* Cannot assign requested address */
+#define	ENETDOWN	100	/* Network is down */
+#define	ENETUNREACH	101	/* Network is unreachable */
+#define	ENETRESET	102	/* Network dropped connection because of reset */
+#define	ECONNABORTED	103	/* Software caused connection abort */
+#define	ECONNRESET	104	/* Connection reset by peer */
+#define	ENOBUFS		105	/* No buffer space available */
+#define	EISCONN		106	/* Transport endpoint is already connected */
+#define	ENOTCONN	107	/* Transport endpoint is not connected */
+#define	ESHUTDOWN	108	/* Cannot send after transport endpoint shutdown */
+#define	ETOOMANYREFS	109	/* Too many references: cannot splice */
+#define	ETIMEDOUT	110	/* Connection timed out */
+#define	ECONNREFUSED	111	/* Connection refused */
+#define	EHOSTDOWN	112	/* Host is down */
+#define	EHOSTUNREACH	113	/* No route to host */
+#define	EALREADY	114	/* Operation already in progress */
+#define	EINPROGRESS	115	/* Operation now in progress */
+#define	ESTALE		116	/* Stale NFS file handle */
+#define	EUCLEAN		117	/* Structure needs cleaning */
+#define	ENOTNAM		118	/* Not a XENIX named type file */
+#define	ENAVAIL		119	/* No XENIX semaphores available */
+#define	EISNAM		120	/* Is a named type file */
+#define	EREMOTEIO	121	/* Remote I/O error */
+#define	EDQUOT		122	/* Quota exceeded */
+
+#define	ENOMEDIUM	123	/* No medium found */
+#define	EMEDIUMTYPE	124	/* Wrong medium type */
+
+/* Should never be seen by user programs */
+#define ERESTARTSYS	512
+#define ERESTARTNOINTR	513
+#define ERESTARTNOHAND	514	/* restart if no handler.. */
+#define ENOIOCTLCMD	515	/* No ioctl command */
+
+#define _LAST_ERRNO	515
+
+#endif
diff --git a/include/asm-sh/global_data.h b/include/asm-sh/global_data.h
new file mode 100644
index 0000000000..4f10e7f5bd
--- /dev/null
+++ b/include/asm-sh/global_data.h
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2002-2003
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef	__ASM_GBL_DATA_H
+#define __ASM_GBL_DATA_H
+
+
+/*
+ * The following data structure is placed in some memory wich is
+ * available very early after boot (like DPRAM on MPC8xx/MPC82xx, or
+ * some locked parts of the data cache) to allow for a minimum set of
+ * global variables during system initialization (until we have set
+ * up the memory controller so that we can use RAM).
+ *
+ * Keep it *SMALL* and remember to set CFG_GBL_DATA_SIZE > sizeof(gd_t)
+ */
+
+typedef struct global_data
+{
+	bd_t *bd;
+	unsigned long flags;
+	unsigned long baudrate;
+	unsigned long have_console;	/* serial_init() was called */
+	unsigned long ram_size;	/* RAM size */
+	unsigned long reloc_off;	/* Relocation Offset */
+	unsigned long env_addr;	/* Address  of Environment struct */
+	unsigned long env_valid;	/* Checksum of Environment valid? */
+	void **jt;		/* jump table */
+} gd_t;
+
+/*
+ * Global Data Flags
+ */
+
+#define	GD_FLG_RELOC	0x00001	/* Code was relocated to RAM     */
+#define	GD_FLG_DEVINIT	0x00002	/* Devices have been initialized */
+#define	GD_FLG_SILENT	0x00004	/* Silent mode                   */
+
+register volatile gd_t *gd asm ("r13");	/* declare this in all files     */
+
+#define DECLARE_GLOBAL_DATA_PTR
+
+#endif /* __ASM_GBL_DATA_H */
diff --git a/include/asm-sh/io.h b/include/asm-sh/io.h
new file mode 100644
index 0000000000..76821eae91
--- /dev/null
+++ b/include/asm-sh/io.h
@@ -0,0 +1,415 @@
+#ifndef __ASM_SH_IO_H
+#define __ASM_SH_IO_H
+
+/*
+ * Convention:
+ *    read{b,w,l}/write{b,w,l} are for PCI,
+ *    while in{b,w,l}/out{b,w,l} are for ISA
+ * These may (will) be platform specific function.
+ * In addition we have 'pausing' versions: in{b,w,l}_p/out{b,w,l}_p
+ * and 'string' versions: ins{b,w,l}/outs{b,w,l}
+ * For read{b,w,l} and write{b,w,l} there are also __raw versions, which
+ * do not have a memory barrier after them.
+ *
+ * In addition, we have
+ *   ctrl_in{b,w,l}/ctrl_out{b,w,l} for SuperH specific I/O.
+ *   which are processor specific.
+ */
+
+/*
+ * We follow the Alpha convention here:
+ *  __inb expands to an inline function call (which either calls via the
+ *        mach_vec if generic, or a machine specific implementation)
+ *  _inb  is a real function call (note ___raw fns are _ version of __raw)
+ *  inb   by default expands to _inb, but the machine specific code may
+ *        define it to __inb if it chooses.
+ */
+
+#include "common.h"
+
+#include "asm/cache.h"
+#include "asm/system.h"
+#include "linux/config.h"
+
+/*
+ * Depending on which platform we are running on, we need different
+ * I/O functions.
+ */
+
+/* Control operations through platform specific headers */
+
+#ifdef __KERNEL__
+
+#define _readb(addr) (*(volatile unsigned char *)(addr))
+#define _readw(addr) (*(volatile unsigned short *)(addr))
+#define _readl(addr) (*(volatile unsigned int *)(addr))
+
+#define _writeb(b,addr) (*(volatile unsigned char *)(addr) = (b))
+#define _writew(b,addr) (*(volatile unsigned short *)(addr) = (b))
+#define _writel(b,addr) (*(volatile unsigned int *)(addr) = (b))
+
+#define __WANT_IO_DEF
+
+#if defined(CONFIG_SH_MB411)		|| \
+       defined(CONFIG_SH_MB442)		|| \
+       defined(CONFIG_SH_MB448)		|| \
+       defined(CONFIG_SH_HMS1)		|| \
+       defined(CONFIG_SH_MB519)		|| \
+       defined(CONFIG_SH_MB618)		|| \
+       defined(CONFIG_SH_HDK7111)	|| \
+       defined(CONFIG_SH_MB628)		|| \
+       defined(CONFIG_SH_MB671)		|| \
+       defined(CONFIG_SH_MB680)		|| \
+       defined(CONFIG_SH_PDK7105)	|| \
+       defined(CONFIG_SH_IPIDTV7105)	|| \
+       defined(CONFIG_SH_MB704)		|| \
+       defined(CONFIG_SH_5197CAB)	|| \
+       defined(CONFIG_SH_CB101)		|| \
+       defined(CONFIG_SH_CB102)
+#  include "asm/io_stb1eval.h"
+#else
+#  error "What system is this?"
+#endif
+
+#undef __WANT_IO_DEF
+
+#endif /* __KERNEL__ */
+
+/* These are always function calls, in both kernel and user space */
+
+static __inline__ unsigned char _inb (unsigned long addr)
+{
+	return *(volatile unsigned char *) addr;
+}
+
+static __inline__ unsigned short _inw (unsigned long addr)
+{
+	return *(volatile unsigned short *) addr;
+}
+
+static __inline__ unsigned int _inl (unsigned long addr)
+{
+	return *(volatile unsigned long *) addr;
+}
+
+static __inline__ void _outb (unsigned char b, unsigned long addr)
+{
+	*(volatile unsigned char *) addr = b;
+}
+
+static __inline__ void _outw (unsigned short b, unsigned long addr)
+{
+	*(volatile unsigned short *) addr = b;
+}
+
+static __inline__ void _outl (unsigned int b, unsigned long addr)
+{
+	*(volatile unsigned long *) addr = b;
+}
+
+extern void _insb (unsigned long port, void *dst, unsigned long count);
+extern void _insw (unsigned long port, void *dst, unsigned long count);
+extern void _insl (unsigned long port, void *dst, unsigned long count);
+extern void _outsb (unsigned long port, const void *src, unsigned long count);
+extern void _outsw (unsigned long port, const void *src, unsigned long count);
+extern void _outsl (unsigned long port, const void *src, unsigned long count);
+
+#ifdef __KERNEL__
+extern unsigned char ___raw_readb (unsigned long addr);
+extern unsigned short ___raw_readw (unsigned long addr);
+extern unsigned int ___raw_readl (unsigned long addr);
+extern void ___raw_writeb (unsigned char b, unsigned long addr);
+extern void ___raw_writew (unsigned short b, unsigned long addr);
+extern void ___raw_writel (unsigned int b, unsigned long addr);
+#endif
+
+#ifdef __KERNEL__
+/*
+ * The platform header files may define some of these macros to use
+ * the inlined versions where appropriate.  These macros may also be
+ * redefined by userlevel programs.
+ */
+#ifndef inb
+# define inb(p)		_inb(p)
+#endif
+#ifndef inw
+# define inw(p)		_inw(p)
+#endif
+#ifndef inl
+# define inl(p)		_inl(p)
+#endif
+
+#ifndef outb
+# define outb(b,p)	_outb((b),(p))
+#endif
+#ifndef outw
+# define outw(w,p)	_outw((w),(p))
+#endif
+#ifndef outl
+# define outl(l,p)	_outl((l),(p))
+#endif
+
+#ifndef inb_p
+# define inb_p		_inb_p
+#endif
+#ifndef inw_p
+# define inw_p		_inw_p
+#endif
+#ifndef inl_p
+# define inl_p		_inl_p
+#endif
+
+#ifndef outb_p
+# define outb_p		_outb_p
+#endif
+#ifndef outw_p
+# define outw_p		_outw_p
+#endif
+#ifndef outl_p
+# define outl_p		_outl_p
+#endif
+
+#ifndef insb
+# define insb(p,d,c)	_insb((p),(d),(c))
+#endif
+#ifndef insw
+# define insw(p,d,c)	_insw((p),(d),(c))
+#endif
+#ifndef insl
+# define insl(p,d,c)	_insl((p),(d),(c))
+#endif
+#ifndef outsb
+# define outsb(p,s,c)	_outsb((p),(s),(c))
+#endif
+#ifndef outsw
+# define outsw(p,s,c)	_outsw((p),(s),(c))
+#endif
+#ifndef outsl
+# define outsl(p,s,c)	_outsl((p),(s),(c))
+#endif
+
+#ifdef __raw_readb
+# define readb(a)	({ unsigned long r_ = __raw_readb(a); mb(); r_; })
+#endif
+#ifdef __raw_readw
+# define readw(a)	({ unsigned long r_ = __raw_readw(a); mb(); r_; })
+#endif
+#ifdef __raw_readl
+# define readl(a)	({ unsigned long r_ = __raw_readl(a); mb(); r_; })
+#endif
+
+#ifdef __raw_writeb
+# define writeb(v,a)	({ __raw_writeb((v),(a)); mb(); })
+#endif
+#ifdef __raw_writew
+# define writew(v,a)	({ __raw_writew((v),(a)); mb(); })
+#endif
+#ifdef __raw_writel
+# define writel(v,a)	({ __raw_writel((v),(a)); mb(); })
+#endif
+
+#ifndef __raw_readb
+# define __raw_readb(a)	___raw_readb((unsigned long)(a))
+#endif
+#ifndef __raw_readw
+# define __raw_readw(a)	___raw_readw((unsigned long)(a))
+#endif
+#ifndef __raw_readl
+# define __raw_readl(a)	___raw_readl((unsigned long)(a))
+#endif
+
+#ifndef __raw_writeb
+# define __raw_writeb(v,a)  ___raw_writeb((v),(unsigned long)(a))
+#endif
+#ifndef __raw_writew
+# define __raw_writew(v,a)  ___raw_writew((v),(unsigned long)(a))
+#endif
+#ifndef __raw_writel
+# define __raw_writel(v,a)  ___raw_writel((v),(unsigned long)(a))
+#endif
+
+#ifndef readb
+# define readb(a)	_readb((unsigned long)(a))
+#endif
+#ifndef readw
+# define readw(a)	_readw((unsigned long)(a))
+#endif
+#ifndef readl
+# define readl(a)	_readl((unsigned long)(a))
+#endif
+
+#ifndef writeb
+# define writeb(v,a)	_writeb((v),(unsigned long)(a))
+#endif
+#ifndef writew
+# define writew(v,a)	_writew((v),(unsigned long)(a))
+#endif
+#ifndef writel
+# define writel(v,a)	_writel((v),(unsigned long)(a))
+#endif
+
+#else
+
+/* Userspace declarations.  */
+
+extern unsigned char inb (unsigned long port);
+extern unsigned short inw (unsigned long port);
+extern unsigned int inl (unsigned long port);
+extern void outb (unsigned char b, unsigned long port);
+extern void outw (unsigned short w, unsigned long port);
+extern void outl (unsigned int l, unsigned long port);
+extern void insb (unsigned long port, void *dst, unsigned long count);
+extern void insw (unsigned long port, void *dst, unsigned long count);
+extern void insl (unsigned long port, void *dst, unsigned long count);
+extern void outsb (unsigned long port, const void *src, unsigned long count);
+extern void outsw (unsigned long port, const void *src, unsigned long count);
+extern void outsl (unsigned long port, const void *src, unsigned long count);
+extern unsigned char readb (unsigned long addr);
+extern unsigned short readw (unsigned long addr);
+extern unsigned long readl (unsigned long addr);
+extern void writeb (unsigned char b, unsigned long addr);
+extern void writew (unsigned short b, unsigned long addr);
+extern void writel (unsigned int b, unsigned long addr);
+
+#endif /* __KERNEL__ */
+
+#ifdef __KERNEL__
+
+/*
+ * If the platform has PC-like I/O, this function converts the offset into
+ * an address.
+ */
+static __inline__ unsigned long isa_port2addr (unsigned long offset)
+{
+	return __isa_port2addr (offset);
+}
+
+#define isa_readb(a) readb(isa_port2addr(a))
+#define isa_readw(a) readw(isa_port2addr(a))
+#define isa_readl(a) readl(isa_port2addr(a))
+#define isa_writeb(b,a) writeb(b,isa_port2addr(a))
+#define isa_writew(w,a) writew(w,isa_port2addr(a))
+#define isa_writel(l,a) writel(l,isa_port2addr(a))
+#define isa_memset_io(a,b,c) \
+  memset((void *)(isa_port2addr((unsigned long)a)),(b),(c))
+#define isa_memcpy_fromio(a,b,c) \
+  memcpy((a),(void *)(isa_port2addr((unsigned long)(b))),(c))
+#define isa_memcpy_toio(a,b,c) \
+  memcpy((void *)(isa_port2addr((unsigned long)(a))),(b),(c))
+
+/* We really want to try and get these to memcpy etc */
+extern void memcpy_fromio (void *, unsigned long, unsigned long);
+extern void memcpy_toio (unsigned long, const void *, unsigned long);
+extern void memset_io (unsigned long, int, unsigned long);
+
+static __inline__ unsigned char ctrl_inb (unsigned long addr)
+{
+	return *(volatile unsigned char *) addr;
+}
+
+static __inline__ unsigned short ctrl_inw (unsigned long addr)
+{
+	return *(volatile unsigned short *) addr;
+}
+
+static __inline__ unsigned int ctrl_inl (unsigned long addr)
+{
+	return *(volatile unsigned long *) addr;
+}
+
+static __inline__ void ctrl_outb (unsigned char b, unsigned long addr)
+{
+	*(volatile unsigned char *) addr = b;
+}
+
+static __inline__ void ctrl_outw (unsigned short b, unsigned long addr)
+{
+	*(volatile unsigned short *) addr = b;
+}
+
+static __inline__ void ctrl_outl (unsigned int b, unsigned long addr)
+{
+	*(volatile unsigned long *) addr = b;
+}
+
+
+#define IO_SPACE_LIMIT 0xffffffff
+
+/*
+ * readX/writeX() are used to access memory mapped devices. On some
+ * architectures the memory mapped IO stuff needs to be accessed
+ * differently. On the x86 architecture, we just read/write the
+ * memory location directly.
+ *
+ * On SH, we have the whole physical address space mapped at all times
+ * (as MIPS does), so "ioremap()" and "iounmap()" do not need to do
+ * anything.  (This isn't true for all machines but we still handle
+ * these cases with wired TLB entries anyway ...)
+ *
+ * We cheat a bit and always return uncachable areas until we've fixed
+ * the drivers to handle caching properly.
+ */
+static __inline__ void *ioremap (unsigned long offset, unsigned long size)
+{
+	return __ioremap (offset, size);
+}
+
+static __inline__ void iounmap (void *addr)
+{
+	return __iounmap (addr);
+}
+
+#define ioremap_nocache(off,size) ioremap(off,size)
+
+static __inline__ int check_signature (unsigned long io_addr,
+				       const unsigned char *signature,
+				       int length)
+{
+	int retval = 0;
+	do {
+		if (readb (io_addr) != *signature)
+			goto out;
+		io_addr++;
+		signature++;
+		length--;
+	} while (length);
+	retval = 1;
+      out:
+	return retval;
+}
+
+/*
+ * The caches on some architectures aren't dma-coherent and have need to
+ * handle this in software.  There are three types of operations that
+ * can be applied to dma buffers.
+ *
+ *  - dma_cache_wback_inv(start, size) makes caches and RAM coherent by
+ *    writing the content of the caches back to memory, if necessary.
+ *    The function also invalidates the affected part of the caches as
+ *    necessary before DMA transfers from outside to memory.
+ *  - dma_cache_inv(start, size) invalidates the affected parts of the
+ *    caches.  Dirty lines of the caches may be written back or simply
+ *    be discarded.  This operation is necessary before dma operations
+ *    to the memory.
+ *  - dma_cache_wback(start, size) writes back any dirty lines but does
+ *    not invalidate the cache.  This can be used before DMA reads from
+ *    memory,
+ */
+
+#define dma_cache_wback_inv(_start,_size) \
+    __flush_purge_region(_start,_size)
+#define dma_cache_inv(_start,_size) \
+    __flush_invalidate_region(_start,_size)
+#define dma_cache_wback(_start,_size) \
+    __flush_wback_region(_start,_size)
+
+static inline void sync(void)
+{
+	/* do nothing */
+	/* Note: may need to include a "synco" instruction here, if we
+	 * have silicon with agressive write-combiners on the SH4-300
+	 * series cores in the future */
+}
+
+#endif /* __KERNEL__ */
+#endif /* __ASM_SH_IO_H */
diff --git a/include/asm-sh/io_generic.h b/include/asm-sh/io_generic.h
new file mode 100644
index 0000000000..cfea623d02
--- /dev/null
+++ b/include/asm-sh/io_generic.h
@@ -0,0 +1,57 @@
+/*
+ * include/asm-sh/io_generic.h
+ *
+ * Copyright 2000 Stuart Menefy (stuart.menefy@st.com)
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Generic IO functions
+ */
+
+#ifndef _ASM_SH_IO_GENERIC_H
+#define _ASM_SH_IO_GENERIC_H
+
+extern unsigned long generic_io_base;
+
+extern unsigned char generic_inb (unsigned long port);
+extern unsigned short generic_inw (unsigned long port);
+extern unsigned int generic_inl (unsigned long port);
+
+extern void generic_outb (unsigned char value, unsigned long port);
+extern void generic_outw (unsigned short value, unsigned long port);
+extern void generic_outl (unsigned int value, unsigned long port);
+
+extern unsigned char generic_inb_p (unsigned long port);
+extern unsigned short generic_inw_p (unsigned long port);
+extern unsigned int generic_inl_p (unsigned long port);
+extern void generic_outb_p (unsigned char value, unsigned long port);
+extern void generic_outw_p (unsigned short value, unsigned long port);
+extern void generic_outl_p (unsigned int value, unsigned long port);
+
+extern void generic_insb (unsigned long port, void *addr,
+			  unsigned long count);
+extern void generic_insw (unsigned long port, void *addr,
+			  unsigned long count);
+extern void generic_insl (unsigned long port, void *addr,
+			  unsigned long count);
+extern void generic_outsb (unsigned long port, const void *addr,
+			   unsigned long count);
+extern void generic_outsw (unsigned long port, const void *addr,
+			   unsigned long count);
+extern void generic_outsl (unsigned long port, const void *addr,
+			   unsigned long count);
+
+extern unsigned char generic_readb (unsigned long addr);
+extern unsigned short generic_readw (unsigned long addr);
+extern unsigned int generic_readl (unsigned long addr);
+extern void generic_writeb (unsigned char b, unsigned long addr);
+extern void generic_writew (unsigned short b, unsigned long addr);
+extern void generic_writel (unsigned int b, unsigned long addr);
+
+extern void *generic_ioremap (unsigned long offset, unsigned long size);
+extern void generic_iounmap (void *addr);
+
+extern unsigned long generic_isa_port2addr (unsigned long offset);
+
+#endif /* _ASM_SH_IO_GENERIC_H */
diff --git a/include/asm-sh/io_stb1eval.h b/include/asm-sh/io_stb1eval.h
new file mode 100644
index 0000000000..4d5b7234ff
--- /dev/null
+++ b/include/asm-sh/io_stb1eval.h
@@ -0,0 +1,89 @@
+ /*
+  * include/asm-sh/io_stb1eval.h
+  *
+  * Copyright 2001 Stuart Menefy (stuart.menefy@st.com)
+  *
+  * May be copied or modified under the terms of the GNU General Public
+  * License.  See linux/COPYING for more information.
+  *
+  * IO functions for the ST40STB1 Eval board
+  */
+
+#ifndef _ASM_SH_IO_STB1EVAL_H
+#define _ASM_SH_IO_STB1EVAL_H
+
+#include <asm/io_generic.h>
+
+extern unsigned long stb1eval_isa_port2addr (unsigned long offset);
+
+#ifdef __WANT_IO_DEF
+# define __inb			generic_inb
+# define __inw			generic_inw
+# define __inl			generic_inl
+# define __outb			generic_outb
+# define __outw			generic_outw
+# define __outl			generic_outl
+
+# define __inb_p		generic_inb_p
+# define __inw_p		generic_inw
+# define __inl_p		generic_inl
+# define __outb_p		generic_outb_p
+# define __outw_p		generic_outw
+# define __outl_p		generic_outl
+
+# define __insb			generic_insb
+# define __insw			generic_insw
+# define __insl			generic_insl
+# define __outsb		generic_outsb
+# define __outsw		generic_outsw
+# define __outsl		generic_outsl
+
+# define __readb		generic_readb
+# define __readw		generic_readw
+# define __readl		generic_readl
+# define __writeb		generic_writeb
+# define __writew		generic_writew
+# define __writel		generic_writel
+
+# define __isa_port2addr	stb1eval_isa_port2addr
+# define __ioremap		generic_ioremap
+# define __iounmap		generic_iounmap
+#endif
+
+static __inline__ unsigned long p4_inb (unsigned long addr)
+{
+	return *(volatile unsigned char *) addr;
+}
+
+static __inline__ unsigned long p4_inw (unsigned long addr)
+{
+	return *(volatile unsigned short *) addr;
+}
+
+static __inline__ unsigned long p4_inl (unsigned long addr)
+{
+	return *(volatile unsigned long *) addr;
+}
+
+static __inline__ void p4_outb (unsigned long addr, unsigned short b)
+{
+	*(volatile unsigned char *) addr = b;
+}
+
+static __inline__ void p4_outw (unsigned long addr, unsigned short b)
+{
+	*(volatile unsigned short *) addr = b;
+}
+
+static __inline__ void p4_outl (unsigned long addr, unsigned int b)
+{
+	*(volatile unsigned long *) addr = b;
+}
+
+#define p4_in(addr)	*(addr)
+#define p4_out(addr,data) *(addr) = (data)
+
+#define p2_inl	p4_inl
+#define p2_outl	p4_outl
+
+#endif /* _ASM_SH_IO_STB1EVAL_H */
diff --git a/include/asm-sh/linkage.h b/include/asm-sh/linkage.h
new file mode 100644
index 0000000000..749adc2435
--- /dev/null
+++ b/include/asm-sh/linkage.h
@@ -0,0 +1,14 @@
+#ifndef _LINUX_LINKAGE_H
+#define _LINUX_LINKAGE_H
+
+#define SYMBOL_NAME(name) name
+#define SYMBOL_NAME_LABEL(name) name ## :
+
+#define ALIGN .balign 4
+
+#define ENTRY(name) \
+  .globl SYMBOL_NAME(name); \
+  ALIGN; \
+  SYMBOL_NAME_LABEL(name)
+
+#endif
diff --git a/include/asm-sh/pio.h b/include/asm-sh/pio.h
new file mode 100644
index 0000000000..f92d4f7ffc
--- /dev/null
+++ b/include/asm-sh/pio.h
@@ -0,0 +1,116 @@
+/*
+ * (C) Copyright STMicroelectronics 2005, 2008, 2009
+ * Andy Stugres, <andy.sturges@st.com>
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _PIO_H_
+#define _PIO_H_	1
+
+#define STPIO_NONPIO		0	/* Non-PIO function (ST40 defn) */
+#define STPIO_BIDIR_Z1		0	/* Input weak pull-up (arch defn) */
+#define STPIO_BIDIR		1	/* Bidirectonal open-drain */
+#define STPIO_OUT		2	/* Output push-pull */
+/*efine STPIO_BIDIR		3	* Bidirectional open drain */
+#define STPIO_IN		4	/* Input Hi-Z */
+/*efine STPIO_IN		5	* Input Hi-Z */
+#define STPIO_ALT_OUT		6	/* Alt output push-pull (arch defn) */
+#define STPIO_ALT_BIDIR		7	/* Alt bidir open drain (arch defn) */
+
+#define STPIO_POUT_OFFSET	0x00
+#define STPIO_PIN_OFFSET	0x10
+#define STPIO_PC0_OFFSET	0x20
+#define STPIO_PC1_OFFSET	0x30
+#define STPIO_PC2_OFFSET	0x40
+#define STPIO_PCOMP_OFFSET	0x50
+#define STPIO_PMASK_OFFSET	0x60
+
+#define STPIO_SET_OFFSET	0x4
+#define STPIO_CLEAR_OFFSET	0x8
+
+#if defined(CONFIG_SH_STB7100)
+#define PIO_PORT_SIZE		0x1000					/* QQQ - DELETE */
+#define PIO_PORT(n)		( ((n)*PIO_PORT_SIZE) + PIO_BASE)	/* QQQ - DELETE */
+#else	/* CONFIG_SH_STB7100 */
+#define PIO_PORT(n)		( ST40_PIO ## n ## _REGS_BASE )
+#endif	/* CONFIG_SH_STB7100 */
+
+#define PIN_C0(PIN, DIR)	((((DIR) & 0x1)!=0) << (PIN))
+#define PIN_C1(PIN, DIR)	((((DIR) & 0x2)!=0) << (PIN))
+#define PIN_C2(PIN, DIR)	((((DIR) & 0x4)!=0) << (PIN))
+
+#define CLEAR_PIN_C0(PIN, DIR)	((((DIR) & 0x1)==0) << (PIN))
+#define CLEAR_PIN_C1(PIN, DIR)	((((DIR) & 0x2)==0) << (PIN))
+#define CLEAR_PIN_C2(PIN, DIR)	((((DIR) & 0x4)==0) << (PIN))
+
+#define SET_PIO_PIN(PIO_ADDR, PIN, DIR)					\
+do {									\
+	writel(	PIN_C0((PIN),(DIR)),					\
+		(PIO_ADDR)+STPIO_PC0_OFFSET+STPIO_SET_OFFSET);		\
+	writel(	PIN_C1((PIN),(DIR)),					\
+		(PIO_ADDR)+STPIO_PC1_OFFSET+STPIO_SET_OFFSET);		\
+	writel(	PIN_C2((PIN),(DIR)),					\
+		(PIO_ADDR)+STPIO_PC2_OFFSET+STPIO_SET_OFFSET);		\
+	writel(	CLEAR_PIN_C0((PIN),(DIR)),				\
+		(PIO_ADDR)+STPIO_PC0_OFFSET+STPIO_CLEAR_OFFSET);	\
+	writel(	CLEAR_PIN_C1((PIN),(DIR)),				\
+		(PIO_ADDR)+STPIO_PC1_OFFSET+STPIO_CLEAR_OFFSET);	\
+	writel(	CLEAR_PIN_C2((PIN),(DIR)),				\
+		(PIO_ADDR)+STPIO_PC2_OFFSET+STPIO_CLEAR_OFFSET);	\
+} while (0)
+
+#define STPIO_SET_PIN(PIO_ADDR, PIN, V)				\
+do {								\
+	writel(	1<<(PIN),					\
+		(PIO_ADDR) + STPIO_POUT_OFFSET +		\
+		((V)? STPIO_SET_OFFSET : STPIO_CLEAR_OFFSET));	\
+} while (0)
+#define STPIO_GET_PIN(PIO_ADDR, PIN)				\
+	((readl((PIO_ADDR)+STPIO_PIN_OFFSET)>>(PIN))&0x01)
+
+#define SET_PIO_ASC_OUTDIR(PIO_ADDR, TX, RX, CTS, RTS, OUTDIR)	\
+do {								\
+	writel(	PIN_C0((TX),  (OUTDIR))		|		\
+		PIN_C0((RX),  STPIO_IN)		|		\
+		PIN_C0((CTS), STPIO_IN)		|		\
+		PIN_C0((RTS), (OUTDIR)),			\
+		(PIO_ADDR)+STPIO_PC0_OFFSET+STPIO_SET_OFFSET);	\
+	writel(	PIN_C1((TX),  (OUTDIR))		|		\
+		PIN_C1((RX),  STPIO_IN)		|		\
+		PIN_C1((CTS), STPIO_IN)		|		\
+		PIN_C1((RTS), (OUTDIR)),			\
+		(PIO_ADDR)+STPIO_PC1_OFFSET+STPIO_SET_OFFSET);	\
+	writel(	PIN_C2((TX),  (OUTDIR))		|		\
+		PIN_C2((RX),  STPIO_IN)		|		\
+		PIN_C2((CTS), STPIO_IN)		|		\
+		PIN_C2((RTS), (OUTDIR)),			\
+		(PIO_ADDR)+STPIO_PC2_OFFSET+STPIO_SET_OFFSET);	\
+} while (0)
+
+#if defined(CONFIG_SH_STX7141)
+#define SET_PIO_ASC(PIO_ADDR, TX, RX, CTS, RTS)			\
+	SET_PIO_ASC_OUTDIR((PIO_ADDR), (TX), (RX), (CTS), (RTS), STPIO_OUT)
+#else	/* CONFIG_SH_STX7141 */
+#define SET_PIO_ASC(PIO_ADDR, TX, RX, CTS, RTS)			\
+	SET_PIO_ASC_OUTDIR((PIO_ADDR), (TX), (RX), (CTS), (RTS), STPIO_ALT_OUT)
+#endif	/* CONFIG_SH_STX7141 */
+
+#endif
diff --git a/include/asm-sh/pmb.h b/include/asm-sh/pmb.h
new file mode 100644
index 0000000000..a5e3069c30
--- /dev/null
+++ b/include/asm-sh/pmb.h
@@ -0,0 +1,78 @@
+/*
+ * (C) Copyright 2008 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#ifndef _PMB_H_
+#define _PMB_H_
+
+	/*
+	 * The PMB contains 16 entries, and supports the following
+	 * 4 page sizes: 16MB, 64MB, 128MB, and 512MB.
+	 *
+	 * Although the PMB has a total of 16 entries, but we will
+	 * pretend that there are only 14, by grouping #0 and #1
+	 * logically together, we will also group #2 and #3 logically
+	 * together. Each of these two new groups will be used to map
+	 * up to 256MB of main memory (LMI0). One group ([2:3]) will
+	 * always map main memory as UN-cached. The other group ([0:1])
+	 * will usually be cached, but will sometimes be un-cached for
+	 * special needs. Both the new groups will reference the *same*
+	 * physical memory, and hence they are virtual aliases for each other.
+	 *
+	 * Thus, PMB[0:1] is used as main memory (LMI), and will mostly
+	 * be used as cached, except on initialization, and when passing
+	 * control to the linux kernel, where it will be un-cached.
+	 * The cacheability of PMB[0:1] may be toggled by calling
+	 * the function sh_toggle_pmb_cacheability().
+	 *
+	 * PMB[2:3] is an alias for PMB[0:1], except it is guaranteed
+	 * to always be UN-cached.
+	 *
+	 * PMB[0:1]  will map 0x80000000 .. 0x8fffffff.	(256MB)
+	 * PMB[2:3]  will map 0x90000000 .. 0x9fffffff.	(256MB)
+	 * PMB[4:15] will map 0xa0000000 .. 0xbfffffff.	(512MB)
+	 *
+	 * If sizeof(LMI) <= 128MB, then PMB[1] and PMB[3] are *unused*,
+	 * i.e. PMB[1].V == PMB[3].V == 0.
+	 *
+	 * Note: PMB[0:3] should all be initialized as UN-cached,
+	 * and then sh_toggle_pmb_cacheability() should be called
+	 * to enable the caching of PMB[0:1].
+	 */
+
+	 /*
+	 * If the main LMI memory is 256MB, then we need to have
+	 * two PMB entries to represent this amount of memory.
+	 * The following predicate will yield TRUE if U-boot
+	 * requires 2 PMB entries (#0, and #1) for main memory
+	 * (plus two more (#2 and #3) for its un-cached alias),
+	 * and FALSE if only a single entry (#0) is required
+	 * (plus one more (#2) for its un-cached alias).
+	 */
+#define CFG_SH_LMI_NEEDS_2_PMB_ENTRIES	\
+	( (CFG_SDRAM_SIZE) > (128*1024*1024) )
+
+
+#endif	/* _PMB_H_ */
+
diff --git a/include/asm-sh/posix_types.h b/include/asm-sh/posix_types.h
new file mode 100644
index 0000000000..a85c8eb953
--- /dev/null
+++ b/include/asm-sh/posix_types.h
@@ -0,0 +1,138 @@
+#ifndef __ASM_SH_POSIX_TYPES_H
+#define __ASM_SH_POSIX_TYPES_H
+
+/*
+ * This file is generally used by user-level software, so you need to
+ * be a little careful about namespace pollution etc.  Also, we cannot
+ * assume GCC is being used.
+ */
+
+typedef unsigned short __kernel_dev_t;
+typedef unsigned long __kernel_ino_t;
+typedef unsigned short __kernel_mode_t;
+typedef unsigned short __kernel_nlink_t;
+typedef long __kernel_off_t;
+typedef int __kernel_pid_t;
+typedef unsigned short __kernel_ipc_pid_t;
+typedef unsigned short __kernel_uid_t;
+typedef unsigned short __kernel_gid_t;
+typedef unsigned int __kernel_size_t;
+typedef int __kernel_ssize_t;
+typedef int __kernel_ptrdiff_t;
+typedef long __kernel_time_t;
+typedef long __kernel_suseconds_t;
+typedef long __kernel_clock_t;
+typedef int __kernel_daddr_t;
+typedef char *__kernel_caddr_t;
+typedef unsigned short __kernel_uid16_t;
+typedef unsigned short __kernel_gid16_t;
+typedef unsigned int __kernel_uid32_t;
+typedef unsigned int __kernel_gid32_t;
+
+typedef unsigned short __kernel_old_uid_t;
+typedef unsigned short __kernel_old_gid_t;
+
+#ifdef __GNUC__
+typedef long long __kernel_loff_t;
+#endif
+
+typedef struct
+{
+#if defined(__KERNEL__) || defined(__USE_ALL)
+	int val[2];
+#else				/* !defined(__KERNEL__) && !defined(__USE_ALL) */
+	int __val[2];
+#endif				/* !defined(__KERNEL__) && !defined(__USE_ALL) */
+} __kernel_fsid_t;
+
+#if defined(__KERNEL__) || !defined(__GLIBC__) || (__GLIBC__ < 2)
+
+#undef	__FD_SET
+static __inline__ void __FD_SET (unsigned long __fd,
+				 __kernel_fd_set * __fdsetp)
+{
+	unsigned long __tmp = __fd / __NFDBITS;
+	unsigned long __rem = __fd % __NFDBITS;
+	__fdsetp->fds_bits[__tmp] |= (1UL << __rem);
+}
+
+#undef	__FD_CLR
+static __inline__ void __FD_CLR (unsigned long __fd,
+				 __kernel_fd_set * __fdsetp)
+{
+	unsigned long __tmp = __fd / __NFDBITS;
+	unsigned long __rem = __fd % __NFDBITS;
+	__fdsetp->fds_bits[__tmp] &= ~(1UL << __rem);
+}
+
+
+#undef	__FD_ISSET
+static __inline__ int __FD_ISSET (unsigned long __fd,
+				  const __kernel_fd_set * __p)
+{
+	unsigned long __tmp = __fd / __NFDBITS;
+	unsigned long __rem = __fd % __NFDBITS;
+	return (__p->fds_bits[__tmp] & (1UL << __rem)) != 0;
+}
+
+/*
+ * This will unroll the loop for the normal constant case (8 ints,
+ * for a 256-bit fd_set)
+ */
+#undef	__FD_ZERO
+static __inline__ void __FD_ZERO (__kernel_fd_set * __p)
+{
+	unsigned long *__tmp = __p->fds_bits;
+	int __i;
+
+	if (__builtin_constant_p (__FDSET_LONGS)) {
+		switch (__FDSET_LONGS) {
+		case 16:
+			__tmp[0] = 0;
+			__tmp[1] = 0;
+			__tmp[2] = 0;
+			__tmp[3] = 0;
+			__tmp[4] = 0;
+			__tmp[5] = 0;
+			__tmp[6] = 0;
+			__tmp[7] = 0;
+			__tmp[8] = 0;
+			__tmp[9] = 0;
+			__tmp[10] = 0;
+			__tmp[11] = 0;
+			__tmp[12] = 0;
+			__tmp[13] = 0;
+			__tmp[14] = 0;
+			__tmp[15] = 0;
+			return;
+
+		case 8:
+			__tmp[0] = 0;
+			__tmp[1] = 0;
+			__tmp[2] = 0;
+			__tmp[3] = 0;
+			__tmp[4] = 0;
+			__tmp[5] = 0;
+			__tmp[6] = 0;
+			__tmp[7] = 0;
+			return;
+
+		case 4:
+			__tmp[0] = 0;
+			__tmp[1] = 0;
+			__tmp[2] = 0;
+			__tmp[3] = 0;
+			return;
+		}
+	}
+	__i = __FDSET_LONGS;
+	while (__i) {
+		__i--;
+		*__tmp = 0;
+		__tmp++;
+	}
+}
+
+#endif /* defined(__KERNEL__) || !defined(__GLIBC__) || (__GLIBC__ < 2) */
+
+#endif /* __ASM_SH_POSIX_TYPES_H */
diff --git a/include/asm-sh/processor.h b/include/asm-sh/processor.h
new file mode 100644
index 0000000000..9165166899
--- /dev/null
+++ b/include/asm-sh/processor.h
@@ -0,0 +1,240 @@
+/*
+ * include/asm-sh/processor.h
+ *
+ * Copyright (C) 1999, 2000  Niibe Yutaka
+ */
+
+#ifndef __ASM_SH_PROCESSOR_H
+#define __ASM_SH_PROCESSOR_H
+
+/* #include <asm/page.h> */
+#include <asm/types.h>
+
+/* #include <linux/threads.h> */
+
+/*
+ * Default implementation of macro that returns current
+ * instruction pointer ("program counter").
+ */
+#define current_text_addr() ({ void *pc; __asm__("mova	1f, %0\n1:":"=z" (pc)); pc; })
+
+/*
+ *  CPU type and hardware bug flags. Kept separately for each CPU.
+ */
+enum cpu_type
+{
+	CPU_SH7708,		/* Represents 7707, 7708, 7708S, 7708R, 7709 */
+	CPU_SH7729,		/* Represents 7709A, 7729 */
+	CPU_SH7750,		/* Represents 7750, 7751 */
+	CPU_ST40,		/* Represents ST40STB1 and ST40GX1 */
+	CPU_SH4202,
+	CPU_SH_NONE
+};
+
+struct sh_cpuinfo
+{
+	enum cpu_type type;
+	char hard_math;
+	unsigned long loops_per_jiffy;
+
+	unsigned int cpu_clock, master_clock, bus_clock, module_clock;
+#ifdef CONFIG_CPU_SUBTYPE_ST40
+	unsigned int memory_clock;
+#endif
+};
+
+extern struct sh_cpuinfo boot_cpu_data;
+
+#define cpu_data (&boot_cpu_data)
+#define current_cpu_data boot_cpu_data
+
+/*
+ * User space process size: 2GB.
+ *
+ * Since SH7709 and SH7750 have "area 7", we can't use 0x7c000000--0x7fffffff
+ */
+#define TASK_SIZE	0x7c000000UL
+
+/* This decides where the kernel will search for a free chunk of vm
+ * space during mmap's.
+ */
+#define TASK_UNMAPPED_BASE	(TASK_SIZE / 3)
+
+/*
+ * Bit of SR register
+ *
+ * FD-bit:
+ *     When it's set, it means the processor doesn't have right to use FPU,
+ *     and it results exception when the floating operation is executed.
+ *
+ * IMASK-bit:
+ *     Interrupt level mask
+ */
+#define SR_FD    0x00008000
+#define SR_IMASK 0x000000f0
+
+/*
+ * FPU structure and data
+ */
+
+struct sh_fpu_hard_struct
+{
+	unsigned long fp_regs[16];
+	unsigned long xfp_regs[16];
+	unsigned long fpscr;
+	unsigned long fpul;
+
+	long status;		/* software status information */
+};
+
+/* Dummy fpu emulator  */
+struct sh_fpu_soft_struct
+{
+	unsigned long fp_regs[16];
+	unsigned long xfp_regs[16];
+	unsigned long fpscr;
+	unsigned long fpul;
+
+	unsigned char lookahead;
+	unsigned long entry_pc;
+};
+
+union sh_fpu_union
+{
+	struct sh_fpu_hard_struct hard;
+	struct sh_fpu_soft_struct soft;
+};
+
+struct thread_struct
+{
+	unsigned long sp;
+	unsigned long pc;
+
+	unsigned long trap_no, error_code;
+	unsigned long address;
+
+	/* Hardware debugging registers */
+	unsigned long ubc_pc1, ubc_pc2;
+
+	/* floating point info */
+	union sh_fpu_union fpu;
+};
+
+/* Count of active tasks with UBC settings */
+extern int ubc_usercnt;
+
+#define INIT_THREAD  {						\
+	sizeof(init_stack) + (long) &init_stack, /* sp */	\
+	0,					 /* pc */	\
+	0, 0, 							\
+	0, 							\
+	0, -1, 							\
+	{{{0,}},} 				/* fpu state */	\
+}
+
+/*
+ * Do necessary setup to start up a newly executed thread.
+ */
+#define start_thread(regs, new_pc, new_sp)	 \
+	set_fs(USER_DS);			 \
+	regs->pr = 0;   		 	 \
+	regs->sr = 0;		/* User mode. */ \
+	regs->pc = new_pc;			 \
+	regs->regs[15] = new_sp
+
+/* Forward declaration, a strange C thing */
+struct task_struct;
+struct mm_struct;
+
+/* Free all resources held by a thread. */
+extern void release_thread (struct task_struct *);
+/*
+ * create a kernel thread without removing it from tasklists
+ */
+extern int arch_kernel_thread (int (*fn) (void *), void *arg,
+			       unsigned long flags);
+
+/*
+ * Bus types
+ */
+#define EISA_bus 0
+#define EISA_bus__is_a_macro	/* for versions in ksyms.c */
+#define MCA_bus 0
+#define MCA_bus__is_a_macro	/* for versions in ksyms.c */
+
+
+/* Copy and release all segment info associated with a VM */
+#define copy_segments(p, mm)	do { } while(0)
+#define release_segments(mm)	do { } while(0)
+
+/*
+ * FPU lazy state save handling.
+ */
+
+static __inline__ void release_fpu (void)
+{
+	unsigned long __dummy;
+
+	/* Set FD flag in SR */
+	__asm__ __volatile__ ("stc	sr, %0\n\t"
+			      "or	%1, %0\n\t"
+			      "ldc	%0, sr":"=&r" (__dummy)
+			      :"r" (SR_FD));
+}
+
+static __inline__ void grab_fpu (void)
+{
+	unsigned long __dummy;
+
+	/* Clear out FD flag in SR */
+	__asm__ __volatile__ ("stc	sr, %0\n\t"
+			      "and	%1, %0\n\t"
+			      "ldc	%0, sr":"=&r" (__dummy)
+			      :"r" (~SR_FD));
+}
+
+extern void save_fpu (struct task_struct *__tsk);
+
+#define unlazy_fpu(tsk) do { 			\
+	if ((tsk)->flags & PF_USEDFPU) {	\
+		save_fpu(tsk); 			\
+	}					\
+} while (0)
+
+#define clear_fpu(tsk) do { 			\
+	if ((tsk)->flags & PF_USEDFPU) { 	\
+		(tsk)->flags &= ~PF_USEDFPU; 	\
+		release_fpu();			\
+	}					\
+} while (0)
+
+/* Double presision, NANS as NANS, rounding to nearest, no exceptions */
+#define FPSCR_INIT  0x00080000
+
+#define	FPSCR_CAUSE_MASK	0x0001f000	/* Cause bits */
+#define	FPSCR_FLAG_MASK		0x0000007c	/* Flag bits */
+
+/*
+ * Return saved PC of a blocked thread.
+ */
+static __inline__ unsigned long thread_saved_pc (struct thread_struct *t)
+{
+	return t->pc;
+}
+
+extern unsigned long get_wchan (struct task_struct *p);
+
+#define KSTK_EIP(tsk)  ((tsk)->thread.pc)
+#define KSTK_ESP(tsk)  ((tsk)->thread.sp)
+
+#define THREAD_SIZE (2*PAGE_SIZE)
+extern struct task_struct *alloc_task_struct (void);
+extern void free_task_struct (struct task_struct *);
+#define get_task_struct(tsk)      atomic_inc(&virt_to_page(tsk)->count)
+
+#define init_task	(init_task_union.task)
+#define init_stack	(init_task_union.stack)
+
+#define cpu_relax()	do { } while (0)
+
+#endif /* __ASM_SH_PROCESSOR_H */
diff --git a/include/asm-sh/ptrace.h b/include/asm-sh/ptrace.h
new file mode 100644
index 0000000000..2dde7f3958
--- /dev/null
+++ b/include/asm-sh/ptrace.h
@@ -0,0 +1,75 @@
+#ifndef __ASM_SH_PTRACE_H
+#define __ASM_SH_PTRACE_H
+
+#include <asm/processor.h>
+#include <asm/ubc.h>
+
+/*
+ * Copyright (C) 1999, 2000  Niibe Yutaka
+ *
+ */
+
+/*
+ * GCC defines register number like this:
+ * -----------------------------
+ *	 0 - 15 are integer registers
+ *	17 - 22 are control/special registers
+ *	24 - 39 fp registers
+ *	40 - 47 xd registers
+ *	48 -    fpscr register
+ * -----------------------------
+ *
+ * We follows above, except:
+ *	16 --- program counter (PC)
+ *	22 --- expevt # (Exception Event Number)
+ *	23 --- floating point communication register
+ */
+#define REG_REG0	 0
+#define REG_REG15	15
+
+#define REG_PC		16
+
+#define REG_PR		17
+#define REG_SR		18
+#define REG_GBR      	19
+#define REG_MACH	20
+#define REG_MACL	21
+
+#define REG_EXPEVT	22
+
+#define REG_FPREG0	23
+#define REG_FPREG15	38
+#define REG_XFREG0	39
+#define REG_XFREG15	54
+
+#define REG_FPSCR	55
+#define REG_FPUL	56
+
+#define PTRACE_SETOPTIONS         21
+
+/* options set using PTRACE_SETOPTIONS */
+#define PTRACE_O_TRACESYSGOOD     0x00000001
+
+/*
+ * This struct defines the way the registers are stored on the
+ * kernel stack during a system call or other kernel entry.
+ */
+struct pt_regs
+{
+	unsigned long regs[16];
+	unsigned long pc;
+	unsigned long pr;
+	unsigned long sr;
+	unsigned long gbr;
+	unsigned long mach;
+	unsigned long macl;
+	unsigned long expevt;
+};
+
+#ifdef __KERNEL__
+#define user_mode(regs) (((regs)->sr & 0x40000000)==0)
+#define instruction_pointer(regs) ((regs)->pc)
+extern void show_regs (struct pt_regs *);
+#endif
+
+#endif /* __ASM_SH_PTRACE_H */
diff --git a/include/asm-sh/regdef.h b/include/asm-sh/regdef.h
new file mode 100644
index 0000000000..fd7e2dfee3
--- /dev/null
+++ b/include/asm-sh/regdef.h
@@ -0,0 +1,35 @@
+/*
+ * include/asm-sh/regdefs.h
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2004, STMicroelectronics
+ */
+
+#ifndef __ASM_SH_REGDEF_H
+#define __ASM_SH_REGDEF_H
+
+/*
+ * Symbolic register names for 32 bit ABI
+ */
+
+#define v0      r0		/* return value */
+#define v1      r1
+#define v2      r2
+#define v3      r3
+#define a0      r4		/* argument registers */
+#define a1      r5
+#define a2      r6
+#define a3      r7
+#define s0      r8		/* callee saved */
+#define s1      r9
+#define s2      r10
+#define s3      r11
+#define gp      r12		/* global pointer */
+#define s4      r13
+#define fp      r14		/* frame pointer */
+#define sp      r15		/* stack pointer */
+
+#endif /* __ASM_SH_REGDEF_H */
diff --git a/include/asm-sh/sh4reg.h b/include/asm-sh/sh4reg.h
new file mode 100644
index 0000000000..41e8704372
--- /dev/null
+++ b/include/asm-sh/sh4reg.h
@@ -0,0 +1,150 @@
+/*
+ * Copyright (C) STMicroelectronics Ltd. 2002, 2003.
+ *
+ * andy.sturges@st.com
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*----------------------------------------------------------------------------*/
+
+#ifndef __SH4REG_H
+#define __SH4REG_H
+
+#include "asm/sh4regtype.h"
+
+
+/*----------------------------------------------------------------------------*/
+
+/*
+ * Core SH4 control registers
+ */
+
+/* Core control registers (common to all SH4 variants) */
+#define SH4_CCN_PTEH	SH4_DWORD_REG(0xff000000)
+#define SH4_CCN_PTEL	SH4_DWORD_REG(0xff000004)
+#define SH4_CCN_TTB	SH4_DWORD_REG(0xff000008)
+#define SH4_CCN_TEA	SH4_DWORD_REG(0xff00000c)
+#define SH4_CCN_MMUCR	SH4_DWORD_REG(0xff000010)
+#define SH4_CCN_BASRA	SH4_BYTE_REG(0xff000014)
+#define SH4_CCN_BASRB	SH4_BYTE_REG(0xff000018)
+#define SH4_CCN_CCR	SH4_DWORD_REG(0xff00001c)
+#define SH4_CCN_TRA	SH4_DWORD_REG(0xff000020)
+#define SH4_CCN_EXPEVT	SH4_DWORD_REG(0xff000024)
+#define SH4_CCN_INTEVT	SH4_DWORD_REG(0xff000028)
+#define SH4_CCN_PVR	SH4_DWORD_REG(0xff000030)
+#define SH4_CCN_PTEA	SH4_DWORD_REG(0xff000034)
+#define SH4_CCN_QACR0	SH4_DWORD_REG(0xff000038)
+#define SH4_CCN_QACR1	SH4_DWORD_REG(0xff00003c)
+#define SH4_CCN_CVR	SH4_DWORD_REG(0xff000040)
+#define SH4_CCN_PRR	SH4_DWORD_REG(0xff000044)
+#define SH4_CCN_PASCR	SH4_DWORD_REG(0xff000070)
+
+/* Some bits in the CCN.CCR register */
+#define SH4_CCR_OCE	(1<<0)
+#define SH4_CCR_WT	(1<<1)
+#define SH4_CCR_CB	(1<<2)
+#define SH4_CCR_OCI	(1<<3)
+#define SH4_CCR_ORA	(1<<5)
+#define SH4_CCR_ICE	(1<<8)
+#define SH4_CCR_ICI	(1<<11)
+#define SH4_CCR_EMODE	(1<<31)
+
+/* Some bits in the CCN.MMUCR register */
+#define	SH4_MMUCR_TI	(1<<2)		/* MMUCR.TI */
+#define	SH4_MMUCR_SE	(1<<4)		/* MMUCR.SE */
+
+/* Some bits in the CCN.PASCR register */
+#define	SH4_PASCR_SE	(1<<31)		/* PASCR.SE */
+
+
+/* User Break Controller control registers (common to all SH4 variants) */
+#define SH4_UBC_BARA	SH4_DWORD_REG(0xff200000)
+#define SH4_UBC_BAMRA	SH4_BYTE_REG(0xff200004)
+#define SH4_UBC_BBRA	SH4_WORD_REG(0xff200008)
+#define SH4_UBC_BASRA	SH4_BYTE_REG(0xff000014)
+#define SH4_UBC_BARB	SH4_DWORD_REG(0xff20000c)
+#define SH4_UBC_BAMRB	SH4_BYTE_REG(0xff200010)
+#define SH4_UBC_BBRB	SH4_WORD_REG(0xff200014)
+#define SH4_UBC_BASRB	SH4_BYTE_REG(0xff000018)
+#define SH4_UBC_BDRB	SH4_DWORD_REG(0xff200018)
+#define SH4_UBC_BDMRB	SH4_DWORD_REG(0xff20001c)
+#define SH4_UBC_BRCR	SH4_WORD_REG(0xff200020)
+
+/* User Debug Interface control registers (common to all SH4 variants) */
+#define SH4_UDI_SDIR	SH4_WORD_REG(0xfff00000)
+#define SH4_UDI_SDDR	SH4_DWORD_REG(0xfff00008)
+#define SH4_UDI_SDDRH	SH4_WORD_REG(0xfff00008)
+#define SH4_UDI_SDDRL	SH4_WORD_REG(0xfff0000a)
+#define SH4_UDI_SDINT	SH4_WORD_REG(0xfff00014)
+
+/* Advanced User Debugger control registers (common to all SH4 variants) */
+#define SH4_AUD_AUCSR	SH4_WORD_REG(0xff2000cc)
+#define SH4_AUD_AUWASR	SH4_DWORD_REG(0xff2000d0)
+#define SH4_AUD_AUWAER	SH4_DWORD_REG(0xff2000d4)
+#define SH4_AUD_AUWBSR	SH4_DWORD_REG(0xff2000d8)
+#define SH4_AUD_AUWBER	SH4_DWORD_REG(0xff2000dc)
+
+/*
+ * Generic SH4 control registers
+ */
+
+/* Timer Unit control registers (common to all SH4 variants) */
+#define TOCR	SH4_BYTE_REG(SH4_TMU_REGS_BASE + 0x00)
+#define TSTR	SH4_BYTE_REG(SH4_TMU_REGS_BASE + 0x04)
+#define TCOR0	SH4_DWORD_REG(SH4_TMU_REGS_BASE + 0x08)
+#define TCNT0	SH4_DWORD_REG(SH4_TMU_REGS_BASE + 0x0c)
+#define TCR0	SH4_WORD_REG(SH4_TMU_REGS_BASE + 0x10)
+#define TCOR1	SH4_DWORD_REG(SH4_TMU_REGS_BASE + 0x14)
+#define TCNT1	SH4_DWORD_REG(SH4_TMU_REGS_BASE + 0x18)
+#define TCR1	SH4_WORD_REG(SH4_TMU_REGS_BASE + 0x1c)
+#define TCOR2	SH4_DWORD_REG(SH4_TMU_REGS_BASE + 0x20)
+#define TCNT2	SH4_DWORD_REG(SH4_TMU_REGS_BASE + 0x24)
+#define TCR2	SH4_WORD_REG(SH4_TMU_REGS_BASE + 0x28)
+#define TCPR2	SH4_DWORD_REG(SH4_TMU_REGS_BASE + 0x2c)
+
+/* Real Time Clock control registers (common to all SH4 variants) */
+#define SH4_RTC_R64CNT	SH4_BYTE_REG(SH4_RTC_REGS_BASE + 0x00)
+#define SH4_RTC_RSECCNT	SH4_BYTE_REG(SH4_RTC_REGS_BASE + 0x04)
+#define SH4_RTC_RMINCNT	SH4_BYTE_REG(SH4_RTC_REGS_BASE + 0x08)
+#define SH4_RTC_RHRCNT	SH4_BYTE_REG(SH4_RTC_REGS_BASE + 0x0c)
+#define SH4_RTC_RWKCNT	SH4_BYTE_REG(SH4_RTC_REGS_BASE + 0x10)
+#define SH4_RTC_RDAYCNT	SH4_BYTE_REG(SH4_RTC_REGS_BASE + 0x14)
+#define SH4_RTC_RMONCNT	SH4_BYTE_REG(SH4_RTC_REGS_BASE + 0x18)
+#define SH4_RTC_RYRCNT	SH4_WORD_REG(SH4_RTC_REGS_BASE + 0x1c)
+#define SH4_RTC_RSECAR	SH4_BYTE_REG(SH4_RTC_REGS_BASE + 0x20)
+#define SH4_RTC_RMINAR	SH4_BYTE_REG(SH4_RTC_REGS_BASE + 0x24)
+#define SH4_RTC_RHRAR	SH4_BYTE_REG(SH4_RTC_REGS_BASE + 0x28)
+#define SH4_RTC_RWKAR	SH4_BYTE_REG(SH4_RTC_REGS_BASE + 0x2c)
+#define SH4_RTC_RDAYAR	SH4_BYTE_REG(SH4_RTC_REGS_BASE + 0x30)
+#define SH4_RTC_RMONAR	SH4_BYTE_REG(SH4_RTC_REGS_BASE + 0x34)
+#define SH4_RTC_RCR1	SH4_BYTE_REG(SH4_RTC_REGS_BASE + 0x38)
+#define SH4_RTC_RCR2	SH4_BYTE_REG(SH4_RTC_REGS_BASE + 0x3c)
+
+/*
+ * Privileged Mapping Buffer (PMB) bit-field defintions
+ */
+#define	SH4_PMB_WT		(1<<0)	/* PMB[n].WT */
+#define	SH4_PMB_C		(1<<3)	/* PMB[n].C */
+#define	SH4_PMB_V		(1<<8)	/* PMB[n].V */
+#define	SH4_PMB_UB		(1<<9)	/* PMB[n].UB */
+
+/*----------------------------------------------------------------------------*/
+
+#endif /* __SH4REG_H */
diff --git a/include/asm-sh/sh4regtype.h b/include/asm-sh/sh4regtype.h
new file mode 100644
index 0000000000..acc1e6dddb
--- /dev/null
+++ b/include/asm-sh/sh4regtype.h
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) STMicroelectronics Ltd. 2002.
+ *
+ * andy.sturges@st.com
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __SH4REGTYPE_H
+#define __SH4REGTYPE_H
+
+
+#ifndef __ASSEMBLY__
+
+typedef volatile unsigned char *const		sh4_byte_reg_t;
+typedef volatile unsigned short *const		sh4_word_reg_t;
+typedef volatile unsigned int *const		sh4_dword_reg_t;
+typedef volatile unsigned long long *const	sh4_gword_reg_t;
+
+#define SH4_BYTE_REG(address)	((sh4_byte_reg_t) (address))
+#define SH4_WORD_REG(address)	((sh4_word_reg_t) (address))
+#define SH4_DWORD_REG(address)	((sh4_dword_reg_t) (address))
+#define SH4_GWORD_REG(address)	((sh4_gword_reg_t) (address))
+
+#else	/* __ASSEMBLY__ */
+
+#define SH4_BYTE_REG(address)	(address)
+#define SH4_WORD_REG(address)	(address)
+#define SH4_DWORD_REG(address)	(address)
+#define SH4_GWORD_REG(address)	(address)
+
+#endif	/* __ASSEMBLY__ */
+
+
+#endif /* __SH4REGTYPE_H */
diff --git a/include/asm-sh/soc.h b/include/asm-sh/soc.h
new file mode 100644
index 0000000000..ea25be4511
--- /dev/null
+++ b/include/asm-sh/soc.h
@@ -0,0 +1,68 @@
+/*
+ * (C) Copyright 2008-2009 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#ifndef _SOC_H_
+#define	_SOC_H_
+
+
+/*
+ *	common call-back functions for STMAC.
+ */
+extern int  stmac_default_pbl (void);
+extern void stmac_set_mac_speed (int speed);
+
+
+/*
+ *	functions for the STx7200 SoC device.
+ */
+extern void stx7200_configure_ethernet (
+	int mac, int rmii, int ext_clk, int phy_bus);
+
+
+/*
+ * SATA initialization functions.
+ */
+extern void stm_sata_miphy_init(void);
+extern int  stm_sata_probe(void);
+
+extern void stb7100_sata_init(void);
+extern void stx7105_configure_sata(void);
+extern void stx7141_configure_sata(void);
+extern void stx7200_configure_sata(void);
+
+
+/*
+ * Software "bit-banging" functions for SPI accesses.
+ */
+extern void		stx7105_spi_scl(const int val);
+extern void		stx7105_spi_sda(const int val);
+extern unsigned char	stx7105_spi_read(void);
+
+extern void		stx7111_spi_scl(const int val);
+extern void		stx7111_spi_sda(const int val);
+extern unsigned char	stx7111_spi_read(void);
+
+#endif	/* _SOC_H_ */
+
diff --git a/include/asm-sh/socregs.h b/include/asm-sh/socregs.h
new file mode 100644
index 0000000000..793ad905d6
--- /dev/null
+++ b/include/asm-sh/socregs.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) STMicroelectronics Ltd. 2004-2009
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#ifndef __SOC_REG_H
+#define __SOC_REG_H
+
+
+#if defined(CONFIG_SH_STB7100)
+#	include <asm/stb7100reg.h>
+#elif defined(CONFIG_SH_STX5197)
+#	include <asm/stx5197reg.h>
+#elif defined(CONFIG_SH_STX7105)
+#	include <asm/stx7105reg.h>
+#elif defined(CONFIG_SH_STX7111)
+#	include <asm/stx7111reg.h>
+#elif defined(CONFIG_SH_STX7141)
+#	include <asm/stx7141reg.h>
+#elif defined(CONFIG_SH_STX7200)
+#	include <asm/stx7200reg.h>
+#else
+#	error Missing Device Definitions!
+#endif
+
+
+#endif /* __SOC_REG_H */
diff --git a/include/asm-sh/st40reg.h b/include/asm-sh/st40reg.h
new file mode 100644
index 0000000000..6593b777fc
--- /dev/null
+++ b/include/asm-sh/st40reg.h
@@ -0,0 +1,706 @@
+/*
+ * Copyright (C) STMicroelectronics Ltd. 2002, 2003, 2007-2009
+ *
+ * andy.sturges@st.com
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * This is derived from STMicroelectronics gnu toolchain example:
+ *   sh-superh-elf/examples/bare/sh4reg/st40reg.h
+ */
+
+#ifndef __ST40REG_H
+#define __ST40REG_H
+
+#include "asm/sh4regtype.h"
+
+/*----------------------------------------------------------------------------*/
+
+/*
+ * Set default endian to little
+ */
+
+#if defined(ST40_LITTLE_ENDIAN) && defined(ST40_BIG_ENDIAN)
+#error ST40_LITTLE_ENDIAN and ST40_BIG_ENDIAN both defined
+#endif
+
+#if !defined(ST40_LITTLE_ENDIAN) && !defined(ST40_BIG_ENDIAN)
+#define ST40_LITTLE_ENDIAN
+#endif
+
+/*----------------------------------------------------------------------------*/
+
+#include "sh4reg.h"
+
+/*----------------------------------------------------------------------------*/
+
+/*
+ * ST40 control registers
+ */
+
+/* Clock Pulse Generator control registers (all ST40 variants) */
+#define ST40_CPG_FRQCR			SH4_WORD_REG(ST40_CPG_REGS_BASE + 0x00)
+#define ST40_CPG_STBCR			SH4_BYTE_REG(ST40_CPG_REGS_BASE + 0x04)
+#define ST40_CPG_WTCNT			SH4_WORD_REG(ST40_CPG_REGS_BASE + 0x08)
+#define ST40_CPG_WTCNT_R		SH4_BYTE_REG(ST40_CPG_REGS_BASE + 0x08)
+#define ST40_CPG_WTCSR			SH4_WORD_REG(ST40_CPG_REGS_BASE + 0x0c)
+#define ST40_CPG_WTCSR_R		SH4_BYTE_REG(ST40_CPG_REGS_BASE + 0x0c)
+#define ST40_CPG_STBCR2			SH4_BYTE_REG(ST40_CPG_REGS_BASE + 0x10)
+#define ST40_CPG_WTCSR2			SH4_WORD_REG(ST40_CPG_REGS_BASE + 0x1c)
+#define ST40_CPG_WTCSR2_R		SH4_BYTE_REG(ST40_CPG_REGS_BASE + 0x1c)
+#define ST40_CPG_FRQCR2			SH4_WORD_REG(ST40_CPG_REGS_BASE + 0xc0)
+
+/* Interrupt controller registers (all ST40 variants) */
+#define ST40_INTC_ICR			SH4_WORD_REG(ST40_INTC_REGS_BASE + 0x00)
+#define ST40_INTC_IPRA			SH4_WORD_REG(ST40_INTC_REGS_BASE + 0x04)
+#define ST40_INTC_IPRB			SH4_WORD_REG(ST40_INTC_REGS_BASE + 0x08)
+#define ST40_INTC_IPRC			SH4_WORD_REG(ST40_INTC_REGS_BASE + 0x0c)
+#define ST40_INTC_IPRD			SH4_WORD_REG(ST40_INTC_REGS_BASE + 0x10)
+
+/* Interrupt Controller control registers (all ST40 variants) */
+#define ST40_INTC2_INTPRI00		SH4_DWORD_REG(ST40_INTC2_REGS_BASE + 0x00)
+#define ST40_INTC2_INTPRI04		SH4_DWORD_REG(ST40_INTC2_REGS_BASE + 0x04)
+#define ST40_INTC2_INTPRI08		SH4_DWORD_REG(ST40_INTC2_REGS_BASE + 0x08)
+#define ST40_INTC2_INTREQ00		SH4_DWORD_REG(ST40_INTC2_REGS_BASE + 0x20)
+#define ST40_INTC2_INTREQ04		SH4_DWORD_REG(ST40_INTC2_REGS_BASE + 0x24)
+#define ST40_INTC2_INTREQ08		SH4_DWORD_REG(ST40_INTC2_REGS_BASE + 0x28)
+#define ST40_INTC2_INTMSK00		SH4_DWORD_REG(ST40_INTC2_REGS_BASE + 0x40)
+#define ST40_INTC2_INTMSK04		SH4_DWORD_REG(ST40_INTC2_REGS_BASE + 0x44)
+#define ST40_INTC2_INTMSK08		SH4_DWORD_REG(ST40_INTC2_REGS_BASE + 0x48)
+#define ST40_INTC2_INTMSKCLR00		SH4_DWORD_REG(ST40_INTC2_REGS_BASE + 0x60)
+#define ST40_INTC2_INTMSKCLR04		SH4_DWORD_REG(ST40_INTC2_REGS_BASE + 0x64)
+#define ST40_INTC2_INTMSKCLR08		SH4_DWORD_REG(ST40_INTC2_REGS_BASE + 0x68)
+#define ST40_INTC2_INTC2MODE		SH4_DWORD_REG(ST40_INTC2_REGS_BASE + 0x80)
+
+/* Interrupt Level Controller control registers (all ST40 variants) */
+#define ST40_ILC_INPUT_INTERRUPT(n)	SH4_DWORD_REG(ST40_ILC_REGS_BASE + (0x0080 + ((n) * 4)))
+#define ST40_ILC_STATUS(n)		SH4_DWORD_REG(ST40_ILC_REGS_BASE + (0x0200 + ((n) * 4)))
+#define ST40_ILC_CLEAR_STATUS(n)	SH4_DWORD_REG(ST40_ILC_REGS_BASE + (0x0280 + ((n) * 4)))
+#define ST40_ILC_ENABLE(n)		SH4_DWORD_REG(ST40_ILC_REGS_BASE + (0x0400 + ((n) * 4)))
+#define ST40_ILC_CLEAR_ENABLE(n)	SH4_DWORD_REG(ST40_ILC_REGS_BASE + (0x0480 + ((n) * 4)))
+#define ST40_ILC_SET_ENABLE(n)		SH4_DWORD_REG(ST40_ILC_REGS_BASE + (0x0500 + ((n) * 4)))
+#define ST40_ILC_WAKEUP_ENABLE(n)	SH4_DWORD_REG(ST40_ILC_REGS_BASE + (0x0600 + ((n) * 4)))
+#define ST40_ILC_WAKEUP_ACTIVE_LEVEL(n)	SH4_DWORD_REG(ST40_ILC_REGS_BASE + (0x0680 + ((n) * 4)))
+
+/* Serial Communication Interfaces control registers (all ST40 variants) */
+#define ST40_SCIF_SCSMR(n)		SH4_WORD_REG(ST40_SCIF##n##_REGS_BASE + 0x00)
+#define ST40_SCIF_SCBRR(n)		SH4_BYTE_REG(ST40_SCIF##n##_REGS_BASE + 0x04)
+#define ST40_SCIF_SCSCR(n)		SH4_WORD_REG(ST40_SCIF##n##_REGS_BASE + 0x08)
+#define ST40_SCIF_SCFTDR(n)		SH4_BYTE_REG(ST40_SCIF##n##_REGS_BASE + 0x0c)
+#define ST40_SCIF_SCFSR(n)		SH4_WORD_REG(ST40_SCIF##n##_REGS_BASE + 0x10)
+#define ST40_SCIF_SCFRDR(n)		SH4_BYTE_REG(ST40_SCIF##n##_REGS_BASE + 0x14)
+#define ST40_SCIF_SCFCR(n)		SH4_WORD_REG(ST40_SCIF##n##_REGS_BASE + 0x18)
+#define ST40_SCIF_SCFDR(n)		SH4_WORD_REG(ST40_SCIF##n##_REGS_BASE + 0x1c)
+#define ST40_SCIF_SCSPTR(n)		SH4_WORD_REG(ST40_SCIF##n##_REGS_BASE + 0x20)
+#define ST40_SCIF_SCLSR(n)		SH4_WORD_REG(ST40_SCIF##n##_REGS_BASE + 0x24)
+
+/* Clock Generator control registers (all ST40 variants) */
+#define ST40_CLOCKGEN_PLL1CR1(n)	SH4_DWORD_REG(ST40_CLOCKGEN##n##_REGS_BASE + 0x00)
+#define ST40_CLOCKGEN_PLL1CR2(n)	SH4_DWORD_REG(ST40_CLOCKGEN##n##_REGS_BASE + 0x08)
+#define ST40_CLOCKGEN_PLL2CR(n)		SH4_DWORD_REG(ST40_CLOCKGEN##n##_REGS_BASE + 0x10)
+#define ST40_CLOCKGEN_STBREQCR(n)	SH4_DWORD_REG(ST40_CLOCKGEN##n##_REGS_BASE + 0x18)
+#define ST40_CLOCKGEN_STBREQCR_SET(n)	SH4_DWORD_REG(ST40_CLOCKGEN##n##_REGS_BASE + 0x20)
+#define ST40_CLOCKGEN_STBREQCR_CLR(n)	SH4_DWORD_REG(ST40_CLOCKGEN##n##_REGS_BASE + 0x28)
+#define ST40_CLOCKGEN_STBACKCR(n)	SH4_DWORD_REG(ST40_CLOCKGEN##n##_REGS_BASE + 0x30)
+#define ST40_CLOCKGEN_CLK4CR(n)		SH4_DWORD_REG(ST40_CLOCKGEN##n##_REGS_BASE + 0x38)
+#define ST40_CLOCKGEN_CPG_BYPASS(n)	SH4_DWORD_REG(ST40_CLOCKGEN##n##_REGS_BASE + 0x40)
+#define ST40_CLOCKGEN_PLL2_MUXCR(n)	SH4_DWORD_REG(ST40_CLOCKGEN##n##_REGS_BASE + 0x48)
+#define ST40_CLOCKGEN_CLK1CR(n)		SH4_DWORD_REG(ST40_CLOCKGEN##n##_REGS_BASE + 0x50)
+#define ST40_CLOCKGEN_CLK2CR(n)		SH4_DWORD_REG(ST40_CLOCKGEN##n##_REGS_BASE + 0x58)
+#define ST40_CLOCKGEN_CLK3CR(n)		SH4_DWORD_REG(ST40_CLOCKGEN##n##_REGS_BASE + 0x60)
+#define ST40_CLOCKGEN_CLK_SELCR(n)	SH4_DWORD_REG(ST40_CLOCKGEN##n##_REGS_BASE + 0x68)
+
+#define ST40_CLOCKGEN_CLK_RATIO(n) ST40_CLOCKGEN_PLL2_MUXCR(n)
+#define ST40_CLOCKGEN_CLKDDRCR(n) ST40_CLOCKGEN_CLK_SELCR(n)
+
+/* Direct Memeory Access Controller control registers (all ST40 variants) */
+#define ST40_DMAC_CHAN0_IDENTITY	SH4_DWORD_REG((ST40_DMAC_REGS_BASE + 0x100) + 0x00)
+#define ST40_DMAC_CHAN0_ENABLE		SH4_DWORD_REG((ST40_DMAC_REGS_BASE + 0x100) + 0x08)
+#define ST40_DMAC_CHAN0_DISABLE		SH4_DWORD_REG((ST40_DMAC_REGS_BASE + 0x100) + 0x10)
+#define ST40_DMAC_CHAN0_STATUS		SH4_DWORD_REG((ST40_DMAC_REGS_BASE + 0x100) + 0x18)
+#define ST40_DMAC_CHAN0_ACTION		SH4_DWORD_REG((ST40_DMAC_REGS_BASE + 0x100) + 0x20)
+#define ST40_DMAC_CHAN0_POINTER		SH4_DWORD_REG((ST40_DMAC_REGS_BASE + 0x100) + 0x28)
+#define ST40_DMAC_CHAN0_SUBBASE		SH4_DWORD_REG((ST40_DMAC_REGS_BASE + 0x100) + 0x30)
+#define ST40_DMAC_CHAN0_SUBENABLE	SH4_DWORD_REG((ST40_DMAC_REGS_BASE + 0x100) + 0x38)
+#define ST40_DMAC_CHAN0_SUBDISABLE	SH4_DWORD_REG((ST40_DMAC_REGS_BASE + 0x100) + 0x40)
+#define ST40_DMAC_CHAN0_SUBINT_ENB	SH4_DWORD_REG((ST40_DMAC_REGS_BASE + 0x100) + 0x48)
+#define ST40_DMAC_CHAN0_SUBINT_DIS	SH4_DWORD_REG((ST40_DMAC_REGS_BASE + 0x100) + 0x50)
+#define ST40_DMAC_CHAN0_SUBINT_STAT	SH4_DWORD_REG((ST40_DMAC_REGS_BASE + 0x100) + 0x58)
+#define ST40_DMAC_CHAN0_SUNINT_ACT	SH4_DWORD_REG((ST40_DMAC_REGS_BASE + 0x100) + 0x60)
+#define ST40_DMAC_CHAN0_CONTROL		SH4_DWORD_REG((ST40_DMAC_REGS_BASE + 0x100) + 0x80)
+#define ST40_DMAC_CHAN0_COUNT		SH4_DWORD_REG((ST40_DMAC_REGS_BASE + 0x100) + 0x88)
+#define ST40_DMAC_CHAN0_SAR		SH4_DWORD_REG((ST40_DMAC_REGS_BASE + 0x100) + 0x90)
+#define ST40_DMAC_CHAN0_DAR		SH4_DWORD_REG((ST40_DMAC_REGS_BASE + 0x100) + 0x98)
+
+#define ST40_DMAC_CHANX_IDENTITY(n)	SH4_DWORD_REG((ST40_DMAC_REGS_BASE + (n)) + 0x00)
+#define ST40_DMAC_CHANX_ENABLE(n)	SH4_DWORD_REG((ST40_DMAC_REGS_BASE + (n)) + 0x08)
+#define ST40_DMAC_CHANX_DISABLE(n)	SH4_DWORD_REG((ST40_DMAC_REGS_BASE + (n)) + 0x10)
+#define ST40_DMAC_CHANX_STATUS(n)	SH4_DWORD_REG((ST40_DMAC_REGS_BASE + (n)) + 0x18)
+#define ST40_DMAC_CHANX_ACTION(n)	SH4_DWORD_REG((ST40_DMAC_REGS_BASE + (n)) + 0x20)
+#define ST40_DMAC_CHANX_POINTER(n)	SH4_DWORD_REG((ST40_DMAC_REGS_BASE + (n)) + 0x28)
+#define ST40_DMAC_CHANX_REQUEST(n)	SH4_DWORD_REG((ST40_DMAC_REGS_BASE + (n)) + 0x30)
+#define ST40_DMAC_CHANX_CONTROL(n)	SH4_DWORD_REG((ST40_DMAC_REGS_BASE + (n)) + 0x80)
+#define ST40_DMAC_CHANX_COUNT(n)	SH4_DWORD_REG((ST40_DMAC_REGS_BASE + (n)) + 0x88)
+#define ST40_DMAC_CHANX_SAR(n)		SH4_DWORD_REG((ST40_DMAC_REGS_BASE + (n)) + 0x90)
+#define ST40_DMAC_CHANX_DAR(n)		SH4_DWORD_REG((ST40_DMAC_REGS_BASE + (n)) + 0x98)
+#define ST40_DMAC_CHANX_NEXT_PTR(n)	SH4_DWORD_REG((ST40_DMAC_REGS_BASE + (n)) + 0xa0)
+#define ST40_DMAC_CHANX_SRC_LENGTH(n)	SH4_DWORD_REG((ST40_DMAC_REGS_BASE + (n)) + 0xa8)
+#define ST40_DMAC_CHANX_SRC_STRIDE(n)	SH4_DWORD_REG((ST40_DMAC_REGS_BASE + (n)) + 0xb0)
+#define ST40_DMAC_CHANX_DST_LENGTH(n)	SH4_DWORD_REG((ST40_DMAC_REGS_BASE + (n)) + 0xb8)
+#define ST40_DMAC_CHANX_DST_STRIDE(n)	SH4_DWORD_REG((ST40_DMAC_REGS_BASE + (n)) + 0xc0)
+
+#define ST40_DMAC_CHAN1_IDENTITY	ST40_DMAC_CHANX_IDENTITY(0x200)
+#define ST40_DMAC_CHAN1_ENABLE		ST40_DMAC_CHANX_ENABLE(0x200)
+#define ST40_DMAC_CHAN1_DISABLE		ST40_DMAC_CHANX_DISABLE(0x200)
+#define ST40_DMAC_CHAN1_STATUS		ST40_DMAC_CHANX_STATUS(0x200)
+#define ST40_DMAC_CHAN1_ACTION		ST40_DMAC_CHANX_ACTION(0x200)
+#define ST40_DMAC_CHAN1_POINTER		ST40_DMAC_CHANX_POINTER(0x200)
+#define ST40_DMAC_CHAN1_REQUEST		ST40_DMAC_CHANX_REQUEST(0x200)
+#define ST40_DMAC_CHAN1_CONTROL		ST40_DMAC_CHANX_CONTROL(0x200)
+#define ST40_DMAC_CHAN1_COUNT		ST40_DMAC_CHANX_COUNT(0x200)
+#define ST40_DMAC_CHAN1_SAR		ST40_DMAC_CHANX_SAR(0x200)
+#define ST40_DMAC_CHAN1_DAR		ST40_DMAC_CHANX_DAR(0x200)
+#define ST40_DMAC_CHAN1_NEXT_PTR	ST40_DMAC_CHANX_NEXT_PTR(0x200)
+#define ST40_DMAC_CHAN1_SRC_LENGTH	ST40_DMAC_CHANX_SRC_LENGTH(0x200)
+#define ST40_DMAC_CHAN1_SRC_STRIDE	ST40_DMAC_CHANX_SRC_STRIDE(0x200)
+#define ST40_DMAC_CHAN1_DST_LENGTH	ST40_DMAC_CHANX_DST_LENGTH(0x200)
+#define ST40_DMAC_CHAN1_DST_STRIDE	ST40_DMAC_CHANX_DST_STRIDE(0x200)
+
+#define ST40_DMAC_CHAN2_IDENTITY	ST40_DMAC_CHANX_IDENTITY(0x300)
+#define ST40_DMAC_CHAN2_ENABLE		ST40_DMAC_CHANX_ENABLE(0x300)
+#define ST40_DMAC_CHAN2_DISABLE		ST40_DMAC_CHANX_DISABLE(0x300)
+#define ST40_DMAC_CHAN2_STATUS		ST40_DMAC_CHANX_STATUS(0x300)
+#define ST40_DMAC_CHAN2_ACTION		ST40_DMAC_CHANX_ACTION(0x300)
+#define ST40_DMAC_CHAN2_POINTER		ST40_DMAC_CHANX_POINTER(0x300)
+#define ST40_DMAC_CHAN2_REQUEST		ST40_DMAC_CHANX_REQUEST(0x300)
+#define ST40_DMAC_CHAN2_CONTROL		ST40_DMAC_CHANX_CONTROL(0x300)
+#define ST40_DMAC_CHAN2_COUNT		ST40_DMAC_CHANX_COUNT(0x300)
+#define ST40_DMAC_CHAN2_SAR		ST40_DMAC_CHANX_SAR(0x300)
+#define ST40_DMAC_CHAN2_DAR		ST40_DMAC_CHANX_DAR(0x300)
+#define ST40_DMAC_CHAN2_NEXT_PTR	ST40_DMAC_CHANX_NEXT_PTR(0x300)
+#define ST40_DMAC_CHAN2_SRC_LENGTH	ST40_DMAC_CHANX_SRC_LENGTH(0x300)
+#define ST40_DMAC_CHAN2_SRC_STRIDE	ST40_DMAC_CHANX_SRC_STRIDE(0x300)
+#define ST40_DMAC_CHAN2_DST_LENGTH	ST40_DMAC_CHANX_DST_LENGTH(0x300)
+#define ST40_DMAC_CHAN2_DST_STRIDE	ST40_DMAC_CHANX_DST_STRIDE(0x300)
+
+#define ST40_DMAC_CHAN3_IDENTITY	ST40_DMAC_CHANX_IDENTITY(0x400)
+#define ST40_DMAC_CHAN3_ENABLE		ST40_DMAC_CHANX_ENABLE(0x400)
+#define ST40_DMAC_CHAN3_DISABLE		ST40_DMAC_CHANX_DISABLE(0x400)
+#define ST40_DMAC_CHAN3_STATUS		ST40_DMAC_CHANX_STATUS(0x400)
+#define ST40_DMAC_CHAN3_ACTION		ST40_DMAC_CHANX_ACTION(0x400)
+#define ST40_DMAC_CHAN3_POINTER		ST40_DMAC_CHANX_POINTER(0x400)
+#define ST40_DMAC_CHAN3_REQUEST		ST40_DMAC_CHANX_REQUEST(0x400)
+#define ST40_DMAC_CHAN3_CONTROL		ST40_DMAC_CHANX_CONTROL(0x400)
+#define ST40_DMAC_CHAN3_COUNT		ST40_DMAC_CHANX_COUNT(0x400)
+#define ST40_DMAC_CHAN3_SAR		ST40_DMAC_CHANX_SAR(0x400)
+#define ST40_DMAC_CHAN3_DAR		ST40_DMAC_CHANX_DAR(0x400)
+#define ST40_DMAC_CHAN3_NEXT_PTR	ST40_DMAC_CHANX_NEXT_PTR(0x400)
+#define ST40_DMAC_CHAN3_SRC_LENGTH	ST40_DMAC_CHANX_SRC_LENGTH(0x400)
+#define ST40_DMAC_CHAN3_SRC_STRIDE	ST40_DMAC_CHANX_SRC_STRIDE(0x400)
+#define ST40_DMAC_CHAN3_DST_LENGTH	ST40_DMAC_CHANX_DST_LENGTH(0x400)
+#define ST40_DMAC_CHAN3_DST_STRIDE	ST40_DMAC_CHANX_DST_STRIDE(0x400)
+
+#define ST40_DMAC_CHAN4_IDENTITY	ST40_DMAC_CHANX_IDENTITY(0x500)
+#define ST40_DMAC_CHAN4_ENABLE		ST40_DMAC_CHANX_ENABLE(0x500)
+#define ST40_DMAC_CHAN4_DISABLE		ST40_DMAC_CHANX_DISABLE(0x500)
+#define ST40_DMAC_CHAN4_STATUS		ST40_DMAC_CHANX_STATUS(0x500)
+#define ST40_DMAC_CHAN4_ACTION		ST40_DMAC_CHANX_ACTION(0x500)
+#define ST40_DMAC_CHAN4_POINTER		ST40_DMAC_CHANX_POINTER(0x500)
+#define ST40_DMAC_CHAN4_REQUEST		ST40_DMAC_CHANX_REQUEST(0x500)
+#define ST40_DMAC_CHAN4_CONTROL		ST40_DMAC_CHANX_CONTROL(0x500)
+#define ST40_DMAC_CHAN4_COUNT		ST40_DMAC_CHANX_COUNT(0x500)
+#define ST40_DMAC_CHAN4_SAR		ST40_DMAC_CHANX_SAR(0x500)
+#define ST40_DMAC_CHAN4_DAR		ST40_DMAC_CHANX_DAR(0x500)
+#define ST40_DMAC_CHAN4_NEXT_PTR	ST40_DMAC_CHANX_NEXT_PTR(0x500)
+#define ST40_DMAC_CHAN4_SRC_LENGTH	ST40_DMAC_CHANX_SRC_LENGTH(0x500)
+#define ST40_DMAC_CHAN4_SRC_STRIDE	ST40_DMAC_CHANX_SRC_STRIDE(0x500)
+#define ST40_DMAC_CHAN4_DST_LENGTH	ST40_DMAC_CHANX_DST_LENGTH(0x500)
+#define ST40_DMAC_CHAN4_DST_STRIDE	ST40_DMAC_CHANX_DST_STRIDE(0x500)
+
+#define ST40_DMAC_VCR_STATUS		SH4_DWORD_REG(ST40_DMAC_REGS_BASE + 0x00)
+#define ST40_DMAC_VCR_VERSION		SH4_DWORD_REG(ST40_DMAC_REGS_BASE + 0x08)
+#define ST40_DMAC_ENABLE		SH4_DWORD_REG(ST40_DMAC_REGS_BASE + 0x10)
+#define ST40_DMAC_DISABLE		SH4_DWORD_REG(ST40_DMAC_REGS_BASE + 0x18)
+#define ST40_DMAC_STATUS		SH4_DWORD_REG(ST40_DMAC_REGS_BASE + 0x20)
+#define ST40_DMAC_INTERRUPT		SH4_DWORD_REG(ST40_DMAC_REGS_BASE + 0x28)
+#define ST40_DMAC_ERROR			SH4_DWORD_REG(ST40_DMAC_REGS_BASE + 0x30)
+#define ST40_DMAC_DEFINED		SH4_DWORD_REG(ST40_DMAC_REGS_BASE + 0x38)
+#define ST40_DMAC_HANDSHAKE		SH4_DWORD_REG(ST40_DMAC_REGS_BASE + 0x40)
+
+/* Parallel I/O control registers (all ST40 variants) */
+#define ST40_PIO_POUT(n)	SH4_DWORD_REG(ST40_PIO##n##_REGS_BASE + 0x00)
+#define ST40_PIO_PIN(n)		SH4_DWORD_REG(ST40_PIO##n##_REGS_BASE + 0x10)
+#define ST40_PIO_PC0(n)		SH4_DWORD_REG(ST40_PIO##n##_REGS_BASE + 0x20)
+#define ST40_PIO_PC1(n)		SH4_DWORD_REG(ST40_PIO##n##_REGS_BASE + 0x30)
+#define ST40_PIO_PC2(n)		SH4_DWORD_REG(ST40_PIO##n##_REGS_BASE + 0x40)
+#define ST40_PIO_PCOMP(n)	SH4_DWORD_REG(ST40_PIO##n##_REGS_BASE + 0x50)
+#define ST40_PIO_PMASK(n)	SH4_DWORD_REG(ST40_PIO##n##_REGS_BASE + 0x60)
+
+/* PIO pseudo registers */
+#define ST40_PIO_SET_POUT(n)	SH4_DWORD_REG(ST40_PIO##n##_REGS_BASE + 0x04)
+#define ST40_PIO_CLEAR_POUT(n)	SH4_DWORD_REG(ST40_PIO##n##_REGS_BASE + 0x08)
+#define ST40_PIO_SET_PC0(n)	SH4_DWORD_REG(ST40_PIO##n##_REGS_BASE + 0x24)
+#define ST40_PIO_CLEAR_PC0(n)	SH4_DWORD_REG(ST40_PIO##n##_REGS_BASE + 0x28)
+#define ST40_PIO_SET_PC1(n)	SH4_DWORD_REG(ST40_PIO##n##_REGS_BASE + 0x34)
+#define ST40_PIO_CLEAR_PC1(n)	SH4_DWORD_REG(ST40_PIO##n##_REGS_BASE + 0x38)
+#define ST40_PIO_SET_PC2(n)	SH4_DWORD_REG(ST40_PIO##n##_REGS_BASE + 0x44)
+#define ST40_PIO_CLEAR_PC2(n)	SH4_DWORD_REG(ST40_PIO##n##_REGS_BASE + 0x48)
+#define ST40_PIO_SET_PCOMP(n)	SH4_DWORD_REG(ST40_PIO##n##_REGS_BASE + 0x54)
+#define ST40_PIO_CLEAR_PCOMP(n)	SH4_DWORD_REG(ST40_PIO##n##_REGS_BASE + 0x58)
+#define ST40_PIO_SET_PMASK(n)	SH4_DWORD_REG(ST40_PIO##n##_REGS_BASE + 0x64)
+#define ST40_PIO_CLEAR_PMASK(n)	SH4_DWORD_REG(ST40_PIO##n##_REGS_BASE + 0x68)
+
+/* Local Memory Interface control registers (all ST40 variants).
+   Define ST40_LMI_VERSION for standard LMIs and ST40_LMIGP_VERSION for GP LMIs.
+ */
+#if !(defined(ST40_LMI_VERSION) || defined(ST40_LMIGP_VERSION))
+/* For variants which do not define which LMI they have we define
+   ST40_LMI_VERSION 2 as the default.
+ */
+#define ST40_LMI_VERSION 2
+#endif
+#if defined(ST40_LMI_VERSION)
+#define ST40_LMI_VCR_0(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000000)
+#define ST40_LMI_VCR_1(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000004)
+#define ST40_LMI_VCR(n)		SH4_GWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000000)
+#define ST40_LMI_MIM_0(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000008)
+#define ST40_LMI_MIM_1(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x00000c)
+#define ST40_LMI_MIM(n)		SH4_GWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000008)
+#define ST40_LMI_SCR_0(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000010)
+#define ST40_LMI_SCR_1(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000014)
+#define ST40_LMI_SCR(n)		SH4_GWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000010)
+#define ST40_LMI_STR_0(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000018)
+#define ST40_LMI_STR_1(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x00001c)
+#define ST40_LMI_STR(n)		SH4_GWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000018)
+#define ST40_LMI_PBS_0(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000020)
+#define ST40_LMI_PBS_1(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000024)
+#define ST40_LMI_PBS(n)		SH4_GWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000020)
+#define ST40_LMI_COC_0(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000028)
+#define ST40_LMI_COC_1(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x00002c)
+#define ST40_LMI_COC(n)		SH4_GWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000028)
+#define ST40_LMI_SDRA0_0(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000030)
+#define ST40_LMI_SDRA0_1(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000034)
+#define ST40_LMI_SDRA0(n)	SH4_GWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000030)
+#define ST40_LMI_SDRA1_0(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000038)
+#define ST40_LMI_SDRA1_1(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x00003c)
+#define ST40_LMI_SDRA1(n)	SH4_GWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000038)
+#define ST40_LMI_CIC_0(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000040)
+#define ST40_LMI_CIC_1(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000044)
+#define ST40_LMI_CIC(n)		SH4_GWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000040)
+#if (ST40_LMI_VERSION > 2)
+#define ST40_LMI_SDMR0(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000048)
+#define ST40_LMI_SDMR1(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000050)
+#else
+#define ST40_LMI_SDMR0(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x800000)
+#define ST40_LMI_SDMR1(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x900000)
+#endif
+#elif defined(ST40_LMIGP_VERSION)
+#define ST40_LMI_VCR_0(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000000)
+#define ST40_LMI_VCR_1(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000004)
+#define ST40_LMI_VCR(n)		SH4_GWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000000)
+#define ST40_LMI_MIM_0(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000008)
+#define ST40_LMI_MIM_1(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x00000c)
+#define ST40_LMI_MIM(n)		SH4_GWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000008)
+#define ST40_LMI_SCR_0(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000010)
+#define ST40_LMI_SCR_1(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000014)
+#define ST40_LMI_SCR(n)		SH4_GWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000010)
+#define ST40_LMI_STR_0(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000018)
+#define ST40_LMI_STR_1(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x00001c)
+#define ST40_LMI_STR(n)		SH4_GWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000018)
+#define ST40_LMI_GCC_0(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000028)
+#define ST40_LMI_GCC_1(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x00002c)
+#define ST40_LMI_GCC(n)		SH4_GWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000028)
+#define ST40_LMI_SDRA0_0(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000030)
+#define ST40_LMI_SDRA0_1(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000034)
+#define ST40_LMI_SDRA0(n)	SH4_GWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000030)
+#define ST40_LMI_SDRA1_0(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000038)
+#define ST40_LMI_SDRA1_1(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x00003c)
+#define ST40_LMI_SDRA1(n)	SH4_GWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000038)
+#define ST40_LMI_CCO_0(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000040)
+#define ST40_LMI_CCO_1(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000044)
+#define ST40_LMI_CCO(n)		SH4_GWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000040)
+#define ST40_LMI_SDMR0(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000048)
+#define ST40_LMI_SDMR1(n)	SH4_DWORD_REG(ST40_LMI##n##_REGS_BASE + 0x000050)
+#endif
+
+/* Enhanced Flash Memory Interface control registers (all ST40 variants) */
+#define ST40_EMI_VCR_0			SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0000)
+#define ST40_EMI_VCR_1			SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0004)
+#define ST40_EMI_VCR			SH4_GWORD_REG(ST40_EMI_REGS_BASE + 0x0000)
+#define ST40_EMI_STATUSCFG		SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0010)
+#define ST40_EMI_STATUSLOCK		SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0018)
+#define ST40_EMI_LOCK			SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0020)
+#define ST40_EMI_GENCFG			SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0028)
+#define ST40_EMI_SDRAMNOPGEN		SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0030)
+#define ST40_EMI_SDRAMMODEREG		SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0038)
+#define ST40_EMI_SDRAMINIT		SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0040)
+#define ST40_EMI_REFRESHINIT		SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0048)
+#define ST40_EMI_FLASHCLKSEL		SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0050)
+#define ST40_EMI_SDRAMCLKSEL		SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0058)
+#define ST40_EMI_MPXCLKSEL		SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0060)
+#define ST40_EMI_CLKENABLE		SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0068)
+#define ST40_EMI_BANK0_EMICONFIGDATA0	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0100)
+#define ST40_EMI_BANK0_EMICONFIGDATA1	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0108)
+#define ST40_EMI_BANK0_EMICONFIGDATA2	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0110)
+#define ST40_EMI_BANK0_EMICONFIGDATA3	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0118)
+#define ST40_EMI_BANK1_EMICONFIGDATA0	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0140)
+#define ST40_EMI_BANK1_EMICONFIGDATA1	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0148)
+#define ST40_EMI_BANK1_EMICONFIGDATA2	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0150)
+#define ST40_EMI_BANK1_EMICONFIGDATA3	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0158)
+#define ST40_EMI_BANK2_EMICONFIGDATA0	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0180)
+#define ST40_EMI_BANK2_EMICONFIGDATA1	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0188)
+#define ST40_EMI_BANK2_EMICONFIGDATA2	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0190)
+#define ST40_EMI_BANK2_EMICONFIGDATA3	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0198)
+#define ST40_EMI_BANK3_EMICONFIGDATA0	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x01c0)
+#define ST40_EMI_BANK3_EMICONFIGDATA1	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x01c8)
+#define ST40_EMI_BANK3_EMICONFIGDATA2	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x01d0)
+#define ST40_EMI_BANK3_EMICONFIGDATA3	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x01d8)
+#define ST40_EMI_BANK4_EMICONFIGDATA0	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0200)
+#define ST40_EMI_BANK4_EMICONFIGDATA1	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0208)
+#define ST40_EMI_BANK4_EMICONFIGDATA2	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0210)
+#define ST40_EMI_BANK4_EMICONFIGDATA3	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0218)
+#define ST40_EMI_BANK5_EMICONFIGDATA0	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0240)
+#define ST40_EMI_BANK5_EMICONFIGDATA1	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0248)
+#define ST40_EMI_BANK5_EMICONFIGDATA2	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0250)
+#define ST40_EMI_BANK5_EMICONFIGDATA3	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0258)
+
+#define ST40_EMI_BASEADDRESS(bank)	SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0800 + (bank)*0x0010)
+#define ST40_EMI_BANK0_BASEADDRESS	ST40_EMI_BASEADDRESS(0)
+#define ST40_EMI_BANK1_BASEADDRESS	ST40_EMI_BASEADDRESS(1)
+#define ST40_EMI_BANK2_BASEADDRESS	ST40_EMI_BASEADDRESS(2)
+#define ST40_EMI_BANK3_BASEADDRESS	ST40_EMI_BASEADDRESS(3)
+#define ST40_EMI_BANK4_BASEADDRESS	ST40_EMI_BASEADDRESS(4)
+#define ST40_EMI_BANK5_BASEADDRESS	ST40_EMI_BASEADDRESS(5)
+#define ST40_EMI_BANK_ENABLE		SH4_DWORD_REG(ST40_EMI_REGS_BASE + 0x0860)
+
+/* EMI NAND flash registers */
+#define ST40_EMI_NAND_REGS_BASE			(ST40_EMI_REGS_BASE + 0x1000)
+#define ST40_EMI_NAND_BOOTBANK_CFG		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0000)
+#define ST40_EMI_NAND_RBN_STA			SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0004)
+#define ST40_EMI_NAND_INT_EN			SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0010)
+#define ST40_EMI_NAND_INT_STA			SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0014)
+#define ST40_EMI_NAND_INT_CLR			SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0018)
+#define ST40_EMI_NAND_INT_EDGE_CFG		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x001c)
+#define ST40_EMI_NAND_CTL_TIMING		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0040)
+#define ST40_EMI_NAND_WEN_TIMING		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0044)
+#define ST40_EMI_NAND_REN_TIMING		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0048)
+#define ST40_EMI_NAND_BLOCK_ZERO_REMAP_REG	SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x004C)
+#define ST40_EMI_NAND_FLEXMODE_CFG		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0100)
+#define ST40_EMI_NAND_FLEX_MUXCTRL		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0104)
+#define ST40_EMI_NAND_FLEX_CS_ALT		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0108)
+#define ST40_EMI_NAND_FLEX_DATAWRT_CFG		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x010c)
+#define ST40_EMI_NAND_FLEX_DATA_RD_CFG		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0110)
+#define ST40_EMI_NAND_FLEX_CMD			SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0114)
+#define ST40_EMI_NAND_FLEX_ADD_REG		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0118)
+#define ST40_EMI_NAND_FLEX_DATA			SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0120)
+#define ST40_EMI_NAND_VERSION_REG		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0144)
+#define ST40_EMI_NAND_ADDRESS_REG_1		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x01E0)
+#define ST40_EMI_NAND_ADDRESS_REG_2		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x01E4)
+#define ST40_EMI_NAND_ADDRESS_REG_3		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x01E8)
+#define ST40_EMI_NAND_MULTI_CS_CONFIG_REG	SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x01EC)
+#define ST40_EMI_NAND_SEQ_REG1			SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0200)
+#define ST40_EMI_NAND_SEQ_REG2			SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0204)
+#define ST40_EMI_NAND_SEQ_REG3			SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0208)
+#define ST40_EMI_NAND_SEQ_REG4			SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x020c)
+#define ST40_EMI_NAND_ADD			SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0210)
+#define ST40_EMI_NAND_EXTRA_REG			SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0214)
+#define ST40_EMI_NAND_CMD			SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0218)
+#define ST40_EMI_NAND_SEQ_CFG			SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x021c)
+#define ST40_EMI_NAND_GEN_CFG			SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0220)
+#define ST40_EMI_NAND_SEQ_STA			SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0240)
+#define ST40_EMI_NAND_ECC_CHECKCODE_0		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0280)
+#define ST40_EMI_NAND_ECC_CHECKCODE_1		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0284)
+#define ST40_EMI_NAND_ECC_CHECKCODE_2		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0288)
+#define ST40_EMI_NAND_ECC_CHECKCODE_3		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x028c)
+#define ST40_EMI_NAND_ECC_CHECKCODE_2X8_0	SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0290)
+#define ST40_EMI_NAND_ECC_CHECKCODE_2X8_1	SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0294)
+#define ST40_EMI_NAND_ECC_CHECKCODE_2X8_2	SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0298)
+#define ST40_EMI_NAND_ECC_CHECKCODE_2X8_3	SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x029C)
+#define ST40_EMI_NAND_DATA_FIFO_REG		SH4_DWORD_REG(ST40_EMI_NAND_REGS_BASE + 0x0300)
+
+/* EMI SPI serial flash registers */
+#define ST40_EMI_SPI_REGS_BASE			(ST40_EMI_REGS_BASE + 0x2000)
+#define ST40_EMI_SPI_CLOCKDIV			SH4_DWORD_REG(ST40_EMI_SPI_REGS_BASE + 0x0010)
+#define ST40_EMI_SPI_MODESELECT			SH4_DWORD_REG(ST40_EMI_SPI_REGS_BASE + 0x0018)
+#define ST40_EMI_SPI_CONFIGDATA			SH4_DWORD_REG(ST40_EMI_SPI_REGS_BASE + 0x0020)
+#define ST40_EMI_SPI_STATUSMODECHANGE		SH4_DWORD_REG(ST40_EMI_SPI_REGS_BASE + 0x0028)
+
+/* Peripheral Component Interconnect control registers (all ST40 variants) */
+/* PCI Local Registers */
+#define ST40_PCI_VCR_STATUS	SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000000)
+#define ST40_PCI_VCR_VERSION	SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000008)
+#define ST40_PCI_CR		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000010)
+#define ST40_PCI_LSR0		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000014)
+#define ST40_PCI_LAR0		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x00001c)
+#define ST40_PCI_INT		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000024)
+#define ST40_PCI_INTM		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000028)
+#define ST40_PCI_AIR		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x00002c)
+#define ST40_PCI_CIR		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000030)
+#define ST40_PCI_AINT		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000040)
+#define ST40_PCI_AINTM		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000044)
+#define ST40_PCI_BMIR		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000048)
+#define ST40_PCI_PAR		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x00004c)
+#define ST40_PCI_MBR		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000050)
+#define ST40_PCI_IOBR		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000054)
+#define ST40_PCI_PINT		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000058)
+#define ST40_PCI_PINTM		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x00005c)
+#define ST40_PCI_MBMR		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000070)
+#define ST40_PCI_IOBMR		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000074)
+
+/* PCI Local Configuration Registers */
+#define ST40_PCI_WCBAR		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x00007c)
+#define ST40_PCI_LOCCFG_UNLOCK	SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000034)
+#define ST40_PCI_RBARR0		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000100)
+#define ST40_PCI_RSR0		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000104)
+#define ST40_PCI_RLAR0		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000108)
+#define ST40_PCI_RBARR1		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000110)
+#define ST40_PCI_RSR1		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000114)
+#define ST40_PCI_RLAR1		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000118)
+#define ST40_PCI_RBARR2		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000120)
+#define ST40_PCI_RSR2		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000124)
+#define ST40_PCI_RLAR2		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000128)
+#define ST40_PCI_RBARR3		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000130)
+#define ST40_PCI_RSR3		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000134)
+#define ST40_PCI_RLAR3		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000138)
+#define ST40_PCI_RBARR4		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000140)
+#define ST40_PCI_RSR4		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000144)
+#define ST40_PCI_RLAR4		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000148)
+#define ST40_PCI_RBARR5		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000150)
+#define ST40_PCI_RSR5		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000154)
+#define ST40_PCI_RLAR5		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000158)
+#define ST40_PCI_RBARR6		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000160)
+#define ST40_PCI_RSR6		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000164)
+#define ST40_PCI_RLAR6		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000168)
+#define ST40_PCI_RBARR7		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000170)
+#define ST40_PCI_RSR7		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000174)
+#define ST40_PCI_RLAR7		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x000178)
+
+/* PCI Configuration Space Registers (CSR) */
+#define ST40_PCI_VID		SH4_WORD_REG(ST40_PCI_REGS_BASE + 0x010000)
+#define ST40_PCI_DID		SH4_WORD_REG(ST40_PCI_REGS_BASE + 0x010002)
+#define ST40_PCI_CMD		SH4_WORD_REG(ST40_PCI_REGS_BASE + 0x010004)
+#define ST40_PCI_STATUS		SH4_WORD_REG(ST40_PCI_REGS_BASE + 0x010006)
+#define ST40_PCI_RID_CLASS	SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x010008)
+#define ST40_PCI_CLS		SH4_BYTE_REG(ST40_PCI_REGS_BASE + 0x01000c)
+#define ST40_PCI_MLT		SH4_BYTE_REG(ST40_PCI_REGS_BASE + 0x01000d)
+#define ST40_PCI_HDR		SH4_BYTE_REG(ST40_PCI_REGS_BASE + 0x01000e)
+#define ST40_PCI_BIST		SH4_BYTE_REG(ST40_PCI_REGS_BASE + 0x01000f)
+#define ST40_PCI_MBAR0		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x010010)
+#define ST40_PCI_IBAR		SH4_DWORD_REG(ST40_PCI_REGS_BASE + 0x010018)
+#define ST40_PCI_SVID		SH4_WORD_REG(ST40_PCI_REGS_BASE + 0x01002c)
+#define ST40_PCI_SID		SH4_WORD_REG(ST40_PCI_REGS_BASE + 0x01002e)
+#define ST40_PCI_CP		SH4_BYTE_REG(ST40_PCI_REGS_BASE + 0x010034)
+#define ST40_PCI_INTLINE	SH4_BYTE_REG(ST40_PCI_REGS_BASE + 0x01003c)
+#define ST40_PCI_INTPIN		SH4_BYTE_REG(ST40_PCI_REGS_BASE + 0x01003d)
+#define ST40_PCI_MINGNT		SH4_BYTE_REG(ST40_PCI_REGS_BASE + 0x01003e)
+#define ST40_PCI_MAXLAT		SH4_BYTE_REG(ST40_PCI_REGS_BASE + 0x01003f)
+#define ST40_PCI_TRDYTIME	SH4_BYTE_REG(ST40_PCI_REGS_BASE + 0x010040)
+#define ST40_PCI_RETRYTIME	SH4_BYTE_REG(ST40_PCI_REGS_BASE + 0x010041)
+#define ST40_PCI_CID		SH4_BYTE_REG(ST40_PCI_REGS_BASE + 0x0100dc)
+#define ST40_PCI_NIP		SH4_BYTE_REG(ST40_PCI_REGS_BASE + 0x0100dd)
+#define ST40_PCI_PMC		SH4_WORD_REG(ST40_PCI_REGS_BASE + 0x0100de)
+#define ST40_PCI_PMCSR		SH4_WORD_REG(ST40_PCI_REGS_BASE + 0x0100e0)
+#define ST40_PCI_PMCSR_BSE	SH4_BYTE_REG(ST40_PCI_REGS_BASE + 0x0100e2)
+#define ST40_PCI_PCDD		SH4_BYTE_REG(ST40_PCI_REGS_BASE + 0x0100e3)
+
+/* External MicroProcessor Interface control registers (all ST40 variants) */
+#define ST40_EMPI_VCR_STATUS	SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0000)
+#define ST40_EMPI_VCR_VERSION	SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0008)
+#define ST40_EMPI_SYSTEM	SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0010)
+#define ST40_EMPI_ISTATUS	SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0018)
+#define ST40_EMPI_IMASK		SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0020)
+#define ST40_EMPI_MPXCFG	SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0028)
+#define ST40_EMPI_DMAINV	SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0030)
+#define ST40_EMPI_DMACFG0	SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0080)
+#define ST40_EMPI_DMACFG1	SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0088)
+#define ST40_EMPI_DMACFG2	SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0090)
+#define ST40_EMPI_DMACFG3	SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0098)
+#define ST40_EMPI_DSTATUS0	SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0100)
+#define ST40_EMPI_DSTATUS1	SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0108)
+#define ST40_EMPI_DSTATUS2	SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0110)
+#define ST40_EMPI_DSTATUS3	SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0118)
+#define ST40_EMPI_RBAR0		SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0200)
+#define ST40_EMPI_RSR0		SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0208)
+#define ST40_EMPI_RLAR0		SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0210)
+#define ST40_EMPI_RBAR1		SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0220)
+#define ST40_EMPI_RSR1		SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0228)
+#define ST40_EMPI_RLAR1		SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0230)
+#define ST40_EMPI_RBAR2		SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0240)
+#define ST40_EMPI_RSR2		SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0248)
+#define ST40_EMPI_RLAR2		SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0250)
+#define ST40_EMPI_RBAR3		SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0260)
+#define ST40_EMPI_RSR3		SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0268)
+#define ST40_EMPI_RLAR3		SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0270)
+#define ST40_EMPI_RBAR4		SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0280)
+#define ST40_EMPI_RSR4		SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0288)
+#define ST40_EMPI_RLAR4		SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x0290)
+#define ST40_EMPI_RBAR5		SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x02a0)
+#define ST40_EMPI_RSR5		SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x02a8)
+#define ST40_EMPI_RLAR5		SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x02b0)
+#define ST40_EMPI_RBAR6		SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x02c0)
+#define ST40_EMPI_RSR6		SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x02c8)
+#define ST40_EMPI_RLAR6		SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x02d0)
+#define ST40_EMPI_RBAR7		SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x02e0)
+#define ST40_EMPI_RSR7		SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x02e8)
+#define ST40_EMPI_RLAR7		SH4_DWORD_REG(ST40_EMPI_REGS_BASE + 0x02f0)
+
+/* MPX Arbiter control registers (all ST40 variants) */
+#define ST40_MPXARB_VCR		SH4_DWORD_REG(ST40_MPXARB_REGS_BASE + 0x0000)
+#define ST40_MPXARB_CONTROL	SH4_DWORD_REG(ST40_MPXARB_REGS_BASE + 0x0010)
+#define ST40_MPXARB_DLLCONTROL	SH4_DWORD_REG(ST40_MPXARB_REGS_BASE + 0x4000)
+#define ST40_MPXARB_DLLSTATUS	SH4_DWORD_REG(ST40_MPXARB_REGS_BASE + 0x4010)
+
+/* Mailbox control registers (all ST40 variants) */
+#define ST40_MAILBOX_ID_VER(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0000)
+#define ST40_MAILBOX_GROUP1_INTERRUPT_STATUS_REG1(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0004)
+#define ST40_MAILBOX_GROUP1_INTERRUPT_STATUS_REG2(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0008)
+#define ST40_MAILBOX_GROUP1_INTERRUPT_STATUS_REG3(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x000c)
+#define ST40_MAILBOX_GROUP1_INTERRUPT_STATUS_REG4(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0010)
+#define ST40_MAILBOX_GROUP1_INTERRUPT_STATUS_REG1_SET(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0024)
+#define ST40_MAILBOX_GROUP1_INTERRUPT_STATUS_REG2_SET(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0028)
+#define ST40_MAILBOX_GROUP1_INTERRUPT_STATUS_REG3_SET(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x002c)
+#define ST40_MAILBOX_GROUP1_INTERRUPT_STATUS_REG4_SET(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0030)
+#define ST40_MAILBOX_GROUP1_INTERRUPT_STATUS_REG1_CLR(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0044)
+#define ST40_MAILBOX_GROUP1_INTERRUPT_STATUS_REG2_CLR(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0048)
+#define ST40_MAILBOX_GROUP1_INTERRUPT_STATUS_REG3_CLR(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x004c)
+#define ST40_MAILBOX_GROUP1_INTERRUPT_STATUS_REG4_CLR(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0050)
+#define ST40_MAILBOX_GROUP1_INTERRUPT_ENABLE_REG1(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0064)
+#define ST40_MAILBOX_GROUP1_INTERRUPT_ENABLE_REG2(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0068)
+#define ST40_MAILBOX_GROUP1_INTERRUPT_ENABLE_REG3(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x006c)
+#define ST40_MAILBOX_GROUP1_INTERRUPT_ENABLE_REG4(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0070)
+#define ST40_MAILBOX_GROUP1_INTERRUPT_ENABLE_REG1_SET(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0084)
+#define ST40_MAILBOX_GROUP1_INTERRUPT_ENABLE_REG2_SET(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0088)
+#define ST40_MAILBOX_GROUP1_INTERRUPT_ENABLE_REG3_SET(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x008c)
+#define ST40_MAILBOX_GROUP1_INTERRUPT_ENABLE_REG4_SET(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0090)
+#define ST40_MAILBOX_GROUP1_INTERRUPT_ENABLE_REG1_CLR(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x00a4)
+#define ST40_MAILBOX_GROUP1_INTERRUPT_ENABLE_REG2_CLR(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x00a8)
+#define ST40_MAILBOX_GROUP1_INTERRUPT_ENABLE_REG3_CLR(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x00ac)
+#define ST40_MAILBOX_GROUP1_INTERRUPT_ENABLE_REG4_CLR(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x00b0)
+#define ST40_MAILBOX_GROUP2_INTERRUPT_STATUS_REG1(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0104)
+#define ST40_MAILBOX_GROUP2_INTERRUPT_STATUS_REG2(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0108)
+#define ST40_MAILBOX_GROUP2_INTERRUPT_STATUS_REG3(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x010c)
+#define ST40_MAILBOX_GROUP2_INTERRUPT_STATUS_REG4(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0110)
+#define ST40_MAILBOX_GROUP2_INTERRUPT_STATUS_REG1_SET(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0124)
+#define ST40_MAILBOX_GROUP2_INTERRUPT_STATUS_REG2_SET(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0128)
+#define ST40_MAILBOX_GROUP2_INTERRUPT_STATUS_REG3_SET(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x012c)
+#define ST40_MAILBOX_GROUP2_INTERRUPT_STATUS_REG4_SET(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0130)
+#define ST40_MAILBOX_GROUP2_INTERRUPT_STATUS_REG1_CLR(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0144)
+#define ST40_MAILBOX_GROUP2_INTERRUPT_STATUS_REG2_CLR(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0148)
+#define ST40_MAILBOX_GROUP2_INTERRUPT_STATUS_REG3_CLR(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x014c)
+#define ST40_MAILBOX_GROUP2_INTERRUPT_STATUS_REG4_CLR(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0150)
+#define ST40_MAILBOX_GROUP2_INTERRUPT_ENABLE_REG1(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0164)
+#define ST40_MAILBOX_GROUP2_INTERRUPT_ENABLE_REG2(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0168)
+#define ST40_MAILBOX_GROUP2_INTERRUPT_ENABLE_REG3(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x016c)
+#define ST40_MAILBOX_GROUP2_INTERRUPT_ENABLE_REG4(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0170)
+#define ST40_MAILBOX_GROUP2_INTERRUPT_ENABLE_REG1_SET(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0184)
+#define ST40_MAILBOX_GROUP2_INTERRUPT_ENABLE_REG2_SET(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0188)
+#define ST40_MAILBOX_GROUP2_INTERRUPT_ENABLE_REG3_SET(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x018c)
+#define ST40_MAILBOX_GROUP2_INTERRUPT_ENABLE_REG4_SET(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0190)
+#define ST40_MAILBOX_GROUP2_INTERRUPT_ENABLE_REG1_CLR(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x01a4)
+#define ST40_MAILBOX_GROUP2_INTERRUPT_ENABLE_REG2_CLR(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x01a8)
+#define ST40_MAILBOX_GROUP2_INTERRUPT_ENABLE_REG3_CLR(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x01ac)
+#define ST40_MAILBOX_GROUP2_INTERRUPT_ENABLE_REG4_CLR(n)	SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x01b0)
+#define ST40_MAILBOX_LOCK0(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0200)
+#define ST40_MAILBOX_LOCK1(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0204)
+#define ST40_MAILBOX_LOCK2(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0208)
+#define ST40_MAILBOX_LOCK3(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x020c)
+#define ST40_MAILBOX_LOCK4(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0210)
+#define ST40_MAILBOX_LOCK5(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0214)
+#define ST40_MAILBOX_LOCK6(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0218)
+#define ST40_MAILBOX_LOCK7(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x021c)
+#define ST40_MAILBOX_LOCK8(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0220)
+#define ST40_MAILBOX_LOCK9(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0224)
+#define ST40_MAILBOX_LOCK10(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0228)
+#define ST40_MAILBOX_LOCK11(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x022c)
+#define ST40_MAILBOX_LOCK12(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0230)
+#define ST40_MAILBOX_LOCK13(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0234)
+#define ST40_MAILBOX_LOCK14(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0238)
+#define ST40_MAILBOX_LOCK15(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x023c)
+#define ST40_MAILBOX_LOCK16(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0240)
+#define ST40_MAILBOX_LOCK17(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0244)
+#define ST40_MAILBOX_LOCK18(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0248)
+#define ST40_MAILBOX_LOCK19(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x024c)
+#define ST40_MAILBOX_LOCK20(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0250)
+#define ST40_MAILBOX_LOCK21(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0254)
+#define ST40_MAILBOX_LOCK22(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0258)
+#define ST40_MAILBOX_LOCK23(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x025c)
+#define ST40_MAILBOX_LOCK24(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0260)
+#define ST40_MAILBOX_LOCK25(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0264)
+#define ST40_MAILBOX_LOCK26(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0268)
+#define ST40_MAILBOX_LOCK27(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x026c)
+#define ST40_MAILBOX_LOCK28(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0270)
+#define ST40_MAILBOX_LOCK29(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0274)
+#define ST40_MAILBOX_LOCK30(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x0278)
+#define ST40_MAILBOX_LOCK31(n)		SH4_DWORD_REG(ST40_MAILBOX##n##_REGS_BASE + 0x027c)
+
+/* System configuration registers (all ST40 variants) */
+#define ST40_SYSCONF_VCR		SH4_DWORD_REG(ST40_SYSCONF_REGS_BASE + 0x00)
+#define ST40_SYSCONF_SYS_CON1_0		SH4_DWORD_REG(ST40_SYSCONF_REGS_BASE + 0x10)
+#define ST40_SYSCONF_SYS_CON1_1		SH4_DWORD_REG(ST40_SYSCONF_REGS_BASE + 0x14)
+#define ST40_SYSCONF_SYS_CON1		SH4_GWORD_REG(ST40_SYSCONF_REGS_BASE + 0x10)
+#define ST40_SYSCONF_SYS_CON2_0		SH4_DWORD_REG(ST40_SYSCONF_REGS_BASE + 0x18)
+#define ST40_SYSCONF_SYS_CON2_1		SH4_DWORD_REG(ST40_SYSCONF_REGS_BASE + 0x1c)
+#define ST40_SYSCONF_SYS_CON2		SH4_GWORD_REG(ST40_SYSCONF_REGS_BASE + 0x18)
+#define ST40_SYSCONF_CNV_STATUS		SH4_BYTE_REG(ST40_SYSCONF_REGS_BASE + 0x20)
+#define ST40_SYSCONF_CNV_SET		SH4_BYTE_REG(ST40_SYSCONF_REGS_BASE + 0x28)
+#define ST40_SYSCONF_CNV_CLEAR		SH4_BYTE_REG(ST40_SYSCONF_REGS_BASE + 0x30)
+#define ST40_SYSCONF_CNV_CONTROL	SH4_DWORD_REG(ST40_SYSCONF_REGS_BASE + 0x38)
+#define ST40_SYSCONF_SYS_STAT1_0	SH4_DWORD_REG(ST40_SYSCONF_REGS_BASE + 0x40)
+#define ST40_SYSCONF_SYS_STAT1_1	SH4_DWORD_REG(ST40_SYSCONF_REGS_BASE + 0x44)
+#define ST40_SYSCONF_SYS_STAT1		SH4_GWORD_REG(ST40_SYSCONF_REGS_BASE + 0x40)
+#define ST40_SYSCONF_SYS_STAT2_0	SH4_DWORD_REG(ST40_SYSCONF_REGS_BASE + 0x48)
+#define ST40_SYSCONF_SYS_STAT2_1	SH4_DWORD_REG(ST40_SYSCONF_REGS_BASE + 0x4c)
+#define ST40_SYSCONF_SYS_STAT2		SH4_GWORD_REG(ST40_SYSCONF_REGS_BASE + 0x48)
+
+/* Synchronous Serial Controller control registers (all ST40 variants) */
+#define ST40_SSC_BRG(n)			SH4_WORD_REG(ST40_SSC##n##_REGS_BASE + 0x0000)
+#define ST40_SSC_TBUF(n)		SH4_WORD_REG(ST40_SSC##n##_REGS_BASE + 0x0004)
+#define ST40_SSC_RBUF(n)		SH4_WORD_REG(ST40_SSC##n##_REGS_BASE + 0x0008)
+#define ST40_SSC_CTL(n)			SH4_WORD_REG(ST40_SSC##n##_REGS_BASE + 0x000c)
+#define ST40_SSC_IEN(n)			SH4_WORD_REG(ST40_SSC##n##_REGS_BASE + 0x0010)
+#define ST40_SSC_STA(n)			SH4_WORD_REG(ST40_SSC##n##_REGS_BASE + 0x0014)
+#define ST40_SSC_I2C(n)			SH4_WORD_REG(ST40_SSC##n##_REGS_BASE + 0x0018)
+#define ST40_SSC_SLAD(n)		SH4_WORD_REG(ST40_SSC##n##_REGS_BASE + 0x001c)
+#define ST40_SSC_REP_START_HOLD(n)	SH4_WORD_REG(ST40_SSC##n##_REGS_BASE + 0x0020)
+#define ST40_SSC_START_HOLD(n)		SH4_WORD_REG(ST40_SSC##n##_REGS_BASE + 0x0024)
+#define ST40_SSC_REP_START_SETUP(n)	SH4_WORD_REG(ST40_SSC##n##_REGS_BASE + 0x0028)
+#define ST40_SSC_DATA_SETUP(n)		SH4_WORD_REG(ST40_SSC##n##_REGS_BASE + 0x002c)
+#define ST40_SSC_STOP_SETUP(n)		SH4_WORD_REG(ST40_SSC##n##_REGS_BASE + 0x0030)
+#define ST40_SSC_BUS_FREE(n)		SH4_WORD_REG(ST40_SSC##n##_REGS_BASE + 0x0034)
+#define ST40_SSC_CLR_STA(n)		SH4_DWORD_REG(ST40_SSC##n##_REGS_BASE + 0x0080)
+#define ST40_SSC_AGFR(n)		SH4_DWORD_REG(ST40_SSC##n##_REGS_BASE + 0x0100)
+#define ST40_SSC_PRSC(n)		SH4_DWORD_REG(ST40_SSC##n##_REGS_BASE + 0x0104)
+
+/* Asynchronous Serial Controller control registers (all ST40 variants) */
+#define ST40_ASC_BAUDRATE(n)		SH4_DWORD_REG(ST40_ASC##n##_REGS_BASE + 0x00)
+#define ST40_ASC_TXBUFFER(n)		SH4_DWORD_REG(ST40_ASC##n##_REGS_BASE + 0x04)
+#define ST40_ASC_RXBUFFER(n)		SH4_DWORD_REG(ST40_ASC##n##_REGS_BASE + 0x08)
+#define ST40_ASC_CONTROL(n)		SH4_DWORD_REG(ST40_ASC##n##_REGS_BASE + 0x0c)
+#define ST40_ASC_INTENABLE(n)		SH4_DWORD_REG(ST40_ASC##n##_REGS_BASE + 0x10)
+#define ST40_ASC_STATUS(n)		SH4_DWORD_REG(ST40_ASC##n##_REGS_BASE + 0x14)
+#define ST40_ASC_GUARDTIME(n)		SH4_DWORD_REG(ST40_ASC##n##_REGS_BASE + 0x18)
+#define ST40_ASC_TIMEOUT(n)		SH4_DWORD_REG(ST40_ASC##n##_REGS_BASE + 0x1c)
+#define ST40_ASC_TXRESET(n)		SH4_DWORD_REG(ST40_ASC##n##_REGS_BASE + 0x20)
+#define ST40_ASC_RXRESET(n)		SH4_DWORD_REG(ST40_ASC##n##_REGS_BASE + 0x24)
+#define ST40_ASC_RETRIES(n)		SH4_DWORD_REG(ST40_ASC##n##_REGS_BASE + 0x28)
+
+#endif /* __ST40REG_H */
diff --git a/include/asm-sh/stb7100reg.h b/include/asm-sh/stb7100reg.h
new file mode 100644
index 0000000000..42bb2b0ac5
--- /dev/null
+++ b/include/asm-sh/stb7100reg.h
@@ -0,0 +1,176 @@
+/*
+ * Copyright (C) STMicroelectronics Ltd. 2005.
+ *
+ * All rights reserved.
+ */
+
+#ifndef __STB7100REG_H
+#define __STB7100REG_H
+
+#include "asm/sh4regtype.h"
+
+/*----------------------------------------------------------------------------*/
+
+/*
+ * Peripheral versions
+ */
+
+#ifndef ST40_LMI_VERSION
+#define ST40_LMI_VERSION 3
+#endif
+
+/*----------------------------------------------------------------------------*/
+
+/*
+ * Base addresses for control register banks
+ */
+
+/* Generic SH4 control registers */
+#ifndef SH4_TMU_REGS_BASE
+#define SH4_TMU_REGS_BASE 0xffd80000
+#endif
+#ifndef SH4_RTC_REGS_BASE
+#define SH4_RTC_REGS_BASE 0xffc80000
+#endif
+
+/* Common ST40 control registers */
+#ifndef ST40_CPG_REGS_BASE
+#define ST40_CPG_REGS_BASE 0xffc00000
+#endif
+#ifndef ST40_INTC_REGS_BASE
+#define ST40_INTC_REGS_BASE 0xffd00000
+#endif
+#ifndef ST40_INTC2_REGS_BASE
+#define ST40_INTC2_REGS_BASE 0xfe080000
+#endif
+#ifndef ST40_SCIF1_REGS_BASE
+#define ST40_SCIF1_REGS_BASE 0xffe00000
+#endif
+#ifndef ST40_SCIF2_REGS_BASE
+#define ST40_SCIF2_REGS_BASE 0xffe80000
+#endif
+
+/* STb7100 control registers */
+#ifndef STB7100_SYSCONF_REGS_BASE
+#define STB7100_SYSCONF_REGS_BASE 0xb9001000
+#endif
+
+#ifndef STB7100_CLOCKGENA_REGS_BASE
+#define STB7100_CLOCKGENA_REGS_BASE 0xb9213000
+#endif
+
+/* System Architecture Volume 2: Bus Interfaces */
+#ifndef ST40_LMISYS_REGS_BASE
+#define ST40_LMISYS_REGS_BASE 0xaf000000
+#endif
+#ifndef ST40_LMIVID_REGS_BASE
+#define ST40_LMIVID_REGS_BASE 0xb7000000
+#endif
+#ifndef ST40_EMI_REGS_BASE
+#define ST40_EMI_REGS_BASE 0xba100000
+#endif
+
+/*----------------------------------------------------------------------------*/
+
+#include "asm/st40reg.h"
+
+/*
+ * STb7100 control registers
+ */
+
+/* Clock Generator control registers (STb7100 variant) */
+#define STB7100_CLOCKGENA_LOCK			SH4_DWORD_REG(STB7100_CLOCKGENA_REGS_BASE + 0x00)
+#define STB7100_CLOCKGENA_MD_STATUS		SH4_DWORD_REG(STB7100_CLOCKGENA_REGS_BASE + 0x04)
+#define STB7100_CLOCKGENA_PLL0_CFG		SH4_DWORD_REG(STB7100_CLOCKGENA_REGS_BASE + 0x08)
+#define STB7100_CLOCKGENA_PLL0_STATUS		SH4_DWORD_REG(STB7100_CLOCKGENA_REGS_BASE + 0x10)
+#define STB7100_CLOCKGENA_PLL0_CLK1_CTRL	SH4_DWORD_REG(STB7100_CLOCKGENA_REGS_BASE + 0x14)
+#define STB7100_CLOCKGENA_PLL0_CLK2_CTRL	SH4_DWORD_REG(STB7100_CLOCKGENA_REGS_BASE + 0x18)
+#define STB7100_CLOCKGENA_PLL0_CLK3_CTRL	SH4_DWORD_REG(STB7100_CLOCKGENA_REGS_BASE + 0x1c)
+#define STB7100_CLOCKGENA_PLL0_CLK4_CTRL	SH4_DWORD_REG(STB7100_CLOCKGENA_REGS_BASE + 0x20)
+#define STB7100_CLOCKGENA_PLL1_CFG		SH4_DWORD_REG(STB7100_CLOCKGENA_REGS_BASE + 0x24)
+#define STB7100_CLOCKGENA_PLL1_STATUS		SH4_DWORD_REG(STB7100_CLOCKGENA_REGS_BASE + 0x2c)
+#define STB7100_CLOCKGENA_CLK_DIV		SH4_DWORD_REG(STB7100_CLOCKGENA_REGS_BASE + 0x30)
+#define STB7100_CLOCKGENA_CLOCK_ENABLE		SH4_DWORD_REG(STB7100_CLOCKGENA_REGS_BASE + 0x34)
+#define STB7100_CLOCKGENA_OUT_CTRL		SH4_DWORD_REG(STB7100_CLOCKGENA_REGS_BASE + 0x38)
+#define STB7100_CLOCKGENA_PLL1_BYPASS		SH4_DWORD_REG(STB7100_CLOCKGENA_REGS_BASE + 0x3c)
+
+/* System configuration registers (STb7100 variant) */
+#if defined(ST40_LITTLE_ENDIAN)
+#define STB7100_SYSCONF_DEVICEID_0	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0000)
+#define STB7100_SYSCONF_DEVICEID_1	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0004)
+#define STB7100_SYSCONF_DEVICEID	STB7100_SYSCONF_DEVICEID_0
+#elif defined(ST40_BIG_ENDIAN)
+#define STB7100_SYSCONF_DEVICEID_0	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0004)
+#define STB7100_SYSCONF_DEVICEID_1	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0000)
+#define STB7100_SYSCONF_DEVICEID	STB7100_SYSCONF_DEVICEID_0
+#else
+#error ST40_LITTLE_ENDIAN and ST40_BIG_ENDIAN undefined
+#endif
+#define STB7100_SYSCONF_SYS_STA00	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0008)
+#define STB7100_SYSCONF_SYS_STA01	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x000c)
+#define STB7100_SYSCONF_SYS_STA02	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0010)
+#define STB7100_SYSCONF_SYS_STA03	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0014)
+#define STB7100_SYSCONF_SYS_STA04	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0018)
+#define STB7100_SYSCONF_SYS_STA05	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x001c)
+#define STB7100_SYSCONF_SYS_STA06	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0020)
+#define STB7100_SYSCONF_SYS_STA07	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0024)
+#define STB7100_SYSCONF_SYS_STA08	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0028)
+#define STB7100_SYSCONF_SYS_STA09	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x002c)
+#define STB7100_SYSCONF_SYS_STA10	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0030)
+#define STB7100_SYSCONF_SYS_STA11	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0034)
+#define STB7100_SYSCONF_SYS_STA12	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0038)
+#define STB7100_SYSCONF_SYS_STA13	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x003c)
+#define STB7100_SYSCONF_SYS_STA14	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0040)
+#define STB7100_SYSCONF_SYS_CFG00	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0100)
+#define STB7100_SYSCONF_SYS_CFG01	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0104)
+#define STB7100_SYSCONF_SYS_CFG02	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0108)
+#define STB7100_SYSCONF_SYS_CFG03	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x010c)
+#define STB7100_SYSCONF_SYS_CFG04	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0110)
+#define STB7100_SYSCONF_SYS_CFG05	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0114)
+#define STB7100_SYSCONF_SYS_CFG06	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0118)
+#define STB7100_SYSCONF_SYS_CFG07	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x011c)
+#define STB7100_SYSCONF_SYS_CFG08	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0120)
+#define STB7100_SYSCONF_SYS_CFG09	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0124)
+#define STB7100_SYSCONF_SYS_CFG10	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0128)
+#define STB7100_SYSCONF_SYS_CFG11	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x012c)
+#define STB7100_SYSCONF_SYS_CFG12	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0130)
+#define STB7100_SYSCONF_SYS_CFG13	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0134)
+#define STB7100_SYSCONF_SYS_CFG14	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0138)
+#define STB7100_SYSCONF_SYS_CFG15	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x013c)
+#define STB7100_SYSCONF_SYS_CFG16	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0140)
+#define STB7100_SYSCONF_SYS_CFG17	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0144)
+#define STB7100_SYSCONF_SYS_CFG18	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0148)
+#define STB7100_SYSCONF_SYS_CFG19	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x014c)
+#define STB7100_SYSCONF_SYS_CFG20	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0150)
+#define STB7100_SYSCONF_SYS_CFG21	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0154)
+#define STB7100_SYSCONF_SYS_CFG22	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0158)
+#define STB7100_SYSCONF_SYS_CFG23	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x015c)
+#define STB7100_SYSCONF_SYS_CFG24	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0160)
+#define STB7100_SYSCONF_SYS_CFG25	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0164)
+#define STB7100_SYSCONF_SYS_CFG26	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0168)
+#define STB7100_SYSCONF_SYS_CFG27	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x016c)
+#define STB7100_SYSCONF_SYS_CFG28	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0170)
+#define STB7100_SYSCONF_SYS_CFG29	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0174)
+#define STB7100_SYSCONF_SYS_CFG30	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0178)
+#define STB7100_SYSCONF_SYS_CFG31	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x017c)
+#define STB7100_SYSCONF_SYS_CFG32	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0180)
+#define STB7100_SYSCONF_SYS_CFG33	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0184)
+#define STB7100_SYSCONF_SYS_CFG34	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0188)
+#define STB7100_SYSCONF_SYS_CFG35	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x018c)
+#define STB7100_SYSCONF_SYS_CFG36	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0190)
+#define STB7100_SYSCONF_SYS_CFG37	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0194)
+#define STB7100_SYSCONF_SYS_CFG38	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x0198)
+#define STB7100_SYSCONF_SYS_CFG39	SH4_DWORD_REG(STB7100_SYSCONF_REGS_BASE + 0x019c)
+
+#define STB7100_DEVID_7100_VAL		0x024
+#define STB7100_DEVID_7109_VAL		0x02c
+#define STB7100_DEVID_ID_SHIFT		12
+#define STB7100_DEVID_ID_MASK		0x3ff
+#define STB7100_DEVID_CUT_SHIFT		28
+#define STB7100_DEVID_CUT_MASK		0xf
+
+#define STB7100_DEVICEID_7100(ID) ((((ID) >> STB7100_DEVID_ID_SHIFT) & STB7100_DEVID_ID_MASK) == STB7100_DEVID_7100_VAL)
+#define STB7100_DEVICEID_7109(ID) ((((ID) >> STB7100_DEVID_ID_SHIFT) & STB7100_DEVID_ID_MASK) == STB7100_DEVID_7109_VAL)
+#define STB7100_DEVICEID_CUT(ID)  ((((ID) >> STB7100_DEVID_CUT_SHIFT) & STB7100_DEVID_CUT_MASK) + 1)
+
+#endif /* __STB7100REG_H */
diff --git a/include/asm-sh/stbus.h b/include/asm-sh/stbus.h
new file mode 100644
index 0000000000..f4441fe5a6
--- /dev/null
+++ b/include/asm-sh/stbus.h
@@ -0,0 +1,99 @@
+/*
+ * Copyright (C) 2007-2008 STMicroelectronics Limited
+ * David McKay <David.McKay@st.com>
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __STBUS_H__
+#define __STBUS_H__
+
+/*
+ * This file attempts to support all the various flavours of USB wrappers,
+ * thus some of the registers appear to overlap.
+ *
+ * Some of these register are described in ADCS 7518758 and 7618754
+ */
+
+
+/* Defines for the USB controller register offsets. */
+#define AHB2STBUS_WRAPPER_GLUE_BASE	(CFG_USB_BASE + 0x00000000)
+#define AHB2STBUS_OHCI_BASE		(CFG_USB_BASE + 0x000ffc00)
+#define AHB2STBUS_EHCI_BASE		(CFG_USB_BASE + 0x000ffe00)
+#define AHB2STBUS_PROTOCOL_BASE		(CFG_USB_BASE + 0x000fff00)
+
+
+/* Protocol converter registers (separate registers) */
+
+/* The transaction opcode is programmed in this register */
+#define AHB2STBUS_STBUS_OPC		(AHB2STBUS_PROTOCOL_BASE + 0x00)
+#define AHB2STBUS_STBUS_OPC_4BIT	0x00
+#define AHB2STBUS_STBUS_OPC_8BIT	0x01
+#define AHB2STBUS_STBUS_OPC_16BIT	0x02
+#define AHB2STBUS_STBUS_OPC_32BIT	0x03
+#define AHB2STBUS_STBUS_OPC_64BIT	0x04
+
+/* The message length in number of packets is programmed in this register. */
+#define AHB2STBUS_MSGSIZE		(AHB2STBUS_PROTOCOL_BASE + 0x04)
+#define AHB2STBUS_MSGSIZE_DISABLE	0x0
+#define AHB2STBUS_MSGSIZE_2		0x1
+#define AHB2STBUS_MSGSIZE_4		0x2
+#define AHB2STBUS_MSGSIZE_8		0x3
+#define AHB2STBUS_MSGSIZE_16		0x4
+#define AHB2STBUS_MSGSIZE_32		0x5
+#define AHB2STBUS_MSGSIZE_64		0x6
+
+/* The chunk size in number of packets is programmed in this register */
+#define AHB2STBUS_CHUNKSIZE		(AHB2STBUS_PROTOCOL_BASE + 0x08)
+#define AHB2STBUS_CHUNKSIZE_DISABLE	0x0
+#define AHB2STBUS_CHUNKSIZE_2		0x1
+#define AHB2STBUS_CHUNKSIZE_4		0x2
+#define AHB2STBUS_CHUNKSIZE_8		0x3
+#define AHB2STBUS_CHUNKSIZE_16		0x4
+#define AHB2STBUS_CHUNKSIZE_32		0x5
+#define AHB2STBUS_CHUNKSIZE_64		0x6
+
+
+/* Protocol converter registers (combined register) */
+
+#define AHB2STBUS_STBUS_CONFIG		(AHB2STBUS_PROTOCOL_BASE + 0x04)
+
+
+/* Wrapper Glue registers */
+
+#define AHB2STBUS_STRAP			(AHB2STBUS_WRAPPER_GLUE_BASE + 0x14)
+#define AHB2STBUS_STRAP_PLL		0x08	/* PLL_PWR_DWN */
+#define AHB2STBUS_STRAP_8_BIT		0x00	/* ss_word_if */
+#define AHB2STBUS_STRAP_16_BIT		0x04	/* ss_word_if */
+
+
+/* QQQ move the following to somewhere more sensible */
+#define USB_FLAGS_STRAP_8BIT			(1<<0)
+#define USB_FLAGS_STRAP_16BIT			(2<<0)
+#define USB_FLAGS_STRAP_PLL			(1<<2)
+#define USB_FLAGS_OPC_MSGSIZE_CHUNKSIZE		(1<<3)
+#define USB_FLAGS_STBUS_CONFIG_THRESHOLD128	(1<<4)
+#define USB_FLAGS_STBUS_CONFIG_THRESHOLD256	(2<<4)
+
+
+/* function to start the USB Host Controller Wrapper */
+extern int ST40_start_host_control(unsigned int flags);
+
+#endif	/* __STBUS_H__ */
diff --git a/include/asm-sh/stm-nand.h b/include/asm-sh/stm-nand.h
new file mode 100644
index 0000000000..e0136a00ce
--- /dev/null
+++ b/include/asm-sh/stm-nand.h
@@ -0,0 +1,139 @@
+/*
+ * (C) Copyright 2008-2009 STMicroelectronics, Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <nand.h>
+
+
+extern struct nand_bbt_descr stm_nand_badblock_pattern_16;
+extern struct nand_bbt_descr stm_nand_badblock_pattern_64;
+
+extern int stm_nand_default_bbt (
+	struct mtd_info *mtd);
+
+
+#ifdef CFG_NAND_ECC_HW3_128	/* for STM "boot-mode" */
+
+
+extern int stm_nand_calculate_ecc (
+	struct mtd_info * const mtd,
+	const u_char * const dat,
+	u_char * const ecc_code);
+
+extern int stm_nand_correct_data (
+	struct mtd_info *mtd,
+	u_char *dat,
+	u_char *read_ecc,
+	u_char *calc_ecc);
+
+extern void stm_nand_enable_hwecc (
+	struct mtd_info *mtd,
+	int mode);
+
+
+extern int stm_nand_read (
+	struct mtd_info *mtd,
+	loff_t from,
+	size_t len,
+	size_t * retlen,
+	u_char * buf);
+
+extern int stm_nand_read_ecc (
+	struct mtd_info *mtd,
+	loff_t from,
+	size_t len,
+	size_t * retlen,
+	u_char * buf,
+	u_char * eccbuf,
+	struct nand_oobinfo *oobsel);
+
+extern int stm_nand_read_oob (
+	struct mtd_info *mtd,
+	loff_t from,
+	size_t len,
+	size_t * retlen,
+	u_char * buf);
+
+
+extern int stm_nand_write (
+	struct mtd_info *mtd,
+	loff_t to,
+	size_t len,
+	size_t * retlen,
+	const u_char * buf);
+
+extern int stm_nand_write_ecc (
+	struct mtd_info *mtd,
+	loff_t to,
+	size_t len,
+	size_t * retlen,
+	const u_char * buf,
+	u_char * eccbuf,
+	struct nand_oobinfo *oobsel);
+
+extern int stm_nand_write_oob (
+	struct mtd_info *mtd,
+	loff_t to,
+	size_t len,
+	size_t * retlen,
+	const u_char *buf);
+
+
+#endif	/* CFG_NAND_ECC_HW3_128 */
+
+
+#ifdef CFG_NAND_FLEX_MODE	/* for STM "flex-mode" (c.f. "bit-banging") */
+
+
+extern int stm_flex_device_ready(
+	struct mtd_info * const mtd);
+
+extern void stm_flex_select_chip (
+	struct mtd_info * const mtd,
+	const int chipnr);
+
+extern void stm_flex_hwcontrol (
+	struct mtd_info * const mtd,
+	int control);
+
+
+extern u_char stm_flex_read_byte(
+	struct mtd_info * const mtd);
+
+extern void stm_flex_write_byte(
+	struct mtd_info * const mtd,
+	u_char byte);
+
+
+extern void stm_flex_read_buf(
+	struct mtd_info * const mtd,
+	u_char * const buf,
+	const int len);
+
+extern void stm_flex_write_buf(
+	struct mtd_info * const mtd,
+	const u_char *buf,
+	const int len);
+
+
+#endif /* CFG_NAND_FLEX_MODE */
+
+
diff --git a/include/asm-sh/string.h b/include/asm-sh/string.h
new file mode 100644
index 0000000000..9b681b3b8a
--- /dev/null
+++ b/include/asm-sh/string.h
@@ -0,0 +1,128 @@
+#ifndef __ASM_SH_STRING_H
+#define __ASM_SH_STRING_H
+
+/*
+ * Copyright (C) 1999 Niibe Yutaka
+ * But consider these trivial functions to be public domain.
+ */
+
+#define __HAVE_ARCH_STRCPY
+static __inline__ char *strcpy (char *__dest, const char *__src)
+{
+	register char *__xdest = __dest;
+	unsigned long __dummy;
+
+	__asm__ __volatile__ ("1:\n\t"
+			      "mov.b	@%1+, %2\n\t"
+			      "mov.b	%2, @%0\n\t"
+			      "cmp/eq	#0, %2\n\t"
+			      "bf/s	1b\n\t"
+			      " add	#1, %0\n\t":"=r" (__dest),
+			      "=r" (__src), "=&z" (__dummy)
+			      :"0" (__dest), "1" (__src)
+			      :"memory", "t");
+
+	return __xdest;
+}
+
+#define __HAVE_ARCH_STRNCPY
+static __inline__ char *strncpy (char *__dest, const char *__src, size_t __n)
+{
+	register char *__xdest = __dest;
+	unsigned long __dummy;
+
+	if (__n == 0)
+		return __xdest;
+
+	__asm__ __volatile__ ("1:\n"
+			      "mov.b	@%1+, %2\n\t"
+			      "mov.b	%2, @%0\n\t"
+			      "cmp/eq	#0, %2\n\t"
+			      "bt/s	2f\n\t"
+			      " cmp/eq	%5,%1\n\t"
+			      "bf/s	1b\n\t"
+			      " add	#1, %0\n"
+			      "2:":"=r"
+			      (__dest), "=r" (__src), "=&z" (__dummy)
+			      :"0" (__dest), "1" (__src), "r" (__src + __n)
+			      :"memory", "t");
+
+	return __xdest;
+}
+
+#define __HAVE_ARCH_STRCMP
+static __inline__ int strcmp (const char *__cs, const char *__ct)
+{
+	register int __res;
+	unsigned long __dummy;
+
+	__asm__ __volatile__ ("mov.b	@%1+, %3\n"
+			      "1:\n\t"
+			      "mov.b	@%0+, %2\n\t"
+			      "cmp/eq #0, %3\n\t"
+			      "bt	2f\n\t"
+			      "cmp/eq %2, %3\n\t"
+			      "bt/s	1b\n\t"
+			      " mov.b	@%1+, %3\n\t"
+			      "add	#-2, %1\n\t"
+			      "mov.b	@%1, %3\n\t"
+			      "sub	%3, %2\n"
+			      "2:":"=r" (__cs),
+			      "=r" (__ct), "=&r" (__res), "=&z" (__dummy)
+			      :"0" (__cs), "1" (__ct)
+			      :"t");
+
+	return __res;
+}
+
+#define __HAVE_ARCH_STRNCMP
+static __inline__ int strncmp (const char *__cs, const char *__ct, size_t __n)
+{
+	register int __res;
+	unsigned long __dummy;
+
+	if (__n == 0)
+		return 0;
+
+	__asm__ __volatile__ ("mov.b	@%1+, %3\n"
+			      "1:\n\t"
+			      "mov.b	@%0+, %2\n\t"
+			      "cmp/eq %6, %0\n\t"
+			      "bt/s	2f\n\t"
+			      " cmp/eq #0, %3\n\t"
+			      "bt/s	3f\n\t"
+			      " cmp/eq %3, %2\n\t"
+			      "bt/s	1b\n\t"
+			      " mov.b	@%1+, %3\n\t"
+			      "add	#-2, %1\n\t"
+			      "mov.b	@%1, %3\n"
+			      "2:\n\t"
+			      "sub	%3, %2\n"
+			      "3:":"=r"
+			      (__cs),
+			      "=r" (__ct), "=&r" (__res), "=&z" (__dummy)
+			      :"0" (__cs), "1" (__ct), "r" (__cs + __n)
+			      :"t");
+
+	return __res;
+}
+
+#define __HAVE_ARCH_MEMSET
+extern void *memset (void *__s, int __c, size_t __count);
+
+#define __HAVE_ARCH_MEMCPY
+extern void *memcpy (void *__to, __const__ void *__from, size_t __n);
+
+#define __HAVE_ARCH_MEMMOVE
+extern void *memmove (void *__dest, __const__ void *__src, size_t __n);
+
+#define __HAVE_ARCH_MEMCHR
+extern void *memchr (const void *__s, int __c, size_t __n);
+
+#define __HAVE_ARCH_STRLEN
+extern size_t strlen (const char *);
+
+/* Don't build bcopy at all ...  */
+#define __HAVE_ARCH_BCOPY
+
+#endif /* __ASM_SH_STRING_H */
diff --git a/include/asm-sh/stx5197reg.h b/include/asm-sh/stx5197reg.h
new file mode 100644
index 0000000000..29518e2faf
--- /dev/null
+++ b/include/asm-sh/stx5197reg.h
@@ -0,0 +1,288 @@
+/*
+ * Copyright (C) STMicroelectronics Ltd. 2008-2009.
+ *
+ * All rights reserved.
+ */
+
+/*
+ * This is derived from STMicroelectronics gnu toolchain example:
+ *   sh-superh-elf/examples/bare/sh4reg/sti5197reg.h
+ */
+
+
+#ifndef __STX5197REG_H
+#define __STX5197REG_H
+
+#include "sh4regtype.h"
+
+/*----------------------------------------------------------------------------*/
+
+/*
+ * Peripheral versions
+ */
+
+#ifndef ST40_LMI_VERSION
+#define ST40_LMI_VERSION 4
+#endif
+#ifndef ST40_NAND_CONTROLLER_VERSION
+#define ST40_NAND_CONTROLLER_VERSION 2
+#endif
+
+/*----------------------------------------------------------------------------*/
+
+/*
+ * Base addresses for control register banks.
+ */
+
+/* Generic SH4 control registers */
+#ifndef SH4_TMU_REGS_BASE
+#define SH4_TMU_REGS_BASE 0xffd80000
+#endif
+
+/* Common ST40 control registers */
+#ifndef ST40_CPG_REGS_BASE
+#define ST40_CPG_REGS_BASE 0xffc00000
+#endif
+#ifndef ST40_INTC_REGS_BASE
+#define ST40_INTC_REGS_BASE 0xffd00000
+#endif
+#ifndef ST40_SCIF2_REGS_BASE
+#define ST40_SCIF2_REGS_BASE 0xffe80000
+#endif
+
+#ifndef STX5197_COMMS_BASE
+#define STX5197_COMMS_BASE 0xfd100000
+#endif
+
+#ifndef ST40_ILC_REGS_BASE
+#define ST40_ILC_REGS_BASE STX5197_COMMS_BASE
+#endif
+
+/* STi5197 control registers */
+#ifndef STX5197_SYSSERV_REGS_BASE
+#define STX5197_SYSSERV_REGS_BASE 0xfdc00000
+#endif
+
+#ifndef STX5197_HD_CONFIG_MONITOR_BASE
+#define STX5197_HD_CONFIG_MONITOR_BASE 0xfd901000
+#endif
+
+/* System Architecture Volume 2: Bus Interfaces */
+#ifndef ST40_LMI_REGS_BASE
+#define ST40_LMI_REGS_BASE 0xfe000000
+#endif
+#ifndef ST40_EMI_REGS_BASE
+#define ST40_EMI_REGS_BASE 0xfdf00000
+#endif
+
+/* System Architecture Volume 4: I/O Devices */
+#ifndef ST40_PIO0_REGS_BASE
+#define ST40_PIO0_REGS_BASE (STX5197_COMMS_BASE + 0x00020000)
+#endif
+#ifndef ST40_PIO1_REGS_BASE
+#define ST40_PIO1_REGS_BASE (STX5197_COMMS_BASE + 0x00021000)
+#endif
+#ifndef ST40_PIO2_REGS_BASE
+#define ST40_PIO2_REGS_BASE (STX5197_COMMS_BASE + 0x00022000)
+#endif
+#ifndef ST40_PIO3_REGS_BASE
+#define ST40_PIO3_REGS_BASE (STX5197_COMMS_BASE + 0x00023000)
+#endif
+#ifndef ST40_PIO4_REGS_BASE
+#define ST40_PIO4_REGS_BASE (STX5197_COMMS_BASE + 0x00024000)
+#endif
+#ifndef ST40_ASC0_REGS_BASE
+#define ST40_ASC0_REGS_BASE (STX5197_COMMS_BASE + 0x00030000)
+#endif
+#ifndef ST40_ASC1_REGS_BASE
+#define ST40_ASC1_REGS_BASE (STX5197_COMMS_BASE + 0x00031000)
+#endif
+#ifndef ST40_ASC2_REGS_BASE
+#define ST40_ASC2_REGS_BASE (STX5197_COMMS_BASE + 0x00032000)
+#endif
+#ifndef ST40_ASC3_REGS_BASE
+#define ST40_ASC3_REGS_BASE (STX5197_COMMS_BASE + 0x00033000)
+#endif
+#ifndef ST40_SSC0_REGS_BASE
+#define ST40_SSC0_REGS_BASE (STX5197_COMMS_BASE + 0x00040000)
+#endif
+#ifndef ST40_SSC1_REGS_BASE
+#define ST40_SSC1_REGS_BASE (STX5197_COMMS_BASE + 0x00041000)
+#endif
+#ifndef ST40_SSC2_REGS_BASE
+#define ST40_SSC2_REGS_BASE (STX5197_COMMS_BASE + 0x00042000)
+#endif
+
+/*----------------------------------------------------------------------------*/
+
+#include "st40reg.h"
+
+/*
+ * STi5197 control registers
+ */
+
+/* System services registers (STi5197 variant) */
+#define STX5197_SYSSERV_PLLA_CONFIG0		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x00)
+#define STX5197_SYSSERV_PLLA_CONFIG1		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x04)
+#define STX5197_SYSSERV_PLLB_CONFIG0		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x08)
+#define STX5197_SYSSERV_PLLB_CONFIG1		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x0C)
+#define STX5197_SYSSERV_FS216_SETUP_A		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x10)
+#define STX5197_SYSSERV_FSA_SETUP		STX5197_SYSSERV_FS216_SETUP_A
+#define STX5197_SYSSERV_FS216X4_CLK1_SETUP0	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x14)
+#define STX5197_SYSSERV_SPARE1_CLK_SETUP0	STX5197_SYSSERV_FS216X4_CLK1_SETUP0
+#define STX5197_SYSSERV_FS216X4_CLK1_SETUP1	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x18)
+#define STX5197_SYSSERV_SPARE1_CLK_SETUP1	STX5197_SYSSERV_FS216X4_CLK1_SETUP1
+#define STX5197_SYSSERV_FS216X4_CLK2_SETUP0	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x20)
+#define STX5197_SYSSERV_PCM_CLK_SETUP0		STX5197_SYSSERV_FS216X4_CLK2_SETUP0
+#define STX5197_SYSSERV_FS216X4_CLK2_SETUP1	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x24)
+#define STX5197_SYSSERV_PCM_CLK_SETUP1		STX5197_SYSSERV_FS216X4_CLK2_SETUP1
+#define STX5197_SYSSERV_FS216X4_CLK3_SETUP0	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x30)
+#define STX5197_SYSSERV_SPDIF_CLK_SETUP0	STX5197_SYSSERV_FS216X4_CLK3_SETUP0
+#define STX5197_SYSSERV_FS216X4_CLK3_SETUP1	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x34)
+#define STX5197_SYSSERV_SPDIF_CLK_SETUP1	STX5197_SYSSERV_FS216X4_CLK3_SETUP1
+#define STX5197_SYSSERV_FS216X4_CLK4_SETUP0	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x40)
+#define STX5197_SYSSERV_SC_CLK_SETUP0		STX5197_SYSSERV_FS216X4_CLK4_SETUP0
+#define STX5197_SYSSERV_FS216X4_CLK4_SETUP1	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x44)
+#define STX5197_SYSSERV_SC_CLK_SETUP1		STX5197_SYSSERV_FS216X4_CLK4_SETUP1
+#define STX5197_SYSSERV_FS216_SETUP_B		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x50)
+#define STX5197_SYSSERV_FSB_SETUP		STX5197_SYSSERV_FS216_SETUP_B
+#define STX5197_SYSSERV_FS216X4_CLK5_SETUP0	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x54)
+#define STX5197_SYSSERV_PIX_CLK_SETUP0		STX5197_SYSSERV_FS216X4_CLK5_SETUP0
+#define STX5197_SYSSERV_FS216X4_CLK5_SETUP1	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x58)
+#define STX5197_SYSSERV_PIX_CLK_SETUP1		STX5197_SYSSERV_FS216X4_CLK5_SETUP1
+#define STX5197_SYSSERV_FS216X4_CLK6_SETUP0	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x60)
+#define STX5197_SYSSERV_FDMA_FS_CLK_SETUP0	STX5197_SYSSERV_FS216X4_CLK6_SETUP0
+#define STX5197_SYSSERV_FS216X4_CLK6_SETUP1	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x64)
+#define STX5197_SYSSERV_FDMA_FS_CLK_SETUP1	STX5197_SYSSERV_FS216X4_CLK6_SETUP1
+#define STX5197_SYSSERV_FS216X4_CLK7_SETUP0	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x70)
+#define STX5197_SYSSERV_AUX_CLK_SETUP0		STX5197_SYSSERV_FS216X4_CLK7_SETUP0
+#define STX5197_SYSSERV_FS216X4_CLK7_SETUP1	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x74)
+#define STX5197_SYSSERV_AUX_CLK_SETUP1		STX5197_SYSSERV_FS216X4_CLK7_SETUP1
+#define STX5197_SYSSERV_FS216X4_CLK8_SETUP0	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x80)
+#define STX5197_SYSSERV_USB_CLK_SETUP0		STX5197_SYSSERV_FS216X4_CLK8_SETUP0
+#define STX5197_SYSSERV_FS216X4_CLK8_SETUP1	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x84)
+#define STX5197_SYSSERV_USB_CLK_SETUP1		STX5197_SYSSERV_FS216X4_CLK8_SETUP1
+#define STX5197_SYSSERV_CLKDIV0_CFG0		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x90)
+#define STX5197_SYSSERV_CLKDIV0_CFG1		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x94)
+#define STX5197_SYSSERV_CLKDIV0_CFG2		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x98)
+#define STX5197_SYSSERV_CLKDIV1_CFG0		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0xa0)
+#define STX5197_SYSSERV_CLKDIV1_CFG1		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0xa4)
+#define STX5197_SYSSERV_CLKDIV1_CFG2		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0xa8)
+#define STX5197_SYSSERV_CLKDIV2_CFG0		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0xac)
+#define STX5197_SYSSERV_CLKDIV2_CFG1		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0xb0)
+#define STX5197_SYSSERV_CLKDIV2_CFG2		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0xb4)
+#define STX5197_SYSSERV_CLKDIV3_CFG0		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0xb8)
+#define STX5197_SYSSERV_CLKDIV3_CFG1		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0xbc)
+#define STX5197_SYSSERV_CLKDIV3_CFG2		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0xc0)
+#define STX5197_SYSSERV_CLKDIV4_CFG0		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0xc4)
+#define STX5197_SYSSERV_CLKDIV4_CFG1		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0xc8)
+#define STX5197_SYSSERV_CLKDIV4_CFG2		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0xcc)
+#define STX5197_SYSSERV_CLKDIV6_CFG0		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0xd0)
+#define STX5197_SYSSERV_CLKDIV6_CFG1		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0xd4)
+#define STX5197_SYSSERV_CLKDIV6_CFG2		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0xd8)
+#define STX5197_SYSSERV_CLKDIV7_CFG0		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0xdc)
+#define STX5197_SYSSERV_CLKDIV7_CFG1		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0xe0)
+#define STX5197_SYSSERV_CLKDIV7_CFG2		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0xe4)
+#define STX5197_SYSSERV_CLKDIV8_CFG0		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0xe8)
+#define STX5197_SYSSERV_CLKDIV8_CFG1		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0xec)
+#define STX5197_SYSSERV_CLKDIV8_CFG2		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0xf0)
+#define STX5197_SYSSERV_CLKDIV9_CFG0		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0xf4)
+#define STX5197_SYSSERV_CLKDIV9_CFG1		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0xf8)
+#define STX5197_SYSSERV_CLKDIV9_CFG2		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0xfc)
+#define STX5197_SYSSERV_CLKDIV10_CFG0		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x100)
+#define STX5197_SYSSERV_CLKDIV10_CFG1		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x104)
+#define STX5197_SYSSERV_CLKDIV10_CFG2		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x108)
+#define STX5197_SYSSERV_MODE_CONTROL		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x110)
+#define STX5197_SYSSERV_REDUCED_PWR_CONTROL	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x114)
+#define STX5197_SYSSERV_LOW_POWER_DIS0		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x118)
+#define STX5197_SYSSERV_LOW_POWER_DIS1		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x11C)
+#define STX5197_SYSSERV_LOW_POWER_COUNTER_CFG0	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x120)
+#define STX5197_SYSSERV_LOW_POWER_COUNTER_CFG1	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x124)
+#define STX5197_SYSSERV_WATCHDOG_COUNTER_CFG0	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x130)
+#define STX5197_SYSSERV_WATCHDOG_COUNTER_CFG1	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x134)
+#define STX5197_SYSSERV_RESET_STATUS		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x140)
+#define STX5197_SYSSERV_SC_POWER_DETECT_CFG	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x144)
+#define STX5197_SYSSERV_SC_INSERTION_RST_CFG	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x148)
+#define STX5197_SYSSERV_CPU_INT_CFG		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x150)
+#define STX5197_SYSSERV_DCO_SD_COUNT		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x160)
+#define STX5197_SYSSERV_DCO_CMD			SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x164)
+#define STX5197_SYSSERV_DCO_PCM_COUNT		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x168)
+#define STX5197_SYSSERV_DCO_HD_COUNT		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x16C)
+#define STX5197_SYSSERV_DCO_MODE_CFG		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x170)
+#define STX5197_SYSSERV_CLOCK_SEL_CFG		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x180)
+#define STX5197_SYSSERV_DIV_FORCE_CFG		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x184)
+#define STX5197_SYSSERV_CLK_OBS_CFG		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x188)
+#define STX5197_SYSSERV_RTCS_LSB_LP		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x200)
+#define STX5197_SYSSERV_RTCS_MSB_LP		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x204)
+#define STX5197_SYSSERV_RTCS_CONTROL_LP		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x208)
+#define STX5197_SYSSERV_RTCS_LSB_27		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x210)
+#define STX5197_SYSSERV_RTCS_MSB_27		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x214)
+#define STX5197_SYSSERV_RTCS_CONTROL_27		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x218)
+#define STX5197_SYSSERV_REG_LOCK_CFG		SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x300)
+#define STX5197_SYSSERV_CLKBIST_PLL0_REFCOUNT	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x0390)
+#define STX5197_SYSSERV_CLKBIST_PLL0_CMPCOUNT	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x0394)
+#define STX5197_SYSSERV_CLKBIST_PLL0_OUTCOUNT	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x0398)
+#define STX5197_SYSSERV_CLKBIST_PLL0_CONTROL	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x039c)
+#define STX5197_SYSSERV_CLKBIST_PLL1_REFCOUNT	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x03a0)
+#define STX5197_SYSSERV_CLKBIST_PLL1_CMPCOUNT	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x03a4)
+#define STX5197_SYSSERV_CLKBIST_PLL1_OUTCOUNT	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x03a8)
+#define STX5197_SYSSERV_CLKBIST_PLL1_CONTROL	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x03ac)
+#define STX5197_SYSSERV_CLKBIST_PCM_REFCOUNT	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x03b0)
+#define STX5197_SYSSERV_CLKBIST_PCM_CMPCOUNT	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x03b4)
+#define STX5197_SYSSERV_CLKBIST_PCM_OUTCOUNT	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x03b8)
+#define STX5197_SYSSERV_CLKBIST_PCM_CONTROL	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x03bc)
+#define STX5197_SYSSERV_CLKBIST_FS0_REFCOUNT	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x03c0)
+#define STX5197_SYSSERV_CLKBIST_FS0_CMPCOUNT	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x03c4)
+#define STX5197_SYSSERV_CLKBIST_FS0_OUTCOUNT	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x03c8)
+#define STX5197_SYSSERV_CLKBIST_FS0_CONTROL	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x03cc)
+#define STX5197_SYSSERV_CLKBIST_FS1_REFCOUNT	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x03d0)
+#define STX5197_SYSSERV_CLKBIST_FS1_CMPCOUNT	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x03d4)
+#define STX5197_SYSSERV_CLKBIST_FS1_OUTCOUNT	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x03d8)
+#define STX5197_SYSSERV_CLKBIST_FS1_CONTROL	SH4_DWORD_REG(STX5197_SYSSERV_REGS_BASE + 0x03dc)
+
+#define STX5197_HD_CONF_MON_CONFIG_CONTROL_C	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x0)
+#define STX5197_HD_CONF_MON_CONFIG_CONTROL_D	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x4)
+#define STX5197_HD_CONF_MON_CONFIG_CONTROL_E	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x8)
+#define STX5197_HD_CONF_MON_CONFIG_CONTROL_F	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0xC)
+#define STX5197_HD_CONF_MON_CONFIG_CONTROL_G	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x10)
+#define STX5197_HD_CONF_MON_CONFIG_CONTROL_H	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x14)
+#define STX5197_HD_CONF_MON_CONFIG_CONTROL_I	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x18)
+#define STX5197_HD_CONF_MON_CONFIG_CONTROL_J	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x1C)
+#define STX5197_HD_CONF_MON_CONFIG_CONTROL_K	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x40)
+#define STX5197_HD_CONF_MON_CONFIG_CONTROL_L	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x44)
+#define STX5197_HD_CONF_MON_CONFIG_CONTROL_M	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x48)
+#define STX5197_HD_CONF_MON_CONFIG_CONTROL_N	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x4C)
+#define STX5197_HD_CONF_MON_CONFIG_CONTROL_O	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x50)
+#define STX5197_HD_CONF_MON_CONFIG_CONTROL_P	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x54)
+#define STX5197_HD_CONF_MON_CONFIG_CONTROL_Q	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x58)
+#define STX5197_HD_CONF_MON_CONFIG_CONTROL_R	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x5C)
+#define STX5197_HD_CONF_MON_CONFIG_MONITOR_C	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x20)
+#define STX5197_HD_CONF_MON_CONFIG_MONITOR_D	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x24)
+#define STX5197_HD_CONF_MON_CONFIG_MONITOR_E	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x28)
+#define STX5197_HD_CONF_MON_CONFIG_MONITOR_F	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x2C)
+#define STX5197_HD_CONF_MON_CONFIG_MONITOR_G	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x30)
+#define STX5197_HD_CONF_MON_CONFIG_MONITOR_H	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x34)
+#define STX5197_HD_CONF_MON_CONFIG_MONITOR_I	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x38)
+#define STX5197_HD_CONF_MON_CONFIG_MONITOR_J	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x3C)
+#define STX5197_HD_CONF_MON_CONFIG_MONITOR_K	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x60)
+#define STX5197_HD_CONF_MON_CONFIG_MONITOR_L	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x64)
+#define STX5197_HD_CONF_MON_CONFIG_MONITOR_M	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x68)
+#define STX5197_HD_CONF_MON_CONFIG_MONITOR_N	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x6C)
+#define STX5197_HD_CONF_MON_CONFIG_MONITOR_O	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x70)
+#define STX5197_HD_CONF_MON_CONFIG_MONITOR_P	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x74)
+#define STX5197_HD_CONF_MON_CONFIG_MONITOR_Q	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x78)
+#define STX5197_HD_CONF_MON_CONFIG_MONITOR_R	SH4_DWORD_REG(STX5197_HD_CONFIG_MONITOR_BASE + 0x7C)
+
+#define STX5197_DEVID_5197c1_VAL	0x003f	/* STx5197 cut 1.x */	/* QQQ - TO CHECK */
+#define STX5197_DEVID_5197c2_VAL	0x003f	/* STx5197 cut 2.x */
+#define STX5197_DEVID_ID_SHIFT		12
+#define STX5197_DEVID_ID_MASK		0x3ff	/* ten bits */
+#define STX5197_DEVID_CUT_SHIFT		28
+#define STX5197_DEVID_CUT_MASK		0xf	/* four bits */
+
+#define STX5197_DEVICEID_5197(ID)	(	\
+	((((ID)>>STX5197_DEVID_ID_SHIFT)&STX5197_DEVID_ID_MASK)==STX5197_DEVID_5197c1_VAL)  || \
+	((((ID)>>STX5197_DEVID_ID_SHIFT)&STX5197_DEVID_ID_MASK)==STX5197_DEVID_5197c2_VAL)     )
+#define STX5197_DEVICEID_CUT(ID)  ((((ID) >> STX5197_DEVID_CUT_SHIFT) & STX5197_DEVID_CUT_MASK) + 1)
+
+#endif /* __STX5197REG_H */
diff --git a/include/asm-sh/stx7105reg.h b/include/asm-sh/stx7105reg.h
new file mode 100644
index 0000000000..a1ca3d9d5c
--- /dev/null
+++ b/include/asm-sh/stx7105reg.h
@@ -0,0 +1,373 @@
+/*
+ * Copyright (C) STMicroelectronics Ltd. 2008.
+ *
+ * All rights reserved.
+ */
+
+/*
+ * This is derived from STMicroelectronics gnu toolchain example:
+ *   sh-superh-elf/examples/bare/sh4reg/sti7105.h
+ */
+
+
+#ifndef __STX7105REG_H
+#define __STX7105REG_H
+
+#include "sh4regtype.h"
+
+/*----------------------------------------------------------------------------*/
+
+/*
+ * Peripheral versions
+ */
+
+#ifndef ST40_LMIGP_VERSION
+#define ST40_LMIGP_VERSION 1
+#endif
+#ifndef ST40_NAND_CONTROLLER_VERSION
+#define ST40_NAND_CONTROLLER_VERSION 1
+#endif
+
+/*----------------------------------------------------------------------------*/
+
+/*
+ * Base addresses for control register banks.
+ */
+
+/* Generic SH4 control registers */
+#ifndef SH4_TMU_REGS_BASE
+#define SH4_TMU_REGS_BASE 0xffd80000
+#endif
+
+/* Common ST40 control registers */
+#ifndef ST40_CPG_REGS_BASE
+#define ST40_CPG_REGS_BASE 0xffc00000
+#endif
+#ifndef ST40_INTC_REGS_BASE
+#define ST40_INTC_REGS_BASE 0xffd00000
+#endif
+#ifndef ST40_SCIF2_REGS_BASE
+#define ST40_SCIF2_REGS_BASE 0xffe80000
+#endif
+
+#ifndef STX7105_COMMS_BASE
+#define STX7105_COMMS_BASE 0xfd000000
+#endif
+
+#ifndef ST40_ILC_REGS_BASE
+#define ST40_ILC_REGS_BASE STX7105_COMMS_BASE
+#endif
+
+/* STx7105 control registers */
+#ifndef STX7105_SYSCONF_REGS_BASE
+#define STX7105_SYSCONF_REGS_BASE 0xfe001000
+#endif
+
+#ifndef STX7105_CLOCKGENA_REGS_BASE
+#define STX7105_CLOCKGENA_REGS_BASE 0xfe213000
+#endif
+
+#ifndef STX7105_CLOCKGENB_REGS_BASE
+#define STX7105_CLOCKGENB_REGS_BASE 0xfe000000
+#endif
+
+/* System Architecture Volume 2: Bus Interfaces */
+#ifndef ST40_LMI_REGS_BASE
+#define ST40_LMI_REGS_BASE 0xfe901000
+#endif
+#ifndef ST40_EMI_REGS_BASE
+#define ST40_EMI_REGS_BASE 0xfe700000
+#endif
+
+/* System Architecture Volume 4: I/O Devices */
+#ifndef ST40_PIO0_REGS_BASE
+#define ST40_PIO0_REGS_BASE (STX7105_COMMS_BASE + 0x00020000)
+#endif
+#ifndef ST40_PIO1_REGS_BASE
+#define ST40_PIO1_REGS_BASE (STX7105_COMMS_BASE + 0x00021000)
+#endif
+#ifndef ST40_PIO2_REGS_BASE
+#define ST40_PIO2_REGS_BASE (STX7105_COMMS_BASE + 0x00022000)
+#endif
+#ifndef ST40_PIO3_REGS_BASE
+#define ST40_PIO3_REGS_BASE (STX7105_COMMS_BASE + 0x00023000)
+#endif
+#ifndef ST40_PIO4_REGS_BASE
+#define ST40_PIO4_REGS_BASE (STX7105_COMMS_BASE + 0x00024000)
+#endif
+#ifndef ST40_PIO5_REGS_BASE
+#define ST40_PIO5_REGS_BASE (STX7105_COMMS_BASE + 0x00025000)
+#endif
+#ifndef ST40_PIO6_REGS_BASE
+#define ST40_PIO6_REGS_BASE (STX7105_COMMS_BASE + 0x00026000)
+#endif
+#ifndef ST40_ASC0_REGS_BASE
+#define ST40_ASC0_REGS_BASE (STX7105_COMMS_BASE + 0x00030000)
+#endif
+#ifndef ST40_ASC1_REGS_BASE
+#define ST40_ASC1_REGS_BASE (STX7105_COMMS_BASE + 0x00031000)
+#endif
+#ifndef ST40_ASC2_REGS_BASE
+#define ST40_ASC2_REGS_BASE (STX7105_COMMS_BASE + 0x00032000)
+#endif
+#ifndef ST40_ASC3_REGS_BASE
+#define ST40_ASC3_REGS_BASE (STX7105_COMMS_BASE + 0x00033000)
+#endif
+#ifndef ST40_SSC0_REGS_BASE
+#define ST40_SSC0_REGS_BASE (STX7105_COMMS_BASE + 0x00040000)
+#endif
+#ifndef ST40_SSC1_REGS_BASE
+#define ST40_SSC1_REGS_BASE (STX7105_COMMS_BASE + 0x00041000)
+#endif
+#ifndef ST40_SSC2_REGS_BASE
+#define ST40_SSC2_REGS_BASE (STX7105_COMMS_BASE + 0x00042000)
+#endif
+#ifndef ST40_SSC3_REGS_BASE
+#define ST40_SSC3_REGS_BASE (STX7105_COMMS_BASE + 0x00043000)
+#endif
+#ifndef ST40_MAILBOX0_REGS_BASE
+#define ST40_MAILBOX0_REGS_BASE 0xfe211000
+#endif
+#ifndef ST40_MAILBOX1_REGS_BASE
+#define ST40_MAILBOX1_REGS_BASE (ST40_MAILBOX0_REGS_BASE + 0x1000)
+#endif
+
+#ifndef ST40_PIO7_REGS_BASE
+#define ST40_PIO7_REGS_BASE	0xfe010000
+#endif
+#ifndef ST40_PIO8_REGS_BASE
+#define ST40_PIO8_REGS_BASE	0xfe011000
+#endif
+#ifndef ST40_PIO9_REGS_BASE
+#define ST40_PIO9_REGS_BASE	0xfe012000
+#endif
+#ifndef ST40_PIO10_REGS_BASE
+#define ST40_PIO10_REGS_BASE	0xfe013000
+#endif
+#ifndef ST40_PIO11_REGS_BASE
+#define ST40_PIO11_REGS_BASE	0xfe014000
+#endif
+#ifndef ST40_PIO12_REGS_BASE
+#define ST40_PIO12_REGS_BASE	0xfe015000
+#endif
+#ifndef ST40_PIO13_REGS_BASE
+#define ST40_PIO13_REGS_BASE	0xfe016000
+#endif
+#ifndef ST40_PIO14_REGS_BASE
+#define ST40_PIO14_REGS_BASE	0xfe017000
+#endif
+#ifndef ST40_PIO15_REGS_BASE
+#define ST40_PIO15_REGS_BASE	0xfe018000
+#endif
+#ifndef ST40_PIO16_REGS_BASE
+#define ST40_PIO16_REGS_BASE	0xfe019000
+#endif
+
+/*----------------------------------------------------------------------------*/
+
+#include "st40reg.h"
+
+/*
+ * STx7105 control registers
+ */
+
+/* Clock Generator control registers (STx7105 variant) */
+#define STX7105_CLOCKGENA_PLL0_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x00)
+#define STX7105_CLOCKGENA_PLL1_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x04)
+#define STX7105_CLOCKGENA_POWER_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x10)
+#define STX7105_CLOCKGENA_CLKOPSRC_SWITCH_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x14)
+#define STX7105_CLOCKGENA_OSC_ENABLE_FB		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x18)
+#define STX7105_CLOCKGENA_PLL0_ENABLE_FB	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x1c)
+#define STX7105_CLOCKGENA_PLL1_ENABLE_FB	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x20)
+#define STX7105_CLOCKGENA_CLKOPSRC_SWITCH_CFG2	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x24)
+#define STX7105_CLOCKGENA_CLKOBS_MUX1_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x30)
+#define STX7105_CLOCKGENA_CLKOBS_MASTER_MAXCOUNT SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x34)
+#define STX7105_CLOCKGENA_CLKOBS_CMD		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x38)
+#define STX7105_CLOCKGENA_CLKOBS_STATUS		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x3c)
+#define STX7105_CLOCKGENA_CLKOBS_SLAVE0_COUNT	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x40)
+#define STX7105_CLOCKGENA_CLKOBS_OSCMUX_DEBUG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x44)
+#define STX7105_CLOCKGENA_CLKOBS_MUX2_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x48)
+#define STX7105_CLOCKGENA_LOW_POWER_CTRL	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x4c)
+#define STX7105_CLOCKGENA_OSC_DIV0_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x800)
+#define STX7105_CLOCKGENA_OSC_DIV1_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x804)
+#define STX7105_CLOCKGENA_OSC_DIV2_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x808)
+#define STX7105_CLOCKGENA_OSC_DIV3_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x80c)
+#define STX7105_CLOCKGENA_OSC_DIV4_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x810)
+#define STX7105_CLOCKGENA_OSC_DIV5_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x814)
+#define STX7105_CLOCKGENA_OSC_DIV6_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x818)
+#define STX7105_CLOCKGENA_OSC_DIV7_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x81c)
+#define STX7105_CLOCKGENA_OSC_DIV8_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x820)
+#define STX7105_CLOCKGENA_OSC_DIV9_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x824)
+#define STX7105_CLOCKGENA_OSC_DIV10_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x828)
+#define STX7105_CLOCKGENA_OSC_DIV11_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x82c)
+#define STX7105_CLOCKGENA_OSC_DIV12_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x830)
+#define STX7105_CLOCKGENA_OSC_DIV13_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x834)
+#define STX7105_CLOCKGENA_OSC_DIV14_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x838)
+#define STX7105_CLOCKGENA_OSC_DIV15_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x83c)
+#define STX7105_CLOCKGENA_OSC_DIV16_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x840)
+#define STX7105_CLOCKGENA_OSC_DIV17_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x844)
+#define STX7105_CLOCKGENA_PLL0HS_DIV0_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x900)
+#define STX7105_CLOCKGENA_PLL0HS_DIV1_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x904)
+#define STX7105_CLOCKGENA_PLL0HS_DIV2_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x908)
+#define STX7105_CLOCKGENA_PLL0HS_DIV3_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0x90c)
+#define STX7105_CLOCKGENA_PLL0LS_DIV4_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xa10)
+#define STX7105_CLOCKGENA_PLL0LS_DIV5_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xa14)
+#define STX7105_CLOCKGENA_PLL0LS_DIV6_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xa18)
+#define STX7105_CLOCKGENA_PLL0LS_DIV7_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xa1c)
+#define STX7105_CLOCKGENA_PLL0LS_DIV8_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xa20)
+#define STX7105_CLOCKGENA_PLL0LS_DIV9_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xa24)
+#define STX7105_CLOCKGENA_PLL0LS_DIV10_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xa28)
+#define STX7105_CLOCKGENA_PLL0LS_DIV11_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xa2c)
+#define STX7105_CLOCKGENA_PLL0LS_DIV12_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xa30)
+#define STX7105_CLOCKGENA_PLL0LS_DIV13_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xa34)
+#define STX7105_CLOCKGENA_PLL0LS_DIV14_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xa38)
+#define STX7105_CLOCKGENA_PLL0LS_DIV15_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xa3c0)
+#define STX7105_CLOCKGENA_PLL0LS_DIV16_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xa40)
+#define STX7105_CLOCKGENA_PLL0LS_DIV17_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xa44)
+#define STX7105_CLOCKGENA_PLL1_DIV0_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xb00)
+#define STX7105_CLOCKGENA_PLL1_DIV1_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xb04)
+#define STX7105_CLOCKGENA_PLL1_DIV2_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xb08)
+#define STX7105_CLOCKGENA_PLL1_DIV3_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xb0c)
+#define STX7105_CLOCKGENA_PLL1_DIV4_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xb10)
+#define STX7105_CLOCKGENA_PLL1_DIV5_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xb14)
+#define STX7105_CLOCKGENA_PLL1_DIV6_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xb18)
+#define STX7105_CLOCKGENA_PLL1_DIV7_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xb1c)
+#define STX7105_CLOCKGENA_PLL1_DIV8_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xb20)
+#define STX7105_CLOCKGENA_PLL1_DIV9_CFG		SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xb24)
+#define STX7105_CLOCKGENA_PLL1_DIV10_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xb28)
+#define STX7105_CLOCKGENA_PLL1_DIV11_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xb2c)
+#define STX7105_CLOCKGENA_PLL1_DIV12_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xb30)
+#define STX7105_CLOCKGENA_PLL1_DIV13_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xb34)
+#define STX7105_CLOCKGENA_PLL1_DIV14_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xb38)
+#define STX7105_CLOCKGENA_PLL1_DIV15_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xb3c)
+#define STX7105_CLOCKGENA_PLL1_DIV16_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xb40)
+#define STX7105_CLOCKGENA_PLL1_DIV17_CFG	SH4_DWORD_REG(STX7105_CLOCKGENA_REGS_BASE + 0xb44)
+
+#define STX7105_CLOCKGENB_LOCK			SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x10)
+#define STX7105_CLOCKGENB_FS0_CTRL		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x14)
+#define STX7105_CLOCKGENB_FS0_MD1		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x18)
+#define STX7105_CLOCKGENB_FS0_PE1		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x1c)
+#define STX7105_CLOCKGENB_FS0_EN_PRG1		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x20)
+#define STX7105_CLOCKGENB_FS0_SDIV1		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x24)
+#define STX7105_CLOCKGENB_FS0_MD2		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x28)
+#define STX7105_CLOCKGENB_FS0_PE2		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x2c)
+#define STX7105_CLOCKGENB_FS0_EN_PRG2		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x30)
+#define STX7105_CLOCKGENB_FS0_SDIV2		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x34)
+#define STX7105_CLOCKGENB_FS0_MD3		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x38)
+#define STX7105_CLOCKGENB_FS0_PE3		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x3c)
+#define STX7105_CLOCKGENB_FS0_EN_PRG3		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x40)
+#define STX7105_CLOCKGENB_FS0_SDIV3		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x44)
+#define STX7105_CLOCKGENB_FS0_CLOCKOUT_CTRL	SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x58)
+#define STX7105_CLOCKGENB_FS1_CTRL		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x5c)
+#define STX7105_CLOCKGENB_FS1_MD1		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x60)
+#define STX7105_CLOCKGENB_FS1_PE1		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x64)
+#define STX7105_CLOCKGENB_FS1_EN_PRG1		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x68)
+#define STX7105_CLOCKGENB_FS1_SDIV1		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x6c)
+#define STX7105_CLOCKGENB_FS1_MD2		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x70)
+#define STX7105_CLOCKGENB_FS1_PE2		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x74)
+#define STX7105_CLOCKGENB_FS1_EN_PRG2		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x78)
+#define STX7105_CLOCKGENB_FS1_SDIV2		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x7c)
+#define STX7105_CLOCKGENB_FS1_MD3		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x80)
+#define STX7105_CLOCKGENB_FS1_PE3		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x84)
+#define STX7105_CLOCKGENB_FS1_EN_PRG3		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x88)
+#define STX7105_CLOCKGENB_FS1_SDIV3		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x8c)
+#define STX7105_CLOCKGENB_FS1_MD4		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x90)
+#define STX7105_CLOCKGENB_FS1_PE4		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x94)
+#define STX7105_CLOCKGENB_FS1_EN_PRG4		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x98)
+#define STX7105_CLOCKGENB_FS1_SDIV4		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0x9c)
+#define STX7105_CLOCKGENB_FS1_CLOCKOUT_CTRL	SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0xa0)
+#define STX7105_CLOCKGENB_DISPLAY_CFG		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0xa4)
+#define STX7105_CLOCKGENB_FS_SELECT		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0xa8)
+#define STX7105_CLOCKGENB_POWER_DOWN		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0xac)
+#define STX7105_CLOCKGENB_POWER_ENABLE		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0xb0)
+#define STX7105_CLOCKGENB_OUT_CTRL		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0xb4)
+#define STX7105_CLOCKGENB_CRYSTAL_SEL		SH4_DWORD_REG(STX7105_CLOCKGENB_REGS_BASE + 0xb8)
+
+/* System configuration registers (STx7105 variant) */
+#define STX7105_SYSCONF_DEVICEID_0		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0000)
+#define STX7105_SYSCONF_DEVICEID_1		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0004)
+#define STX7105_SYSCONF_DEVICEID		SH4_GWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0000)
+#define STX7105_SYSCONF_SYS_STA00		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0008)
+#define STX7105_SYSCONF_SYS_STA01		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x000c)
+#define STX7105_SYSCONF_SYS_STA02		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0010)
+#define STX7105_SYSCONF_SYS_STA03		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0014)
+#define STX7105_SYSCONF_SYS_STA04		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0018)
+#define STX7105_SYSCONF_SYS_STA05		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x001c)
+#define STX7105_SYSCONF_SYS_STA06		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0020)
+#define STX7105_SYSCONF_SYS_STA07		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0024)
+#define STX7105_SYSCONF_SYS_STA08		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0028)
+#define STX7105_SYSCONF_SYS_STA09		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x002c)
+#define STX7105_SYSCONF_SYS_STA10		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0030)
+#define STX7105_SYSCONF_SYS_STA11		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0034)
+#define STX7105_SYSCONF_SYS_STA12		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0038)
+#define STX7105_SYSCONF_SYS_STA13		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x003c)
+#define STX7105_SYSCONF_SYS_STA14		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0040)
+#define STX7105_SYSCONF_SYS_STA15		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0044)
+#define STX7105_SYSCONF_SYS_CFG00		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0100)
+#define STX7105_SYSCONF_SYS_CFG01		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0104)
+#define STX7105_SYSCONF_SYS_CFG02		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0108)
+#define STX7105_SYSCONF_SYS_CFG03		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x010c)
+#define STX7105_SYSCONF_SYS_CFG04		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0110)
+#define STX7105_SYSCONF_SYS_CFG05		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0114)
+#define STX7105_SYSCONF_SYS_CFG06		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0118)
+#define STX7105_SYSCONF_SYS_CFG07		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x011c)
+#define STX7105_SYSCONF_SYS_CFG08		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0120)
+#define STX7105_SYSCONF_SYS_CFG09		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0124)
+#define STX7105_SYSCONF_SYS_CFG10		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0128)
+#define STX7105_SYSCONF_SYS_CFG11		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x012c)
+#define STX7105_SYSCONF_SYS_CFG12		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0130)
+#define STX7105_SYSCONF_SYS_CFG13		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0134)
+#define STX7105_SYSCONF_SYS_CFG14		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0138)
+#define STX7105_SYSCONF_SYS_CFG15		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x013c)
+#define STX7105_SYSCONF_SYS_CFG16		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0140)
+#define STX7105_SYSCONF_SYS_CFG17		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0144)
+#define STX7105_SYSCONF_SYS_CFG18		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0148)
+#define STX7105_SYSCONF_SYS_CFG19		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x014c)
+#define STX7105_SYSCONF_SYS_CFG20		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0150)
+#define STX7105_SYSCONF_SYS_CFG21		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0154)
+#define STX7105_SYSCONF_SYS_CFG22		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0158)
+#define STX7105_SYSCONF_SYS_CFG23		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x015c)
+#define STX7105_SYSCONF_SYS_CFG24		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0160)
+#define STX7105_SYSCONF_SYS_CFG25		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0164)
+#define STX7105_SYSCONF_SYS_CFG26		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0168)
+#define STX7105_SYSCONF_SYS_CFG27		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x016c)
+#define STX7105_SYSCONF_SYS_CFG28		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0170)
+#define STX7105_SYSCONF_SYS_CFG29		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0174)
+#define STX7105_SYSCONF_SYS_CFG30		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0178)
+#define STX7105_SYSCONF_SYS_CFG31		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x017c)
+#define STX7105_SYSCONF_SYS_CFG32		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0180)
+#define STX7105_SYSCONF_SYS_CFG33		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0184)
+#define STX7105_SYSCONF_SYS_CFG34		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0188)
+#define STX7105_SYSCONF_SYS_CFG35		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x018c)
+#define STX7105_SYSCONF_SYS_CFG36		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0190)
+#define STX7105_SYSCONF_SYS_CFG37		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0194)
+#define STX7105_SYSCONF_SYS_CFG38		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x0198)
+#define STX7105_SYSCONF_SYS_CFG39		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x019c)
+#define STX7105_SYSCONF_SYS_CFG40		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x01a0)
+#define STX7105_SYSCONF_SYS_CFG41		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x01a4)
+#define STX7105_SYSCONF_SYS_CFG42		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x01a8)
+#define STX7105_SYSCONF_SYS_CFG43		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x01ac)
+#define STX7105_SYSCONF_SYS_CFG44		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x01b0)
+#define STX7105_SYSCONF_SYS_CFG45		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x01b4)
+#define STX7105_SYSCONF_SYS_CFG46		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x01b8)
+#define STX7105_SYSCONF_SYS_CFG47		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x01bc)
+#define STX7105_SYSCONF_SYS_CFG48		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x01c0)
+#define STX7105_SYSCONF_SYS_CFG49		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x01c4)
+#define STX7105_SYSCONF_SYS_CFG50		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x01c8)
+#define STX7105_SYSCONF_SYS_CFG51		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x01cc)
+#define STX7105_SYSCONF_SYS_CFG52		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x01d0)
+#define STX7105_SYSCONF_SYS_CFG53		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x01d4)
+#define STX7105_SYSCONF_SYS_CFG54		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x01d8)
+#define STX7105_SYSCONF_SYS_CFG55		SH4_DWORD_REG(STX7105_SYSCONF_REGS_BASE + 0x01dc)
+
+/* Device ID values, masks & predicates */
+#define STX7105_DEVID_7105_VAL		0x03E
+#define STX7105_DEVID_ID_SHIFT		12
+#define STX7105_DEVID_ID_MASK		0x3ff
+#define STX7105_DEVID_CUT_SHIFT		28
+#define STX7105_DEVID_CUT_MASK		0xf
+
+#define STX7105_DEVICEID_7105(ID) ((((ID) >> STX7105_DEVID_ID_SHIFT) & STX7105_DEVID_ID_MASK) == STX7105_DEVID_7105_VAL)
+#define STX7105_DEVICEID_CUT(ID)  ((((ID) >> STX7105_DEVID_CUT_SHIFT) & STX7105_DEVID_CUT_MASK) + 1)
+
+#endif /* __STX7105REG_H */
diff --git a/include/asm-sh/stx7111reg.h b/include/asm-sh/stx7111reg.h
new file mode 100644
index 0000000000..4833c16a52
--- /dev/null
+++ b/include/asm-sh/stx7111reg.h
@@ -0,0 +1,332 @@
+/*
+ * Copyright (C) STMicroelectronics Ltd. 2008.
+ *
+ * All rights reserved.
+ */
+
+/*
+ * This is derived from STMicroelectronics gnu toolchain example:
+ *   sh-superh-elf/examples/bare/sh4reg/sti7111reg.h
+ */
+
+
+#ifndef __STX7111REG_H
+#define __STX7111REG_H
+
+#include "sh4regtype.h"
+
+/*----------------------------------------------------------------------------*/
+
+/*
+ * Peripheral versions
+ */
+
+#ifndef ST40_LMIGP_VERSION
+#define ST40_LMIGP_VERSION 1
+#endif
+#ifndef ST40_NAND_CONTROLLER_VERSION
+#define ST40_NAND_CONTROLLER_VERSION 1
+#endif
+
+/*----------------------------------------------------------------------------*/
+
+/*
+ * Base addresses for control register banks.
+ */
+
+/* Generic SH4 control registers */
+#ifndef SH4_TMU_REGS_BASE
+#define SH4_TMU_REGS_BASE 0xffd80000
+#endif
+
+/* Common ST40 control registers */
+#ifndef ST40_CPG_REGS_BASE
+#define ST40_CPG_REGS_BASE 0xffc00000
+#endif
+#ifndef ST40_INTC_REGS_BASE
+#define ST40_INTC_REGS_BASE 0xffd00000
+#endif
+#ifndef ST40_SCIF2_REGS_BASE
+#define ST40_SCIF2_REGS_BASE 0xffe80000
+#endif
+
+#ifndef STX7111_COMMS_BASE
+#define STX7111_COMMS_BASE 0xfd000000
+#endif
+
+#ifndef ST40_ILC_REGS_BASE
+#define ST40_ILC_REGS_BASE STX7111_COMMS_BASE
+#endif
+
+/* STx7111 control registers */
+#ifndef STX7111_SYSCONF_REGS_BASE
+#define STX7111_SYSCONF_REGS_BASE 0xfe001000
+#endif
+
+#ifndef STX7111_CLOCKGENA_REGS_BASE
+#define STX7111_CLOCKGENA_REGS_BASE 0xfe213000
+#endif
+
+#ifndef STX7111_CLOCKGENB_REGS_BASE
+#define STX7111_CLOCKGENB_REGS_BASE 0xfe000000
+#endif
+
+/* System Architecture Volume 2: Bus Interfaces */
+#ifndef ST40_LMI_REGS_BASE
+#define ST40_LMI_REGS_BASE 0xfe901000
+#endif
+#ifndef ST40_EMI_REGS_BASE
+#define ST40_EMI_REGS_BASE 0xfe700000
+#endif
+
+/* System Architecture Volume 4: I/O Devices */
+#ifndef ST40_PIO0_REGS_BASE
+#define ST40_PIO0_REGS_BASE (STX7111_COMMS_BASE + 0x00020000)
+#endif
+#ifndef ST40_PIO1_REGS_BASE
+#define ST40_PIO1_REGS_BASE (STX7111_COMMS_BASE + 0x00021000)
+#endif
+#ifndef ST40_PIO2_REGS_BASE
+#define ST40_PIO2_REGS_BASE (STX7111_COMMS_BASE + 0x00022000)
+#endif
+#ifndef ST40_PIO3_REGS_BASE
+#define ST40_PIO3_REGS_BASE (STX7111_COMMS_BASE + 0x00023000)
+#endif
+#ifndef ST40_PIO4_REGS_BASE
+#define ST40_PIO4_REGS_BASE (STX7111_COMMS_BASE + 0x00024000)
+#endif
+#ifndef ST40_PIO5_REGS_BASE
+#define ST40_PIO5_REGS_BASE (STX7111_COMMS_BASE + 0x00025000)
+#endif
+#ifndef ST40_PIO6_REGS_BASE
+#define ST40_PIO6_REGS_BASE (STX7111_COMMS_BASE + 0x00026000)
+#endif
+#ifndef ST40_ASC0_REGS_BASE
+#define ST40_ASC0_REGS_BASE (STX7111_COMMS_BASE + 0x00030000)
+#endif
+#ifndef ST40_ASC1_REGS_BASE
+#define ST40_ASC1_REGS_BASE (STX7111_COMMS_BASE + 0x00031000)
+#endif
+#ifndef ST40_ASC2_REGS_BASE
+#define ST40_ASC2_REGS_BASE (STX7111_COMMS_BASE + 0x00032000)
+#endif
+#ifndef ST40_ASC3_REGS_BASE
+#define ST40_ASC3_REGS_BASE (STX7111_COMMS_BASE + 0x00033000)
+#endif
+#ifndef ST40_SSC0_REGS_BASE
+#define ST40_SSC0_REGS_BASE (STX7111_COMMS_BASE + 0x00040000)
+#endif
+#ifndef ST40_SSC1_REGS_BASE
+#define ST40_SSC1_REGS_BASE (STX7111_COMMS_BASE + 0x00041000)
+#endif
+#ifndef ST40_SSC2_REGS_BASE
+#define ST40_SSC2_REGS_BASE (STX7111_COMMS_BASE + 0x00042000)
+#endif
+#ifndef ST40_SSC3_REGS_BASE
+#define ST40_SSC3_REGS_BASE (STX7111_COMMS_BASE + 0x00043000)
+#endif
+#ifndef ST40_MAILBOX0_REGS_BASE
+#define ST40_MAILBOX0_REGS_BASE 0xfe211000
+#endif
+#ifndef ST40_MAILBOX1_REGS_BASE
+#define ST40_MAILBOX1_REGS_BASE (ST40_MAILBOX0_REGS_BASE + 0x1000)
+#endif
+
+/*----------------------------------------------------------------------------*/
+
+#include "st40reg.h"
+
+/*
+ * STx7111 control registers
+ */
+
+/* Clock Generator control registers (STx7111 variant) */
+#define STX7111_CLOCKGENA_PLL0_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x00)
+#define STX7111_CLOCKGENA_PLL1_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x04)
+#define STX7111_CLOCKGENA_POWER_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x10)
+#define STX7111_CLOCKGENA_CLKOPSRC_SWITCH_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x14)
+#define STX7111_CLOCKGENA_CLKOPSRC_SWITCH_CFG2	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x24)
+#define STX7111_CLOCKGENA_CLKOBS_MUX1_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x30)
+#define STX7111_CLOCKGENA_CLKOBS_MUX2_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x48)
+#define STX7111_CLOCKGENA_OSC_DIV0_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x800)
+#define STX7111_CLOCKGENA_OSC_DIV1_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x804)
+#define STX7111_CLOCKGENA_OSC_DIV2_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x808)
+#define STX7111_CLOCKGENA_OSC_DIV3_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x80c)
+#define STX7111_CLOCKGENA_OSC_DIV4_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x810)
+#define STX7111_CLOCKGENA_OSC_DIV5_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x814)
+#define STX7111_CLOCKGENA_OSC_DIV6_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x818)
+#define STX7111_CLOCKGENA_OSC_DIV7_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x81c)
+#define STX7111_CLOCKGENA_OSC_DIV8_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x820)
+#define STX7111_CLOCKGENA_OSC_DIV9_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x824)
+#define STX7111_CLOCKGENA_OSC_DIV10_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x828)
+#define STX7111_CLOCKGENA_OSC_DIV11_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x82c)
+#define STX7111_CLOCKGENA_OSC_DIV12_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x830)
+#define STX7111_CLOCKGENA_OSC_DIV13_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x834)
+#define STX7111_CLOCKGENA_OSC_DIV14_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x838)
+#define STX7111_CLOCKGENA_OSC_DIV15_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x83c)
+#define STX7111_CLOCKGENA_OSC_DIV16_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x840)
+#define STX7111_CLOCKGENA_OSC_DIV17_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x844)
+#define STX7111_CLOCKGENA_PLL0HS_DIV0_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x900)
+#define STX7111_CLOCKGENA_PLL0HS_DIV1_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x904)
+#define STX7111_CLOCKGENA_PLL0HS_DIV2_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x908)
+#define STX7111_CLOCKGENA_PLL0HS_DIV3_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0x90c)
+#define STX7111_CLOCKGENA_PLL0LS_DIV4_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xa10)
+#define STX7111_CLOCKGENA_PLL0LS_DIV5_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xa14)
+#define STX7111_CLOCKGENA_PLL0LS_DIV6_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xa18)
+#define STX7111_CLOCKGENA_PLL0LS_DIV7_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xa1c)
+#define STX7111_CLOCKGENA_PLL0LS_DIV8_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xa20)
+#define STX7111_CLOCKGENA_PLL0LS_DIV9_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xa24)
+#define STX7111_CLOCKGENA_PLL0LS_DIV10_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xa28)
+#define STX7111_CLOCKGENA_PLL0LS_DIV11_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xa2c)
+#define STX7111_CLOCKGENA_PLL0LS_DIV12_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xa30)
+#define STX7111_CLOCKGENA_PLL0LS_DIV13_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xa34)
+#define STX7111_CLOCKGENA_PLL0LS_DIV14_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xa38)
+#define STX7111_CLOCKGENA_PLL0LS_DIV15_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xa3c0)
+#define STX7111_CLOCKGENA_PLL0LS_DIV16_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xa40)
+#define STX7111_CLOCKGENA_PLL0LS_DIV17_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xa44)
+#define STX7111_CLOCKGENA_PLL1_DIV0_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xb00)
+#define STX7111_CLOCKGENA_PLL1_DIV1_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xb04)
+#define STX7111_CLOCKGENA_PLL1_DIV2_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xb08)
+#define STX7111_CLOCKGENA_PLL1_DIV3_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xb0c)
+#define STX7111_CLOCKGENA_PLL1_DIV4_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xb10)
+#define STX7111_CLOCKGENA_PLL1_DIV5_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xb14)
+#define STX7111_CLOCKGENA_PLL1_DIV6_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xb18)
+#define STX7111_CLOCKGENA_PLL1_DIV7_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xb1c)
+#define STX7111_CLOCKGENA_PLL1_DIV8_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xb20)
+#define STX7111_CLOCKGENA_PLL1_DIV9_CFG		SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xb24)
+#define STX7111_CLOCKGENA_PLL1_DIV10_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xb28)
+#define STX7111_CLOCKGENA_PLL1_DIV11_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xb2c)
+#define STX7111_CLOCKGENA_PLL1_DIV12_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xb30)
+#define STX7111_CLOCKGENA_PLL1_DIV13_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xb34)
+#define STX7111_CLOCKGENA_PLL1_DIV14_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xb38)
+#define STX7111_CLOCKGENA_PLL1_DIV15_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xb3c)
+#define STX7111_CLOCKGENA_PLL1_DIV16_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xb40)
+#define STX7111_CLOCKGENA_PLL1_DIV17_CFG	SH4_DWORD_REG(STX7111_CLOCKGENA_REGS_BASE + 0xb44)
+
+#define STX7111_CLOCKGENB_FS0_CTRL		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x14)
+#define STX7111_CLOCKGENB_FS0_MD1		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x18)
+#define STX7111_CLOCKGENB_FS0_PE1		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x1c)
+#define STX7111_CLOCKGENB_FS0_EN_PRG1		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x20)
+#define STX7111_CLOCKGENB_FS0_SDIV1		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x24)
+#define STX7111_CLOCKGENB_FS0_MD2		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x28)
+#define STX7111_CLOCKGENB_FS0_PE2		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x2c)
+#define STX7111_CLOCKGENB_FS0_EN_PRG2		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x30)
+#define STX7111_CLOCKGENB_FS0_SDIV2		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x34)
+#define STX7111_CLOCKGENB_FS0_MD3		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x38)
+#define STX7111_CLOCKGENB_FS0_PE3		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x3c)
+#define STX7111_CLOCKGENB_FS0_EN_PRG3		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x40)
+#define STX7111_CLOCKGENB_FS0_SDIV3		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x44)
+#define STX7111_CLOCKGENB_FS0_CLOCKOUT_CTRL	SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x58)
+#define STX7111_CLOCKGENB_FS1_CTRL		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x5c)
+#define STX7111_CLOCKGENB_FS1_MD1		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x60)
+#define STX7111_CLOCKGENB_FS1_PE1		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x64)
+#define STX7111_CLOCKGENB_FS1_EN_PRG1		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x68)
+#define STX7111_CLOCKGENB_FS1_SDIV1		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x6c)
+#define STX7111_CLOCKGENB_FS1_MD2		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x70)
+#define STX7111_CLOCKGENB_FS1_PE2		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x74)
+#define STX7111_CLOCKGENB_FS1_EN_PRG2		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x78)
+#define STX7111_CLOCKGENB_FS1_SDIV2		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x7c)
+#define STX7111_CLOCKGENB_FS1_MD3		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x80)
+#define STX7111_CLOCKGENB_FS1_PE3		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x84)
+#define STX7111_CLOCKGENB_FS1_EN_PRG3		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x88)
+#define STX7111_CLOCKGENB_FS1_SDIV3		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x8c)
+#define STX7111_CLOCKGENB_FS1_MD4		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x90)
+#define STX7111_CLOCKGENB_FS1_PE4		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x94)
+#define STX7111_CLOCKGENB_FS1_EN_PRG4		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x98)
+#define STX7111_CLOCKGENB_FS1_SDIV4		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0x9c)
+#define STX7111_CLOCKGENB_FS1_CLOCKOUT_CTRL	SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0xa0)
+#define STX7111_CLOCKGENB_DISPLAY_CFG		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0xa4)
+#define STX7111_CLOCKGENB_FS_SELECT		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0xa8)
+#define STX7111_CLOCKGENB_POWER_DOWN		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0xac)
+#define STX7111_CLOCKGENB_POWER_ENABLE		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0xb0)
+#define STX7111_CLOCKGENB_OUT_CTRL		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0xb4)
+#define STX7111_CLOCKGENB_CRISTAL_SEL		SH4_DWORD_REG(STX7111_CLOCKGENB_REGS_BASE + 0xb8)
+
+/* System configuration registers (STx7111 variant) */
+#define STX7111_SYSCONF_DEVICEID_0		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0000)
+#define STX7111_SYSCONF_DEVICEID_1		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0004)
+#define STX7111_SYSCONF_DEVICEID		SH4_GWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0000)
+#define STX7111_SYSCONF_SYS_STA00		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0008)
+#define STX7111_SYSCONF_SYS_STA01		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x000c)
+#define STX7111_SYSCONF_SYS_STA02		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0010)
+#define STX7111_SYSCONF_SYS_STA03		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0014)
+#define STX7111_SYSCONF_SYS_STA04		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0018)
+#define STX7111_SYSCONF_SYS_STA05		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x001c)
+#define STX7111_SYSCONF_SYS_STA06		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0020)
+#define STX7111_SYSCONF_SYS_STA07		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0024)
+#define STX7111_SYSCONF_SYS_STA08		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0028)
+#define STX7111_SYSCONF_SYS_STA09		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x002c)
+#define STX7111_SYSCONF_SYS_STA10		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0030)
+#define STX7111_SYSCONF_SYS_STA11		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0034)
+#define STX7111_SYSCONF_SYS_STA12		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0038)
+#define STX7111_SYSCONF_SYS_STA13		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x003c)
+#define STX7111_SYSCONF_SYS_STA14		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0040)
+#define STX7111_SYSCONF_SYS_STA15		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0044)
+#define STX7111_SYSCONF_SYS_CFG00		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0100)
+#define STX7111_SYSCONF_SYS_CFG01		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0104)
+#define STX7111_SYSCONF_SYS_CFG02		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0108)
+#define STX7111_SYSCONF_SYS_CFG03		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x010c)
+#define STX7111_SYSCONF_SYS_CFG04		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0110)
+#define STX7111_SYSCONF_SYS_CFG05		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0114)
+#define STX7111_SYSCONF_SYS_CFG06		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0118)
+#define STX7111_SYSCONF_SYS_CFG07		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x011c)
+#define STX7111_SYSCONF_SYS_CFG08		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0120)
+#define STX7111_SYSCONF_SYS_CFG09		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0124)
+#define STX7111_SYSCONF_SYS_CFG10		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0128)
+#define STX7111_SYSCONF_SYS_CFG11		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x012c)
+#define STX7111_SYSCONF_SYS_CFG12		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0130)
+#define STX7111_SYSCONF_SYS_CFG13		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0134)
+#define STX7111_SYSCONF_SYS_CFG14		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0138)
+#define STX7111_SYSCONF_SYS_CFG15		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x013c)
+#define STX7111_SYSCONF_SYS_CFG16		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0140)
+#define STX7111_SYSCONF_SYS_CFG17		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0144)
+#define STX7111_SYSCONF_SYS_CFG18		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0148)
+#define STX7111_SYSCONF_SYS_CFG19		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x014c)
+#define STX7111_SYSCONF_SYS_CFG20		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0150)
+#define STX7111_SYSCONF_SYS_CFG21		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0154)
+#define STX7111_SYSCONF_SYS_CFG22		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0158)
+#define STX7111_SYSCONF_SYS_CFG23		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x015c)
+#define STX7111_SYSCONF_SYS_CFG24		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0160)
+#define STX7111_SYSCONF_SYS_CFG25		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0164)
+#define STX7111_SYSCONF_SYS_CFG26		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0168)
+#define STX7111_SYSCONF_SYS_CFG27		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x016c)
+#define STX7111_SYSCONF_SYS_CFG28		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0170)
+#define STX7111_SYSCONF_SYS_CFG29		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0174)
+#define STX7111_SYSCONF_SYS_CFG30		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0178)
+#define STX7111_SYSCONF_SYS_CFG31		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x017c)
+#define STX7111_SYSCONF_SYS_CFG32		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0180)
+#define STX7111_SYSCONF_SYS_CFG33		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0184)
+#define STX7111_SYSCONF_SYS_CFG34		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0188)
+#define STX7111_SYSCONF_SYS_CFG35		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x018c)
+#define STX7111_SYSCONF_SYS_CFG36		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0190)
+#define STX7111_SYSCONF_SYS_CFG37		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0194)
+#define STX7111_SYSCONF_SYS_CFG38		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x0198)
+#define STX7111_SYSCONF_SYS_CFG39		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x019c)
+#define STX7111_SYSCONF_SYS_CFG40		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x01a0)
+#define STX7111_SYSCONF_SYS_CFG41		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x01a4)
+#define STX7111_SYSCONF_SYS_CFG42		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x01a8)
+#define STX7111_SYSCONF_SYS_CFG43		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x01ac)
+#define STX7111_SYSCONF_SYS_CFG44		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x01b0)
+#define STX7111_SYSCONF_SYS_CFG45		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x01b4)
+#define STX7111_SYSCONF_SYS_CFG46		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x01b8)
+#define STX7111_SYSCONF_SYS_CFG47		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x01bc)
+#define STX7111_SYSCONF_SYS_CFG48		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x01c0)
+#define STX7111_SYSCONF_SYS_CFG49		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x01c4)
+#define STX7111_SYSCONF_SYS_CFG50		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x01c8)
+#define STX7111_SYSCONF_SYS_CFG51		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x01cc)
+#define STX7111_SYSCONF_SYS_CFG52		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x01d0)
+#define STX7111_SYSCONF_SYS_CFG53		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x01d4)
+#define STX7111_SYSCONF_SYS_CFG54		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x01d8)
+#define STX7111_SYSCONF_SYS_CFG55		SH4_DWORD_REG(STX7111_SYSCONF_REGS_BASE + 0x01dc)
+
+/* Device ID values, masks & predicates */
+#define STX7111_DEVID_7111_VAL		0x03B
+#define STX7111_DEVID_ID_SHIFT		12
+#define STX7111_DEVID_ID_MASK		0x3ff
+#define STX7111_DEVID_CUT_SHIFT		28
+#define STX7111_DEVID_CUT_MASK		0xf
+
+#define STX7111_DEVICEID_7111(ID) ((((ID) >> STX7111_DEVID_ID_SHIFT) & STX7111_DEVID_ID_MASK) == STX7111_DEVID_7111_VAL)
+#define STX7111_DEVICEID_CUT(ID)  ((((ID) >> STX7111_DEVID_CUT_SHIFT) & STX7111_DEVID_CUT_MASK) + 1)
+
+#endif /* __STX7111REG_H */
diff --git a/include/asm-sh/stx7141reg.h b/include/asm-sh/stx7141reg.h
new file mode 100644
index 0000000000..ed5dc1fe29
--- /dev/null
+++ b/include/asm-sh/stx7141reg.h
@@ -0,0 +1,377 @@
+/*
+ * Copyright (C) STMicroelectronics Ltd. 2008.
+ *
+ * All rights reserved.
+ */
+
+/*
+ * This is derived from STMicroelectronics gnu toolchain example:
+ *   sh-superh-elf/examples/bare/sh4reg/sti7141reg.h
+ */
+
+
+#ifndef __STX7141REG_H
+#define __STX7141REG_H
+
+#include "sh4regtype.h"
+
+/*----------------------------------------------------------------------------*/
+
+/*
+ * Peripheral versions
+ */
+
+#ifndef ST40_LMIGP_VERSION
+#define ST40_LMIGP_VERSION 1
+#endif
+#ifndef ST40_NAND_CONTROLLER_VERSION
+#define ST40_NAND_CONTROLLER_VERSION 1
+#endif
+
+/*----------------------------------------------------------------------------*/
+
+/*
+ * Base addresses for control register banks.
+ */
+
+/* Generic SH4 control registers */
+#ifndef SH4_TMU_REGS_BASE
+#define SH4_TMU_REGS_BASE 0xffd80000
+#endif
+
+/* Common ST40 control registers */
+#ifndef ST40_CPG_REGS_BASE
+#define ST40_CPG_REGS_BASE 0xffc00000
+#endif
+#ifndef ST40_INTC_REGS_BASE
+#define ST40_INTC_REGS_BASE 0xffd00000
+#endif
+#ifndef ST40_SCIF2_REGS_BASE
+#define ST40_SCIF2_REGS_BASE 0xffe80000
+#endif
+
+#ifndef STX7141_COMMS_BASE
+#define STX7141_COMMS_BASE 0xfd000000
+#endif
+
+/* This is the COMMS ILC */
+#ifndef ST40_ILC_REGS_BASE
+#define ST40_ILC_REGS_BASE STX7141_COMMS_BASE
+#endif
+
+/*
+ * The STx7141 has two further ILC3's which we access in a similar way, but
+ * specify the ILC index first.
+ */
+#define STX7141_ILC_INPUT_INTERRUPT(n, m)	SH4_DWORD_REG(STX7141_ILC##n##_REGS_BASE + (0x0080 + ((m) * 4)))
+#define STX7141_ILC_STATUS(n, m)		SH4_DWORD_REG(STX7141_ILC##n##_REGS_BASE + (0x0200 + ((m) * 4)))
+#define STX7141_ILC_CLEAR_STATUS(n, m)		SH4_DWORD_REG(STX7141_ILC##n##_REGS_BASE + (0x0280 + ((m) * 4)))
+#define STX7141_ILC_ENABLE(n, m)		SH4_DWORD_REG(STX7141_ILC##n##_REGS_BASE + (0x0400 + ((m) * 4)))
+#define STX7141_ILC_CLEAR_ENABLE(n, m)		SH4_DWORD_REG(STX7141_ILC##n##_REGS_BASE + (0x0480 + ((m) * 4)))
+#define STX7141_ILC_SET_ENABLE(n, m)		SH4_DWORD_REG(STX7141_ILC##n##_REGS_BASE + (0x0500 + ((m) * 4)))
+#define STX7141_ILC_WAKEUP_ENABLE(n, m)		SH4_DWORD_REG(STX7141_ILC##n##_REGS_BASE + (0x0600 + ((m) * 4)))
+#define STX7141_ILC_WAKEUP_ACTIVE_LEVEL(n, m)	SH4_DWORD_REG(STX7141_ILC##n##_REGS_BASE + (0x0680 + ((m) * 4)))
+
+/* eSTB ST40 ILC */
+#ifndef STX7141_ILC0_REGS_BASE
+#define STX7141_ILC0_REGS_BASE 0xfd120000
+#endif
+
+/* eCM ST40 ILC */
+#ifndef STX7141_ILC1_REGS_BASE
+#define STX7141_ILC1_REGS_BASE 0xfd122000
+#endif
+
+#ifdef __STX7141_ECM__
+/* The eCM has an INTC2 */
+#ifndef ST40_INTC2_REGS_BASE
+#define ST40_INTC2_REGS_BASE 0xfd124000
+#endif
+#endif
+
+/* STx7141 control registers */
+#ifndef STX7141_SYSCONF_REGS_BASE
+#define STX7141_SYSCONF_REGS_BASE 0xfe001000
+#endif
+
+#ifndef STX7141_CLOCKGENA_REGS_BASE
+#define STX7141_CLOCKGENA_REGS_BASE 0xfe213000
+#endif
+
+#ifndef STX7141_CLOCKGENB_REGS_BASE
+#define STX7141_CLOCKGENB_REGS_BASE 0xfe000000
+#endif
+
+/* System Architecture Volume 2: Bus Interfaces */
+#ifndef ST40_LMI0_REGS_BASE
+#define ST40_LMI0_REGS_BASE 0xfe901000
+#endif
+#ifndef ST40_LMI1_REGS_BASE
+#define ST40_LMI1_REGS_BASE 0xfe902000
+#endif
+#ifndef ST40_EMI_REGS_BASE
+#define ST40_EMI_REGS_BASE 0xfe700000
+#endif
+
+/* System Architecture Volume 4: I/O Devices */
+#ifndef ST40_PIO1_REGS_BASE
+#define ST40_PIO1_REGS_BASE (STX7141_COMMS_BASE + 0x00020000)
+#endif
+#ifndef ST40_PIO2_REGS_BASE
+#define ST40_PIO2_REGS_BASE (STX7141_COMMS_BASE + 0x00021000)
+#endif
+#ifndef ST40_PIO3_REGS_BASE
+#define ST40_PIO3_REGS_BASE (STX7141_COMMS_BASE + 0x00022000)
+#endif
+#ifndef ST40_PIO4_REGS_BASE
+#define ST40_PIO4_REGS_BASE (STX7141_COMMS_BASE + 0x00023000)
+#endif
+#ifndef ST40_PIO5_REGS_BASE
+#define ST40_PIO5_REGS_BASE (STX7141_COMMS_BASE + 0x00024000)
+#endif
+#ifndef ST40_PIO6_REGS_BASE
+#define ST40_PIO6_REGS_BASE (STX7141_COMMS_BASE + 0x00025000)
+#endif
+#ifndef ST40_PIO7_REGS_BASE
+#define ST40_PIO7_REGS_BASE (STX7141_COMMS_BASE + 0x00026000)
+#endif
+
+/* The STx7141 also has a bank of stand-alone bank of PIOs */
+#ifndef STX7141_T1_PIO_REGS_BASE
+#define STX7141_T1_PIO_REGS_BASE 0xfe010000
+#endif
+
+#ifndef ST40_PIO8_REGS_BASE
+#define ST40_PIO8_REGS_BASE STX7141_T1_PIO_REGS_BASE
+#endif
+#ifndef ST40_PIO9_REGS_BASE
+#define ST40_PIO9_REGS_BASE (STX7141_T1_PIO_REGS_BASE + 0x00001000)
+#endif
+#ifndef ST40_PIO10_REGS_BASE
+#define ST40_PIO10_REGS_BASE (STX7141_T1_PIO_REGS_BASE + 0x00002000)
+#endif
+#ifndef ST40_PIO11_REGS_BASE
+#define ST40_PIO11_REGS_BASE (STX7141_T1_PIO_REGS_BASE + 0x00003000)
+#endif
+#ifndef ST40_PIO12_REGS_BASE
+#define ST40_PIO12_REGS_BASE (STX7141_T1_PIO_REGS_BASE + 0x00004000)
+#endif
+#ifndef ST40_PIO13_REGS_BASE
+#define ST40_PIO13_REGS_BASE (STX7141_T1_PIO_REGS_BASE + 0x00005000)
+#endif
+#ifndef ST40_PIO14_REGS_BASE
+#define ST40_PIO14_REGS_BASE (STX7141_T1_PIO_REGS_BASE + 0x00006000)
+#endif
+#ifndef ST40_PIO15_REGS_BASE
+#define ST40_PIO15_REGS_BASE (STX7141_T1_PIO_REGS_BASE + 0x00007000)
+#endif
+#ifndef ST40_PIO16_REGS_BASE
+#define ST40_PIO16_REGS_BASE (STX7141_T1_PIO_REGS_BASE + 0x00008000)
+#endif
+
+#ifndef ST40_ASC0_REGS_BASE
+#define ST40_ASC0_REGS_BASE (STX7141_COMMS_BASE + 0x00030000)
+#endif
+#ifndef ST40_ASC1_REGS_BASE
+#define ST40_ASC1_REGS_BASE (STX7141_COMMS_BASE + 0x00031000)
+#endif
+#ifndef ST40_ASC2_REGS_BASE
+#define ST40_ASC2_REGS_BASE (STX7141_COMMS_BASE + 0x00032000)
+#endif
+#ifndef ST40_MAILBOX0_REGS_BASE
+#define ST40_MAILBOX0_REGS_BASE 0xfe211000
+#endif
+#ifndef ST40_MAILBOX1_REGS_BASE
+#define ST40_MAILBOX1_REGS_BASE (ST40_MAILBOX0_REGS_BASE + 0x1000)
+#endif
+#ifndef ST40_MAILBOX2_REGS_BASE
+#define ST40_MAILBOX2_REGS_BASE (ST40_MAILBOX0_REGS_BASE + 0x0800)
+#endif
+#ifndef ST40_MAILBOX3_REGS_BASE
+#define ST40_MAILBOX3_REGS_BASE (ST40_MAILBOX0_REGS_BASE + 0x1800)
+#endif
+
+/*----------------------------------------------------------------------------*/
+
+#include "st40reg.h"
+
+/*
+ * STx7141 control registers
+ */
+
+/* Clock Generator control registers (STx7141 variant) */
+#define STX7141_CLOCKGENA_PLL0_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x00)
+#define STX7141_CLOCKGENA_PLL1_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x04)
+#define STX7141_CLOCKGENA_POWER_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x10)
+#define STX7141_CLOCKGENA_CLKOPSRC_SWITCH_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x14)
+#define STX7141_CLOCKGENA_OSC_ENABLE_FB		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x18)
+#define STX7141_CLOCKGENA_PLL0_ENABLE_FB	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x1c)
+#define STX7141_CLOCKGENA_PLL1_ENABLE_FB	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x20)
+#define STX7141_CLOCKGENA_CLKOPSRC_SWITCH_CFG2	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x24)
+#define STX7141_CLOCKGENA_CLKOBS_MUX1_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x30)
+#define STX7141_CLOCKGENA_CLKOBS_MASTER_MAXCOUNT SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x34)
+#define STX7141_CLOCKGENA_CLKOBS_CMD		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x38)
+#define STX7141_CLOCKGENA_CLKOBS_STATUS		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x3c)
+#define STX7141_CLOCKGENA_CLKOBS_SLAVE0_COUNT	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x40)
+#define STX7141_CLOCKGENA_CLKOBS_OSCMUX_DEBUG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x44)
+#define STX7141_CLOCKGENA_CLKOBS_MUX2_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x48)
+#define STX7141_CLOCKGENA_LOW_POWER_CTRL	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x4c)
+#define STX7141_CLOCKGENA_OSC_DIV0_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x800)
+#define STX7141_CLOCKGENA_OSC_DIV1_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x804)
+#define STX7141_CLOCKGENA_OSC_DIV2_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x808)
+#define STX7141_CLOCKGENA_OSC_DIV3_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x80c)
+#define STX7141_CLOCKGENA_OSC_DIV4_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x810)
+#define STX7141_CLOCKGENA_OSC_DIV5_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x814)
+#define STX7141_CLOCKGENA_OSC_DIV6_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x818)
+#define STX7141_CLOCKGENA_OSC_DIV7_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x81c)
+#define STX7141_CLOCKGENA_OSC_DIV8_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x820)
+#define STX7141_CLOCKGENA_OSC_DIV9_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x824)
+#define STX7141_CLOCKGENA_OSC_DIV10_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x828)
+#define STX7141_CLOCKGENA_OSC_DIV11_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x82c)
+#define STX7141_CLOCKGENA_OSC_DIV12_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x830)
+#define STX7141_CLOCKGENA_OSC_DIV13_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x834)
+#define STX7141_CLOCKGENA_OSC_DIV14_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x838)
+#define STX7141_CLOCKGENA_OSC_DIV15_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x83c)
+#define STX7141_CLOCKGENA_OSC_DIV16_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x840)
+#define STX7141_CLOCKGENA_OSC_DIV17_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x844)
+#define STX7141_CLOCKGENA_PLL0HS_DIV0_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x900)
+#define STX7141_CLOCKGENA_PLL0HS_DIV1_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x904)
+#define STX7141_CLOCKGENA_PLL0HS_DIV2_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x908)
+#define STX7141_CLOCKGENA_PLL0HS_DIV3_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0x90c)
+#define STX7141_CLOCKGENA_PLL0LS_DIV4_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xa10)
+#define STX7141_CLOCKGENA_PLL0LS_DIV5_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xa14)
+#define STX7141_CLOCKGENA_PLL0LS_DIV6_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xa18)
+#define STX7141_CLOCKGENA_PLL0LS_DIV7_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xa1c)
+#define STX7141_CLOCKGENA_PLL0LS_DIV8_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xa20)
+#define STX7141_CLOCKGENA_PLL0LS_DIV9_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xa24)
+#define STX7141_CLOCKGENA_PLL0LS_DIV10_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xa28)
+#define STX7141_CLOCKGENA_PLL0LS_DIV11_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xa2c)
+#define STX7141_CLOCKGENA_PLL0LS_DIV12_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xa30)
+#define STX7141_CLOCKGENA_PLL0LS_DIV13_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xa34)
+#define STX7141_CLOCKGENA_PLL0LS_DIV14_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xa38)
+#define STX7141_CLOCKGENA_PLL0LS_DIV15_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xa3c)
+#define STX7141_CLOCKGENA_PLL0LS_DIV16_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xa40)
+#define STX7141_CLOCKGENA_PLL0LS_DIV17_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xa44)
+#define STX7141_CLOCKGENA_PLL1_DIV0_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xb00)
+#define STX7141_CLOCKGENA_PLL1_DIV1_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xb04)
+#define STX7141_CLOCKGENA_PLL1_DIV2_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xb08)
+#define STX7141_CLOCKGENA_PLL1_DIV3_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xb0c)
+#define STX7141_CLOCKGENA_PLL1_DIV4_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xb10)
+#define STX7141_CLOCKGENA_PLL1_DIV5_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xb14)
+#define STX7141_CLOCKGENA_PLL1_DIV6_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xb18)
+#define STX7141_CLOCKGENA_PLL1_DIV7_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xb1c)
+#define STX7141_CLOCKGENA_PLL1_DIV8_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xb20)
+#define STX7141_CLOCKGENA_PLL1_DIV9_CFG		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xb24)
+#define STX7141_CLOCKGENA_PLL1_DIV10_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xb28)
+#define STX7141_CLOCKGENA_PLL1_DIV11_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xb2c)
+#define STX7141_CLOCKGENA_PLL1_DIV12_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xb30)
+#define STX7141_CLOCKGENA_PLL1_DIV13_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xb34)
+#define STX7141_CLOCKGENA_PLL1_DIV14_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xb38)
+#define STX7141_CLOCKGENA_PLL1_DIV15_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xb3c)
+#define STX7141_CLOCKGENA_PLL1_DIV16_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xb40)
+#define STX7141_CLOCKGENA_PLL1_DIV17_CFG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xb44)
+#define STX7141_CLOCKGENA_PLL0_BIST_REFCOUNT	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xf00)
+#define STX7141_CLOCKGENA_PLL0_BIST_CMPCOUNT	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xf04)
+#define STX7141_CLOCKGENA_PLL0_BIST_CONFIG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xf08)
+#define STX7141_CLOCKGENA_PLL0_BIST_OUTCOUNT	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xf0c)
+#define STX7141_CLOCKGENA_PLL1_BIST_REFCOUNT	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xf10)
+#define STX7141_CLOCKGENA_PLL1_BIST_CMPCOUNT	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xf14)
+#define STX7141_CLOCKGENA_PLL1_BIST_CONFIG	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xf18)
+#define STX7141_CLOCKGENA_PLL1_BIST_OUTCOUNT	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xf1c)
+#define STX7141_CLOCKGENA_JITTERBIST_PAT	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xf20)
+#define STX7141_CLOCKGENA_JITTERBIST_CMD	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xf24)
+#define STX7141_CLOCKGENA_JITTERBIST_CPT_PAT	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xf28)
+#define STX7141_CLOCKGENA_JITTERBIST_CPT_NOT_PAT SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xf2c)
+#define STX7141_CLOCKGENA_JITTERBIST_BEAT_COUNT	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xf30)
+#define STX7141_CLOCKGENA_JITTERBIST_BEAT_EDGE	SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xf34)
+#define STX7141_CLOCKGENA_BIST_BENDBAD		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xff8)
+#define STX7141_CLOCKGENA_BIST_SELECT		SH4_DWORD_REG(STX7141_CLOCKGENA_REGS_BASE + 0xffc)
+
+/* System configuration registers (STx7141 variant) */
+#define STX7141_SYSCONF_DEVICEID_0		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0000)
+#define STX7141_SYSCONF_DEVICEID_1		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0004)
+#define STX7141_SYSCONF_DEVICEID		SH4_GWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0000)
+#define STX7141_SYSCONF_SYS_STA00		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0008)
+#define STX7141_SYSCONF_SYS_STA01		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x000c)
+#define STX7141_SYSCONF_SYS_STA02		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0010)
+#define STX7141_SYSCONF_SYS_STA03		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0014)
+#define STX7141_SYSCONF_SYS_STA04		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0018)
+#define STX7141_SYSCONF_SYS_STA05		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x001c)
+#define STX7141_SYSCONF_SYS_STA06		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0020)
+#define STX7141_SYSCONF_SYS_STA07		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0024)
+#define STX7141_SYSCONF_SYS_STA08		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0028)
+#define STX7141_SYSCONF_SYS_STA09		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x002c)
+#define STX7141_SYSCONF_SYS_STA10		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0030)
+#define STX7141_SYSCONF_SYS_STA11		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0034)
+#define STX7141_SYSCONF_SYS_STA12		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0038)
+#define STX7141_SYSCONF_SYS_STA13		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x003c)
+#define STX7141_SYSCONF_SYS_STA14		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0040)
+#define STX7141_SYSCONF_SYS_STA15		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0044)
+#define STX7141_SYSCONF_SYS_CFG00		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0100)
+#define STX7141_SYSCONF_SYS_CFG01		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0104)
+#define STX7141_SYSCONF_SYS_CFG02		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0108)
+#define STX7141_SYSCONF_SYS_CFG03		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x010c)
+#define STX7141_SYSCONF_SYS_CFG04		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0110)
+#define STX7141_SYSCONF_SYS_CFG05		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0114)
+#define STX7141_SYSCONF_SYS_CFG06		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0118)
+#define STX7141_SYSCONF_SYS_CFG07		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x011c)
+#define STX7141_SYSCONF_SYS_CFG08		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0120)
+#define STX7141_SYSCONF_SYS_CFG09		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0124)
+#define STX7141_SYSCONF_SYS_CFG10		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0128)
+#define STX7141_SYSCONF_SYS_CFG11		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x012c)
+#define STX7141_SYSCONF_SYS_CFG12		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0130)
+#define STX7141_SYSCONF_SYS_CFG13		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0134)
+#define STX7141_SYSCONF_SYS_CFG14		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0138)
+#define STX7141_SYSCONF_SYS_CFG15		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x013c)
+#define STX7141_SYSCONF_SYS_CFG16		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0140)
+#define STX7141_SYSCONF_SYS_CFG17		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0144)
+#define STX7141_SYSCONF_SYS_CFG18		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0148)
+#define STX7141_SYSCONF_SYS_CFG19		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x014c)
+#define STX7141_SYSCONF_SYS_CFG20		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0150)
+#define STX7141_SYSCONF_SYS_CFG21		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0154)
+#define STX7141_SYSCONF_SYS_CFG22		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0158)
+#define STX7141_SYSCONF_SYS_CFG23		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x015c)
+#define STX7141_SYSCONF_SYS_CFG24		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0160)
+#define STX7141_SYSCONF_SYS_CFG25		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0164)
+#define STX7141_SYSCONF_SYS_CFG26		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0168)
+#define STX7141_SYSCONF_SYS_CFG27		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x016c)
+#define STX7141_SYSCONF_SYS_CFG28		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0170)
+#define STX7141_SYSCONF_SYS_CFG29		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0174)
+#define STX7141_SYSCONF_SYS_CFG30		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0178)
+#define STX7141_SYSCONF_SYS_CFG31		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x017c)
+#define STX7141_SYSCONF_SYS_CFG32		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0180)
+#define STX7141_SYSCONF_SYS_CFG33		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0184)
+#define STX7141_SYSCONF_SYS_CFG34		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0188)
+#define STX7141_SYSCONF_SYS_CFG35		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x018c)
+#define STX7141_SYSCONF_SYS_CFG36		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0190)
+#define STX7141_SYSCONF_SYS_CFG37		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0194)
+#define STX7141_SYSCONF_SYS_CFG38		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x0198)
+#define STX7141_SYSCONF_SYS_CFG39		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x019c)
+#define STX7141_SYSCONF_SYS_CFG40		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x01a0)
+#define STX7141_SYSCONF_SYS_CFG41		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x01a4)
+#define STX7141_SYSCONF_SYS_CFG42		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x01a8)
+#define STX7141_SYSCONF_SYS_CFG43		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x01ac)
+#define STX7141_SYSCONF_SYS_CFG44		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x01b0)
+#define STX7141_SYSCONF_SYS_CFG45		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x01b4)
+#define STX7141_SYSCONF_SYS_CFG46		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x01b8)
+#define STX7141_SYSCONF_SYS_CFG47		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x01bc)
+#define STX7141_SYSCONF_SYS_CFG48		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x01c0)
+#define STX7141_SYSCONF_SYS_CFG49		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x01c4)
+#define STX7141_SYSCONF_SYS_CFG50		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x01c8)
+#define STX7141_SYSCONF_SYS_CFG51		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x01cc)
+#define STX7141_SYSCONF_SYS_CFG52		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x01d0)
+#define STX7141_SYSCONF_SYS_CFG53		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x01d4)
+#define STX7141_SYSCONF_SYS_CFG54		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x01d8)
+#define STX7141_SYSCONF_SYS_CFG55		SH4_DWORD_REG(STX7141_SYSCONF_REGS_BASE + 0x01dc)
+
+/* Device ID values, masks & predicates */
+#define STX7141_DEVID_7141_VAL		0x03C
+#define STX7141_DEVID_ID_SHIFT		12
+#define STX7141_DEVID_ID_MASK		0x3ff
+#define STX7141_DEVID_CUT_SHIFT		28
+#define STX7141_DEVID_CUT_MASK		0xf
+
+#define STX7141_DEVICEID_7141(ID) ((((ID) >> STX7141_DEVID_ID_SHIFT) & STX7141_DEVID_ID_MASK) == STX7141_DEVID_7141_VAL)
+#define STX7141_DEVICEID_CUT(ID)  ((((ID) >> STX7141_DEVID_CUT_SHIFT) & STX7141_DEVID_CUT_MASK) + 1)
+
+#endif /* __STX7141REG_H */
diff --git a/include/asm-sh/stx7200reg.h b/include/asm-sh/stx7200reg.h
new file mode 100644
index 0000000000..313ea4b57b
--- /dev/null
+++ b/include/asm-sh/stx7200reg.h
@@ -0,0 +1,328 @@
+/*
+ * Copyright (C) STMicroelectronics Ltd. 2007.
+ *
+ * All rights reserved.
+ */
+
+/*
+ * This is derived from STMicroelectronics gnu toolchain example:
+ *   sh-superh-elf/examples/bare/sh4reg/sti7200reg.h
+ */
+
+
+#ifndef __STX7200REG_H
+#define __STX7200REG_H
+
+#include "sh4regtype.h"
+
+/*----------------------------------------------------------------------------*/
+
+/*
+ * Peripheral versions
+ */
+
+#ifndef ST40_LMIGP_VERSION
+#define ST40_LMIGP_VERSION 1
+#endif
+
+/*----------------------------------------------------------------------------*/
+
+/*
+ * Base addresses for control register banks.
+ */
+
+/* Generic SH4 control registers */
+#ifndef SH4_TMU_REGS_BASE
+#define SH4_TMU_REGS_BASE 0xffd80000
+#endif
+#ifndef SH4_RTC_REGS_BASE
+#define SH4_RTC_REGS_BASE 0xffc80000
+#endif
+
+/* Common ST40 control registers */
+#ifndef ST40_CPG_REGS_BASE
+#define ST40_CPG_REGS_BASE 0xffc00000
+#endif
+#ifndef ST40_INTC_REGS_BASE
+#define ST40_INTC_REGS_BASE 0xffd00000
+#endif
+#ifndef ST40_SCIF2_REGS_BASE
+#define ST40_SCIF2_REGS_BASE 0xffe80000
+#endif
+
+#ifndef ST40_ILC_REGS_BASE
+#define ST40_ILC_REGS_BASE 0xfd804000
+#endif
+
+/* STx7200 control registers */
+#ifndef STX7200_SYSCONF_REGS_BASE
+#define STX7200_SYSCONF_REGS_BASE 0xfd704000
+#endif
+
+#ifndef STX7200_CLOCKGENA_REGS_BASE
+#define STX7200_CLOCKGENA_REGS_BASE 0xfd700000
+#endif
+
+#ifndef STX7200_CLOCKGENB_REGS_BASE
+#define STX7200_CLOCKGENB_REGS_BASE (STX7200_CLOCKGENA_REGS_BASE + 0x1000)
+#endif
+
+#ifndef STX7200_CLOCKGENC_REGS_BASE
+#define STX7200_CLOCKGENC_REGS_BASE (STX7200_CLOCKGENA_REGS_BASE + 0x2000)
+#endif
+
+#ifndef STX7200_STBUS_NODE00_REGS_BASE
+#define STX7200_STBUS_NODE00_REGS_BASE 0xfdc05000
+#endif
+#ifndef STX7200_STBUS_NODE01_REGS_BASE
+#define STX7200_STBUS_NODE01_REGS_BASE 0xfdc05c00
+#endif
+#ifndef STX7200_STBUS_NODE04_REGS_BASE
+#define STX7200_STBUS_NODE04_REGS_BASE 0xfdc05600
+#endif
+#ifndef STX7200_STBUS_NODE08_REGS_BASE
+#define STX7200_STBUS_NODE08_REGS_BASE 0xfdc05a00
+#endif
+#ifndef STX7200_STBUS_NODE09_REGS_BASE
+#define STX7200_STBUS_NODE09_REGS_BASE 0xfdc06000
+#endif
+#ifndef STX7200_STBUS_NODE10_REGS_BASE
+#define STX7200_STBUS_NODE10_REGS_BASE 0xfdc06200
+#endif
+#ifndef STX7200_STBUS_NODE12_REGS_BASE
+#define STX7200_STBUS_NODE12_REGS_BASE 0xfdc05800
+#endif
+#ifndef STX7200_STBUS_NODE13_REGS_BASE
+#define STX7200_STBUS_NODE13_REGS_BASE 0xfdc05200
+#endif
+#ifndef STX7200_STBUS_NODE17_REGS_BASE
+#define STX7200_STBUS_NODE17_REGS_BASE 0xfdc05400
+#endif
+#ifndef STX7200_STBUS_NODE18_REGS_BASE
+#define STX7200_STBUS_NODE18_REGS_BASE 0xfdc05e00
+#endif
+#ifndef STX7200_STBUS_NODE20_REGS_BASE
+#define STX7200_STBUS_NODE20_REGS_BASE 0xfdc06400
+#endif
+
+/* System Architecture Volume 2: Bus Interfaces */
+#ifndef ST40_LMI0_REGS_BASE
+#define ST40_LMI0_REGS_BASE 0xfdd18000
+#endif
+#ifndef ST40_LMI1_REGS_BASE
+#define ST40_LMI1_REGS_BASE 0xfdd19000
+#endif
+#ifndef ST40_EMI_REGS_BASE
+#define ST40_EMI_REGS_BASE 0xfdf00000
+#endif
+
+/* System Architecture Volume 4: I/O Devices */
+#ifndef STX7200_COMMS_BASE
+#define STX7200_COMMS_BASE 0xfd000000
+#endif
+
+#ifndef ST40_PIO0_REGS_BASE
+#define ST40_PIO0_REGS_BASE (STX7200_COMMS_BASE + 0x00020000)
+#endif
+#ifndef ST40_PIO1_REGS_BASE
+#define ST40_PIO1_REGS_BASE (STX7200_COMMS_BASE + 0x00021000)
+#endif
+#ifndef ST40_PIO2_REGS_BASE
+#define ST40_PIO2_REGS_BASE (STX7200_COMMS_BASE + 0x00022000)
+#endif
+#ifndef ST40_PIO3_REGS_BASE
+#define ST40_PIO3_REGS_BASE (STX7200_COMMS_BASE + 0x00023000)
+#endif
+#ifndef ST40_PIO4_REGS_BASE
+#define ST40_PIO4_REGS_BASE (STX7200_COMMS_BASE + 0x00024000)
+#endif
+#ifndef ST40_PIO5_REGS_BASE
+#define ST40_PIO5_REGS_BASE (STX7200_COMMS_BASE + 0x00025000)
+#endif
+#ifndef ST40_PIO6_REGS_BASE
+#define ST40_PIO6_REGS_BASE (STX7200_COMMS_BASE + 0x00026000)
+#endif
+#ifndef ST40_PIO7_REGS_BASE
+#define ST40_PIO7_REGS_BASE (STX7200_COMMS_BASE + 0x00027000)
+#endif
+#ifndef ST40_ASC0_REGS_BASE
+#define ST40_ASC0_REGS_BASE (STX7200_COMMS_BASE + 0x00030000)
+#endif
+#ifndef ST40_ASC1_REGS_BASE
+#define ST40_ASC1_REGS_BASE (STX7200_COMMS_BASE + 0x00031000)
+#endif
+#ifndef ST40_ASC2_REGS_BASE
+#define ST40_ASC2_REGS_BASE (STX7200_COMMS_BASE + 0x00032000)
+#endif
+#ifndef ST40_ASC3_REGS_BASE
+#define ST40_ASC3_REGS_BASE (STX7200_COMMS_BASE + 0x00033000)
+#endif
+#ifndef ST40_SSC0_REGS_BASE
+#define ST40_SSC0_REGS_BASE (STX7200_COMMS_BASE + 0x00040000)
+#endif
+#ifndef ST40_SSC1_REGS_BASE
+#define ST40_SSC1_REGS_BASE (STX7200_COMMS_BASE + 0x00041000)
+#endif
+#ifndef ST40_SSC2_REGS_BASE
+#define ST40_SSC2_REGS_BASE (STX7200_COMMS_BASE + 0x00042000)
+#endif
+#ifndef ST40_SSC3_REGS_BASE
+#define ST40_SSC3_REGS_BASE (STX7200_COMMS_BASE + 0x00043000)
+#endif
+#ifndef ST40_SSC4_REGS_BASE
+#define ST40_SSC4_REGS_BASE (STX7200_COMMS_BASE + 0x00044000)
+#endif
+#ifndef ST40_MAILBOX0_REGS_BASE
+#define ST40_MAILBOX0_REGS_BASE 0xfd800000
+#endif
+#ifndef ST40_MAILBOX1_REGS_BASE
+#define ST40_MAILBOX1_REGS_BASE (ST40_MAILBOX0_REGS_BASE + 0x1000)
+#endif
+#ifndef ST40_MAILBOX2_REGS_BASE
+#define ST40_MAILBOX2_REGS_BASE (ST40_MAILBOX0_REGS_BASE + 0x2000)
+#endif
+#ifndef ST40_MAILBOX3_REGS_BASE
+#define ST40_MAILBOX3_REGS_BASE (ST40_MAILBOX0_REGS_BASE + 0x3000)
+#endif
+
+/*----------------------------------------------------------------------------*/
+
+#include "st40reg.h"
+
+/*
+ * STx7200 control registers
+ */
+
+/* Clock Generator control registers (STx7200 variant) */
+#define STX7200_CLOCKGENA_PLL0_CFG		SH4_DWORD_REG(STX7200_CLOCKGENA_REGS_BASE + 0x00)
+#define STX7200_CLOCKGENA_PLL1_CFG		SH4_DWORD_REG(STX7200_CLOCKGENA_REGS_BASE + 0x04)
+#define STX7200_CLOCKGENA_PLL2_CFG		SH4_DWORD_REG(STX7200_CLOCKGENA_REGS_BASE + 0x08)
+#define STX7200_CLOCKGENA_MUX_CFG		SH4_DWORD_REG(STX7200_CLOCKGENA_REGS_BASE + 0x0c)
+#define STX7200_CLOCKGENA_DIV_CFG		SH4_DWORD_REG(STX7200_CLOCKGENA_REGS_BASE + 0x10)
+#define STX7200_CLOCKGENA_DIV2_CFG		SH4_DWORD_REG(STX7200_CLOCKGENA_REGS_BASE + 0x14)
+#define STX7200_CLOCKGENA_CLKOBS_MUX_CFG	SH4_DWORD_REG(STX7200_CLOCKGENA_REGS_BASE + 0x18)
+#define STX7200_CLOCKGENA_POWER_CFG		SH4_DWORD_REG(STX7200_CLOCKGENA_REGS_BASE + 0x1c)
+#define STX7200_CLOCKGENA_CLKOBS_MAX		SH4_DWORD_REG(STX7200_CLOCKGENA_REGS_BASE + 0x20)
+#define STX7200_CLOCKGENA_CLKOBS_RESULT		SH4_DWORD_REG(STX7200_CLOCKGENA_REGS_BASE + 0x24)
+#define STX7200_CLOCKGENA_CLKOBS_CTRL		SH4_DWORD_REG(STX7200_CLOCKGENA_REGS_BASE + 0x28)
+
+#define STX7200_CLOCKGENB_FS0_SETUP		SH4_DWORD_REG(STX7200_CLOCKGENB_REGS_BASE + 0x00)
+#define STX7200_CLOCKGENB_FS1_SETUP		SH4_DWORD_REG(STX7200_CLOCKGENB_REGS_BASE + 0x04)
+#define STX7200_CLOCKGENB_FS2_SETUP		SH4_DWORD_REG(STX7200_CLOCKGENB_REGS_BASE + 0x08)
+#define STX7200_CLOCKGENB_FS0_CLK1_CFG		SH4_DWORD_REG(STX7200_CLOCKGENB_REGS_BASE + 0x0c)
+#define STX7200_CLOCKGENB_FS0_CLK2_CFG		SH4_DWORD_REG(STX7200_CLOCKGENB_REGS_BASE + 0x10)
+#define STX7200_CLOCKGENB_FS0_CLK3_CFG		SH4_DWORD_REG(STX7200_CLOCKGENB_REGS_BASE + 0x14)
+#define STX7200_CLOCKGENB_FS0_CLK4_CFG		SH4_DWORD_REG(STX7200_CLOCKGENB_REGS_BASE + 0x18)
+#define STX7200_CLOCKGENB_FS1_CLK1_CFG		SH4_DWORD_REG(STX7200_CLOCKGENB_REGS_BASE + 0x1c)
+#define STX7200_CLOCKGENB_FS1_CLK2_CFG		SH4_DWORD_REG(STX7200_CLOCKGENB_REGS_BASE + 0x20)
+#define STX7200_CLOCKGENB_FS1_CLK3_CFG		SH4_DWORD_REG(STX7200_CLOCKGENB_REGS_BASE + 0x24)
+#define STX7200_CLOCKGENB_FS1_CLK4_CFG		SH4_DWORD_REG(STX7200_CLOCKGENB_REGS_BASE + 0x28)
+#define STX7200_CLOCKGENB_FS2_CLK1_CFG		SH4_DWORD_REG(STX7200_CLOCKGENB_REGS_BASE + 0x2c)
+#define STX7200_CLOCKGENB_FS2_CLK2_CFG		SH4_DWORD_REG(STX7200_CLOCKGENB_REGS_BASE + 0x30)
+#define STX7200_CLOCKGENB_FS2_CLK3_CFG		SH4_DWORD_REG(STX7200_CLOCKGENB_REGS_BASE + 0x34)
+#define STX7200_CLOCKGENB_FS2_CLK4_CFG		SH4_DWORD_REG(STX7200_CLOCKGENB_REGS_BASE + 0x38)
+#define STX7200_CLOCKGENB_PLL0_CFG		SH4_DWORD_REG(STX7200_CLOCKGENB_REGS_BASE + 0x3c)
+#define STX7200_CLOCKGENB_CLKRCV_CFG		SH4_DWORD_REG(STX7200_CLOCKGENB_REGS_BASE + 0x40)
+#define STX7200_CLOCKGENB_IN_MUX_CFG		SH4_DWORD_REG(STX7200_CLOCKGENB_REGS_BASE + 0x44)
+#define STX7200_CLOCKGENB_OUT_MUX_CFG		SH4_DWORD_REG(STX7200_CLOCKGENB_REGS_BASE + 0x48)
+#define STX7200_CLOCKGENB_DIV_CFG		SH4_DWORD_REG(STX7200_CLOCKGENB_REGS_BASE + 0x4c)
+#define STX7200_CLOCKGENB_DIV2_CFG		SH4_DWORD_REG(STX7200_CLOCKGENB_REGS_BASE + 0x50)
+#define STX7200_CLOCKGENB_CLKOBS_MUX_CFG	SH4_DWORD_REG(STX7200_CLOCKGENB_REGS_BASE + 0x54)
+#define STX7200_CLOCKGENB_POWER_CFG		SH4_DWORD_REG(STX7200_CLOCKGENB_REGS_BASE + 0x58)
+#define STX7200_CLOCKGENB_CLKOBS_MAX		SH4_DWORD_REG(STX7200_CLOCKGENB_REGS_BASE + 0x5c)
+#define STX7200_CLOCKGENB_CLKOBS_RESULT		SH4_DWORD_REG(STX7200_CLOCKGENB_REGS_BASE + 0x60)
+#define STX7200_CLOCKGENB_CLKOBS_CTRL		SH4_DWORD_REG(STX7200_CLOCKGENB_REGS_BASE + 0x64)
+
+/* System configuration registers (STx7200 variant) */
+#define STX7200_SYSCONF_DEVICEID_0	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0000)
+#define STX7200_SYSCONF_DEVICEID_1	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0004)
+#define STX7200_SYSCONF_DEVICEID	SH4_GWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0000)
+#define STX7200_SYSCONF_SYS_STA00	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0008)
+#define STX7200_SYSCONF_SYS_STA01	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x000c)
+#define STX7200_SYSCONF_SYS_STA02	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0010)
+#define STX7200_SYSCONF_SYS_STA03	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0014)
+#define STX7200_SYSCONF_SYS_STA04	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0018)
+#define STX7200_SYSCONF_SYS_STA05	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x001c)
+#define STX7200_SYSCONF_SYS_STA06	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0020)
+#define STX7200_SYSCONF_SYS_STA07	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0024)
+#define STX7200_SYSCONF_SYS_STA08	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0028)
+#define STX7200_SYSCONF_SYS_STA09	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x002c)
+#define STX7200_SYSCONF_SYS_STA10	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0030)
+#define STX7200_SYSCONF_SYS_STA11	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0034)
+#define STX7200_SYSCONF_SYS_STA12	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0038)
+#define STX7200_SYSCONF_SYS_STA13	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x003c)
+#define STX7200_SYSCONF_SYS_STA14	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0040)
+#define STX7200_SYSCONF_SYS_STA15	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0044)
+#define STX7200_SYSCONF_SYS_CFG00	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0100)
+#define STX7200_SYSCONF_SYS_CFG01	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0104)
+#define STX7200_SYSCONF_SYS_CFG02	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0108)
+#define STX7200_SYSCONF_SYS_CFG03	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x010c)
+#define STX7200_SYSCONF_SYS_CFG04	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0110)
+#define STX7200_SYSCONF_SYS_CFG05	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0114)
+#define STX7200_SYSCONF_SYS_CFG06	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0118)
+#define STX7200_SYSCONF_SYS_CFG07	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x011c)
+#define STX7200_SYSCONF_SYS_CFG08	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0120)
+#define STX7200_SYSCONF_SYS_CFG09	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0124)
+#define STX7200_SYSCONF_SYS_CFG10	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0128)
+#define STX7200_SYSCONF_SYS_CFG11	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x012c)
+#define STX7200_SYSCONF_SYS_CFG12	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0130)
+#define STX7200_SYSCONF_SYS_CFG13	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0134)
+#define STX7200_SYSCONF_SYS_CFG14	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0138)
+#define STX7200_SYSCONF_SYS_CFG15	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x013c)
+#define STX7200_SYSCONF_SYS_CFG16	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0140)
+#define STX7200_SYSCONF_SYS_CFG17	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0144)
+#define STX7200_SYSCONF_SYS_CFG18	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0148)
+#define STX7200_SYSCONF_SYS_CFG19	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x014c)
+#define STX7200_SYSCONF_SYS_CFG20	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0150)
+#define STX7200_SYSCONF_SYS_CFG21	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0154)
+#define STX7200_SYSCONF_SYS_CFG22	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0158)
+#define STX7200_SYSCONF_SYS_CFG23	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x015c)
+#define STX7200_SYSCONF_SYS_CFG24	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0160)
+#define STX7200_SYSCONF_SYS_CFG25	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0164)
+#define STX7200_SYSCONF_SYS_CFG26	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0168)
+#define STX7200_SYSCONF_SYS_CFG27	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x016c)
+#define STX7200_SYSCONF_SYS_CFG28	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0170)
+#define STX7200_SYSCONF_SYS_CFG29	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0174)
+#define STX7200_SYSCONF_SYS_CFG30	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0178)
+#define STX7200_SYSCONF_SYS_CFG31	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x017c)
+#define STX7200_SYSCONF_SYS_CFG32	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0180)
+#define STX7200_SYSCONF_SYS_CFG33	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0184)
+#define STX7200_SYSCONF_SYS_CFG34	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0188)
+#define STX7200_SYSCONF_SYS_CFG35	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x018c)
+#define STX7200_SYSCONF_SYS_CFG36	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0190)
+#define STX7200_SYSCONF_SYS_CFG37	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0194)
+#define STX7200_SYSCONF_SYS_CFG38	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x0198)
+#define STX7200_SYSCONF_SYS_CFG39	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x019c)
+#define STX7200_SYSCONF_SYS_CFG40	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x01a0)
+#define STX7200_SYSCONF_SYS_CFG41	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x01a4)
+#define STX7200_SYSCONF_SYS_CFG42	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x01a8)
+#define STX7200_SYSCONF_SYS_CFG43	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x01ac)
+#define STX7200_SYSCONF_SYS_CFG44	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x01b0)
+#define STX7200_SYSCONF_SYS_CFG45	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x01b4)
+#define STX7200_SYSCONF_SYS_CFG46	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x01b8)
+#define STX7200_SYSCONF_SYS_CFG47	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x01bc)
+#define STX7200_SYSCONF_SYS_CFG48	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x01c0)
+#define STX7200_SYSCONF_SYS_CFG49	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x01c4)
+#define STX7200_SYSCONF_SYS_CFG50	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x01c8)
+#define STX7200_SYSCONF_SYS_CFG51	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x01cc)
+#define STX7200_SYSCONF_SYS_CFG52	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x01d0)
+#define STX7200_SYSCONF_SYS_CFG53	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x01d4)
+#define STX7200_SYSCONF_SYS_CFG54	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x01d8)
+#define STX7200_SYSCONF_SYS_CFG55	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x01dc)
+#define STX7200_SYSCONF_SYS_CFG56	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x01e0)
+#define STX7200_SYSCONF_SYS_CFG57	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x01e4)
+#define STX7200_SYSCONF_SYS_CFG58	SH4_DWORD_REG(STX7200_SYSCONF_REGS_BASE + 0x01e8)
+
+#define STX7200_DEVID_7200c1_VAL	0x2C0	/* STx7200 cut 1.x */
+#define STX7200_DEVID_7200c2_VAL	0x037	/* STx7200 cut 2.x */
+#define STX7200_DEVID_ID_SHIFT		12
+#define STX7200_DEVID_ID_MASK		0x3ff	/* ten bits */
+#define STX7200_DEVID_CUT_SHIFT		28
+#define STX7200_DEVID_CUT_MASK		0xf	/* four bits */
+
+#define STX7200_DEVICEID_7200(ID)	(	\
+	((((ID)>>STX7200_DEVID_ID_SHIFT)&STX7200_DEVID_ID_MASK)==STX7200_DEVID_7200c1_VAL)  || \
+	((((ID)>>STX7200_DEVID_ID_SHIFT)&STX7200_DEVID_ID_MASK)==STX7200_DEVID_7200c2_VAL)     )
+#define STX7200_DEVICEID_CUT(ID)  ((((ID) >> STX7200_DEVID_CUT_SHIFT) & STX7200_DEVID_CUT_MASK) + 1)
+
+#endif /* __STX7200REG_H */
diff --git a/include/asm-sh/system.h b/include/asm-sh/system.h
new file mode 100644
index 0000000000..9891ab9973
--- /dev/null
+++ b/include/asm-sh/system.h
@@ -0,0 +1,296 @@
+#ifndef __ASM_SH_SYSTEM_H
+#define __ASM_SH_SYSTEM_H
+
+/*
+ * Copyright (C) 1999, 2000  Niibe Yutaka  &  Kaz Kojima
+ */
+
+#include <linux/config.h>
+
+/* #include <linux/kernel.h> */
+
+/*
+ *	switch_to() should switch tasks to task nr n, first
+ */
+
+typedef struct
+{
+	unsigned long seg;
+} mm_segment_t;
+
+#ifdef CONFIG_SMP
+#error no SMP SuperH
+#else
+#define prepare_to_switch()	do { } while(0)
+#define switch_to(prev,next,last) do { \
+ register struct task_struct *__last; \
+ register unsigned long *__ts1 __asm__ ("r1") = &prev->thread.sp; \
+ register unsigned long *__ts2 __asm__ ("r2") = &prev->thread.pc; \
+ register unsigned long *__ts4 __asm__ ("r4") = (unsigned long *)prev; \
+ register unsigned long *__ts5 __asm__ ("r5") = (unsigned long *)next; \
+ register unsigned long *__ts6 __asm__ ("r6") = &next->thread.sp; \
+ register unsigned long __ts7 __asm__ ("r7") = next->thread.pc; \
+ __asm__ __volatile__ (".balign 4\n\t" \
+		       "stc.l	gbr, @-r15\n\t" \
+		       "sts.l	pr, @-r15\n\t" \
+		       "mov.l	r8, @-r15\n\t" \
+		       "mov.l	r9, @-r15\n\t" \
+		       "mov.l	r10, @-r15\n\t" \
+		       "mov.l	r11, @-r15\n\t" \
+		       "mov.l	r12, @-r15\n\t" \
+		       "mov.l	r13, @-r15\n\t" \
+		       "mov.l	r14, @-r15\n\t" \
+		       "mov.l	r15, @r1	! save SP\n\t" \
+		       "mov.l	@r6, r15	! change to new stack\n\t" \
+		       "mov.l	%0, @-r15	! push R0 onto new stack\n\t" \
+		       "mova	1f, %0\n\t" \
+		       "mov.l	%0, @r2	! save PC\n\t" \
+		       "mov.l	2f, %0\n\t" \
+		       "jmp	@%0		! call __switch_to\n\t" \
+		       " lds	r7, pr	!  with return to new PC\n\t" \
+		       ".balign	4\n"	\
+		       "2:\n\t" \
+		       ".long	" "__switch_to\n" \
+		       "1:\n\t" \
+		       "mov.l	@r15+, %0	! pop R0 from new stack\n\t" \
+		       "mov.l	@r15+, r14\n\t" \
+		       "mov.l	@r15+, r13\n\t" \
+		       "mov.l	@r15+, r12\n\t" \
+		       "mov.l	@r15+, r11\n\t" \
+		       "mov.l	@r15+, r10\n\t" \
+		       "mov.l	@r15+, r9\n\t" \
+		       "mov.l	@r15+, r8\n\t" \
+		       "lds.l	@r15+, pr\n\t" \
+		       "ldc.l	@r15+, gbr\n\t" \
+		       :"=&z" (__last) \
+		       :"0" (prev), \
+			"r" (__ts1), "r" (__ts2), \
+			"r" (__ts4), "r" (__ts5), "r" (__ts6), "r" (__ts7) \
+		       :"r3", "t"); \
+  last = __last; \
+} while (0)
+#endif
+
+#define nop() __asm__ __volatile__ ("nop")
+
+
+#define xchg(ptr,x) ((__typeof__(*(ptr)))__xchg((unsigned long)(x),(ptr),sizeof(*(ptr))))
+
+static __inline__ unsigned long tas (volatile int *m)
+{				/* #define tas(ptr) (xchg((ptr),1)) */
+	unsigned long retval;
+
+	__asm__ __volatile__ ("tas.b	@%1\n\t"
+			      "movt	%0":"=r" (retval):"r" (m):"t",
+			      "memory");
+	return retval;
+}
+
+extern void __xchg_called_with_bad_pointer (void);
+
+#define mb()	__asm__ __volatile__ ("": : :"memory")
+#define rmb()	mb()
+#define wmb()	__asm__ __volatile__ ("": : :"memory")
+
+#ifdef CONFIG_SMP
+#define smp_mb()	mb()
+#define smp_rmb()	rmb()
+#define smp_wmb()	wmb()
+#else
+#define smp_mb()	barrier()
+#define smp_rmb()	barrier()
+#define smp_wmb()	barrier()
+#endif
+
+#define set_mb(var, value)  do { var = value; mb(); } while (0)
+#define set_wmb(var, value) do { var = value; wmb(); } while (0)
+
+/* Interrupt Control */
+static __inline__ void __sti (void)
+{
+	unsigned long __dummy0, __dummy1;
+
+	__asm__ __volatile__ ("stc	sr, %0\n\t"
+			      "and	%1, %0\n\t"
+			      "stc	r6_bank, %1\n\t"
+			      "or	%1, %0\n\t"
+			      "ldc	%0, sr":"=&r"
+			      (__dummy0), "=r" (__dummy1)
+			      :"1" (~0x000000f0)
+			      :"memory");
+}
+
+static __inline__ void __cli (void)
+{
+	unsigned long __dummy;
+	__asm__ __volatile__ ("stc	sr, %0\n\t"
+			      "or	#0xf0, %0\n\t"
+			      "ldc	%0, sr":"=&z" (__dummy)
+			      :	/* no inputs */
+			      :"memory");
+}
+
+#define __save_flags(x) \
+	__asm__ __volatile__("stc sr, %0\n\t" \
+			     "and #0xf0, %0"  \
+			     : "=&z" (x) :/**/: "memory" )
+
+static __inline__ unsigned long __save_and_cli (void)
+{
+	unsigned long flags, __dummy;
+
+	__asm__ __volatile__ ("stc	sr, %1\n\t"
+			      "mov	%1, %0\n\t"
+			      "or	#0xf0, %0\n\t"
+			      "ldc	%0, sr\n\t"
+			      "mov	%1, %0\n\t"
+			      "and	#0xf0, %0":"=&z"
+			      (flags), "=&r" (__dummy)
+			      : /**/:"memory");
+	return flags;
+}
+
+#ifdef DEBUG_CLI_STI
+static __inline__ void __restore_flags (unsigned long x)
+{
+	if ((x & 0x000000f0) != 0x000000f0)
+		__sti ();
+	else {
+		unsigned long flags;
+		__save_flags (flags);
+
+		if (flags == 0) {
+			extern void dump_stack (void);
+			printk (KERN_ERR "BUG!\n");
+			dump_stack ();
+			__cli ();
+		}
+	}
+}
+#else
+#define __restore_flags(x) do { 			\
+	if ((x & 0x000000f0) != 0x000000f0)		\
+		__sti();				\
+} while (0)
+#endif
+
+#define really_restore_flags(x) do { 			\
+	if ((x & 0x000000f0) != 0x000000f0)		\
+		__sti();				\
+	else						\
+		__cli();				\
+} while (0)
+
+/*
+ * Jump to P2 area.
+ * When handling TLB or caches, we need to do it from P2 area.
+ */
+#define jump_to_P2()			\
+do {					\
+	unsigned long __dummy;		\
+	__asm__ __volatile__(		\
+		"mov.l	1f, %0\n\t"	\
+		"or	%1, %0\n\t"	\
+		"jmp	@%0\n\t"	\
+		" nop\n\t" 		\
+		".balign 4\n"		\
+		"1:	.long 2f\n"	\
+		"2:"			\
+		: "=&r" (__dummy)	\
+		: "r" (0x20000000));	\
+} while (0)
+
+/*
+ * Back to P1 area.
+ */
+#define back_to_P1()					\
+do {							\
+	unsigned long __dummy;				\
+	__asm__ __volatile__(				\
+		"nop;nop;nop;nop;nop;nop;nop\n\t"	\
+		"mov.l	1f, %0\n\t"			\
+		"jmp	@%0\n\t"			\
+		" nop\n\t"				\
+		".balign 4\n"				\
+		"1:	.long 2f\n"			\
+		"2:"					\
+		: "=&r" (__dummy));			\
+} while (0)
+
+#define __save_and_sti(x)       do { __save_flags(x); __sti(); } while(0);
+
+/* For spinlocks etc */
+#define local_irq_save(x)	x = __save_and_cli()
+#define local_irq_set(x)	__save_and_sti(x)
+#define local_irq_restore(x)	__restore_flags(x)
+#define local_irq_disable()	__cli()
+#define local_irq_enable()	__sti()
+
+#ifdef CONFIG_SMP
+
+extern void __global_cli (void);
+extern void __global_sti (void);
+extern unsigned long __global_save_flags (void);
+extern void __global_restore_flags (unsigned long);
+#define cli() __global_cli()
+#define sti() __global_sti()
+#define save_flags(x) ((x)=__global_save_flags())
+#define restore_flags(x) __global_restore_flags(x)
+#define save_and_sti(x) do { save_flags(x); sti(); } while(0);
+#else
+
+#define cli() __cli()
+#define sti() __sti()
+#define save_flags(x) __save_flags(x)
+#define save_and_cli(x) x = __save_and_cli()
+#define save_and_sti(x) __save_and_sti(x)
+#define restore_flags(x) __restore_flags(x)
+
+#endif
+
+static __inline__ unsigned long xchg_u32 (volatile int *m, unsigned long val)
+{
+	unsigned long flags, retval;
+
+	save_and_cli (flags);
+	retval = *m;
+	*m = val;
+	restore_flags (flags);
+	return retval;
+}
+
+static __inline__ unsigned long xchg_u8 (volatile unsigned char *m,
+					 unsigned long val)
+{
+	unsigned long flags, retval;
+
+	save_and_cli (flags);
+	retval = *m;
+	*m = val & 0xff;
+	restore_flags (flags);
+	return retval;
+}
+
+static __inline__ unsigned long __xchg (unsigned long x, volatile void *ptr,
+					int size)
+{
+	switch (size) {
+	case 4:
+		return xchg_u32 (ptr, x);
+		break;
+	case 1:
+		return xchg_u8 (ptr, x);
+		break;
+	}
+	__xchg_called_with_bad_pointer ();
+	return x;
+}
+
+/* XXX
+ * disable hlt during certain critical i/o operations
+ */
+#define HAVE_DISABLE_HLT
+void disable_hlt (void);
+void enable_hlt (void);
+
+#endif
diff --git a/include/asm-sh/termbits.h b/include/asm-sh/termbits.h
new file mode 100644
index 0000000000..0aa52f15bd
--- /dev/null
+++ b/include/asm-sh/termbits.h
@@ -0,0 +1,173 @@
+#ifndef __ASM_SH_TERMBITS_H
+#define __ASM_SH_TERMBITS_H
+
+#include <linux/posix_types.h>
+
+typedef unsigned char cc_t;
+typedef unsigned int speed_t;
+typedef unsigned int tcflag_t;
+
+#define NCCS 19
+struct termios
+{
+	tcflag_t c_iflag;	/* input mode flags */
+	tcflag_t c_oflag;	/* output mode flags */
+	tcflag_t c_cflag;	/* control mode flags */
+	tcflag_t c_lflag;	/* local mode flags */
+	cc_t c_line;		/* line discipline */
+	cc_t c_cc[NCCS];	/* control characters */
+};
+
+/* c_cc characters */
+#define VINTR 0
+#define VQUIT 1
+#define VERASE 2
+#define VKILL 3
+#define VEOF 4
+#define VTIME 5
+#define VMIN 6
+#define VSWTC 7
+#define VSTART 8
+#define VSTOP 9
+#define VSUSP 10
+#define VEOL 11
+#define VREPRINT 12
+#define VDISCARD 13
+#define VWERASE 14
+#define VLNEXT 15
+#define VEOL2 16
+
+/* c_iflag bits */
+#define IGNBRK	0000001
+#define BRKINT	0000002
+#define IGNPAR	0000004
+#define PARMRK	0000010
+#define INPCK	0000020
+#define ISTRIP	0000040
+#define INLCR	0000100
+#define IGNCR	0000200
+#define ICRNL	0000400
+#define IUCLC	0001000
+#define IXON	0002000
+#define IXANY	0004000
+#define IXOFF	0010000
+#define IMAXBEL	0020000
+
+/* c_oflag bits */
+#define OPOST	0000001
+#define OLCUC	0000002
+#define ONLCR	0000004
+#define OCRNL	0000010
+#define ONOCR	0000020
+#define ONLRET	0000040
+#define OFILL	0000100
+#define OFDEL	0000200
+#define NLDLY	0000400
+#define   NL0	0000000
+#define   NL1	0000400
+#define CRDLY	0003000
+#define   CR0	0000000
+#define   CR1	0001000
+#define   CR2	0002000
+#define   CR3	0003000
+#define TABDLY	0014000
+#define   TAB0	0000000
+#define   TAB1	0004000
+#define   TAB2	0010000
+#define   TAB3	0014000
+#define   XTABS	0014000
+#define BSDLY	0020000
+#define   BS0	0000000
+#define   BS1	0020000
+#define VTDLY	0040000
+#define   VT0	0000000
+#define   VT1	0040000
+#define FFDLY	0100000
+#define   FF0	0000000
+#define   FF1	0100000
+
+/* c_cflag bit meaning */
+#define CBAUD	0010017
+#define  B0	0000000		/* hang up */
+#define  B50	0000001
+#define  B75	0000002
+#define  B110	0000003
+#define  B134	0000004
+#define  B150	0000005
+#define  B200	0000006
+#define  B300	0000007
+#define  B600	0000010
+#define  B1200	0000011
+#define  B1800	0000012
+#define  B2400	0000013
+#define  B4800	0000014
+#define  B9600	0000015
+#define  B19200	0000016
+#define  B38400	0000017
+#define EXTA B19200
+#define EXTB B38400
+#define CSIZE	0000060
+#define   CS5	0000000
+#define   CS6	0000020
+#define   CS7	0000040
+#define   CS8	0000060
+#define CSTOPB	0000100
+#define CREAD	0000200
+#define PARENB	0000400
+#define PARODD	0001000
+#define HUPCL	0002000
+#define CLOCAL	0004000
+#define CBAUDEX 0010000
+#define    B57600 0010001
+#define   B115200 0010002
+#define   B230400 0010003
+#define   B460800 0010004
+#define   B500000 0010005
+#define   B576000 0010006
+#define   B921600 0010007
+#define  B1000000 0010010
+#define  B1152000 0010011
+#define  B1500000 0010012
+#define  B2000000 0010013
+#define  B2500000 0010014
+#define  B3000000 0010015
+#define  B3500000 0010016
+#define  B4000000 0010017
+#define CIBAUD	  002003600000	/* input baud rate (not used) */
+#define CMSPAR	  010000000000	/* mark or space (stick) parity */
+#define CRTSCTS	  020000000000	/* flow control */
+
+/* c_lflag bits */
+#define ISIG	0000001
+#define ICANON	0000002
+#define XCASE	0000004
+#define ECHO	0000010
+#define ECHOE	0000020
+#define ECHOK	0000040
+#define ECHONL	0000100
+#define NOFLSH	0000200
+#define TOSTOP	0000400
+#define ECHOCTL	0001000
+#define ECHOPRT	0002000
+#define ECHOKE	0004000
+#define FLUSHO	0010000
+#define PENDIN	0040000
+#define IEXTEN	0100000
+
+/* tcflow() and TCXONC use these */
+#define	TCOOFF		0
+#define	TCOON		1
+#define	TCIOFF		2
+#define	TCION		3
+
+/* tcflush() and TCFLSH use these */
+#define	TCIFLUSH	0
+#define	TCOFLUSH	1
+#define	TCIOFLUSH	2
+
+/* tcsetattr uses these */
+#define	TCSANOW		0
+#define	TCSADRAIN	1
+#define	TCSAFLUSH	2
+
+#endif /* __ASM_SH_TERMBITS_H */
diff --git a/include/asm-sh/types.h b/include/asm-sh/types.h
new file mode 100644
index 0000000000..46e4940301
--- /dev/null
+++ b/include/asm-sh/types.h
@@ -0,0 +1,74 @@
+/*
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __ASM_SH_TYPES_H
+#define __ASM_SH_TYPES_H
+
+typedef unsigned short umode_t;
+
+/*
+ * __xx is ok: it doesn't pollute the POSIX namespace. Use these in the
+ * header files exported to user space
+ */
+
+typedef __signed__ char __s8;
+typedef unsigned char __u8;
+
+typedef __signed__ short __s16;
+typedef unsigned short __u16;
+
+typedef __signed__ int __s32;
+typedef unsigned int __u32;
+
+#if defined(__GNUC__) && !defined(__STRICT_ANSI__)
+typedef __signed__ long long __s64;
+typedef unsigned long long __u64;
+#endif
+
+/*
+ * These aren't exported outside the kernel to avoid name space clashes
+ */
+#ifdef __KERNEL__
+
+typedef __signed__ char s8;
+typedef unsigned char u8;
+
+typedef __signed__ short s16;
+typedef unsigned short u16;
+
+typedef __signed__ int s32;
+typedef unsigned int u32;
+
+typedef __signed__ long long s64;
+typedef unsigned long long u64;
+
+#define BITS_PER_LONG 32
+
+/* Dma addresses are 32-bits wide.  */
+
+typedef u32 dma_addr_t;
+typedef u64 dma64_addr_t;
+
+#endif /* __KERNEL__ */
+
+#endif /* __ASM_SH_TYPES_H */
diff --git a/include/asm-sh/u-boot.h b/include/asm-sh/u-boot.h
new file mode 100644
index 0000000000..0106515ca7
--- /dev/null
+++ b/include/asm-sh/u-boot.h
@@ -0,0 +1,68 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk, DENX Software Engineering, <wd@denx.de>
+ * (C) Copyright 2004-2009 STMicroelectronics.
+ * Andy Sturges <andy.sturges@st.com>
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _U_BOOT_H_
+#define _U_BOOT_H_	1
+
+typedef struct bd_info
+{
+	int bi_baudrate;	/* serial console baudrate */
+	unsigned long bi_ip_addr;	/* IP Address */
+	unsigned char bi_enetaddr[6];	/* Ethernet adress */
+	unsigned long bi_arch_number;	/* unique id for this board */
+	unsigned long bi_boot_params;	/* where this board expects params */
+	unsigned long bi_memstart;	/* start of DRAM memory */
+	unsigned long bi_memsize;	/* size  of DRAM memory in bytes */
+#ifndef CFG_NO_FLASH
+	unsigned long bi_flashstart;	/* start of FLASH memory */
+	unsigned long bi_flashsize;	/* size  of FLASH memory */
+	unsigned long bi_flashoffset;	/* reserved area for startup monitor */
+#endif /* CFG_NO_FLASH */
+#ifdef CONFIG_SH_STB7100
+	unsigned long bi_devid;
+	unsigned long bi_pll0frq;
+	unsigned long bi_pll1frq;
+	unsigned long bi_st40cpufrq;
+	unsigned long bi_st40busfrq;
+	unsigned long bi_st40perfrq;
+	unsigned long bi_st231frq;
+	unsigned long bi_stbusfrq;
+	unsigned long bi_emifrq;
+	unsigned long bi_lmifrq;
+#endif
+#if	defined(CONFIG_SH_STX5197) ||	\
+	defined(CONFIG_SH_STX7105) ||	\
+	defined(CONFIG_SH_STX7111) ||	\
+	defined(CONFIG_SH_STX7141) ||	\
+	defined(CONFIG_SH_STX7200)
+	unsigned long bi_devid;
+	unsigned long bi_emifrq;
+#endif
+} bd_t;
+#define bi_env_data bi_env->data
+#define bi_env_crc  bi_env->crc
+
+#endif /* _U_BOOT_H_ */
diff --git a/include/asm-sh/ubc.h b/include/asm-sh/ubc.h
new file mode 100644
index 0000000000..a9003cf9cd
--- /dev/null
+++ b/include/asm-sh/ubc.h
@@ -0,0 +1,72 @@
+#ifndef __ASM_SH_UBC_H
+#define __ASM_SH_UBC_H
+
+/* User Break Controller */
+
+#if defined(CONFIG_CPU_SUBTYPE_SH7709)
+#define UBC_TYPE_SH7729	(cpu_data->type == CPU_SH7729)
+#else
+#define UBC_TYPE_SH7729	0
+#endif
+
+#if defined(__sh3__)
+#define UBC_BARA                0xffffffb0
+#define UBC_BAMRA               0xffffffb4
+#define UBC_BBRA                0xffffffb8
+#define UBC_BASRA               0xffffffe4
+#define UBC_BARB                0xffffffa0
+#define UBC_BAMRB               0xffffffa4
+#define UBC_BBRB                0xffffffa8
+#define UBC_BASRB               0xffffffe8
+#define UBC_BDRB                0xffffff90
+#define UBC_BDMRB               0xffffff94
+#define UBC_BRCR                0xffffff98
+#elif defined(__SH4__)
+#define UBC_BARA		0xff200000
+#define UBC_BAMRA		0xff200004
+#define UBC_BBRA		0xff200008
+#define UBC_BASRA		0xff000014
+#define UBC_BARB		0xff20000c
+#define UBC_BAMRB		0xff200010
+#define UBC_BBRB		0xff200014
+#define UBC_BASRB		0xff000018
+#define UBC_BDRB		0xff200018
+#define UBC_BDMRB		0xff20001c
+#define UBC_BRCR		0xff200020
+#endif
+
+#define BAMR_ASID		(1 << 2)
+#define BAMR_NONE		0
+#define BAMR_10			0x1
+#define BAMR_12			0x2
+#define BAMR_ALL		0x3
+#define BAMR_16			0x8
+#define BAMR_20			0x9
+
+#define BBR_INST		(1 << 4)
+#define BBR_DATA		(2 << 4)
+#define BBR_READ		(1 << 2)
+#define BBR_WRITE		(2 << 2)
+#define BBR_BYTE		0x1
+#define BBR_HALF		0x2
+#define BBR_LONG		0x3
+#define BBR_QUAD		(1 << 6)	/* SH7750 */
+#define BBR_CPU			(1 << 6)	/* SH7709A,SH7729 */
+#define BBR_DMA			(2 << 6)	/* SH7709A,SH7729 */
+
+#define BRCR_CMFA		(1 << 15)
+#define BRCR_CMFB		(1 << 14)
+#define BRCR_PCTE		(1 << 11)
+#define BRCR_PCBA		(1 << 10)	/* 1: after execution */
+#define BRCR_DBEB		(1 << 7)
+#define BRCR_PCBB		(1 << 6)
+#define BRCR_SEQ		(1 << 3)
+#define BRCR_UBDE		(1 << 0)
+
+#ifndef __ASSEMBLY__
+/* arch/sh/kernel/ubc.S */
+extern void ubc_wakeup (void);
+extern void ubc_sleep (void);
+#endif
+
+#endif /* __ASM_SH_UBC_H */
diff --git a/include/common.h b/include/common.h
index 63ac8b062c..ffd6850036 100644
--- a/include/common.h
+++ b/include/common.h
@@ -27,6 +27,12 @@
 #undef	_LINUX_CONFIG_H
 #define _LINUX_CONFIG_H 1	/* avoid reading Linux autoconf.h file	*/
 
+#ifdef __GNUC__
+#define inline		inline __attribute__((always_inline))
+#define __inline__	__inline__ __attribute__((always_inline))
+#endif
+#define __weak		__attribute__((weak))
+
 typedef unsigned char		uchar;
 typedef volatile unsigned long	vu_long;
 typedef volatile unsigned short vu_short;
@@ -242,6 +248,11 @@ void	forceenv     (char *, char *);
 # include <asm/setup.h>
 # include <asm/u-boot-arm.h>	/* ARM version to be fixed! */
 #endif /* CONFIG_ARM */
+
+#ifdef CONFIG_STM_ST231
+# include <asm/setup.h>
+#endif /* CONFIG_STM_ST231 */
+
 #ifdef CONFIG_I386		/* x86 version to be fixed! */
 # include <asm/u-boot-i386.h>
 #endif /* CONFIG_I386 */
@@ -578,6 +589,7 @@ void	wait_ticks    (unsigned long);
 
 /* lib_$(ARCH)/time.c */
 void	udelay	      (unsigned long);
+void	ndelay        (unsigned long nsec);
 ulong	usec2ticks    (unsigned long usec);
 ulong	ticks2usec    (unsigned long ticks);
 int	init_timebase (void);
@@ -650,7 +662,7 @@ int	pcmcia_init (void);
 /*
  * Board-specific Platform code can reimplement show_boot_progress () if needed
  */
-void inline show_boot_progress (int val);
+void __attribute__((weak)) show_boot_progress (int val);
 
 #ifdef CONFIG_INIT_CRITICAL
 #error CONFIG_INIT_CRITICAL is deprecated!
diff --git a/include/configs/5197cab.h b/include/configs/5197cab.h
new file mode 100644
index 0000000000..93c5573d39
--- /dev/null
+++ b/include/configs/5197cab.h
@@ -0,0 +1,260 @@
+/*
+ * (C) Copyright 2009 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+
+#define CONFIG_SH4	1		/* This is an SH4 CPU		*/
+#define CONFIG_CPU_SUBTYPE_SH4_3XX	/* it is an SH4-300		*/
+
+
+/*-----------------------------------------------------------------------
+ * Are we booting directly from a SPI Serial Flash device ?
+ * If so, then define the "CFG_BOOT_FROM_SPI" macro,
+ * otherwise (e.g. for NOR/NAND Flash booting), do not define it.
+ * As the STx5197-CAB board only has SPI flash, then define it.
+ */
+#define CFG_BOOT_FROM_SPI		/* define to build a SPI-bootable image */
+
+
+/*-----------------------------------------------------------------------
+ * Start addresses for the final memory configuration
+ * Assume we run out of uncached memory for the moment
+ */
+
+#ifdef CONFIG_SH_SE_MODE
+#define CFG_SE_PHYSICAL_BASE	0x40000000	/* LMI Physical Address */
+#define CFG_SDRAM_BASE		0x80000000      /* LMI    Cached addr via PMB */
+#define CFG_SE_UNACHED_BASE	0x90000000	/* LMI UN-cached addr via PMB */
+#define CFG_SE_SDRAM_WINDOW	(CFG_SDRAM_SIZE-1)
+#else
+#define CFG_SDRAM_BASE		0x8C000000      /* SDRAM in P1 region */
+#endif
+
+#define CFG_SDRAM_SIZE		0x04000000	/* 64 MiB of LMI SDRAM */
+
+#define CFG_EMI_SPI_BASE	0xA0000000	/* SPI Serial FLASH in SPIBOOT-mode */
+#define CFG_MONITOR_BASE	0		/* Offset in SPI for u-boot.bin */
+#define CFG_MONITOR_LEN		0x00040000	/* Reserve 256 KiB for Monitor */
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1 MiB for malloc */
+#define CFG_BOOTPARAMS_LEN	(128 << 10)	/* 128 KiB */
+#define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
+
+#define CFG_MEMTEST_START	CFG_SDRAM_BASE
+#define CFG_MEMTEST_END		(CFG_SDRAM_BASE + CFG_SDRAM_SIZE - (3 << 20))
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define XSTR(s) STR(s)
+#define STR(s) #s
+
+#define BOARD 5197cab
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		"board=" XSTR(BOARD) "\0" \
+		"monitor_base=" XSTR(CFG_MONITOR_BASE) "\0" \
+		"monitor_len=" XSTR(CFG_MONITOR_LEN) "\0" \
+		"load_addr=" XSTR(CFG_LOAD_ADDR) "\0" \
+		"update=" \
+		  "eeprom write $load_addr $monitor_base $monitor_len\0"
+
+/*--------------------------------------------------------------
+ * Command line configuration.
+ */
+
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_NFS
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+
+/*--------------------------------------------------------------
+ * Serial console info
+ */
+
+/*
+ * We can use one of two methods for the "serial" console.
+ * We can either use the (normal hardware) internal ST ASC UART;
+ * OR we can use STMicroelectronics' DTF (Data Transfer Format)
+ * mechanism over a JTAG link to a remote GDB debugger.
+ */
+#if 1
+#	define CONFIG_STM_ASC_SERIAL	/* use a ST ASC UART */
+#else
+#	define CONFIG_STM_DTF_SERIAL	/* use DTF over JTAG */
+#endif
+
+#define CFG_STM_ASC2_BASE		0xfd132000ul	/* UART2 = AS0 */
+#define CFG_STM_ASC3_BASE		0xfd133000ul	/* UART3 = AS1 */
+
+/* 9-pin Female connector (J1), or 4-pin header (J2) */
+#define CFG_STM_ASC_BASE		CFG_STM_ASC3_BASE
+
+/*---------------------------------------------------------------
+ * Ethernet driver config
+ */
+
+/* are we using the internal ST MAC device ? */
+#define CONFIG_DRIVER_NETSTMAC
+
+/* Config for on-chip STMAC + LAN8700 PHY */
+#ifdef CONFIG_DRIVER_NETSTMAC
+#	define CFG_STM_STMAC_BASE	0xfde00000ul	/* MAC = STM MAC */
+#	define CONFIG_STMAC_LAN8700			/* PHY = SMSC LAN8700 */
+#else
+#	undef CONFIG_CMD_NET		/* un-define if no networking at all */
+#endif	/* CONFIG_DRIVER_NETSTMAC */
+
+/*  If this board does not have eeprom for ethernet address so allow the user
+ *  to set it in the environment
+ */
+#define CONFIG_ENV_OVERWRITE
+
+/*---------------------------------------------------------------
+ * USB driver config
+ */
+
+/* Choose if we want USB Mass-Storage Support */
+#define CONFIG_SH_STB7100_USB
+
+#ifdef CONFIG_SH_STB7100_USB
+#	define CONFIG_CMD_USB
+#	define CONFIG_CMD_FAT
+#	define CONFIG_USB_OHCI_NEW
+#	define CONFIG_USB_STORAGE
+#	define CFG_USB_OHCI_CPU_INIT
+#	define CFG_USB0_BASE			0xfdd00000	/* front panel */
+#	define CFG_USB_BASE			CFG_USB0_BASE
+#	define CFG_USB_OHCI_REGS_BASE		(CFG_USB_BASE+0xffc00)
+#	define CFG_USB_OHCI_SLOT_NAME		"ohci"
+#	define CFG_USB_OHCI_MAX_ROOT_PORTS	1
+#	define LITTLEENDIAN
+#endif	/* ifdef CONFIG_SH_STB7100_USB */
+
+/*---------------------------------------------------------------
+ * IDE driver config
+ */
+
+#if defined(CONFIG_SH_STB7100_USB)
+#	define CFG_64BIT_LBA
+#	define CONFIG_LBA48
+#	define CONFIG_DOS_PARTITION
+#	define CONFIG_CMD_EXT2
+#endif
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+
+#define CFG_HUSH_PARSER		1
+#define CONFIG_AUTO_COMPLETE	1
+#define CFG_LONGHELP		1		/* undef to save memory		*/
+#define CFG_PROMPT		"5197CAB> "	/* Monitor Command Prompt	*/
+#define CFG_PROMPT_HUSH_PS2	"> "
+#define CFG_CBSIZE		1024
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
+#define CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_HZ			1000		/* HZ for timer ticks	*/
+#define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
+#define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
+#define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
+#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+#define CONFIG_CMDLINE_EDITING
+
+/*-----------------------------------------------------------------------
+ * FLASH organization
+ */
+
+/* Choose if we want FLASH Support (SPI, NAND &/or NOR devices)
+ *
+ * Note: by default CONFIG_CMD_FLASH & CONFIG_CMD_IMLS are both
+ * defined in config_cmd_default.h.
+ * However if we do not have any NOR flash, then un-define them.
+ */
+#undef CONFIG_CMD_FLASH				/* NOR-flash specific */
+#undef CONFIG_CMD_IMLS				/* NOR-flash specific */
+#define CFG_NO_FLASH				/* NOR-flash specific */
+
+/*-----------------------------------------------------------------------
+ * SPI SERIAL FLASH organization
+ */
+
+/*
+ *	Name	Manuf	Device
+ *	-----	-----	------
+ *	U10	ST	M25P32
+ *	U13	ST	M25PX64/128
+ *	U4	Atmel	AT45DB321
+ *	U12	Mxic	MX25Lxx
+ */
+/* choose Atmel or ST SPI Serial Flash */
+#if 1
+#	define CONFIG_SPI_FLASH_ST	/* ST M25Pxx (U10, U13) */
+#elif 1
+#	define CONFIG_SPI_FLASH_ATMEL	/* ATMEL AT45DB321 (U4) */
+#else
+#	define CONFIG_SPI_FLASH_MXIC	/* MXIC MX25Lxxx (U12) */
+#endif
+
+#define CONFIG_SPI			/* enable the SPI driver */
+#define CONFIG_CMD_SPI			/* SPI serial bus command support */
+#define CONFIG_CMD_EEPROM		/* enable the "eeprom" command set */
+#define CFG_I2C_FRAM			/* to minimize performance degradation */
+#undef  CFG_EEPROM_PAGE_WRITE_DELAY_MS	/* to minimize performance degradation */
+
+/*
+ *	NOTE: To use the Atmel AT45DB321D serial flash for booting,
+ *	then it is required to re-program the page size to 512 bytes.
+ *	(default is 528 bytes per page). This is a once only,
+ *	irreversible programming option, and can not be undone.
+ *	This programming may be done from U-boot (booted via JTAG)
+ *
+ *		U-Boot> sspi 0 32 3D2A80A6	--> FFFFFFFF
+ *		U-Boot> sspi 0 16 D7		--> FFB4
+ *	Then power-cycle the board before using it.
+ */
+
+/*-----------------------------------------------------------------------
+ * Address, size, & location of U-boot's Environment Sector
+ */
+
+#define CFG_ENV_SIZE			0x4000	/* 16 KiB of environment data */
+
+#if 1
+#	define CFG_ENV_IS_IN_EEPROM		/* ENV is stored in SPI Serial Flash */
+#	define CFG_ENV_OFFSET	CFG_MONITOR_LEN	/* immediately after u-boot.bin */
+#else
+#	define CFG_ENV_IS_NOWHERE		/* ENV is stored in volatile RAM */
+#endif
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/cb101.h b/include/configs/cb101.h
new file mode 100644
index 0000000000..a715b7c9f1
--- /dev/null
+++ b/include/configs/cb101.h
@@ -0,0 +1,273 @@
+/*
+ * (C) Copyright 2007 STMicroelectronics.
+ *
+ * Stuart Menefy <stuart.menefy@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+
+#define CONFIG_SH4	1		/* This is an SH4 CPU		*/
+#define CONFIG_CPU_SUBTYPE_SH4_2XX	/* its an SH4-202		*/
+
+
+/*-----------------------------------------------------------------------
+ * Start addresses for the final memory configuration
+ * Assume we run out of uncached memory for the moment
+ */
+
+#ifdef CONFIG_SH_SE_MODE
+#define CFG_FLASH_BASE		0xA0000000	/* FLASH (uncached) via PMB */
+#define CFG_SDRAM_BASE		0x80000000      /* LMI0 via PMB */
+#define CFG_SE_PHYSICAL_BASE	0x40000000	/* LMI0 Physical Address */
+#define CFG_SE_UNACHED_BASE	0x90000000	/* LMI0 un-cached addr via PMB */
+#define CFG_SE_SDRAM_WINDOW	(CFG_SDRAM_SIZE-1)
+#else
+#define CFG_FLASH_BASE		0xA0000000	/* FLASH in P2 region */
+#define CFG_SDRAM_BASE		0x88000000      /* SDRAM in P1 region */
+#endif
+
+#define CFG_SDRAM_SIZE		0x08000000	/* 128 MiB of LMI0 SDRAM */
+
+#define CFG_MONITOR_LEN		0x00040000	/* Reserve 256 KiB for Monitor */
+#define CFG_MONITOR_BASE        CFG_FLASH_BASE
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1 MiB for malloc */
+#define CFG_BOOTPARAMS_LEN	(128 << 10)	/* 128 KiB */
+#define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
+
+#define CFG_MEMTEST_START	CFG_SDRAM_BASE
+#define CFG_MEMTEST_END		(CFG_SDRAM_BASE + CFG_SDRAM_SIZE - (3 << 20))
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define XSTR(s) STR(s)
+#define STR(s) #s
+
+#define BOARD cb101
+
+#if CFG_MONITOR_LEN == 0x00020000		/* 128 KiB */
+#	define MONITOR_SECTORS	"1:0"		/* 1 sector */
+#elif CFG_MONITOR_LEN == 0x00040000		/* 256 KiB */
+#	define MONITOR_SECTORS	"1:0-1"		/* 2 sectors */
+#else						/* unknown */
+#	error "Unable to determine sectors for monitor"
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		"board=" XSTR(BOARD) "\0" \
+		"monitor_base=" XSTR(CFG_MONITOR_BASE) "\0" \
+		"monitor_len=" XSTR(CFG_MONITOR_LEN) "\0" \
+		"monitor_sec=" MONITOR_SECTORS "\0" \
+		"load_addr=" XSTR(CFG_LOAD_ADDR) "\0" \
+		"unprot=" \
+		  "protect off $monitor_sec\0" \
+		"update=" \
+		  "erase $monitor_sec;" \
+		  "cp.b $load_addr $monitor_base $monitor_len;" \
+		  "protect on $monitor_sec\0"
+
+/*--------------------------------------------------------------
+ * Command line configuration.
+ */
+
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_NFS
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_NAND
+#define CONFIG_CMD_JFFS2
+
+/*--------------------------------------------------------------
+ * Serial console info
+ */
+
+/* we are using the internal ST ASC UART */
+#define CONFIG_STM_ASC_SERIAL	1
+
+/* choose which UART to use */
+#define CFG_STM_ASC_BASE	0xfd033000ul	/* UART3 */
+
+/*---------------------------------------------------------------
+ * Ethernet driver config
+ */
+
+/* are we using the internal ST MAC device ? */
+#define CONFIG_DRIVER_NETSTMAC
+
+#define CONFIG_STMAC_MAC0			/* Use MAC #0 */
+#define CFG_STM_STMAC_BASE	 0xfd500000ul	/* MAC #0 */
+#define CONFIG_STMAC_STE10XP			/* ST STE10xP */
+
+/*  If this board does not have eeprom for ethernet address so allow the user
+ *  to set it in the environment
+ */
+#define CONFIG_ENV_OVERWRITE
+
+
+/*---------------------------------------------------------------
+ * USB driver config
+ */
+
+/* Choose if we want USB Mass-Storage Support */
+#define CONFIG_SH_STB7100_USB
+
+#ifdef CONFIG_SH_STB7100_USB
+#	define CONFIG_CMD_USB
+#	define CONFIG_CMD_FAT
+#	define CONFIG_USB_OHCI_NEW
+#	define CONFIG_USB_STORAGE
+#	define CFG_USB_OHCI_CPU_INIT
+#	define CFG_USB0_BASE			0xfd200000	/* header */
+#	define CFG_USB1_BASE			0xfd300000	/* nearest RJ-45 */
+#	define CFG_USB2_BASE			0xfd400000	/* nearest edge */
+#	define CFG_USB_BASE			CFG_USB2_BASE
+#	define CFG_USB_OHCI_REGS_BASE		(CFG_USB_BASE+0xffc00)
+#	define CFG_USB_OHCI_SLOT_NAME		"ohci"
+#	define CFG_USB_OHCI_MAX_ROOT_PORTS	1
+#	define LITTLEENDIAN
+	/* The following macro should ONLY be defined, when using
+	 * STi7200 cut 1.x, without the RC-delay board fix applied. */
+#	define CONFIG_USB_STI7200_CUT1_SOFT_JTAG_RESET_WORKAROUND
+#endif	/* ifdef CONFIG_SH_STB7100_USB */
+
+/*---------------------------------------------------------------
+ * IDE driver config
+ */
+
+/* SATA should work on cut 2 of the STi7200 */
+//#define CONFIG_SH_STB7100_SATA
+
+#ifdef CONFIG_SH_STB7100_SATA
+#	define CFG_PIO_MODE		4
+#	define CFG_IDE_MAXBUS		1
+#	define CFG_IDE_MAXDEVICE	1
+#	define CFG_ATA_BASE_ADDR	0x????
+#	define CFG_ATA_IDE0_OFFSET	0x0
+#	define CFG_ATA_REG_OFFSET	0x0
+#	define CFG_ATA_DATA_OFFSET	0x0
+#	define CFG_ATA_STRIDE		0x4
+#	define CFG_ATA_ALT_OFFSET	0x8
+#endif	/* CONFIG_SH_STB7100_SATA */
+
+#if defined(CONFIG_SH_STB7100_SATA) ||	\
+    defined(CONFIG_SH_STB7100_USB)
+#	define CFG_64BIT_LBA
+#	define CONFIG_LBA48
+#	define CONFIG_DOS_PARTITION
+#	define CONFIG_CMD_EXT2
+#endif
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+
+#define CFG_HUSH_PARSER		1
+#define CONFIG_AUTO_COMPLETE	1
+#define CFG_LONGHELP		1		/* undef to save memory		*/
+#define CFG_PROMPT		"CB101> "	/* Monitor Command Prompt	*/
+#define CFG_PROMPT_HUSH_PS2	"> "
+#define CFG_CBSIZE		1024
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
+#define CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_HZ			1000		/* HZ for timer ticks	*/
+#define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
+#define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
+#define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
+#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+#define CONFIG_CMDLINE_EDITING
+
+/*-----------------------------------------------------------------------
+ * NOR FLASH organization
+ */
+
+/* M58LT256GT: 32MiB 259 blocks, 128KiB block size plus parameter block */
+#define CFG_FLASH_CFI_WIDTH	FLASH_CFI_16BIT
+#define CFG_FLASH_CFI_DRIVER
+#define CFG_FLASH_CFI
+#define CONFIG_FLASH_PROTECT_SINGLE_CELL
+#define CFG_FLASH_PROTECTION	1	/* use hardware flash protection	*/
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks		*/
+#define CFG_MAX_FLASH_SECT	259	/* max number of sectors on one chip	*/
+#define CFG_FLASH_EMPTY_INFO		/* test if each sector is empty		*/
+
+/*-----------------------------------------------------------------------
+ * NAND FLASH organization
+ */
+
+#define CFG_MAX_NAND_DEVICE	2
+#define NAND_MAX_CHIPS		CFG_MAX_NAND_DEVICE
+#define CFG_NAND0_BASE		0xA2000000	/* Physical 0x02000000 */
+#define CFG_NAND1_BASE		0xA3000000	/* Physical 0x03000000 */
+#define CFG_NAND_BASE_LIST	{ CFG_NAND0_BASE, CFG_NAND1_BASE }
+
+/*-----------------------------------------------------------------------
+ * Addresss, size, & location of U-boot's Environment Sector
+ */
+
+#define CFG_ENV_IS_IN_FLASH	1
+#define CFG_ENV_OFFSET		CFG_MONITOR_LEN
+#define CFG_ENV_ADDR		(CFG_FLASH_BASE + CFG_ENV_OFFSET)
+#define CFG_ENV_SIZE		0x10000
+#define CFG_ENV_SECT_SIZE	0x20000
+
+/*----------------------------------------------------------------------
+ * JFFS2 support
+ */
+
+#if defined(CONFIG_CMD_JFFS2)
+#define CONFIG_JFFS2_NAND	/* JFFS2 support on NAND Flash */
+#define CONFIG_JFFS2_CMDLINE	/* mtdparts command line support */
+#define MTDPARTS_DEFAULT						\
+	"mtdparts="							\
+	"physmap-flash:"	/* First NOR flash device */		\
+		"256k(U-Boot)"		/* first partition */		\
+		",128k(Environment)"					\
+		",-(RestOfNor0)"	/* last partition */		\
+		";"		/* delimiter */				\
+	"gen_nand.1:"		/* First NAND flash device */		\
+		"32M(kernel-nand0)"	/* first partition */		\
+		",32M(root-nand0)"					\
+		",-(RestOfNand0)"	/* last partition */		\
+		";"		/* delimiter */				\
+	"gen_nand.2:"		/* Second NAND flash device */		\
+		"32M(kernel-nand1)"	/* first partition */		\
+		",32M(root-nand1)"					\
+		",-(RestOfNand1)"	/* last partition */
+#define MTDIDS_DEFAULT							\
+	"nor0=physmap-flash"	/* First NOR flash device */		\
+		","		/* delimiter */				\
+	"nand0=gen_nand.1"	/* First NAND flash device */		\
+		","		/* delimiter */				\
+	"nand1=gen_nand.2"	/* Second NAND flash device */
+#endif	/* CONFIG_CMD_JFFS2 */
+
+#endif	/* __CONFIG_H */
+
diff --git a/include/configs/cb102.h b/include/configs/cb102.h
new file mode 100644
index 0000000000..5b996e03e9
--- /dev/null
+++ b/include/configs/cb102.h
@@ -0,0 +1,249 @@
+/*
+ * (C) Copyright 2007-2008 STMicroelectronics.
+ *
+ * Stuart Menefy <stuart.menefy@st.com>
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+
+#define CONFIG_SH4	1		/* This is an SH4 CPU		*/
+#define CONFIG_CPU_SUBTYPE_SH4_3XX	/* it is an SH4-300		*/
+
+
+/*-----------------------------------------------------------------------
+ * Start addresses for the final memory configuration
+ * Assume we run out of uncached memory for the moment
+ */
+
+#ifdef CONFIG_SH_SE_MODE
+#define CFG_FLASH_BASE		0xA0000000	/* FLASH (uncached) via PMB */
+#define CFG_SDRAM_BASE		0x80000000      /* LMI0 via PMB */
+#define CFG_SE_PHYSICAL_BASE	0x40000000	/* LMI0 Physical Address */
+#define CFG_SE_UNACHED_BASE	0x90000000	/* LMI0 un-cached addr via PMB */
+#define CFG_SE_SDRAM_WINDOW	(CFG_SDRAM_SIZE-1)
+#else
+#define CFG_FLASH_BASE		0xA0000000	/* FLASH in P2 region */
+#define CFG_SDRAM_BASE		0x88000000      /* SDRAM in P1 region */
+#endif
+
+#define CFG_SDRAM_SIZE		0x10000000	/* 256 MiB of LMI0 SDRAM */
+
+#define CFG_MONITOR_LEN		0x00040000	/* Reserve 256 KiB for Monitor */
+#define CFG_MONITOR_BASE        CFG_FLASH_BASE
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1 MiB for malloc */
+#define CFG_BOOTPARAMS_LEN	(128 << 10)	/* 128 KiB */
+#define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
+
+#define CFG_MEMTEST_START	CFG_SDRAM_BASE
+#define CFG_MEMTEST_END		(CFG_SDRAM_BASE + CFG_SDRAM_SIZE - (3 << 20))
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define XSTR(s) STR(s)
+#define STR(s) #s
+
+#define BOARD cb102
+
+#if CFG_MONITOR_LEN == 0x00020000		/* 128 KiB */
+#	define MONITOR_SECTORS	"1:0-8"		/* 9 sectors */
+#elif CFG_MONITOR_LEN == 0x00040000		/* 256 KiB */
+#	define MONITOR_SECTORS	"1:0-10"	/* 11 sectors */
+#else						/* unknown */
+#	error "Unable to determine sectors for monitor"
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		"board=" XSTR(BOARD) "\0" \
+		"monitor_base=" XSTR(CFG_MONITOR_BASE) "\0" \
+		"monitor_len=" XSTR(CFG_MONITOR_LEN) "\0" \
+		"monitor_sec=" MONITOR_SECTORS "\0" \
+		"load_addr=" XSTR(CFG_LOAD_ADDR) "\0" \
+		"unprot=" \
+		  "protect off $monitor_sec\0" \
+		"update=" \
+		  "erase $monitor_sec;" \
+		  "cp.b $load_addr $monitor_base $monitor_len;" \
+		  "protect on $monitor_sec\0"
+
+/*--------------------------------------------------------------
+ * Command line configuration.
+ */
+
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_NFS
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+//#define CONFIG_CMD_JFFS2	/* QQQ: is this needed ? */
+
+/*--------------------------------------------------------------
+ * Serial console info
+ */
+
+/* we are using the internal ST ASC UART */
+#define CONFIG_STM_ASC_SERIAL	1
+
+/* choose which UART to use */
+#define CFG_STM_ASC_BASE	0xfd033000ul	/* TERM UART3 (J8001) */
+
+/*---------------------------------------------------------------
+ * Ethernet driver config
+ */
+
+/* are we using the internal ST MAC device ? */
+#define CONFIG_DRIVER_NETSTMAC
+#define CONFIG_STMAC_MAC0			/* Use MAC #0 */
+#define CFG_STM_STMAC_BASE	 0xfd500000ul	/* MAC #0 */
+
+/* we use the on-board SMSC PHY */
+#define CONFIG_STMAC_LAN8700			/* SMSC LAN8700 */
+
+/*  If this board does not have eeprom for ethernet address so allow the user
+ *  to set it in the environment
+ */
+#define CONFIG_ENV_OVERWRITE
+
+
+/*---------------------------------------------------------------
+ * USB driver config
+ */
+
+/* Choose if we want USB Mass-Storage Support */
+#define CONFIG_SH_STB7100_USB
+
+#ifdef CONFIG_SH_STB7100_USB
+#	define CONFIG_CMD_USB
+#	define CONFIG_CMD_FAT
+#	define CONFIG_USB_OHCI_NEW
+#	define CONFIG_USB_STORAGE
+#	define CFG_USB_OHCI_CPU_INIT
+#	define CFG_USB0_BASE			0xfd200000	/* ST72681 + NAND08GW3B */
+#	define CFG_USB1_BASE			0xfd300000	/* Front (near RJ-45) */
+#	define CFG_USB2_BASE			0xfd400000	/* Rear (J9002) */
+#	define CFG_USB_BASE			CFG_USB2_BASE
+#	undef CFG_USB_BASE					/* QQQ - DELETE */
+#	define CFG_USB_BASE			CFG_USB2_BASE	/* QQQ - DELETE */
+#	define CFG_USB_OHCI_REGS_BASE		(CFG_USB_BASE+0xffc00)
+#	define CFG_USB_OHCI_SLOT_NAME		"ohci"
+#	define CFG_USB_OHCI_MAX_ROOT_PORTS	1
+#	define LITTLEENDIAN
+#endif	/* ifdef CONFIG_SH_STB7100_USB */
+
+/*---------------------------------------------------------------
+ * IDE driver config
+ */
+
+#if defined(CONFIG_SH_STB7100_SATA) ||	\
+    defined(CONFIG_SH_STB7100_USB)
+#	define CFG_64BIT_LBA
+#	define CONFIG_LBA48
+#	define CONFIG_DOS_PARTITION
+#	define CONFIG_CMD_EXT2
+#endif
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+
+#define CFG_HUSH_PARSER		1
+#define CONFIG_AUTO_COMPLETE	1
+#define CFG_LONGHELP		1		/* undef to save memory		*/
+#define CFG_PROMPT		"CB102> "	/* Monitor Command Prompt	*/
+#define CFG_PROMPT_HUSH_PS2	"> "
+#define CFG_CBSIZE		1024
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
+#define CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_HZ			1000		/* HZ for timer ticks	*/
+#define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
+#define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
+#define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
+#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+#define CONFIG_CMDLINE_EDITING
+
+/*-----------------------------------------------------------------------
+ * NOR FLASH organization
+ */
+
+#if 1
+/* M29W640GB: 8MiB, 127*64 KiB plus 8*8 KiB, a total of 135 blocks */
+#define CFG_FLASH_CFI_DRIVER
+#define CFG_FLASH_CFI
+#define CONFIG_FLASH_PROTECT_SINGLE_CELL
+#define CFG_FLASH_PROTECTION	1	/* use hardware flash protection	*/
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks		*/
+#define CFG_MAX_FLASH_SECT	135	/* max number of sectors on one chip	*/
+#define CFG_FLASH_EMPTY_INFO		/* test if each sector is empty		*/
+#elif 0
+/* M58LT256GT: 32MiB 259 blocks, 128KiB block size plus parameter block */
+#define CFG_FLASH_CFI_DRIVER
+#define CFG_FLASH_CFI
+#define CONFIG_FLASH_PROTECT_SINGLE_CELL
+#define CFG_FLASH_PROTECTION	1	/* use hardware flash protection	*/
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks		*/
+#define CFG_MAX_FLASH_SECT	259	/* max number of sectors on one chip	*/
+#define CFG_FLASH_EMPTY_INFO		/* test if each sector is empty		*/
+#endif
+
+/*-----------------------------------------------------------------------
+ * NAND FLASH organization
+ */
+
+/* NAND flash is NOT visible via the EMI, but only through OHCI */
+
+/*-----------------------------------------------------------------------
+ * Address, size, & location of U-boot's Environment Sector
+ */
+
+#define CFG_ENV_IS_IN_FLASH	1
+#define CFG_ENV_OFFSET		CFG_MONITOR_LEN
+#define CFG_ENV_ADDR		(CFG_FLASH_BASE + CFG_ENV_OFFSET)
+#define CFG_ENV_SIZE		0x10000		/* 64 KiB */
+#define CFG_ENV_SECT_SIZE	0x10000		/* 64 KiB */
+
+/*----------------------------------------------------------------------
+ * JFFS2 support
+ */
+
+#if defined(CONFIG_CMD_JFFS2)
+#define CONFIG_JFFS2_CMDLINE	/* mtdparts command line support */
+#define MTDPARTS_DEFAULT						\
+	"mtdparts="							\
+	"physmap-flash:"	/* First NOR flash device */		\
+		"256k(U-Boot)"		/* first partition */		\
+		",128k(Environment)"					\
+		",-(RestOfNor0)"	/* last partition */
+#define MTDIDS_DEFAULT							\
+	"nor0=physmap-flash"	/* First NOR flash device */
+#endif	/* CONFIG_CMD_JFFS2 */
+
+#endif	/* __CONFIG_H */
+
diff --git a/include/configs/hdk7111.h b/include/configs/hdk7111.h
new file mode 100644
index 0000000000..a4bdd10e08
--- /dev/null
+++ b/include/configs/hdk7111.h
@@ -0,0 +1,424 @@
+/*
+ * (C) Copyright 2008-2009 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+
+#define CONFIG_SH4	1		/* This is an SH4 CPU		*/
+#define CONFIG_CPU_SUBTYPE_SH4_3XX	/* it is an SH4-300		*/
+
+
+/*-----------------------------------------------------------------------
+ * Are we booting directly from a NAND Flash device ?
+ * If so, then define the "CFG_BOOT_FROM_NAND" macro,
+ * otherwise (e.g. NOR/SPI Flash booting), do not define it.
+ *
+ * NOTE: it is the user's responsibility to ensure that
+ * EMI Bank #1 (CSB) is programmed to be large enough
+ * to access all of the NOR flash (32MiB), when it is "swapped"
+ * with EMI Bank #1 (CBA), when booting from NAND.
+ */
+#undef CFG_BOOT_FROM_NAND		/* define to build a NAND-bootable image */
+
+
+/*-----------------------------------------------------------------------
+ * Are we booting directly from a SPI Serial Flash device ?
+ * If so, then define the "CFG_BOOT_FROM_SPI" macro,
+ * otherwise (e.g. for NOR/NAND Flash booting), do not define it.
+ */
+#undef CFG_BOOT_FROM_SPI		/* define to build a SPI-bootable image */
+
+
+/*-----------------------------------------------------------------------
+ * Start addresses for the final memory configuration
+ * Assume we run out of uncached memory for the moment
+ */
+
+#if defined(CFG_BOOT_FROM_SPI)		/* we are booting from SPI serial flash */
+#define CFG_EMI_SPI_BASE	0xA0000000	/* CSA: SPI Flash,  Physical 0x00000000 (64MiB) */
+#define CFG_EMI_NAND_BASE	0xA0000000	/* CSA: NAND Flash, Physical 0x00000000 (64MiB) */
+#define CFG_EMI_NOR_BASE	0xA4000000	/* CSB: NOR Flash,  Physical 0x04000000 (32MiB) */
+#define CFG_NAND_FLEX_CSn_MAP	{ 0 }		/* NAND is on Chip Select CSA */
+#elif defined(CFG_BOOT_FROM_NAND)	/* we are booting from NAND flash */
+#define CFG_EMI_NAND_BASE	0xA0000000	/* CSA: NAND Flash, Physical 0x00000000 (64MiB) */
+#define CFG_EMI_NOR_BASE	0xA4000000	/* CSB: NOR Flash,  Physical 0x04000000 (32MiB) */
+#define CFG_NAND_FLEX_CSn_MAP	{ 0 }		/* NAND is on Chip Select CSA */
+#else					/* else, we are booting from NOR flash */
+#define CFG_EMI_NOR_BASE	0xA0000000	/* CSA: NOR Flash,  Physical 0x00000000 (64MiB) */
+#define CFG_EMI_NAND_BASE	0xA4000000	/* CSB: NAND Flash, Physical 0x04000000 (32MiB) */
+#define CFG_NAND_FLEX_CSn_MAP	{ 1 }		/* NAND is on Chip Select CSB */
+#endif /* CFG_BOOT_FROM_NAND */
+
+#ifdef CONFIG_SH_SE_MODE
+#define CFG_FLASH_BASE		CFG_EMI_NOR_BASE/* NOR FLASH (uncached) via PMB */
+#define CFG_SE_PHYSICAL_BASE	0x40000000	/* LMI Physical Address */
+#define CFG_SDRAM_BASE		0x80000000      /* LMI    Cached addr via PMB */
+#define CFG_SE_UNACHED_BASE	0x90000000	/* LMI UN-cached addr via PMB */
+#define CFG_SE_SDRAM_WINDOW	(CFG_SDRAM_SIZE-1)
+#else
+#define CFG_FLASH_BASE		CFG_EMI_NOR_BASE/* NOR FLASH in P2 region */
+#define CFG_SDRAM_BASE		0x8C000000      /* SDRAM in P1 region */
+#endif
+
+#define CFG_SDRAM_SIZE		0x10000000	/* 256 MiB of LMI SDRAM */
+
+#define CFG_MONITOR_LEN		0x00040000	/* Reserve 256 KiB for Monitor */
+#define CFG_MONITOR_BASE        CFG_FLASH_BASE
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1 MiB for malloc */
+#define CFG_BOOTPARAMS_LEN	(128 << 10)	/* 128 KiB */
+#define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
+
+#define CFG_MEMTEST_START	CFG_SDRAM_BASE
+#define CFG_MEMTEST_END		(CFG_SDRAM_BASE + CFG_SDRAM_SIZE - (3 << 20))
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define XSTR(s) STR(s)
+#define STR(s) #s
+
+#define BOARD hdk7111
+
+#if CFG_MONITOR_LEN == 0x00008000		/* 32 KiB */
+#	define MONITOR_SECTORS	"1:0"		/* 1 sector */
+#elif CFG_MONITOR_LEN == 0x00010000		/* 64 KiB */
+#	define MONITOR_SECTORS	"1:0-1"		/* 2 sectors */
+#elif CFG_MONITOR_LEN == 0x00018000		/* 96 KiB */
+#	define MONITOR_SECTORS	"1:0-2"		/* 3 sectors */
+#elif CFG_MONITOR_LEN == 0x00020000		/* 128 KiB */
+#	define MONITOR_SECTORS	"1:0-3"		/* 4 sectors */
+#elif CFG_MONITOR_LEN == 0x00040000		/* 256 KiB */
+#	define MONITOR_SECTORS	"1:0-4"		/* 5 sectors */
+#else						/* unknown */
+#	error "Unable to determine sectors for monitor"
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		"board=" XSTR(BOARD) "\0" \
+		"monitor_base=" XSTR(CFG_MONITOR_BASE) "\0" \
+		"monitor_len=" XSTR(CFG_MONITOR_LEN) "\0" \
+		"monitor_sec=" MONITOR_SECTORS "\0" \
+		"load_addr=" XSTR(CFG_LOAD_ADDR) "\0" \
+		"unprot=" \
+		  "protect off $monitor_sec\0" \
+		"update=" \
+		  "erase $monitor_sec;" \
+		  "cp.b $load_addr $monitor_base $monitor_len;" \
+		  "protect on $monitor_sec\0"
+
+/*--------------------------------------------------------------
+ * Command line configuration.
+ */
+
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_NFS
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+
+/*--------------------------------------------------------------
+ * Serial console info
+ */
+
+/*
+ * We can use one of two methods for the "serial" console.
+ * We can either use the (normal hardware) internal ST ASC UART;
+ * OR we can use STMicroelectronics' DTF (Data Transfer Format)
+ * mechanism over a JTAG link to a remote GDB debugger.
+ */
+#if 1
+#	define CONFIG_STM_ASC_SERIAL	/* use a ST ASC UART */
+#else
+#	define CONFIG_STM_DTF_SERIAL	/* use DTF over JTAG */
+#endif
+
+/* choose which ST ASC UART to use (UART2 == JD1) */
+#define CFG_STM_ASC_BASE	ST40_ASC2_REGS_BASE	/* UART2 */
+
+/*---------------------------------------------------------------
+ * Ethernet driver config
+ */
+
+/*
+ * There is only 1 option for ethernet:
+ * using the on-chip ST-GMAC, with the on-board Teridian PHY.
+ */
+
+/* are we using the internal ST GMAC device ? */
+#define CONFIG_DRIVER_NET_STM_GMAC
+
+/*
+ * Select the appropriate base address for the GMAC.
+ * Also, choose which PHY to use.
+ */
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+#	define CFG_STM_STMAC_BASE	 0xfd110000ul	/* MAC = STM GMAC0 */
+#	define CONFIG_STMAC_78Q2123			/* PHY = TERIDIAN 78Q2123 */
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+/*  If this board does not have eeprom for ethernet address so allow the user
+ *  to set it in the environment
+ */
+#define CONFIG_ENV_OVERWRITE
+
+
+/*---------------------------------------------------------------
+ * USB driver config
+ */
+
+/* Choose if we want USB Mass-Storage Support */
+#define CONFIG_SH_STB7100_USB
+
+#ifdef CONFIG_SH_STB7100_USB
+#	define CONFIG_CMD_USB
+#	define CONFIG_CMD_FAT
+#	define CONFIG_USB_OHCI_NEW
+#	define CONFIG_USB_STORAGE
+#	define CFG_USB_OHCI_CPU_INIT
+#	define CFG_USB_BASE			0xfe100000
+#	define CFG_USB_OHCI_REGS_BASE		(CFG_USB_BASE+0xffc00)
+#	define CFG_USB_OHCI_SLOT_NAME		"ohci"
+#	define CFG_USB_OHCI_MAX_ROOT_PORTS	1
+#	define LITTLEENDIAN
+#endif	/* ifdef CONFIG_SH_STB7100_USB */
+
+/*---------------------------------------------------------------
+ * IDE driver config
+ */
+
+#if defined(CONFIG_SH_STB7100_USB)
+#	define CFG_64BIT_LBA
+#	define CONFIG_LBA48
+#	define CONFIG_DOS_PARTITION
+#	define CONFIG_CMD_EXT2
+#endif
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+
+#define CFG_HUSH_PARSER		1
+#define CONFIG_AUTO_COMPLETE	1
+#define CFG_LONGHELP		1		/* undef to save memory		*/
+#define CFG_PROMPT		"HDK7111> "	/* Monitor Command Prompt	*/
+#define CFG_PROMPT_HUSH_PS2	"> "
+#define CFG_CBSIZE		1024
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
+#define CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_HZ			1000		/* HZ for timer ticks	*/
+#define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
+#define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
+#define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
+#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+#define CONFIG_CMDLINE_EDITING
+
+/*-----------------------------------------------------------------------
+ * FLASH organization
+ */
+
+/* Choose if we want FLASH Support (SPI, NAND or NOR devices)
+ * With the HDK7111 board, we may use all three of
+ * SPI, NOR and NAND flash, at the same time, if we want.
+ *
+ * Note: by default CONFIG_CMD_FLASH is defined in config_cmd_default.h
+ */
+#undef CONFIG_CMD_FLASH		/* undefine it, define only if needed */
+#define CONFIG_CMD_FLASH	/* define for NOR flash */
+#define CONFIG_CMD_NAND		/* define for NAND flash */
+#define CONFIG_SPI_FLASH	/* define for SPI serial flash */
+
+/*-----------------------------------------------------------------------
+ * NOR FLASH organization
+ */
+
+/* NOR Flash: 32MiB 259 blocks, 128 KiB block size */
+#ifdef CONFIG_CMD_FLASH				/* NOR flash present ? */
+#	define CFG_FLASH_CFI_DRIVER
+#	define CFG_FLASH_CFI
+#	define CONFIG_FLASH_PROTECT_SINGLE_CELL
+#	define CFG_FLASH_PROTECTION	1	/* use hardware flash protection	*/
+#	define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks		*/
+#	define CFG_MAX_FLASH_SECT	259	/* max number of sectors on one chip	*/
+#	define CFG_FLASH_EMPTY_INFO		/* test if each sector is empty		*/
+#	define MTDPARTS_NOR						\
+	"physmap-flash:"	/* First NOR flash device */		\
+		"256k(U-Boot)"		/* first partition */		\
+		",128k(Environment)"					\
+		",4M(Kernel)"						\
+		",-(RestOfNor0)"	/* last partition */
+#	define MTDIDS_NOR						\
+	"nor0=physmap-flash"	/* First NOR flash device */
+#else
+#	undef CONFIG_CMD_IMLS			/* NOR-flash specific */
+#	define CFG_NO_FLASH			/* NOR-flash specific */
+#endif	/* CONFIG_CMD_FLASH */
+
+/*-----------------------------------------------------------------------
+ * NAND FLASH organization
+ */
+
+#ifdef CONFIG_CMD_NAND				/* NAND flash present ? */
+#	define CFG_MAX_NAND_DEVICE	1
+#	define NAND_MAX_CHIPS		CFG_MAX_NAND_DEVICE
+#	define CFG_NAND0_BASE		CFG_EMI_NAND_BASE
+#	define CFG_NAND_BASE_LIST	{ CFG_NAND0_BASE }
+#	define MTDPARTS_NAND						\
+	"gen_nand.1:"		/* First NAND flash device */		\
+		"128k(env-nand0)"	/* first partition */		\
+		",4M(kernel-nand0)"					\
+		",32M(root-nand0)"					\
+		",-(RestOfNand0)"	/* last partition */
+#	define MTDIDS_NAND						\
+	"nand0=gen_nand.1"	/* First NAND flash device */
+
+	/*
+	 * Currently, there are 2 main modes to read/write from/to
+	 * NAND devices on STM SoCs:
+	 *	a) "bit-banging" (can NOT be used in boot-from-NAND)
+	 *	b) FLEX-mode (only supported means for boot-from-NAND)
+	 * If CFG_NAND_FLEX_MODE is defined, then FLEX-mode will be
+	 * used, otherwise, "bit-banging" will be used.
+	 */
+#	define CFG_NAND_FLEX_MODE	/* define to use NAND FLEX-MODE */
+
+	/*
+	 * Do we want to read/write NAND Flash compatible with the ST40's
+	 * NAND Controller H/W IP block for "boot-mode"? If we want
+	 * to read/write NAND flash that is meant to support booting
+	 * from NAND, then we need to use 3 bytes of ECC per 128 byte
+	 * record.  If so, then define the "CFG_NAND_ECC_HW3_128" macro.
+	 */
+#	define CFG_NAND_ECC_HW3_128	/* define for "boot-from-NAND" compatibility */
+
+	/*
+	 * If using CFG_NAND_ECC_HW3_128, then we must also define
+	 * where the (high watermark) boundary is. That is, the
+	 * NAND offset, below which we are in "boot-mode", and
+	 * must use 3 bytes of ECC for each 128 byte record.
+	 * For this offset (and above) we can use any supported
+	 * ECC configuration (e.g 3/256 S/W, or 3/512 H/W).
+	 */
+#	define CFG_NAND_STM_BOOT_MODE_BOUNDARY (1ul << 20)	/* 1 MiB */
+
+	/*
+	 * If we want to store the U-boot environment variables in
+	 * the NAND device, then we also need to specify *where* the
+	 * environment variables will be stored. Typically this
+	 * would be immediately after the U-boot monitor itself.
+	 * However, that *may* be a bad block. Define the following
+	 * to place the environment in an appropriate good block.
+	 */
+#	define CFG_NAND_ENV_OFFSET (CFG_MONITOR_LEN + 0x0)	/* immediately after u-boot.bin */
+#endif	/* CONFIG_CMD_NAND */
+
+/*-----------------------------------------------------------------------
+ * SPI SERIAL FLASH organization
+ */
+
+/*
+ *	Name	Manuf	Device
+ *	-----	-----	------
+ *	UD4	ST	M25P16
+ */
+#if defined(CONFIG_SPI_FLASH)			/* SPI serial flash present ? */
+#	define CONFIG_SPI_FLASH_ST		/* ST M25Pxx (UD4) */
+#	define CONFIG_SPI			/* enable the SPI driver */
+#	define CONFIG_CMD_SPI			/* SPI serial bus command support */
+#	define CONFIG_CMD_EEPROM		/* enable the "eeprom" command set */
+#	define CFG_I2C_FRAM			/* to minimize performance degradation */
+#	undef  CFG_EEPROM_PAGE_WRITE_DELAY_MS	/* to minimize performance degradation */
+#	define CONFIG_SOFT_SPI			/* Use "bit-banging" PIO (not the SSC) */
+#endif	/* CONFIG_SPI_FLASH */
+
+	/* NOTE: Not yet implemented SPI over SSC for STx7111 */
+#if defined(CONFIG_SOFT_SPI)			/* Use "bit-banging" for SPI */
+#	define SPI_SCL(val)	do { stx7111_spi_scl((val)); } while (0)
+#	define SPI_SDA(val)	do { stx7111_spi_sda((val)); } while (0)
+#	define SPI_DELAY	do { udelay(1); } while (0)	/* QQQ: only 500 kHz ??? */
+#	define SPI_READ		stx7111_spi_read()
+#endif	/* CONFIG_SOFT_SPI */
+
+/*-----------------------------------------------------------------------
+ * Address, size, & location of U-boot's Environment Sector
+ */
+
+#define CFG_ENV_SIZE			0x4000	/* 16 KiB of environment data */
+
+#if 1 && defined(CONFIG_CMD_FLASH)		/* NOR flash present ? */
+#	define CFG_ENV_IS_IN_FLASH		/* environment in NOR flash */
+#	define CFG_ENV_OFFSET	CFG_MONITOR_LEN	/* immediately after u-boot.bin */
+#	define CFG_ENV_SECT_SIZE	0x20000	/* 128 KiB Sector size */
+#elif 1 && defined(CONFIG_CMD_NAND)		/* NAND flash present ? */
+#	define CFG_ENV_IS_IN_NAND		/* environment in NAND flash */
+#	define CFG_ENV_OFFSET	CFG_NAND_ENV_OFFSET
+#	if CFG_ENV_SIZE < 0x20000		/* needs to be a multiple of block-size */
+#		undef CFG_ENV_SIZE		/* give it just one large-page block */
+#		define CFG_ENV_SIZE	0x20000	/* 128 KiB of environment data */
+#	endif /* if CFG_ENV_SIZE < 0x20000 */
+#elif 1 && defined(CONFIG_SPI_FLASH)		/* SPI serial flash present ? */
+#	define CFG_ENV_IS_IN_EEPROM		/* ENV is stored in SPI Serial Flash */
+#	define CFG_ENV_OFFSET	CFG_MONITOR_LEN	/* immediately after u-boot.bin */
+#else
+#	define CFG_ENV_IS_NOWHERE		/* ENV is stored in volatile RAM */
+#endif	/* CONFIG_CMD_NAND */
+
+/*----------------------------------------------------------------------
+ * JFFS2 + MTD Partition support
+ */
+
+#if 1 && (defined(CONFIG_CMD_FLASH) || defined(CONFIG_CMD_NAND))
+#	define CONFIG_CMD_JFFS2			/* enable JFFS2 support */
+#endif
+
+#if defined(CONFIG_CMD_JFFS2)
+#	define CONFIG_JFFS2_CMDLINE		/* mtdparts command line support */
+#	define CONFIG_JFFS2_NAND		/* JFFS2 support on NAND Flash */
+#	if defined(CONFIG_CMD_FLASH) && defined(CONFIG_CMD_NAND) /* Both NOR + NAND */
+#		define MTDPARTS_DEFAULT						\
+		"mtdparts="							\
+			MTDPARTS_NOR	/* NOR flash devices */			\
+			";"		/* delimiter */				\
+			MTDPARTS_NAND	/* NAND flash devices */
+#		define MTDIDS_DEFAULT						\
+			MTDIDS_NOR	/* NOR flash devices */			\
+			","		/* delimiter */				\
+			MTDIDS_NAND	/* NAND flash devices */
+#	elif defined(CONFIG_CMD_FLASH)		/* Only NOR flash devices */
+#		define MTDPARTS_DEFAULT	"mtdparts=" MTDPARTS_NOR
+#		define MTDIDS_DEFAULT	MTDIDS_NOR
+#	elif defined(CONFIG_CMD_NAND)		/* Only NAND flash devices */
+#		define MTDPARTS_DEFAULT	"mtdparts=" MTDPARTS_NAND
+#		define MTDIDS_DEFAULT	MTDIDS_NAND
+#	endif	/* defined(CONFIG_CMD_FLASH) && defined(CONFIG_CMD_NAND) */
+#endif	/* CONFIG_CMD_JFFS2 */
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/hms1.h b/include/configs/hms1.h
new file mode 100644
index 0000000000..63cf6e73df
--- /dev/null
+++ b/include/configs/hms1.h
@@ -0,0 +1,257 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+
+#define CONFIG_SH4	1		/* This is an SH4 CPU		*/
+#define CONFIG_CPU_SUBTYPE_SH4_2XX	/* its an SH4-202		*/
+
+#define INPUT_CLOCK_RATE 27
+
+
+/*-----------------------------------------------------------------------
+ * Start addresses for the final memory configuration
+ * Assume we run out of uncached memory for the moment
+ */
+
+#define CFG_SDRAM_BASE		0x84000000      /* SDRAM in P1 region         */
+#define CFG_SDRAM_SIZE		0x08000000
+#define CFG_FLASH_BASE		0xA0000000
+#define CFG_RESET_ADDRESS	0xA0000000
+
+#define CFG_MONITOR_LEN		0x00040000	/* Reserve 256 kB for Monitor */
+#define CFG_MONITOR_BASE	0xA0000000
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1MB kB for malloc */
+#define CFG_BOOTPARAMS_LEN	(128 << 10)
+#define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
+
+#define CFG_MEMTEST_START	CFG_SDRAM_BASE
+#define CFG_MEMTEST_END		(CFG_SDRAM_BASE + CFG_SDRAM_SIZE - (2 << 20))
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define XSTR(s) STR(s)
+#define STR(s) #s
+
+#define BOARD HMS1
+
+#if CFG_MONITOR_LEN == 0x00020000		/* 128 kB */
+#	define MONITOR_SECTORS	"1:0"		/* 1 sector */
+#elif CFG_MONITOR_LEN == 0x00040000		/* 256 kB */
+#	define MONITOR_SECTORS	"1:0-1"		/* 2 sectors */
+#else						/* unknown */
+#	error "Unable to determine sectors for monitor"
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		"board=" XSTR(BOARD) "\0" \
+		"monitor_base=" XSTR(CFG_MONITOR_BASE) "\0" \
+		"monitor_len=" XSTR(CFG_MONITOR_LEN) "\0" \
+		"monitor_sec=" MONITOR_SECTORS "\0" \
+		"load_addr=" XSTR(CFG_LOAD_ADDR) "\0" \
+		"unprot=" \
+		  "protect off $monitor_sec\0" \
+		"update=" \
+		  "erase $monitor_sec;" \
+		  "cp.b $load_addr $monitor_base $monitor_len;" \
+		  "protect on $monitor_sec\0" \
+		"enableVpp=" \
+		  "mw b8022028 20;" \
+		  "mw b8022034 20;" \
+		  "mw b8022048 20;"	/* set PIO2[5] as OUTPUT */ \
+		  "mw b8022004 20\0"	/* set PIO2[5] = HIGH */ \
+		"disableVpp=" \
+		  "mw b8022028 20;" \
+		  "mw b8022034 20;" \
+		  "mw b8022048 20;"	/* set PIO2[5] as OUTPUT */ \
+		  "mw b8022008 20\0"	/* set PIO2[5] = LOW */
+
+/*--------------------------------------------------------------
+ * Command line configuration.
+ */
+
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_NFS
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_IDE
+#define CONFIG_CMD_JFFS2
+
+/*--------------------------------------------------------------
+ * Serial console info
+ */
+
+/* we are using the internal ST ASC UART */
+#define CONFIG_STM_ASC_SERIAL	1
+
+/* choose which UART to use */
+#define CFG_STM_ASC_BASE	0xb8032000ul	/* UART2 */
+
+/*---------------------------------------------------------------
+ * Ethernet driver config
+ */
+
+/*
+ * There is only 1 option for ethernet:
+ *    The on-board SMSC LAN9117 (combined MAC+PHY)
+ */
+
+#define CONFIG_DRIVER_SMC911X
+#define CONFIG_SMC911X_BASE	0xA1000000ul
+
+/*  If this board does not have eeprom for ethernet address so allow the user
+ *  to set it in the environment
+ */
+
+/* #define CONFIG_ENV_OVERWRITE */
+
+
+/*---------------------------------------------------------------
+ * USB driver config
+ */
+
+/* Choose if we want USB Mass-Storage Support */
+//#define CONFIG_SH_STB7100_USB
+
+#ifdef CONFIG_SH_STB7100_USB
+#	define CONFIG_CMD_USB
+#	define CONFIG_CMD_FAT
+#	define CONFIG_USB_OHCI_NEW
+#	define CONFIG_USB_STORAGE
+#	define CFG_USB_OHCI_CPU_INIT
+#	define CFG_USB_BASE			0xb9100000
+#	define CFG_USB_OHCI_REGS_BASE		(CFG_USB_BASE+0xffc00)
+#	define CFG_USB_OHCI_SLOT_NAME		"ohci"
+#	define CFG_USB_OHCI_MAX_ROOT_PORTS	1
+#	define LITTLEENDIAN
+#endif	/* ifdef CONFIG_SH_STB7100_USB */
+
+/*---------------------------------------------------------------
+ * IDE driver config
+ */
+
+/* Choose one of the the following two: */
+//#define CONFIG_SH_STB7100_IDE
+#define CONFIG_SH_STB7100_SATA
+
+#ifdef CONFIG_SH_STB7100_IDE
+#	define CFG_PIO_MODE		4
+#	define CFG_IDE_MAXBUS		1
+#	define CFG_IDE_MAXDEVICE	1
+#	define CFG_ATA_BASE_ADDR	0xA2800000
+#	define CFG_ATA_IDE0_OFFSET	0x00200000
+#	define CFG_ATA_REG_OFFSET	0
+#	define CFG_ATA_DATA_OFFSET	0
+#	define CFG_ATA_STRIDE		0x00020000
+#	define CFG_ATA_ALT_OFFSET	-0x0100000
+#endif	/* CONFIG_SH_STB7100_IDE */
+
+#ifdef CONFIG_SH_STB7100_SATA
+#	define CFG_PIO_MODE		4
+#	define CFG_IDE_MAXBUS		1
+#	define CFG_IDE_MAXDEVICE	1
+#	define CFG_ATA_BASE_ADDR	0xB9209800
+#	define CFG_ATA_IDE0_OFFSET	0x0
+#	define CFG_ATA_REG_OFFSET	0x0
+#	define CFG_ATA_DATA_OFFSET	0x0
+#	define CFG_ATA_STRIDE		0x4
+#	define CFG_ATA_ALT_OFFSET	0x8
+#endif	/* CONFIG_SH_STB7100_SATA */
+
+#if defined(CONFIG_SH_STB7100_IDE)  ||	\
+    defined(CONFIG_SH_STB7100_SATA) ||	\
+    defined(CONFIG_SH_STB7100_USB)
+#	define CFG_64BIT_LBA
+#	define CONFIG_LBA48
+#	define CONFIG_DOS_PARTITION
+#	define CONFIG_CMD_EXT2
+#endif
+
+/*----------------------------------------------------------------------
+ * JFFS2 support
+ */
+
+#if defined(CONFIG_CMD_JFFS2)
+
+#define CFG_JFFS_CUSTOM_PART
+#define CFG_JFFS_SINGLE_PART	1
+
+#define CFG_JFFS2_FIRST_SECTOR 18  /* u-boot, env, kernel  */
+#define CFG_JFFS2_FIRST_BANK 0
+#define CFG_JFFS2_NUM_BANKS 1
+
+#endif
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+
+#define CFG_HUSH_PARSER		1
+#define CFG_LONGHELP		1		/* undef to save memory		*/
+#define CFG_PROMPT		"HMS1> "	/* Monitor Command Prompt	*/
+#define CFG_PROMPT_HUSH_PS2	"> "
+#define CFG_CBSIZE		1024
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
+#define CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_HZ			1000		/* HZ for timer ticks		*/
+#define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
+#define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
+#define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
+#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+#define CONFIG_AUTO_COMPLETE
+#define CONFIG_CMDLINE_EDITING
+
+/*-----------------------------------------------------------------------
+ * NOR FLASH organization
+ */
+
+/* stb7100 mboard organised as 8MB flash with 128k blocks */
+#define CFG_FLASH_CFI_DRIVER
+#define CFG_FLASH_CFI
+#define CFG_FLASH_PROTECTION	1	/* use hardware flash protection	*/
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks		*/
+#define CFG_MAX_FLASH_SECT	64	/* max number of sectors on one chip	*/
+#define CFG_FLASH_EMPTY_INFO		/* test if each sector is empty		*/
+
+/*-----------------------------------------------------------------------
+ * Addresss, size, & location of U-boot's Environment Sector
+ */
+
+#define CFG_ENV_IS_IN_FLASH	1
+#define CFG_ENV_OFFSET		CFG_MONITOR_LEN
+#define CFG_ENV_ADDR		(CFG_FLASH_BASE + CFG_ENV_OFFSET)
+#define CFG_ENV_SIZE		0x20000
+#define CFG_ENV_SECT_SIZE	0x20000
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/ipidtv7105.h b/include/configs/ipidtv7105.h
new file mode 100644
index 0000000000..8f85dc00c1
--- /dev/null
+++ b/include/configs/ipidtv7105.h
@@ -0,0 +1,381 @@
+/*
+ * (C) Copyright 2008-2009 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+
+#define CONFIG_SH4	1		/* This is an SH4 CPU		*/
+#define CONFIG_CPU_SUBTYPE_SH4_3XX	/* it is an SH4-300		*/
+
+
+/*-----------------------------------------------------------------------
+ * Are we booting directly from a NAND Flash device ?
+ * If so, then define the "CFG_BOOT_FROM_NAND" macro,
+ * otherwise (e.g. NOR/SPI Flash booting), do not define it.
+ */
+#undef CFG_BOOT_FROM_NAND		/* define to build a NAND-bootable image */
+#define CFG_BOOT_FROM_NAND	/* QQQ: define until boot-from-SPI is working */
+
+
+/*-----------------------------------------------------------------------
+ * Are we booting directly from a SPI Serial Flash device ?
+ * If so, then define the "CFG_BOOT_FROM_SPI" macro,
+ * otherwise (e.g. for NAND Flash booting), do not define it.
+ */
+#undef CFG_BOOT_FROM_SPI		/* define to build a SPI-bootable image */
+
+
+/*-----------------------------------------------------------------------
+ * Start addresses for the final memory configuration
+ * Assume we run out of uncached memory for the moment
+ */
+
+#if defined(CFG_BOOT_FROM_SPI)		/* we are booting from SPI serial flash */
+/* QQQ: Note, need access to a modified board to verify the SPI configuration */
+#error QQQ: to add boot-from-SPI configuration!
+#elif defined(CFG_BOOT_FROM_NAND)	/* we are booting from NAND */
+#define CFG_EMI_NAND_BASE	0xA0000000	/* CSA: NAND Flash, Physical 0x00000000 (64MiB) */
+#define CFG_NAND_FLEX_CSn_MAP	{ 0 }		/* NAND is on Chip Select CSA */
+#else
+#define CFG_EMI_NAND_BASE	0xA6000000	/* CSC: NAND Flash, Physical 0x06000000 (8MiB) */
+#define CFG_NAND_FLEX_CSn_MAP	{ 2 }		/* NAND is on Chip Select CSC */
+#endif /* CFG_BOOT_FROM_NAND */
+
+#ifdef CONFIG_SH_SE_MODE
+#define CFG_SE_PHYSICAL_BASE	0x40000000	/* LMI Physical Address */
+#define CFG_SDRAM_BASE		0x80000000      /* LMI    Cached addr via PMB */
+#define CFG_SE_UNACHED_BASE	0x90000000	/* LMI UN-cached addr via PMB */
+#define CFG_SE_SDRAM_WINDOW	(CFG_SDRAM_SIZE-1)
+#else
+#define CFG_SDRAM_BASE		0x8C000000      /* SDRAM in P1 region */
+#endif
+
+#define CFG_SDRAM_SIZE		0x10000000	/* 256 MiB of LMI SDRAM */
+
+#define CFG_MONITOR_LEN		0x00040000	/* Reserve 256 KiB for Monitor */
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1 MiB for malloc */
+#define CFG_BOOTPARAMS_LEN	(128 << 10)	/* 128 KiB */
+#define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
+
+#define CFG_MEMTEST_START	CFG_SDRAM_BASE
+#define CFG_MEMTEST_END		(CFG_SDRAM_BASE + CFG_SDRAM_SIZE - (3 << 20))
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define XSTR(s) STR(s)
+#define STR(s) #s
+
+#define BOARD ipidtv7105
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		"board=" XSTR(BOARD) "\0" \
+		"monitor_len=" XSTR(CFG_MONITOR_LEN) "\0" \
+		"load_addr=" XSTR(CFG_LOAD_ADDR) "\0"
+
+/*--------------------------------------------------------------
+ * Command line configuration.
+ */
+
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_NFS
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+
+/*--------------------------------------------------------------
+ * Serial console info
+ */
+
+/*
+ * We can use one of two methods for the "serial" console.
+ * We can either use the (normal hardware) internal ST ASC UART;
+ * OR we can use STMicroelectronics' DTF (Data Transfer Format)
+ * mechanism over a JTAG link to a remote GDB debugger.
+ */
+#if 1
+#	define CONFIG_STM_ASC_SERIAL	/* use a ST ASC UART */
+#else
+#	define CONFIG_STM_DTF_SERIAL	/* use DTF over JTAG */
+#endif
+
+/* choose which ST ASC UART to use */
+#if 1
+	/* 9-pin D-type connector on debug board - CN8 (next to RJ-45) */
+#	define CFG_STM_ASC_BASE		ST40_ASC0_REGS_BASE	/* UART #0 */
+#else
+	/* 9-pin D-type connector on debug board - CN7 */
+#	define CFG_STM_ASC_BASE		ST40_ASC3_REGS_BASE	/* UART #3 */
+#endif
+
+/*---------------------------------------------------------------
+ * Ethernet driver config
+ */
+
+/*
+ * There are 2 options for ethernet, both use the on-chip ST-GMAC.
+ * The choice in PHYs are:
+ *    The on-board Micrel KSZ8041FTL
+ *    External PHY connected via the MII off-board 15x2 header.
+ */
+
+/* are we using the internal ST GMAC device ? */
+#define CONFIG_DRIVER_NET_STM_GMAC
+
+/*
+ * Select the appropriate base address for the GMAC.
+ * Also, choose which PHY to use.
+ */
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+#	define CFG_STM_STMAC_BASE	0xfd110000ul	/* MAC = STM GMAC0 */
+#	define CONFIG_STMAC_KSZ8041FTL			/* PHY = Micrel KSZ8041FTL */
+#else
+#	undef CONFIG_CMD_NET		/* undefine if no networking at all */
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+/*  If this board does not have eeprom for ethernet address so allow the user
+ *  to set it in the environment
+ */
+#define CONFIG_ENV_OVERWRITE
+
+
+/*---------------------------------------------------------------
+ * USB driver config
+ */
+
+/* Choose if we want USB Mass-Storage Support */
+#define CONFIG_SH_STB7100_USB
+
+#ifdef CONFIG_SH_STB7100_USB
+#	define CONFIG_CMD_USB
+#	define CONFIG_CMD_FAT
+#	define CONFIG_USB_OHCI_NEW
+#	define CONFIG_USB_STORAGE
+#	define CFG_USB_OHCI_CPU_INIT
+#	define CFG_USB0_BASE			0xfe100000	/* CN10 upper slot */
+#	define CFG_USB1_BASE			0xfea00000	/* CN10 lower slot */
+#	define CFG_USB_BASE			CFG_USB0_BASE
+#	define CONFIG_SH_STX_STX7105_USB_PORT0		/* enable Port #0 */
+#	define CONFIG_SH_STX_STX7105_USB_OC	1	/* use overcurrent */
+#	define CONFIG_SH_STX_STX7105_USB_PW	1	/* use power control */
+#	define CFG_USB_OHCI_REGS_BASE		(CFG_USB_BASE+0xffc00)
+#	define CFG_USB_OHCI_SLOT_NAME		"ohci"
+#	define CFG_USB_OHCI_MAX_ROOT_PORTS	1
+#	define LITTLEENDIAN
+#endif	/* ifdef CONFIG_SH_STB7100_USB */
+
+/*---------------------------------------------------------------
+ * SATA driver config
+ */
+
+/* SATA works on cut 3.x of the STx7105 (just one port) */
+/* Choose if we want to use a SATA HDD */
+//#define CONFIG_SH_STM_SATA
+
+#ifdef CONFIG_SH_STM_SATA
+#	define CONFIG_CMD_IDE				/* enable "ide" command set */
+#	define CFG_ATA_BASE_ADDR	0xfe209000	/* E-SATA connector */
+#	define CFG_ATA_IDE0_OFFSET	0x800		/* Host Controller */
+#	define CFG_ATA_REG_OFFSET	0x0
+#	define CFG_ATA_DATA_OFFSET	0x0
+#	define CFG_ATA_STRIDE		0x4
+#	define CFG_IDE_MAXBUS		1
+#	define CFG_IDE_MAXDEVICE	1
+#endif	/* CONFIG_SH_STM_SATA */
+
+#if defined(CONFIG_SH_STM_SATA) ||	\
+    defined(CONFIG_SH_STB7100_USB)
+#	define CFG_64BIT_LBA
+#	define CONFIG_LBA48
+#	define CONFIG_DOS_PARTITION
+#	define CONFIG_CMD_EXT2
+#endif
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+
+#define CFG_HUSH_PARSER		1
+#define CONFIG_AUTO_COMPLETE	1
+#define CFG_LONGHELP		1		/* undef to save memory		*/
+#define CFG_PROMPT		"IPIDTV7105> "	/* Monitor Command Prompt	*/
+#define CFG_PROMPT_HUSH_PS2	"> "
+#define CFG_CBSIZE		1024
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
+#define CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_HZ			1000		/* HZ for timer ticks	*/
+#define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
+#define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
+#define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
+#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+#define CONFIG_CMDLINE_EDITING
+
+/*-----------------------------------------------------------------------
+ * FLASH organization
+ */
+
+/* Choose if we want FLASH Support (SPI and/or NAND) */
+#define CONFIG_CMD_NAND		/* define for NAND flash */
+#define CONFIG_SPI_FLASH	/* define for SPI serial flash */
+
+/*
+ * Note: by default CONFIG_CMD_FLASH & CONFIG_CMD_IMLS are both
+ * defined in config_cmd_default.h.
+ * However if we do not have any NOR flash, then un-define them.
+ */
+#undef CONFIG_CMD_FLASH		/* NOR-flash specific */
+#undef CONFIG_CMD_IMLS		/* NOR-flash specific */
+#define CFG_NO_FLASH		/* NOR-flash specific */
+
+/*-----------------------------------------------------------------------
+ * NAND FLASH organization
+ */
+
+#ifdef CONFIG_CMD_NAND				/* NAND flash present ? */
+#	define CFG_MAX_NAND_DEVICE	1
+#	define NAND_MAX_CHIPS		CFG_MAX_NAND_DEVICE
+#	define CFG_NAND0_BASE		CFG_EMI_NAND_BASE
+#	define CFG_NAND_BASE_LIST	{ CFG_NAND0_BASE }
+#	define MTDPARTS_NAND						\
+	"gen_nand.1:"		/* First NAND flash device */		\
+		"128k(env-nand0)"	/* first partition */		\
+		",4M(kernel-nand0)"					\
+		",32M(root-nand0)"					\
+		",-(RestOfNand0)"	/* last partition */
+#	define MTDIDS_NAND						\
+	"nand0=gen_nand.1"	/* First NAND flash device */
+
+	/*
+	 * Currently, there are 2 main modes to read/write from/to
+	 * NAND devices on STM SoCs:
+	 *	a) "bit-banging" (can NOT be used in boot-from-NAND)
+	 *	b) FLEX-mode (only supported means for boot-from-NAND)
+	 * If CFG_NAND_FLEX_MODE is defined, then FLEX-mode will be
+	 * used, otherwise, "bit-banging" will be used.
+	 */
+#	define CFG_NAND_FLEX_MODE	/* define to use NAND FLEX-MODE */
+
+	/*
+	 * Do we want to read/write NAND Flash compatible with the ST40's
+	 * NAND Controller H/W IP block for "boot-mode"? If we want
+	 * to read/write NAND flash that is meant to support booting
+	 * from NAND, then we need to use 3 bytes of ECC per 128 byte
+	 * record.  If so, then define the "CFG_NAND_ECC_HW3_128" macro.
+	 */
+#	define CFG_NAND_ECC_HW3_128	/* define for "boot-from-NAND" compatibility */
+
+	/*
+	 * If using CFG_NAND_ECC_HW3_128, then we must also define
+	 * where the (high watermark) boundary is. That is, the
+	 * NAND offset, below which we are in "boot-mode", and
+	 * must use 3 bytes of ECC for each 128 byte record.
+	 * For this offset (and above) we can use any supported
+	 * ECC configuration (e.g 3/256 S/W, or 3/512 H/W).
+	 */
+#	define CFG_NAND_STM_BOOT_MODE_BOUNDARY (1ul << 20)	/* 1 MiB */
+
+	/*
+	 * If we want to store the U-boot environment variables in
+	 * the NAND device, then we also need to specify *where* the
+	 * environment variables will be stored. Typically this
+	 * would be immediately after the U-boot monitor itself.
+	 * However, that *may* be a bad block. Define the following
+	 * to place the environment in an appropriate good block.
+	 */
+#	define CFG_NAND_ENV_OFFSET (CFG_MONITOR_LEN + 0x0)	/* immediately after u-boot.bin */
+#endif	/* CONFIG_CMD_NAND */
+
+/*-----------------------------------------------------------------------
+ * SPI SERIAL FLASH organization
+ */
+
+/*
+ *	Name	Manuf	Device
+ *	-----	-----	------
+ *	U33	ST	M25P32
+ */
+#if defined(CONFIG_SPI_FLASH)			/* SPI serial flash present ? */
+#	define CONFIG_SPI_FLASH_ST		/* ST M25Pxx (US3) */
+#	define CONFIG_SPI			/* enable the SPI driver */
+#	define CONFIG_CMD_SPI			/* SPI serial bus command support */
+#	define CONFIG_CMD_EEPROM		/* enable the "eeprom" command set */
+#	define CFG_I2C_FRAM			/* to minimize performance degradation */
+#	undef  CFG_EEPROM_PAGE_WRITE_DELAY_MS	/* to minimize performance degradation */
+#	define CONFIG_SOFT_SPI			/* Use "bit-banging" PIO (not the SSC) */
+#endif	/* CONFIG_SPI_FLASH */
+
+#if defined(CONFIG_SOFT_SPI)			/* Use "bit-banging" for SPI */
+#	define SPI_SCL(val)	do { stx7105_spi_scl((val)); } while (0)
+#	define SPI_SDA(val)	do { stx7105_spi_sda((val)); } while (0)
+#	define SPI_DELAY	do { udelay(1); } while (0)	/* QQQ: only 500 kHz ??? */
+#	define SPI_READ		stx7105_spi_read()
+#endif	/* CONFIG_SOFT_SPI */
+
+
+/*-----------------------------------------------------------------------
+ * Address, size, & location of U-boot's Environment Sector
+ */
+
+#define CFG_ENV_SIZE			0x4000	/* 16 KiB of environment data */
+
+#if 1 && defined(CONFIG_CMD_NAND)		/* NAND flash present ? */
+#	define CFG_ENV_IS_IN_NAND		/* environment in NAND flash */
+#	define CFG_ENV_OFFSET	CFG_NAND_ENV_OFFSET
+#	if CFG_ENV_SIZE < 0x20000		/* needs to be a multiple of block-size */
+#		undef CFG_ENV_SIZE		/* give it just one large-page block */
+#		define CFG_ENV_SIZE	0x20000	/* 128 KiB of environment data */
+#	endif /* if CFG_ENV_SIZE < 0x20000 */
+#elif 1 && defined(CONFIG_SPI_FLASH)		/* SPI serial flash present ? */
+#	define CFG_ENV_IS_IN_EEPROM		/* ENV is stored in SPI Serial Flash */
+#	define CFG_ENV_OFFSET	CFG_MONITOR_LEN	/* immediately after u-boot.bin */
+#else
+#	define CFG_ENV_IS_NOWHERE		/* ENV is stored in volatile RAM */
+#endif	/* CONFIG_CMD_NAND */
+
+/*----------------------------------------------------------------------
+ * JFFS2 + MTD Partition support
+ */
+
+#if 0 && defined(CONFIG_CMD_NAND)
+#	define CONFIG_CMD_JFFS2			/* enable JFFS2 support */
+#endif
+
+#if defined(CONFIG_CMD_JFFS2)
+#	define CONFIG_JFFS2_CMDLINE		/* mtdparts command line support */
+#	define CONFIG_JFFS2_NAND		/* JFFS2 support on NAND Flash */
+#	if defined(CONFIG_CMD_NAND)		/* Only NAND flash devices */
+#		define MTDPARTS_DEFAULT	"mtdparts=" MTDPARTS_NAND
+#		define MTDIDS_DEFAULT	MTDIDS_NAND
+#	endif	/* defined(CONFIG_CMD_NAND) */
+#endif	/* CONFIG_CMD_JFFS2 */
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/mb411.h b/include/configs/mb411.h
new file mode 100644
index 0000000000..0a7a5d307b
--- /dev/null
+++ b/include/configs/mb411.h
@@ -0,0 +1,280 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+
+#define CONFIG_SH4	1		/* This is an SH4 CPU		*/
+#define CONFIG_CPU_SUBTYPE_SH4_2XX	/* its an SH4-202		*/
+
+#define INPUT_CLOCK_RATE 27
+
+
+/*-----------------------------------------------------------------------
+ * Start addresses for the final memory configuration
+ * Assume we run out of uncached memory for the moment
+ */
+
+#define CFG_SDRAM_BASE		0x84000000      /* SDRAM in P1 region         */
+#define CFG_SDRAM_SIZE		0x02000000
+#define CFG_FLASH_BASE		0xA0000000
+#define CFG_RESET_ADDRESS	0xA0000000
+
+#define CFG_MONITOR_LEN		0x00020000	/* Reserve 128 KiB for Monitor */
+#define CFG_MONITOR_BASE        0xA0000000
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1 MiB for malloc */
+#define CFG_BOOTPARAMS_LEN	(128 << 10)
+#define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
+
+#define CFG_MEMTEST_START	CFG_SDRAM_BASE
+#define CFG_MEMTEST_END		(CFG_SDRAM_BASE + CFG_SDRAM_SIZE - (2 << 20))
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define XSTR(s) STR(s)
+#define STR(s) #s
+
+#define BOARD mb411
+
+#if CFG_MONITOR_LEN == 0x00020000		/* 128 KiB */
+#	define MONITOR_SECTORS	"1:0"		/* 1 sector */
+#elif CFG_MONITOR_LEN == 0x00040000		/* 256 KiB */
+#	define MONITOR_SECTORS	"1:0-1"		/* 2 sectors */
+#else						/* unknown */
+#	error "Unable to determine sectors for monitor"
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		"board=" XSTR(BOARD) "\0" \
+		"monitor_base=" XSTR(CFG_MONITOR_BASE) "\0" \
+		"monitor_len=" XSTR(CFG_MONITOR_LEN) "\0" \
+		"monitor_sec=" MONITOR_SECTORS "\0" \
+		"load_addr=" XSTR(CFG_LOAD_ADDR) "\0" \
+		"unprot=" \
+		  "protect off $monitor_sec\0" \
+		"update=" \
+		  "erase $monitor_sec;" \
+		  "cp.b $load_addr $monitor_base $monitor_len;" \
+		  "protect on $monitor_sec\0"
+
+/*--------------------------------------------------------------
+ * Command line configuration.
+ */
+
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_NFS
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_IDE
+#define CONFIG_CMD_JFFS2
+
+/*--------------------------------------------------------------
+ * Serial console info
+ */
+
+/*
+ * We can use one of two methods for the "serial" console.
+ * We can either use the (normal hardware) internal ST ASC UART;
+ * OR we can use STMicroelectronics' DTF (Data Transfer Format)
+ * mechanism over a JTAG link to a remote GDB debugger.
+ */
+#if 1
+#	define CONFIG_STM_ASC_SERIAL	/* use a ST ASC UART */
+#else
+#	define CONFIG_STM_DTF_SERIAL	/* use DTF over JTAG */
+#endif
+
+/* choose which ST ASC UART to use */
+#if 1
+#	define CFG_STM_ASC_BASE		0xb8032000ul	/* UART2 */
+#else
+#	define CFG_STM_ASC_BASE		0xb8033000ul	/* UART3 */
+#endif
+
+/*---------------------------------------------------------------
+ * Ethernet driver config
+ */
+
+/*
+ * There are 3 options for ethernet:
+ *    The on-board SMSC LAN91C111
+ *    for STb7109, the on-chip STMAC & on-board PHY
+ *    The DB641 STEM card - this has two ethernet devices Port0 and Port1
+ */
+
+#if 1
+	/* Config for SMSC LAN91C111 (combined MAC+PHY) */
+#	define CONFIG_DRIVER_SMC91111
+#	define CONFIG_SMC91111_BASE		0xa3e00300ul
+#elif 1
+	/* Config for on-chip STMAC + STE10xP PHY */
+#	define CONFIG_DRIVER_NETSTMAC
+#	define CFG_STM_STMAC_BASE		0xb8110000ul
+#	define CONFIG_STMAC_STE10XP
+#	define CONFIG_CMD_MII
+#else
+	/* Config for SMSC LAN9118 STEM card */
+#	define CONFIG_DRIVER_SMC911X
+#	if 1
+#		define CONFIG_SMC911X_BASE	0xA1000000ul /* PORT 0 */
+#	else
+#		define CONFIG_SMC911X_BASE	0xA1800000ul /* PORT 1 */
+#	endif
+#endif
+
+
+/*  If this board does not have eeprom for ethernet address so allow the user
+ *  to set it in the environment
+ */
+
+/* #define CONFIG_ENV_OVERWRITE */
+
+
+/*---------------------------------------------------------------
+ * USB driver config
+ */
+
+/* Choose if we want USB Mass-Storage Support */
+//#define CONFIG_SH_STB7100_USB
+
+#ifdef CONFIG_SH_STB7100_USB
+#	define CONFIG_CMD_USB
+#	define CONFIG_CMD_FAT
+#	define CONFIG_USB_OHCI_NEW
+#	define CONFIG_USB_STORAGE
+#	define CFG_USB_OHCI_CPU_INIT
+#	define CFG_USB_BASE			0xb9100000
+#	define CFG_USB_OHCI_REGS_BASE		(CFG_USB_BASE+0xffc00)
+#	define CFG_USB_OHCI_SLOT_NAME		"ohci"
+#	define CFG_USB_OHCI_MAX_ROOT_PORTS	1
+#	define LITTLEENDIAN
+#endif	/* ifdef CONFIG_SH_STB7100_USB */
+
+/*---------------------------------------------------------------
+ * IDE driver config
+ */
+
+/* Choose one of the the following two: */
+#define CONFIG_SH_STB7100_IDE
+//#define CONFIG_SH_STB7100_SATA
+
+#ifdef CONFIG_SH_STB7100_IDE
+#	define CFG_PIO_MODE		4
+#	define CFG_IDE_MAXBUS		1
+#	define CFG_IDE_MAXDEVICE	1
+#	define CFG_ATA_BASE_ADDR	0xA2800000
+#	define CFG_ATA_IDE0_OFFSET	0x00200000
+#	define CFG_ATA_REG_OFFSET	0
+#	define CFG_ATA_DATA_OFFSET	0
+#	define CFG_ATA_STRIDE		0x00020000
+#	define CFG_ATA_ALT_OFFSET	-0x0100000
+#endif	/* CONFIG_SH_STB7100_IDE */
+
+#ifdef CONFIG_SH_STB7100_SATA
+#	define CFG_PIO_MODE		4
+#	define CFG_IDE_MAXBUS		1
+#	define CFG_IDE_MAXDEVICE	1
+#	define CFG_ATA_BASE_ADDR	0xB9209800
+#	define CFG_ATA_IDE0_OFFSET	0x0
+#	define CFG_ATA_REG_OFFSET	0x0
+#	define CFG_ATA_DATA_OFFSET	0x0
+#	define CFG_ATA_STRIDE		0x4
+#	define CFG_ATA_ALT_OFFSET	0x8
+#endif	/* CONFIG_SH_STB7100_SATA */
+
+#if defined(CONFIG_SH_STB7100_IDE)  ||	\
+    defined(CONFIG_SH_STB7100_SATA) ||	\
+    defined(CONFIG_SH_STB7100_USB)
+#	define CFG_64BIT_LBA
+#	define CONFIG_LBA48
+#	define CONFIG_DOS_PARTITION
+#	define CONFIG_CMD_EXT2
+#endif
+
+/*----------------------------------------------------------------------
+ * JFFS2 support
+ */
+
+#if defined(CONFIG_CMD_JFFS2)
+
+#define CFG_JFFS_CUSTOM_PART
+#define CFG_JFFS_SINGLE_PART	1
+
+#define CFG_JFFS2_FIRST_SECTOR 18  /* u-boot, env, kernel  */
+#define CFG_JFFS2_FIRST_BANK 0
+#define CFG_JFFS2_NUM_BANKS 1
+
+#endif
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+
+#define CFG_HUSH_PARSER		1
+#define CFG_LONGHELP		1		/* undef to save memory		*/
+#define CFG_PROMPT		"MB411> "	/* Monitor Command Prompt	*/
+#define CFG_PROMPT_HUSH_PS2	"> "
+#define CFG_CBSIZE		1024
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
+#define CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_HZ			1000		/* HZ for timer ticks		*/
+#define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
+#define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
+#define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
+#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+#define CONFIG_AUTO_COMPLETE
+#define CONFIG_CMDLINE_EDITING
+
+/*-----------------------------------------------------------------------
+ * NOR FLASH organization
+ */
+
+/* STb7100 Mboard organised as 8 MiB flash with 128 KiB blocks */
+#define CFG_FLASH_CFI_DRIVER
+#define CFG_FLASH_CFI
+#define CFG_FLASH_PROTECTION	1	/* use hardware flash protection	*/
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks		*/
+#define CFG_MAX_FLASH_SECT	64	/* max number of sectors on one chip	*/
+#define CFG_FLASH_EMPTY_INFO		/* test if each sector is empty		*/
+
+/*-----------------------------------------------------------------------
+ * Addresss, size, & location of U-boot's Environment Sector
+ */
+
+#define CFG_ENV_IS_IN_FLASH	1
+#define CFG_ENV_OFFSET		CFG_MONITOR_LEN
+#define CFG_ENV_ADDR		(CFG_FLASH_BASE + CFG_ENV_OFFSET)
+#define CFG_ENV_SIZE		0x10000
+#define CFG_ENV_SECT_SIZE	0x20000
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/mb442.h b/include/configs/mb442.h
new file mode 100644
index 0000000000..e03fb93d4a
--- /dev/null
+++ b/include/configs/mb442.h
@@ -0,0 +1,274 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+
+#define CONFIG_SH4	1		/* This is an SH4 CPU		*/
+#define CONFIG_CPU_SUBTYPE_SH4_2XX	/* its an SH4-202		*/
+
+#ifndef INPUT_CLOCK_RATE
+#warning Assuming 30MHz clock input
+#define INPUT_CLOCK_RATE 30
+#endif
+
+
+/*-----------------------------------------------------------------------
+ * Start addresses for the final memory configuration
+ * Assume we run out of uncached memory for the moment
+ */
+
+#ifdef CONFIG_SH_SE_MODE
+#define CFG_FLASH_BASE		0xA0000000	/* FLASH (uncached) via PMB */
+#define CFG_SDRAM_BASE		0x80000000      /* LMI-Sys via PMB */
+#define CFG_SE_PHYSICAL_BASE	0x40000000	/* LMI-Sys Physical Address */
+#define CFG_SE_UNACHED_BASE	0x90000000	/* LMI-Sys un-cached addr via PMB */
+#define CFG_SE_SDRAM_WINDOW	(CFG_SDRAM_SIZE-1)
+#else
+#define CFG_FLASH_BASE		0xA0000000	/* FLASH in P2 region */
+#define CFG_SDRAM_BASE		0x84000000      /* SDRAM in P1 region */
+#endif
+
+#define CFG_SDRAM_SIZE		0x04000000	/* 64 MiB of LMI-Sys SDRAM */
+
+#define CFG_MONITOR_LEN		0x00020000	/* Reserve 128 KiB for Monitor */
+#define CFG_MONITOR_BASE        CFG_FLASH_BASE
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1 MiB for malloc */
+#define CFG_BOOTPARAMS_LEN	(128 << 10)
+#define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
+
+#define CFG_MEMTEST_START	CFG_SDRAM_BASE
+#define CFG_MEMTEST_END		(CFG_SDRAM_BASE + CFG_SDRAM_SIZE - (3 << 20))
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define XSTR(s) STR(s)
+#define STR(s) #s
+
+#define BOARD mb442
+
+#if CFG_MONITOR_LEN == 0x00020000		/* 128 KiB */
+#	define MONITOR_SECTORS	"1:0"		/* 1 sector */
+#elif CFG_MONITOR_LEN == 0x00040000		/* 256 KiB */
+#	define MONITOR_SECTORS	"1:0-1"		/* 2 sectors */
+#else						/* unknown */
+#	error "Unable to determine sectors for monitor"
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		"board=" XSTR(BOARD) "_" XSTR(INPUT_CLOCK_RATE) "\0" \
+		"monitor_base=" XSTR(CFG_MONITOR_BASE) "\0" \
+		"monitor_len=" XSTR(CFG_MONITOR_LEN) "\0" \
+		"monitor_sec=" MONITOR_SECTORS "\0" \
+		"load_addr=" XSTR(CFG_LOAD_ADDR) "\0" \
+		"unprot=" \
+		  "protect off $monitor_sec\0" \
+		"update=" \
+		  "erase $monitor_sec;" \
+		  "cp.b $load_addr $monitor_base $monitor_len;" \
+		  "protect on $monitor_sec\0"
+
+/*--------------------------------------------------------------
+ * Command line configuration.
+ */
+
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_NFS
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_IDE
+
+/*--------------------------------------------------------------
+ * Serial console info
+ */
+
+/*
+ * We can use one of two methods for the "serial" console.
+ * We can either use the (normal hardware) internal ST ASC UART;
+ * OR we can use STMicroelectronics' DTF (Data Transfer Format)
+ * mechanism over a JTAG link to a remote GDB debugger.
+ */
+#if 1
+#	define CONFIG_STM_ASC_SERIAL	/* use a ST ASC UART */
+#else
+#	define CONFIG_STM_DTF_SERIAL	/* use DTF over JTAG */
+#endif
+
+/* choose which ST ASC UART to use */
+#if 1
+#	define CFG_STM_ASC_BASE		0xb8032000ul	/* UART2 */
+#else
+#	define CFG_STM_ASC_BASE		0xb8033000ul	/* UART3 */
+#endif
+
+/*---------------------------------------------------------------
+ * Ethernet driver config
+ */
+
+/*
+ * There are 2 options for ethernet:
+ *    The on-board SMSC LAN91C111
+ *    for STb7109, the on-chip STMAC & on-board PHY
+ */
+
+#if 1
+	/* Config for SMSC LAN91C111 (combined MAC+PHY) */
+#	define CONFIG_DRIVER_SMC91111
+#ifdef CONFIG_SH_SE_MODE
+#	define CONFIG_SMC91111_BASE	0xb2000300ul
+#else	/* CONFIG_SH_SE_MODE */
+#	define CONFIG_SMC91111_BASE	0xa2000300ul
+#endif	/* CONFIG_SH_SE_MODE */
+#else
+	/* Config for on-chip STMAC + STE10xP PHY */
+#	define CONFIG_DRIVER_NETSTMAC
+#	define CFG_STM_STMAC_BASE	0xb8110000ul
+#	define CONFIG_STMAC_STE10XP
+#	define CONFIG_CMD_MII
+#endif
+
+
+/*  If this board does not have eeprom for ethernet address so allow the user
+ *  to set it in the environment
+ */
+
+#define CONFIG_ENV_OVERWRITE
+
+
+/*---------------------------------------------------------------
+ * USB driver config
+ */
+
+/* Choose if we want USB Mass-Storage Support */
+//#define CONFIG_SH_STB7100_USB
+
+#ifdef CONFIG_SH_STB7100_USB
+#	define CONFIG_CMD_USB
+#	define CONFIG_CMD_FAT
+#	define CONFIG_USB_OHCI_NEW
+#	define CONFIG_USB_STORAGE
+#	define CFG_USB_OHCI_CPU_INIT
+#	define CFG_USB_BASE			0xb9100000
+#	define CFG_USB_OHCI_REGS_BASE		(CFG_USB_BASE+0xffc00)
+#	define CFG_USB_OHCI_SLOT_NAME		"ohci"
+#	define CFG_USB_OHCI_MAX_ROOT_PORTS	1
+#	define LITTLEENDIAN
+#endif	/* ifdef CONFIG_SH_STB7100_USB */
+
+/*---------------------------------------------------------------
+ * IDE driver config
+ */
+
+/* Choose one of the the following two: */
+//#define CONFIG_SH_STB7100_IDE
+#define CONFIG_SH_STB7100_SATA
+
+#ifdef CONFIG_SH_STB7100_IDE
+#	define CFG_PIO_MODE		4
+#	define CFG_IDE_MAXBUS		1
+#	define CFG_IDE_MAXDEVICE	1
+#ifdef CONFIG_SH_SE_MODE
+#	define CFG_ATA_BASE_ADDR	0xB2800000
+#else	/* CONFIG_SH_SE_MODE */
+#	define CFG_ATA_BASE_ADDR	0xA2800000
+#endif	/* CONFIG_SH_SE_MODE */
+#	define CFG_ATA_IDE0_OFFSET	0x00200000
+#	define CFG_ATA_REG_OFFSET	0
+#	define CFG_ATA_DATA_OFFSET	0
+#	define CFG_ATA_STRIDE		0x00020000
+#	define CFG_ATA_ALT_OFFSET	-0x0100000
+#endif	/* CONFIG_SH_STB7100_IDE */
+
+#ifdef CONFIG_SH_STB7100_SATA
+#	define CFG_PIO_MODE		4
+#	define CFG_IDE_MAXBUS		1
+#	define CFG_IDE_MAXDEVICE	1
+#	define CFG_ATA_BASE_ADDR	0xB9209800
+#	define CFG_ATA_IDE0_OFFSET	0x0
+#	define CFG_ATA_REG_OFFSET	0x0
+#	define CFG_ATA_DATA_OFFSET	0x0
+#	define CFG_ATA_STRIDE		0x4
+#	define CFG_ATA_ALT_OFFSET	0x8
+#endif	/* CONFIG_SH_STB7100_SATA */
+
+#if defined(CONFIG_SH_STB7100_IDE)  ||	\
+    defined(CONFIG_SH_STB7100_SATA) ||	\
+    defined(CONFIG_SH_STB7100_USB)
+#	define CFG_64BIT_LBA
+#	define CONFIG_LBA48
+#	define CONFIG_DOS_PARTITION
+#	define CONFIG_CMD_EXT2
+#endif
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+
+#define CFG_HUSH_PARSER		1
+#define CFG_LONGHELP		1		/* undef to save memory		*/
+#define CFG_PROMPT		"MB442> "	/* Monitor Command Prompt	*/
+#define CFG_PROMPT_HUSH_PS2	"> "
+#define CFG_CBSIZE		1024
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
+#define CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_HZ			1000		/* HZ for timer ticks	*/
+#define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
+#define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
+#define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
+#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+#define CONFIG_CMDLINE_EDITING
+#define CONFIG_AUTO_COMPLETE       1
+
+/*-----------------------------------------------------------------------
+ * NOR FLASH organization
+ */
+
+/* STb7100 reference board organised as 8 MiB flash with 128 KiB blocks */
+#define CFG_FLASH_CFI_DRIVER
+#define CFG_FLASH_CFI
+#define CFG_FLASH_PROTECTION	1	/* use hardware flash protection	*/
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks		*/
+#define CFG_MAX_FLASH_SECT	64	/* max number of sectors on one chip	*/
+#define CFG_FLASH_EMPTY_INFO		/* test if each sector is empty		*/
+
+/*-----------------------------------------------------------------------
+ * Addresss, size, & location of U-boot's Environment Sector
+ */
+
+#define CFG_ENV_IS_IN_FLASH	1
+#define CFG_ENV_OFFSET		CFG_MONITOR_LEN
+#define CFG_ENV_ADDR		(CFG_FLASH_BASE + CFG_ENV_OFFSET)
+#define CFG_ENV_SIZE		0x10000
+#define CFG_ENV_SECT_SIZE	0x20000
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/mb448.h b/include/configs/mb448.h
new file mode 100644
index 0000000000..428021a6c8
--- /dev/null
+++ b/include/configs/mb448.h
@@ -0,0 +1,251 @@
+/*
+ * (C) Copyright 2004 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+
+#define CONFIG_SH4	1		/* This is an SH4 CPU		*/
+#define CONFIG_CPU_SUBTYPE_SH4_2XX	/* its an SH4-202		*/
+
+#define INPUT_CLOCK_RATE 27
+
+
+/*-----------------------------------------------------------------------
+ * Start addresses for the final memory configuration
+ * Assume we run out of uncached memory for the moment
+ */
+
+#define CFG_SDRAM_BASE		0x84000000      /* SDRAM in P1 region         */
+#define CFG_SDRAM_SIZE		0x02000000
+#define CFG_FLASH_BASE		0xA0000000
+#define CFG_RESET_ADDRESS	0xA0000000
+
+#define CFG_MONITOR_LEN		0x00020000	/* Reserve 128 KiB for Monitor */
+#define CFG_MONITOR_BASE        0xA0000000
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1 MiB for malloc */
+#define CFG_BOOTPARAMS_LEN	(128 << 10)
+#define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
+
+#define CFG_MEMTEST_START	CFG_SDRAM_BASE
+#define CFG_MEMTEST_END		(CFG_SDRAM_BASE + CFG_SDRAM_SIZE - (2 << 20))
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define XSTR(s) STR(s)
+#define STR(s) #s
+
+#define BOARD mb448
+
+#if CFG_MONITOR_LEN == 0x00020000		/* 128 KiB */
+#	define MONITOR_SECTORS	"1:0"		/* 1 sector */
+#elif CFG_MONITOR_LEN == 0x00040000		/* 256 KiB */
+#	define MONITOR_SECTORS	"1:0-1"		/* 2 sectors */
+#else						/* unknown */
+#	error "Unable to determine sectors for monitor"
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		"board=" XSTR(BOARD) "\0" \
+		"monitor_base=" XSTR(CFG_MONITOR_BASE) "\0" \
+		"monitor_len=" XSTR(CFG_MONITOR_LEN) "\0" \
+		"monitor_sec=" MONITOR_SECTORS "\0" \
+		"load_addr=" XSTR(CFG_LOAD_ADDR) "\0" \
+		"unprot=" \
+		  "protect off $monitor_sec\0" \
+		"update=" \
+		  "erase $monitor_sec;" \
+		  "cp.b $load_addr $monitor_base $monitor_len;" \
+		  "protect on $monitor_sec\0"
+
+/*--------------------------------------------------------------
+ * Command line configuration.
+ */
+
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_NFS
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_IDE
+
+/*--------------------------------------------------------------
+ * Serial console info
+ */
+
+/*
+ * We can use one of two methods for the "serial" console.
+ * We can either use the (normal hardware) internal ST ASC UART;
+ * OR we can use STMicroelectronics' DTF (Data Transfer Format)
+ * mechanism over a JTAG link to a remote GDB debugger.
+ */
+#if 1
+#	define CONFIG_STM_ASC_SERIAL	/* use a ST ASC UART */
+#else
+#	define CONFIG_STM_DTF_SERIAL	/* use DTF over JTAG */
+#endif
+
+/* choose which ST ASC UART to use */
+#define CFG_STM_ASC_BASE	0xb8032000ul	/* UART2 */
+
+/*---------------------------------------------------------------
+ * Ethernet driver config
+ */
+
+/*
+ * There are 2 options for ethernet:
+ *    The on-board SMSC LAN91C111
+ *    the on-chip STMAC & on-board PHY
+ */
+
+#if 1
+	/* Config for SMSC LAN91C111 (combined MAC+PHY) */
+#	define CONFIG_DRIVER_SMC91111
+#	define CONFIG_SMC91111_BASE	0xa2000300ul
+#else
+	/* Config for on-chip STMAC + STE10xP PHY */
+#	define CONFIG_DRIVER_NETSTMAC
+#	define CFG_STM_STMAC_BASE	0xb8110000ul
+#	define CONFIG_STMAC_STE10XP
+#	define CONFIG_CMD_MII
+#endif
+
+
+/*  If this board does not have eeprom for ethernet address so allow the user
+ *  to set it in the environment
+ */
+
+#define CONFIG_ENV_OVERWRITE
+
+
+/*---------------------------------------------------------------
+ * USB driver config
+ */
+
+/* Choose if we want USB Mass-Storage Support */
+//#define CONFIG_SH_STB7100_USB
+
+#ifdef CONFIG_SH_STB7100_USB
+#	define CONFIG_CMD_USB
+#	define CONFIG_CMD_FAT
+#	define CONFIG_USB_OHCI_NEW
+#	define CONFIG_USB_STORAGE
+#	define CFG_USB_OHCI_CPU_INIT
+#	define CFG_USB_BASE			0xb9100000
+#	define CFG_USB_OHCI_REGS_BASE		(CFG_USB_BASE+0xffc00)
+#	define CFG_USB_OHCI_SLOT_NAME		"ohci"
+#	define CFG_USB_OHCI_MAX_ROOT_PORTS	1
+#	define LITTLEENDIAN
+#endif	/* ifdef CONFIG_SH_STB7100_USB */
+
+/*---------------------------------------------------------------
+ * IDE driver config
+ */
+
+/* Choose one of the the following two: */
+//#define CONFIG_SH_STB7100_IDE
+#define CONFIG_SH_STB7100_SATA
+
+#ifdef CONFIG_SH_STB7100_IDE
+#	define CFG_PIO_MODE		4
+#	define CFG_IDE_MAXBUS		1
+#	define CFG_IDE_MAXDEVICE	1
+#	define CFG_ATA_BASE_ADDR	0xA2800000
+#	define CFG_ATA_IDE0_OFFSET	0x00200000
+#	define CFG_ATA_REG_OFFSET	0
+#	define CFG_ATA_DATA_OFFSET	0
+#	define CFG_ATA_STRIDE		0x00020000
+#	define CFG_ATA_ALT_OFFSET	-0x0100000
+#endif	/* CONFIG_SH_STB7100_IDE */
+
+#ifdef CONFIG_SH_STB7100_SATA
+#	define CFG_PIO_MODE		4
+#	define CFG_IDE_MAXBUS		1
+#	define CFG_IDE_MAXDEVICE	1
+#	define CFG_ATA_BASE_ADDR	0xB9209800
+#	define CFG_ATA_IDE0_OFFSET	0x0
+#	define CFG_ATA_REG_OFFSET	0x0
+#	define CFG_ATA_DATA_OFFSET	0x0
+#	define CFG_ATA_STRIDE		0x4
+#	define CFG_ATA_ALT_OFFSET	0x8
+#endif	/* CONFIG_SH_STB7100_SATA */
+
+#if defined(CONFIG_SH_STB7100_IDE)  ||	\
+    defined(CONFIG_SH_STB7100_SATA) ||	\
+    defined(CONFIG_SH_STB7100_USB)
+#	define CFG_64BIT_LBA
+#	define CONFIG_LBA48
+#	define CONFIG_DOS_PARTITION
+#	define CONFIG_CMD_EXT2
+#endif
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+
+#define CFG_HUSH_PARSER		1
+#define CONFIG_AUTO_COMPLETE	1
+#define CFG_LONGHELP		1		/* undef to save memory		*/
+#define CFG_PROMPT		"MB448> "	/* Monitor Command Prompt	*/
+#define CFG_PROMPT_HUSH_PS2	"> "
+#define CFG_CBSIZE		1024
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
+#define CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_HZ			1000		/* HZ for timer ticks	*/
+#define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
+#define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
+#define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
+#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+#define CONFIG_CMDLINE_EDITING
+
+/*-----------------------------------------------------------------------
+ * NOR FLASH organization
+ */
+
+/* STb7109E reference board organised as 8 MiB flash with 128 KiB blocks */
+#define CFG_FLASH_CFI_DRIVER
+#define CFG_FLASH_CFI
+#define CFG_FLASH_PROTECTION	1	/* use hardware flash protection	*/
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks		*/
+#define CFG_MAX_FLASH_SECT	64	/* max number of sectors on one chip	*/
+#define CFG_FLASH_EMPTY_INFO		/* test if each sector is empty		*/
+
+/*-----------------------------------------------------------------------
+ * Addresss, size, & location of U-boot's Environment Sector
+ */
+
+#define CFG_ENV_IS_IN_FLASH	1
+#define CFG_ENV_OFFSET		CFG_MONITOR_LEN
+#define CFG_ENV_ADDR		(CFG_FLASH_BASE + CFG_ENV_OFFSET)
+#define CFG_ENV_SIZE		0x10000
+#define CFG_ENV_SECT_SIZE	0x20000
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/mb519.h b/include/configs/mb519.h
new file mode 100644
index 0000000000..fd60ad9908
--- /dev/null
+++ b/include/configs/mb519.h
@@ -0,0 +1,260 @@
+/*
+ * (C) Copyright 2007 STMicroelectronics.
+ *
+ * Stuart Menefy <stuart.menefy@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+
+#define CONFIG_SH4	1		/* This is an SH4 CPU		*/
+#define CONFIG_CPU_SUBTYPE_SH4_2XX	/* its an SH4-202		*/
+
+
+/*-----------------------------------------------------------------------
+ * Start addresses for the final memory configuration
+ * Assume we run out of uncached memory for the moment
+ */
+
+#ifdef CONFIG_SH_SE_MODE
+#define CFG_FLASH_BASE		0xA0000000	/* FLASH (uncached) via PMB */
+#define CFG_SDRAM_BASE		0x80000000      /* LMI0 via PMB */
+#define CFG_SE_PHYSICAL_BASE	0x40000000	/* LMI0 Physical Address */
+#define CFG_SE_UNACHED_BASE	0x90000000	/* LMI0 un-cached addr via PMB */
+#define CFG_SE_SDRAM_WINDOW	(CFG_SDRAM_SIZE-1)
+#else
+#define CFG_FLASH_BASE		0xA0000000	/* FLASH in P2 region */
+#define CFG_SDRAM_BASE		0x88000000      /* SDRAM in P1 region */
+#endif
+
+#define CFG_SDRAM_SIZE		0x08000000	/* 128 MiB of LMI0 SDRAM */
+
+#define CFG_MONITOR_LEN		0x00020000	/* Reserve 128 KiB for Monitor */
+#define CFG_MONITOR_BASE        CFG_FLASH_BASE
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1 MiB for malloc */
+#define CFG_BOOTPARAMS_LEN	(128 << 10)	/* 128 KiB */
+#define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
+
+#define CFG_MEMTEST_START	CFG_SDRAM_BASE
+#define CFG_MEMTEST_END		(CFG_SDRAM_BASE + CFG_SDRAM_SIZE - (3 << 20))
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define XSTR(s) STR(s)
+#define STR(s) #s
+
+#define BOARD mb519
+
+#if CFG_MONITOR_LEN == 0x00020000		/* 128 KiB */
+#	define MONITOR_SECTORS	"1:0"		/* 1 sector */
+#elif CFG_MONITOR_LEN == 0x00040000		/* 256 KiB */
+#	define MONITOR_SECTORS	"1:0-1"		/* 2 sectors */
+#else						/* unknown */
+#	error "Unable to determine sectors for monitor"
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		"board=" XSTR(BOARD) "\0" \
+		"monitor_base=" XSTR(CFG_MONITOR_BASE) "\0" \
+		"monitor_len=" XSTR(CFG_MONITOR_LEN) "\0" \
+		"monitor_sec=" MONITOR_SECTORS "\0" \
+		"load_addr=" XSTR(CFG_LOAD_ADDR) "\0" \
+		"unprot=" \
+		  "protect off $monitor_sec\0" \
+		"update=" \
+		  "erase $monitor_sec;" \
+		  "cp.b $load_addr $monitor_base $monitor_len;" \
+		  "protect on $monitor_sec\0"
+
+/*--------------------------------------------------------------
+ * Command line configuration.
+ */
+
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_NFS
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+
+/*--------------------------------------------------------------
+ * Serial console info
+ */
+
+/*
+ * We can use one of two methods for the "serial" console.
+ * We can either use the (normal hardware) internal ST ASC UART;
+ * OR we can use STMicroelectronics' DTF (Data Transfer Format)
+ * mechanism over a JTAG link to a remote GDB debugger.
+ */
+#if 1
+#	define CONFIG_STM_ASC_SERIAL	/* use a ST ASC UART */
+#else
+#	define CONFIG_STM_DTF_SERIAL	/* use DTF over JTAG */
+#endif
+
+/* choose which ST ASC UART to use */
+#define CFG_STM_ASC_BASE	0xfd032000ul	/* UART2 (lower) */
+//#define CFG_STM_ASC_BASE	0xfd033000ul	/* UART3 (upper) */
+
+/*---------------------------------------------------------------
+ * Ethernet driver config
+ */
+
+/*
+ * There are 2 options for ethernet, both use the on-chip ST-MAC.
+ * The choice in PHYs are:
+ *    The on-board ST STE101P PHY.
+ *    External PHY connected via the MII off-board connector.
+ */
+
+/* are we using the internal ST MAC device ? */
+#define CONFIG_DRIVER_NETSTMAC
+
+/* choose which internal MAC to use */
+#if 1
+#	define CONFIG_STMAC_MAC0			/* Use MAC #0 */
+#else
+#	define CONFIG_STMAC_MAC1			/* Use MAC #1 */
+#endif
+
+/*
+ * Select the appropriate base address for the selected MAC.
+ * Also, choose which external PHY type to use.
+ */
+#if defined(CONFIG_STMAC_MAC0)
+#	define CFG_STM_STMAC_BASE	 0xfd500000ul	/* MAC #0 */
+#	define CONFIG_STMAC_STE10XP			/* ST STE10xP */
+#elif defined(CONFIG_STMAC_MAC1)
+#	define CFG_STM_STMAC_BASE	 0xfd510000ul	/* MAC #1 */
+#	define CONFIG_STMAC_LAN8700			/* SMSC LAN8700 */
+#endif
+
+/*  If this board does not have eeprom for ethernet address so allow the user
+ *  to set it in the environment
+ */
+#define CONFIG_ENV_OVERWRITE
+
+
+/*---------------------------------------------------------------
+ * USB driver config
+ */
+
+/* Choose if we want USB Mass-Storage Support */
+//#define CONFIG_SH_STB7100_USB
+
+#ifdef CONFIG_SH_STB7100_USB
+#	define CONFIG_CMD_USB
+#	define CONFIG_CMD_FAT
+#	define CONFIG_USB_OHCI_NEW
+#	define CONFIG_USB_STORAGE
+#	define CFG_USB_OHCI_CPU_INIT
+#	define CFG_USB0_BASE			0xfd200000	/* middle */
+#	define CFG_USB1_BASE			0xfd300000	/* right */
+#	define CFG_USB2_BASE			0xfd400000	/* left */
+#	define CFG_USB_BASE			CFG_USB0_BASE
+#	define CFG_USB_OHCI_REGS_BASE		(CFG_USB_BASE+0xffc00)
+#	define CFG_USB_OHCI_SLOT_NAME		"ohci"
+#	define CFG_USB_OHCI_MAX_ROOT_PORTS	1
+#	define LITTLEENDIAN
+	/* The following macro should ONLY be defined, when using
+	 * STi7200 cut 1.x, without the RC-delay board fix applied. */
+#	define CONFIG_USB_STI7200_CUT1_SOFT_JTAG_RESET_WORKAROUND
+#endif	/* ifdef CONFIG_SH_STB7100_USB */
+
+/*---------------------------------------------------------------
+ * IDE driver config
+ */
+
+/* SATA should work on cut 2 of the STi7200 */
+//#define CONFIG_SH_STB7100_SATA
+
+#ifdef CONFIG_SH_STB7100_SATA
+#	define CFG_PIO_MODE		4
+#	define CFG_IDE_MAXBUS		1
+#	define CFG_IDE_MAXDEVICE	1
+#	define CFG_ATA_BASE_ADDR	0x????
+#	define CFG_ATA_IDE0_OFFSET	0x0
+#	define CFG_ATA_REG_OFFSET	0x0
+#	define CFG_ATA_DATA_OFFSET	0x0
+#	define CFG_ATA_STRIDE		0x4
+#	define CFG_ATA_ALT_OFFSET	0x8
+#endif	/* CONFIG_SH_STB7100_SATA */
+
+#if defined(CONFIG_SH_STB7100_SATA) ||	\
+    defined(CONFIG_SH_STB7100_USB)
+#	define CFG_64BIT_LBA
+#	define CONFIG_LBA48
+#	define CONFIG_DOS_PARTITION
+#	define CONFIG_CMD_EXT2
+#endif
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+
+#define CFG_HUSH_PARSER		1
+#define CONFIG_AUTO_COMPLETE	1
+#define CFG_LONGHELP		1		/* undef to save memory		*/
+#define CFG_PROMPT		"MB519> "	/* Monitor Command Prompt	*/
+#define CFG_PROMPT_HUSH_PS2	"> "
+#define CFG_CBSIZE		1024
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
+#define CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_HZ			1000		/* HZ for timer ticks	*/
+#define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
+#define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
+#define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
+#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+#define CONFIG_CMDLINE_EDITING
+
+/*-----------------------------------------------------------------------
+ * NOR FLASH organization
+ */
+
+/* M58LT256GT: 32MiB 259 blocks, 128 KiB block size plus parameter block */
+#define CFG_FLASH_CFI_DRIVER
+#define CFG_FLASH_CFI
+#define CONFIG_FLASH_PROTECT_SINGLE_CELL
+#define CFG_FLASH_PROTECTION	1	/* use hardware flash protection	*/
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks		*/
+#define CFG_MAX_FLASH_SECT	259	/* max number of sectors on one chip	*/
+#define CFG_FLASH_EMPTY_INFO		/* test if each sector is empty		*/
+
+/*-----------------------------------------------------------------------
+ * Addresss, size, & location of U-boot's Environment Sector
+ */
+
+#define CFG_ENV_IS_IN_FLASH	1
+#define CFG_ENV_OFFSET		CFG_MONITOR_LEN
+#define CFG_ENV_ADDR		(CFG_FLASH_BASE + CFG_ENV_OFFSET)
+#define CFG_ENV_SIZE		0x10000
+#define CFG_ENV_SECT_SIZE	0x20000
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/mb618.h b/include/configs/mb618.h
new file mode 100644
index 0000000000..e0cef676af
--- /dev/null
+++ b/include/configs/mb618.h
@@ -0,0 +1,307 @@
+/*
+ * (C) Copyright 2008 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+
+#define CONFIG_SH4	1		/* This is an SH4 CPU		*/
+#define CONFIG_CPU_SUBTYPE_SH4_3XX	/* it is an SH4-300		*/
+
+
+/*-----------------------------------------------------------------------
+ * Start addresses for the final memory configuration
+ * Assume we run out of uncached memory for the moment
+ */
+
+#ifdef CONFIG_SH_SE_MODE
+#define CFG_FLASH_BASE		0xA0000000	/* FLASH (uncached) via PMB */
+#define CFG_SE_PHYSICAL_BASE	0x40000000	/* LMI Physical Address */
+#define CFG_SDRAM_BASE		0x80000000      /* LMI    Cached addr via PMB */
+#define CFG_SE_UNACHED_BASE	0x90000000	/* LMI UN-cached addr via PMB */
+#define CFG_SE_SDRAM_WINDOW	(CFG_SDRAM_SIZE-1)
+#else
+#define CFG_FLASH_BASE		0xA0000000	/* FLASH in P2 region */
+#define CFG_SDRAM_BASE		0x8C000000      /* SDRAM in P1 region */
+#endif
+
+#define CFG_SDRAM_SIZE		0x08000000	/* 128 MiB of LMI SDRAM */
+
+#define CFG_MONITOR_LEN		0x00040000	/* Reserve 256 KiB for Monitor */
+#define CFG_MONITOR_BASE        CFG_FLASH_BASE
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1 MiB for malloc */
+#define CFG_BOOTPARAMS_LEN	(128 << 10)	/* 128 KiB */
+#define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
+
+#define CFG_MEMTEST_START	CFG_SDRAM_BASE
+#define CFG_MEMTEST_END		(CFG_SDRAM_BASE + CFG_SDRAM_SIZE - (3 << 20))
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define XSTR(s) STR(s)
+#define STR(s) #s
+
+#define BOARD mb618
+
+#if CFG_MONITOR_LEN == 0x00008000		/* 32 KiB */
+#	define MONITOR_SECTORS	"1:0"		/* 1 sector */
+#elif CFG_MONITOR_LEN == 0x00010000		/* 64 KiB */
+#	define MONITOR_SECTORS	"1:0-1"		/* 2 sectors */
+#elif CFG_MONITOR_LEN == 0x00018000		/* 96 KiB */
+#	define MONITOR_SECTORS	"1:0-2"		/* 3 sectors */
+#elif CFG_MONITOR_LEN == 0x00020000		/* 128 KiB */
+#	define MONITOR_SECTORS	"1:0-3"		/* 4 sectors */
+#elif CFG_MONITOR_LEN == 0x00040000		/* 256 KiB */
+#	define MONITOR_SECTORS	"1:0-4"		/* 5 sectors */
+#else						/* unknown */
+#	error "Unable to determine sectors for monitor"
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		"board=" XSTR(BOARD) "\0" \
+		"monitor_base=" XSTR(CFG_MONITOR_BASE) "\0" \
+		"monitor_len=" XSTR(CFG_MONITOR_LEN) "\0" \
+		"monitor_sec=" MONITOR_SECTORS "\0" \
+		"load_addr=" XSTR(CFG_LOAD_ADDR) "\0" \
+		"unprot=" \
+		  "protect off $monitor_sec\0" \
+		"update=" \
+		  "erase $monitor_sec;" \
+		  "cp.b $load_addr $monitor_base $monitor_len;" \
+		  "protect on $monitor_sec\0"
+
+/*--------------------------------------------------------------
+ * Command line configuration.
+ */
+
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_NFS
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+
+/*--------------------------------------------------------------
+ * Serial console info
+ */
+
+/*
+ * We can use one of two methods for the "serial" console.
+ * We can either use the (normal hardware) internal ST ASC UART;
+ * OR we can use STMicroelectronics' DTF (Data Transfer Format)
+ * mechanism over a JTAG link to a remote GDB debugger.
+ */
+#if 1
+#	define CONFIG_STM_ASC_SERIAL	/* use a ST ASC UART */
+#else
+#	define CONFIG_STM_DTF_SERIAL	/* use DTF over JTAG */
+#endif
+
+/* choose which ST ASC UART to use */
+#if 1
+#	define CFG_STM_ASC_BASE		0xfd032000ul	/* UART2 */
+#else
+#	define CFG_STM_ASC_BASE		0xfd033000ul	/* UART3 */
+#endif
+
+/*---------------------------------------------------------------
+ * Ethernet driver config
+ */
+
+/*
+ * There are 2 options for ethernet, both use the on-chip ST-GMAC.
+ * The choice in PHYs are:
+ *    The on-board SMSC LAN8700
+ *    External PHY connected via the MII off-board connector.
+ */
+
+/* are we using the internal ST GMAC device ? */
+#define CONFIG_DRIVER_NET_STM_GMAC
+
+/*
+ * Select the appropriate base address for the GMAC.
+ * Also, choose which PHY to use.
+ */
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+#	define CFG_STM_STMAC_BASE	 0xfd110000ul	/* MAC = STM GMAC0 */
+#	define CONFIG_STMAC_LAN8700			/* PHY = SMSC LAN8700 */
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+/*  If this board does not have eeprom for ethernet address so allow the user
+ *  to set it in the environment
+ */
+#define CONFIG_ENV_OVERWRITE
+
+
+/*---------------------------------------------------------------
+ * USB driver config
+ */
+
+/* Choose if we want USB Mass-Storage Support */
+#define CONFIG_SH_STB7100_USB
+
+#ifdef CONFIG_SH_STB7100_USB
+#	define CONFIG_CMD_USB
+#	define CONFIG_CMD_FAT
+#	define CONFIG_USB_OHCI_NEW
+#	define CONFIG_USB_STORAGE
+#	define CFG_USB_OHCI_CPU_INIT
+#	define CFG_USB_BASE			0xfe100000
+#	define CFG_USB_OHCI_REGS_BASE		(CFG_USB_BASE+0xffc00)
+#	define CFG_USB_OHCI_SLOT_NAME		"ohci"
+#	define CFG_USB_OHCI_MAX_ROOT_PORTS	1
+#	define LITTLEENDIAN
+#endif	/* ifdef CONFIG_SH_STB7100_USB */
+
+/*---------------------------------------------------------------
+ * IDE driver config
+ */
+
+#if defined(CONFIG_SH_STB7100_USB)
+#	define CFG_64BIT_LBA
+#	define CONFIG_LBA48
+#	define CONFIG_DOS_PARTITION
+#	define CONFIG_CMD_EXT2
+#endif
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+
+#define CFG_HUSH_PARSER		1
+#define CONFIG_AUTO_COMPLETE	1
+#define CFG_LONGHELP		1		/* undef to save memory		*/
+#define CFG_PROMPT		"MB618> "	/* Monitor Command Prompt	*/
+#define CFG_PROMPT_HUSH_PS2	"> "
+#define CFG_CBSIZE		1024
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
+#define CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_HZ			1000		/* HZ for timer ticks	*/
+#define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
+#define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
+#define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
+#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+#define CONFIG_CMDLINE_EDITING
+
+/*-----------------------------------------------------------------------
+ * FLASH organization
+ */
+
+/* Whether the hardware supports NOR or NAND Flash depends on J34.
+ * One ONE of these may be present at any one time. Each hides the other.
+ * In position 1-2 CSA selects NAND, in position 2-3 is selects NOR.
+ * Note that J30A must also be in position 2-3 to select the
+ * on-board Flash (for either the on-board NOR or NAND flash).
+ *
+ * i.e.		ON-board NOR FLASH:	J30A:2-3, J34:2-3
+ *	 	ON-board NAND FLASH:	J30A:2-3, J34:1-2
+ */
+//#define CONFIG_CMD_NAND		/* define for NAND flash */
+
+/*-----------------------------------------------------------------------
+ * NOR FLASH organization
+ */
+
+/* M58LT256GT: 32MiB 259 blocks, 128 KiB block size */
+#ifndef CONFIG_CMD_NAND				/* NOR flash present ? */
+#	define CONFIG_CMD_JFFS2			/* enable JFFS2 support */
+#	define CFG_FLASH_CFI_DRIVER
+#	define CFG_FLASH_CFI
+#	define CONFIG_FLASH_PROTECT_SINGLE_CELL
+#	define CFG_FLASH_PROTECTION	1	/* use hardware flash protection	*/
+#	define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks		*/
+#	define CFG_MAX_FLASH_SECT	259	/* max number of sectors on one chip	*/
+#	define CFG_FLASH_EMPTY_INFO		/* test if each sector is empty		*/
+#define MTDPARTS_DEFAULT						\
+	"mtdparts="							\
+	"physmap-flash:"	/* First NOR flash device */		\
+		"256k(U-Boot)"		/* first partition */		\
+		",128k(Environment)"					\
+		",4M(Kernel)"						\
+		",-(RestOfNor)"		/* last partition */
+#define MTDIDS_DEFAULT							\
+	"nor0=physmap-flash"	/* First NOR flash device */
+#endif	/* CONFIG_CMD_NAND */
+
+/*-----------------------------------------------------------------------
+ * NAND FLASH organization
+ */
+
+/* NAND512W3A: 64MiB  8-bit, 4096 Blocks (16KiB+512B) of 32 Pages (512+16) */
+/* NAND512W4A: 64MiB 16-bit, 4096 Blocks (16KiB+512B) of 32 Pages (512+16) */
+#ifdef CONFIG_CMD_NAND				/* NAND flash present ? */
+#	define CONFIG_CMD_JFFS2			/* enable JFFS2 support */
+#	define CFG_MAX_NAND_DEVICE	1
+#	define NAND_MAX_CHIPS		CFG_MAX_NAND_DEVICE
+#	define CFG_NAND0_BASE		CFG_FLASH_BASE	/* Occludes NOR flash */
+#	define CFG_NAND_BASE_LIST	{ CFG_NAND0_BASE }
+#	undef CONFIG_CMD_FLASH			/* NOR-flash specific */
+#	undef CONFIG_CMD_IMLS			/* NOR-flash specific */
+#	define CFG_NO_FLASH			/* no NOR-flash when using NAND-flash */
+#define MTDPARTS_DEFAULT						\
+	"mtdparts="							\
+	"gen_nand.1:"		/* First NAND flash device */		\
+		"128k(Environment)"	/* first partition */		\
+		",4M(Kernel)"						\
+		",32M(rootfs)"						\
+		",-(RestOfNand)"	/* last partition */
+#define MTDIDS_DEFAULT							\
+	"nand0=gen_nand.1"	/* First NAND flash device */
+#endif	/* CONFIG_CMD_NAND */
+
+/*-----------------------------------------------------------------------
+ * Addresss, size, & location of U-boot's Environment Sector
+ */
+
+#ifdef CONFIG_CMD_NAND				/* NAND flash present ? */
+#	define CFG_ENV_IS_IN_NAND		/* enviroment in NAND flash */
+#	define CFG_ENV_OFFSET	0		/* begining of NAND flash */
+#else
+#	define CFG_ENV_IS_IN_FLASH		/* environment in NOR flash */
+#	define CFG_ENV_OFFSET	CFG_MONITOR_LEN	/* After u-boot.bin */
+#endif	/* CONFIG_CMD_NAND */
+#define CFG_ENV_ADDR		(CFG_FLASH_BASE + CFG_ENV_OFFSET)
+#define CFG_ENV_SIZE		0x10000
+#define CFG_ENV_SECT_SIZE	0x20000
+
+/*----------------------------------------------------------------------
+ * JFFS2 support
+ */
+
+#if defined(CONFIG_CMD_JFFS2)
+#	ifdef CONFIG_CMD_NAND			/* NAND flash present ? */
+#		define CONFIG_JFFS2_NAND	/* JFFS2 support on NAND Flash */
+#	endif	/* CONFIG_CMD_NAND */
+#	define CONFIG_JFFS2_CMDLINE		/* mtdparts command line support */
+#endif	/* CONFIG_CMD_JFFS2 */
+
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/mb628.h b/include/configs/mb628.h
new file mode 100644
index 0000000000..5ce3021997
--- /dev/null
+++ b/include/configs/mb628.h
@@ -0,0 +1,327 @@
+/*
+ * (C) Copyright 2008-2009 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+
+#define CONFIG_SH4	1		/* This is an SH4 CPU		*/
+#define CONFIG_CPU_SUBTYPE_SH4_3XX	/* it is an SH4-300		*/
+
+
+/*-----------------------------------------------------------------------
+ * Start addresses for the final memory configuration
+ * Assume we run out of uncached memory for the moment
+ *
+ * See board/mb628/config.mk for details of the memory map.
+ */
+
+#ifdef CONFIG_SH_SE_MODE
+#define CFG_FLASH_BASE		0xA0000000	/* FLASH (uncached) via PMB */
+#define CFG_SE_PHYSICAL_BASE	0x40000000	/* LMI Physical Address */
+#define CFG_SDRAM_BASE		0x80800000      /* LMI    Cached addr via PMB */
+#define CFG_SE_UNACHED_BASE	0x90000000	/* LMI UN-cached addr via PMB */
+#define CFG_SE_SDRAM_WINDOW	(CFG_SDRAM_SIZE-1)
+#else
+#define CFG_FLASH_BASE		0xA0000000	/* FLASH in P2 region */
+#define CFG_SDRAM_BASE		0x8C800000      /* SDRAM in P1 region */
+#endif
+
+#define CFG_SDRAM_SIZE		0x03200000	/* 50 MiB of LMI SDRAM */
+
+#define CFG_MONITOR_LEN		0x00040000	/* Reserve 256 KiB for Monitor */
+#define CFG_MONITOR_BASE        CFG_FLASH_BASE
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1 MiB for malloc */
+#define CFG_BOOTPARAMS_LEN	(128 << 10)	/* 128 KiB */
+#define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
+
+#define CFG_MEMTEST_START	CFG_SDRAM_BASE
+#define CFG_MEMTEST_END		(CFG_SDRAM_BASE + CFG_SDRAM_SIZE - (3 << 20))
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define XSTR(s) STR(s)
+#define STR(s) #s
+
+#define BOARD mb628
+
+#if CFG_MONITOR_LEN == 0x00008000		/* 32 KiB */
+#	define MONITOR_SECTORS	"1:0"		/* 1 sector */
+#elif CFG_MONITOR_LEN == 0x00010000		/* 64 KiB */
+#	define MONITOR_SECTORS	"1:0-1"		/* 2 sectors */
+#elif CFG_MONITOR_LEN == 0x00018000		/* 96 KiB */
+#	define MONITOR_SECTORS	"1:0-2"		/* 3 sectors */
+#elif CFG_MONITOR_LEN == 0x00020000		/* 128 KiB */
+#	define MONITOR_SECTORS	"1:0-3"		/* 4 sectors */
+#elif CFG_MONITOR_LEN == 0x00040000		/* 256 KiB */
+#	define MONITOR_SECTORS	"1:0-4"		/* 5 sectors */
+#else						/* unknown */
+#	error "Unable to determine sectors for monitor"
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		"board=" XSTR(BOARD) "\0" \
+		"monitor_base=" XSTR(CFG_MONITOR_BASE) "\0" \
+		"monitor_len=" XSTR(CFG_MONITOR_LEN) "\0" \
+		"monitor_sec=" MONITOR_SECTORS "\0" \
+		"load_addr=" XSTR(CFG_LOAD_ADDR) "\0" \
+		"unprot=" \
+		  "protect off $monitor_sec\0" \
+		"update=" \
+		  "erase $monitor_sec;" \
+		  "cp.b $load_addr $monitor_base $monitor_len;" \
+		  "protect on $monitor_sec\0"
+
+/*--------------------------------------------------------------
+ * Command line configuration.
+ */
+
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_NFS
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+
+/*--------------------------------------------------------------
+ * Serial console info
+ */
+
+/*
+ * We can use one of two methods for the "serial" console.
+ * We can either use the (normal hardware) internal ST ASC UART;
+ * OR we can use STMicroelectronics' DTF (Data Transfer Format)
+ * mechanism over a JTAG link to a remote GDB debugger.
+ */
+#if 1
+#	define CONFIG_STM_ASC_SERIAL	/* use a ST ASC UART */
+#else
+#	define CONFIG_STM_DTF_SERIAL	/* use DTF over JTAG */
+#endif
+
+/* choose which ST ASC UART to use */
+#if 1
+	/* ASC1	(left-most)	"RS232 1" */
+#	define CFG_STM_ASC_BASE		0xfd031000
+#else
+	/* ASC2	(right-most)	"RS232 2" */
+#	define CFG_STM_ASC_BASE		0xfd032000
+#endif
+
+/*---------------------------------------------------------------
+ * Ethernet driver config
+ */
+
+/*
+ * There are 2 options for ethernet, both use the on-chip ST-GMAC.
+ * The choice in PHYs are:
+ *    The on-board SMSC LAN8700
+ *    External PHY connected via the MII off-board connector.
+ */
+
+/* are we using the internal ST GMAC device ? */
+#define CONFIG_DRIVER_NET_STM_GMAC
+
+/*
+ * Select the appropriate base address for the GMAC.
+ * Also, choose which PHY to use.
+ */
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+#	define CFG_STM_STMAC_BASE	 0xfd110000ul	/* MAC = STM GMAC0 */
+#	define CONFIG_STMAC_LAN8700			/* PHY = SMSC LAN8700 */
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+/*  If this board does not have eeprom for ethernet address so allow the user
+ *  to set it in the environment
+ */
+#define CONFIG_ENV_OVERWRITE
+
+
+/*---------------------------------------------------------------
+ * USB driver config
+ */
+
+/* Choose if we want USB Mass-Storage Support */
+//QQQ	#define CONFIG_SH_STB7100_USB
+
+#ifdef CONFIG_SH_STB7100_USB
+#	define CONFIG_CMD_USB
+#	define CONFIG_CMD_FAT
+#	define CONFIG_USB_OHCI_NEW
+#	define CONFIG_USB_STORAGE
+#	define CFG_USB_OHCI_CPU_INIT
+#	define CFG_USB_BASE			0xfe100000
+#	define CFG_USB_OHCI_REGS_BASE		(CFG_USB_BASE+0xffc00)
+#	define CFG_USB_OHCI_SLOT_NAME		"ohci"
+#	define CFG_USB_OHCI_MAX_ROOT_PORTS	1
+#	define LITTLEENDIAN
+#endif	/* ifdef CONFIG_SH_STB7100_USB */
+
+/*---------------------------------------------------------------
+ * SATA driver config
+ */
+
+/* SATA works on cut 2.x of the STx7141 (just one port) */
+/* Choose if we want to use a SATA HDD */
+//#define CONFIG_SH_STM_SATA
+
+#ifdef CONFIG_SH_STM_SATA
+#	define CONFIG_CMD_IDE				/* enable "ide" command set */
+#	define CFG_ATA_BASE_ADDR	0xfe209000	/* E-SATA panel connector */
+#	define CFG_ATA_IDE0_OFFSET	0x800		/* Host Controller */
+#	define CFG_ATA_REG_OFFSET	0x0
+#	define CFG_ATA_DATA_OFFSET	0x0
+#	define CFG_ATA_STRIDE		0x4
+#	define CFG_IDE_MAXBUS		1
+#	define CFG_IDE_MAXDEVICE	1
+#endif	/* CONFIG_SH_STM_SATA */
+
+#if defined(CONFIG_SH_STM_SATA) ||	\
+    defined(CONFIG_SH_STB7100_USB)
+#	define CFG_64BIT_LBA
+#	define CONFIG_LBA48
+#	define CONFIG_DOS_PARTITION
+#	define CONFIG_CMD_EXT2
+#endif
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+
+#define CFG_HUSH_PARSER		1
+#define CONFIG_AUTO_COMPLETE	1
+#define CFG_LONGHELP		1		/* undef to save memory		*/
+#define CFG_PROMPT		"MB628> "	/* Monitor Command Prompt	*/
+#define CFG_PROMPT_HUSH_PS2	"> "
+#define CFG_CBSIZE		1024
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
+#define CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_HZ			1000		/* HZ for timer ticks	*/
+#define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
+#define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
+#define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
+#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+#define CONFIG_CMDLINE_EDITING
+
+/*-----------------------------------------------------------------------
+ * FLASH organization
+ */
+
+/* Whether the hardware supports NOR or NAND Flash depends on J70.
+ * Only ONE of these may be present at any one time. Each hides the other.
+ * In position 1-2 CSA selects NAND, in position 2-3 is selects NOR.
+ * Note that J69 must also be in position 2-3 to select the
+ * on-board Flash (for either the on-board NOR or NAND flash).
+ *
+ * i.e.		ON-board NOR FLASH:	J69:2-3, J70:2-3
+ *	 	ON-board NAND FLASH:	J69:2-3, J70:1-2
+ */
+//#define CONFIG_CMD_NAND		/* define for NAND flash */
+
+/*-----------------------------------------------------------------------
+ * NOR FLASH organization
+ */
+
+/* M58LT256JSB: 32MiB 259 blocks, 128 KiB block size */
+#ifndef CONFIG_CMD_NAND				/* NOR flash present ? */
+#	define CONFIG_CMD_JFFS2			/* enable JFFS2 support */
+#	define CFG_FLASH_CFI_DRIVER
+#	define CFG_FLASH_CFI
+#	define CONFIG_FLASH_PROTECT_SINGLE_CELL
+#	define CFG_FLASH_PROTECTION	1	/* use hardware flash protection	*/
+#	define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks		*/
+#	define CFG_MAX_FLASH_SECT	259	/* max number of sectors on one chip	*/
+#	define CFG_FLASH_EMPTY_INFO		/* test if each sector is empty		*/
+#define MTDPARTS_DEFAULT						\
+	"mtdparts="							\
+	"physmap-flash:"	/* First NOR flash device */		\
+		"256k(U-Boot)"		/* first partition */		\
+		",128k(Environment)"					\
+		",4M(Kernel)"						\
+		",-(RestOfNor)"		/* last partition */
+#define MTDIDS_DEFAULT							\
+	"nor0=physmap-flash"	/* First NOR flash device */
+#endif	/* CONFIG_CMD_NAND */
+
+/*-----------------------------------------------------------------------
+ * NAND FLASH organization
+ */
+
+/* NAND512W3A: 64MiB  8-bit, 4096 Blocks (16KiB+512B) of 32 Pages (512+16) */
+/* NAND512W4A: 64MiB 16-bit, 4096 Blocks (16KiB+512B) of 32 Pages (512+16) */
+#ifdef CONFIG_CMD_NAND				/* NAND flash present ? */
+#	define CONFIG_CMD_JFFS2			/* enable JFFS2 support */
+#	define CFG_MAX_NAND_DEVICE	1
+#	define NAND_MAX_CHIPS		CFG_MAX_NAND_DEVICE
+#	define CFG_NAND0_BASE		CFG_FLASH_BASE	/* Occludes NOR flash */
+#	define CFG_NAND_BASE_LIST	{ CFG_NAND0_BASE }
+#	undef CONFIG_CMD_FLASH			/* NOR-flash specific */
+#	undef CONFIG_CMD_IMLS			/* NOR-flash specific */
+#	define CFG_NO_FLASH			/* no NOR-flash when using NAND-flash */
+#define MTDPARTS_DEFAULT						\
+	"mtdparts="							\
+	"gen_nand.1:"		/* First NAND flash device */		\
+		"128k(Environment)"	/* first partition */		\
+		",4M(Kernel)"						\
+		",32M(rootfs)"						\
+		",-(RestOfNand)"	/* last partition */
+#define MTDIDS_DEFAULT							\
+	"nand0=gen_nand.1"	/* First NAND flash device */
+#endif	/* CONFIG_CMD_NAND */
+
+/*-----------------------------------------------------------------------
+ * Addresss, size, & location of U-boot's Environment Sector
+ */
+
+#ifdef CONFIG_CMD_NAND				/* NAND flash present ? */
+#	define CFG_ENV_IS_IN_NAND		/* enviroment in NAND flash */
+#	define CFG_ENV_OFFSET	0		/* begining of NAND flash */
+#else
+#	define CFG_ENV_IS_IN_FLASH		/* environment in NOR flash */
+#	define CFG_ENV_OFFSET	CFG_MONITOR_LEN	/* After u-boot.bin */
+#endif	/* CONFIG_CMD_NAND */
+#define CFG_ENV_ADDR		(CFG_FLASH_BASE + CFG_ENV_OFFSET)
+#define CFG_ENV_SIZE		0x10000
+#define CFG_ENV_SECT_SIZE	0x20000
+
+/*----------------------------------------------------------------------
+ * JFFS2 support
+ */
+
+#if defined(CONFIG_CMD_JFFS2)
+#	ifdef CONFIG_CMD_NAND			/* NAND flash present ? */
+#		define CONFIG_JFFS2_NAND	/* JFFS2 support on NAND Flash */
+#	endif	/* CONFIG_CMD_NAND */
+#	define CONFIG_JFFS2_CMDLINE		/* mtdparts command line support */
+#endif	/* CONFIG_CMD_JFFS2 */
+
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/mb671.h b/include/configs/mb671.h
new file mode 100644
index 0000000000..d1d94c1b84
--- /dev/null
+++ b/include/configs/mb671.h
@@ -0,0 +1,257 @@
+/*
+ * (C) Copyright 2007-2009 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+
+#define CONFIG_SH4	1		/* This is an SH4 CPU		*/
+#define CONFIG_CPU_SUBTYPE_SH4_3XX	/* it is an SH4-300		*/
+
+
+/*-----------------------------------------------------------------------
+ * Start addresses for the final memory configuration
+ * Assume we run out of uncached memory for the moment
+ */
+
+#ifdef CONFIG_SH_SE_MODE
+#define CFG_FLASH_BASE		0xA0000000	/* FLASH (uncached) via PMB */
+#define CFG_SDRAM_BASE		0x80000000      /* LMI0 via PMB */
+#define CFG_SE_PHYSICAL_BASE	0x40000000	/* LMI0 Physical Address */
+#define CFG_SE_UNACHED_BASE	0x90000000	/* LMI0 un-cached addr via PMB */
+#define CFG_SE_SDRAM_WINDOW	(CFG_SDRAM_SIZE-1)
+#else
+#define CFG_FLASH_BASE		0xA0000000	/* FLASH in P2 region */
+#define CFG_SDRAM_BASE		0x88000000      /* SDRAM in P1 region */
+#endif
+
+#define CFG_SDRAM_SIZE		0x10000000	/* 256 MiB of LMI0 SDRAM */
+
+#define CFG_MONITOR_LEN		0x00020000	/* Reserve 128 KiB for Monitor */
+#define CFG_MONITOR_BASE        CFG_FLASH_BASE
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1 MiB for malloc */
+#define CFG_BOOTPARAMS_LEN	(128 << 10)	/* 128 KiB */
+#define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
+
+#define CFG_MEMTEST_START	CFG_SDRAM_BASE
+#define CFG_MEMTEST_END		(CFG_SDRAM_BASE + CFG_SDRAM_SIZE - (3 << 20))
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define XSTR(s) STR(s)
+#define STR(s) #s
+
+#define BOARD mb671
+
+#if CFG_MONITOR_LEN == 0x00020000		/* 128 KiB */
+#	define MONITOR_SECTORS	"1:0"		/* 1 sector */
+#elif CFG_MONITOR_LEN == 0x00040000		/* 256 KiB */
+#	define MONITOR_SECTORS	"1:0-1"		/* 2 sectors */
+#else						/* unknown */
+#	error "Unable to determine sectors for monitor"
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		"board=" XSTR(BOARD) "\0" \
+		"monitor_base=" XSTR(CFG_MONITOR_BASE) "\0" \
+		"monitor_len=" XSTR(CFG_MONITOR_LEN) "\0" \
+		"monitor_sec=" MONITOR_SECTORS "\0" \
+		"load_addr=" XSTR(CFG_LOAD_ADDR) "\0" \
+		"unprot=" \
+		  "protect off $monitor_sec\0" \
+		"update=" \
+		  "erase $monitor_sec;" \
+		  "cp.b $load_addr $monitor_base $monitor_len;" \
+		  "protect on $monitor_sec\0"
+
+/*--------------------------------------------------------------
+ * Command line configuration.
+ */
+
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_NFS
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+
+/*--------------------------------------------------------------
+ * Serial console info
+ */
+
+/*
+ * We can use one of two methods for the "serial" console.
+ * We can either use the (normal hardware) internal ST ASC UART;
+ * OR we can use STMicroelectronics' DTF (Data Transfer Format)
+ * mechanism over a JTAG link to a remote GDB debugger.
+ */
+#if 1
+#	define CONFIG_STM_ASC_SERIAL	/* use a ST ASC UART */
+#else
+#	define CONFIG_STM_DTF_SERIAL	/* use DTF over JTAG */
+#endif
+
+/* choose which ST ASC UART to use */
+#define CFG_STM_ASC_BASE	0xfd032000ul	/* UART2 (lower) */
+//#define CFG_STM_ASC_BASE	0xfd033000ul	/* UART3 (upper) */
+
+/*---------------------------------------------------------------
+ * Ethernet driver config
+ */
+
+/*
+ * There are 2 options for ethernet, both use the on-chip ST-MAC.
+ * The choice in PHYs is:
+ *    1) The on-board SMSC LAN8700 PHY.
+ *    2) External PHY connected via the MII off-board connector (MB539B).
+ */
+
+/* are we using the internal ST MAC device ? */
+#define CONFIG_DRIVER_NETSTMAC
+
+/* choose which internal MAC to use */
+#if 1
+#	define CONFIG_STMAC_MAC0			/* Use MAC #0 */
+#else
+#	define CONFIG_STMAC_MAC1			/* Use MAC #1 */
+#endif
+
+/*
+ * Select the appropriate base address for the selected MAC.
+ * Also, choose which external PHY type to use.
+ */
+#if defined(CONFIG_STMAC_MAC0)
+#	define CFG_STM_STMAC_BASE	 0xfd500000ul	/* MAC #0 */
+#	define CONFIG_STMAC_LAN8700			/* SMSC LAN8700 */
+#elif defined(CONFIG_STMAC_MAC1)
+#	define CFG_STM_STMAC_BASE	 0xfd510000ul	/* MAC #1 */
+#	define CONFIG_STMAC_LAN8700			/* SMSC LAN8700 */
+#endif
+
+/*  If this board does not have eeprom for ethernet address so allow the user
+ *  to set it in the environment
+ */
+#define CONFIG_ENV_OVERWRITE
+
+
+/*---------------------------------------------------------------
+ * USB driver config
+ */
+
+/* Choose if we want USB Mass-Storage Support */
+//#define CONFIG_SH_STB7100_USB
+
+#ifdef CONFIG_SH_STB7100_USB
+#	define CONFIG_CMD_USB
+#	define CONFIG_CMD_FAT
+#	define CONFIG_USB_OHCI_NEW
+#	define CONFIG_USB_STORAGE
+#	define CFG_USB_OHCI_CPU_INIT
+#	define CFG_USB0_BASE			0xfd200000	/* middle */
+#	define CFG_USB1_BASE			0xfd300000	/* right */
+#	define CFG_USB2_BASE			0xfd400000	/* left */
+#	define CFG_USB_BASE			CFG_USB0_BASE
+#	define CFG_USB_OHCI_REGS_BASE		(CFG_USB_BASE+0xffc00)
+#	define CFG_USB_OHCI_SLOT_NAME		"ohci"
+#	define CFG_USB_OHCI_MAX_ROOT_PORTS	1
+#	define LITTLEENDIAN
+#endif	/* ifdef CONFIG_SH_STB7100_USB */
+
+/*---------------------------------------------------------------
+ * SATA driver config
+ */
+
+/* SATA works on cut 3.x of the STx7200 (just one port) */
+/* Choose if we want to use a SATA HDD */
+//#define CONFIG_SH_STM_SATA
+
+#ifdef CONFIG_SH_STM_SATA
+#	define CONFIG_CMD_IDE				/* enable "ide" command set */
+#	define CFG_ATA_BASE_ADDR	0xfd520000	/* SATA #0 */
+#	define CFG_ATA_IDE0_OFFSET	0x800		/* Host Controller */
+#	define CFG_ATA_REG_OFFSET	0x0
+#	define CFG_ATA_DATA_OFFSET	0x0
+#	define CFG_ATA_STRIDE		0x4
+#	define CFG_IDE_MAXBUS		1
+#	define CFG_IDE_MAXDEVICE	1
+#endif	/* CONFIG_SH_STM_SATA */
+
+#if defined(CONFIG_SH_STM_SATA) ||	\
+    defined(CONFIG_SH_STB7100_USB)
+#	define CFG_64BIT_LBA
+#	define CONFIG_LBA48
+#	define CONFIG_DOS_PARTITION
+#	define CONFIG_CMD_EXT2
+#endif
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+
+#define CFG_HUSH_PARSER		1
+#define CONFIG_AUTO_COMPLETE	1
+#define CFG_LONGHELP		1		/* undef to save memory		*/
+#define CFG_PROMPT		"MB671> "	/* Monitor Command Prompt	*/
+#define CFG_PROMPT_HUSH_PS2	"> "
+#define CFG_CBSIZE		1024
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
+#define CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_HZ			1000		/* HZ for timer ticks	*/
+#define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
+#define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
+#define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
+#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+#define CONFIG_CMDLINE_EDITING
+
+/*-----------------------------------------------------------------------
+ * NOR FLASH organization
+ */
+
+/* M58LT256GT: 32MiB 259 blocks, 128 KiB block size plus parameter block */
+#define CFG_FLASH_CFI_DRIVER
+#define CFG_FLASH_CFI
+#define CONFIG_FLASH_PROTECT_SINGLE_CELL
+#define CFG_FLASH_PROTECTION	1	/* use hardware flash protection	*/
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks		*/
+#define CFG_MAX_FLASH_SECT	259	/* max number of sectors on one chip	*/
+#define CFG_FLASH_EMPTY_INFO		/* test if each sector is empty		*/
+
+/*-----------------------------------------------------------------------
+ * Addresss, size, & location of U-boot's Environment Sector
+ */
+
+#define CFG_ENV_IS_IN_FLASH	1
+#define CFG_ENV_OFFSET		CFG_MONITOR_LEN
+#define CFG_ENV_ADDR		(CFG_FLASH_BASE + CFG_ENV_OFFSET)
+#define CFG_ENV_SIZE		0x10000
+#define CFG_ENV_SECT_SIZE	0x20000
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/mb680.h b/include/configs/mb680.h
new file mode 100644
index 0000000000..f27e9cf09b
--- /dev/null
+++ b/include/configs/mb680.h
@@ -0,0 +1,429 @@
+/*
+ * (C) Copyright 2008-2009 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+
+#define CONFIG_SH4	1		/* This is an SH4 CPU		*/
+#define CONFIG_CPU_SUBTYPE_SH4_3XX	/* it is an SH4-300		*/
+
+
+/*-----------------------------------------------------------------------
+ * Are we booting directly from a NAND Flash device ?
+ * If so, then define the "CFG_BOOT_FROM_NAND" macro,
+ * otherwise (e.g. NOR/SPI Flash booting), do not define it.
+ */
+#undef CFG_BOOT_FROM_NAND		/* define to build a NAND-bootable image */
+
+
+/*-----------------------------------------------------------------------
+ * Start addresses for the final memory configuration
+ * Assume we run out of uncached memory for the moment
+ */
+
+#ifdef CFG_BOOT_FROM_NAND	/* we are booting from NAND, so *DO* swap CSA and CSB in EPLD */
+		/*
+		 * QQQ: do we want to make sizeof(CSA) = 8MiB, and sizeof(CSB) = 64MiB ?
+		 * If so, then who takes responsibility for this???
+		 * Is this implicit in the GDB pokes, or explicit in U-Boot's init code?
+		 * Should U-Boot read SW8(1) on the MB705, and do something?
+		 */
+#define CFG_EMI_NAND_BASE	0xA0000000	/* CSA: NAND Flash, Physical 0x00000000 (64MiB) */
+#define CFG_EMI_NOR_BASE	0xA4000000	/* CSB: NOR Flash,  Physical 0x04000000 (8MiB) */
+#define CFG_NAND_FLEX_CSn_MAP	{ 0 }		/* NAND is on Chip Select CSA */
+#else		/* else, do *NOT* swap CSA and CSB in EPLD */
+#define CFG_EMI_NOR_BASE	0xA0000000	/* CSA: NOR Flash,  Physical 0x00000000 (64MiB) */
+#define CFG_EMI_NAND_BASE	0xA4000000	/* CSB: NAND Flash, Physical 0x04000000 (8MiB) */
+#define CFG_NAND_FLEX_CSn_MAP	{ 1 }		/* NAND is on Chip Select CSB */
+#endif /* CFG_BOOT_FROM_NAND */
+
+#ifdef CONFIG_SH_SE_MODE
+#define CFG_FLASH_BASE		CFG_EMI_NOR_BASE/* NOR FLASH (uncached) via PMB */
+#define CFG_SE_PHYSICAL_BASE	0x40000000	/* LMI Physical Address */
+#define CFG_SDRAM_BASE		0x80000000      /* LMI    Cached addr via PMB */
+#define CFG_SE_UNACHED_BASE	0x90000000	/* LMI UN-cached addr via PMB */
+#define CFG_SE_SDRAM_WINDOW	(CFG_SDRAM_SIZE-1)
+#else
+#define CFG_FLASH_BASE		CFG_EMI_NOR_BASE/* NOR FLASH in P2 region */
+#define CFG_SDRAM_BASE		0x8C000000      /* SDRAM in P1 region */
+#endif
+
+#define CFG_SDRAM_SIZE		0x10000000	/* 256 MiB of LMI SDRAM */
+
+#define CFG_MONITOR_LEN		0x00040000	/* Reserve 256 KiB for Monitor */
+#define CFG_MONITOR_BASE        CFG_FLASH_BASE
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1 MiB for malloc */
+#define CFG_BOOTPARAMS_LEN	(128 << 10)	/* 128 KiB */
+#define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
+
+#define CFG_MEMTEST_START	CFG_SDRAM_BASE
+#define CFG_MEMTEST_END		(CFG_SDRAM_BASE + CFG_SDRAM_SIZE - (3 << 20))
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define XSTR(s) STR(s)
+#define STR(s) #s
+
+#define BOARD mb680
+
+#if CFG_MONITOR_LEN == 0x00008000		/* 32 KiB */
+#	define MONITOR_SECTORS	"1:0"		/* 1 sector */
+#elif CFG_MONITOR_LEN == 0x00010000		/* 64 KiB */
+#	define MONITOR_SECTORS	"1:0-1"		/* 2 sectors */
+#elif CFG_MONITOR_LEN == 0x00018000		/* 96 KiB */
+#	define MONITOR_SECTORS	"1:0-2"		/* 3 sectors */
+#elif CFG_MONITOR_LEN == 0x00020000		/* 128 KiB */
+#	define MONITOR_SECTORS	"1:0-3"		/* 4 sectors */
+#elif CFG_MONITOR_LEN == 0x00040000		/* 256 KiB */
+#	define MONITOR_SECTORS	"1:0-4"		/* 5 sectors */
+#else						/* unknown */
+#	error "Unable to determine sectors for monitor"
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		"board=" XSTR(BOARD) "\0" \
+		"monitor_base=" XSTR(CFG_MONITOR_BASE) "\0" \
+		"monitor_len=" XSTR(CFG_MONITOR_LEN) "\0" \
+		"monitor_sec=" MONITOR_SECTORS "\0" \
+		"load_addr=" XSTR(CFG_LOAD_ADDR) "\0" \
+		"unprot=" \
+		  "protect off $monitor_sec\0" \
+		"update=" \
+		  "erase $monitor_sec;" \
+		  "cp.b $load_addr $monitor_base $monitor_len;" \
+		  "protect on $monitor_sec\0"
+
+/*--------------------------------------------------------------
+ * Command line configuration.
+ */
+
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_NFS
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+
+/*--------------------------------------------------------------
+ * Serial console info
+ */
+
+/*
+ * We can use one of two methods for the "serial" console.
+ * We can either use the (normal hardware) internal ST ASC UART;
+ * OR we can use STMicroelectronics' DTF (Data Transfer Format)
+ * mechanism over a JTAG link to a remote GDB debugger.
+ */
+#if 1
+#	define CONFIG_STM_ASC_SERIAL	/* use a ST ASC UART */
+#else
+#	define CONFIG_STM_DTF_SERIAL	/* use DTF over JTAG */
+#endif
+
+/* choose which ST ASC UART to use */
+#if 1
+#	define CFG_STM_ASC_BASE		0xfd032000ul	/* UART2 = AS0 */
+#else
+#	define CFG_STM_ASC_BASE		0xfd033000ul	/* UART3 = AS1 */
+#endif
+
+/*---------------------------------------------------------------
+ * Ethernet driver config
+ */
+
+/*
+ * There are 3 options for ethernet, all use the on-chip ST-GMAC.
+ * The choice in PHYs are:
+ *    The on-board Nat Semi DP83865	(only on Rev A, B)
+ *    The on-board SMSC LAN8700		(only on Rev C)		(NOW the DEFAULT)
+ *    External PHY connected via the MII off-board connector.
+ */
+
+/* are we using the internal ST GMAC device ? */
+#define CONFIG_DRIVER_NET_STM_GMAC
+
+/*
+ * Select the appropriate base address for the GMAC.
+ * Also, choose which PHY to use.
+ */
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+#	define CFG_STM_STMAC_BASE	 0xfd110000ul	/* MAC = STM GMAC0 */
+#if 0							/* Choose NS or SMSC PHY */
+#	define CONFIG_STMAC_DP83865	/* Rev A,B */	/* PHY = NS DP83865 */
+#else
+#	define CONFIG_STMAC_LAN8700	/* Rev C */	/* PHY = SMSC LAN8700 */
+#endif
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+/*  If this board does not have eeprom for ethernet address so allow the user
+ *  to set it in the environment
+ */
+#define CONFIG_ENV_OVERWRITE
+
+
+/*---------------------------------------------------------------
+ * USB driver config
+ */
+
+/* Choose if we want USB Mass-Storage Support */
+#define CONFIG_SH_STB7100_USB
+
+#ifdef CONFIG_SH_STB7100_USB
+#	define CONFIG_CMD_USB
+#	define CONFIG_CMD_FAT
+#	define CONFIG_USB_OHCI_NEW
+#	define CONFIG_USB_STORAGE
+#	define CFG_USB_OHCI_CPU_INIT
+#	define CFG_USB0_BASE			0xfe100000	/* upper */
+#	define CFG_USB1_BASE			0xfea00000	/* lower */
+#	define CFG_USB_BASE			CFG_USB0_BASE
+#	define CONFIG_SH_STX_STX7105_USB_PORT0		/* enable Port #0 */
+#	define CONFIG_SH_STX_STX7105_USB_OC	1	/* use overcurrent */
+#	define CONFIG_SH_STX_STX7105_USB_PW	1	/* use power control */
+#	define CFG_USB_OHCI_REGS_BASE		(CFG_USB_BASE+0xffc00)
+#	define CFG_USB_OHCI_SLOT_NAME		"ohci"
+#	define CFG_USB_OHCI_MAX_ROOT_PORTS	1
+#	define LITTLEENDIAN
+#endif	/* ifdef CONFIG_SH_STB7100_USB */
+
+/*---------------------------------------------------------------
+ * SATA driver config
+ */
+
+/* SATA works on cut 3.x of the STx7105 (just one port) */
+/* Choose if we want to use a SATA HDD */
+//#define CONFIG_SH_STM_SATA
+
+#ifdef CONFIG_SH_STM_SATA
+#	define CONFIG_CMD_IDE				/* enable "ide" command set */
+#	define CFG_ATA_BASE_ADDR	0xfe209000	/* E-SATA panel connector */
+#	define CFG_ATA_IDE0_OFFSET	0x800		/* Host Controller */
+#	define CFG_ATA_REG_OFFSET	0x0
+#	define CFG_ATA_DATA_OFFSET	0x0
+#	define CFG_ATA_STRIDE		0x4
+#	define CFG_IDE_MAXBUS		1
+#	define CFG_IDE_MAXDEVICE	1
+#endif	/* CONFIG_SH_STM_SATA */
+
+#if defined(CONFIG_SH_STM_SATA) ||	\
+    defined(CONFIG_SH_STB7100_USB)
+#	define CFG_64BIT_LBA
+#	define CONFIG_LBA48
+#	define CONFIG_DOS_PARTITION
+#	define CONFIG_CMD_EXT2
+#endif
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+
+#define CFG_HUSH_PARSER		1
+#define CONFIG_AUTO_COMPLETE	1
+#define CFG_LONGHELP		1		/* undef to save memory		*/
+#define CFG_PROMPT		"MB680> "	/* Monitor Command Prompt	*/
+#define CFG_PROMPT_HUSH_PS2	"> "
+#define CFG_CBSIZE		1024
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
+#define CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_HZ			1000		/* HZ for timer ticks	*/
+#define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
+#define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
+#define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
+#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+#define CONFIG_CMDLINE_EDITING
+
+/*-----------------------------------------------------------------------
+ * FLASH organization
+ */
+
+/* Choose if we want FLASH Support (NAND &/or NOR devices)
+ * With the MB680 + MB705 combination, we may use *both*
+ * NOR and NAND flash, at the same time, if we want.
+ *
+ * Note: by default CONFIG_CMD_FLASH is defined in config_cmd_default.h
+ */
+#undef CONFIG_CMD_FLASH		/* undefine it, define only if needed */
+#define CONFIG_CMD_FLASH	/* define for NOR flash */
+#define CONFIG_CMD_NAND		/* define for NAND flash */
+
+/*-----------------------------------------------------------------------
+ * NOR FLASH organization
+ */
+
+/* M58LT256: 32MiB 259 blocks, 128 KiB block size */
+#ifdef CONFIG_CMD_FLASH				/* NOR flash present ? */
+#	define CFG_FLASH_CFI_DRIVER
+#	define CFG_FLASH_CFI
+#	define CONFIG_FLASH_PROTECT_SINGLE_CELL
+#	define CFG_FLASH_PROTECTION	1	/* use hardware flash protection	*/
+#	define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks		*/
+#	define CFG_MAX_FLASH_SECT	259	/* max number of sectors on one chip	*/
+#	define CFG_FLASH_EMPTY_INFO		/* test if each sector is empty		*/
+#	define MTDPARTS_NOR						\
+	"physmap-flash:"	/* First NOR flash device */		\
+		"256k(U-Boot)"		/* first partition */		\
+		",128k(Environment)"					\
+		",4M(Kernel)"						\
+		",-(RestOfNor0)"	/* last partition */
+#	define MTDIDS_NOR						\
+	"nor0=physmap-flash"	/* First NOR flash device */
+#else
+#	undef CONFIG_CMD_IMLS			/* NOR-flash specific */
+#	define CFG_NO_FLASH			/* NOR-flash specific */
+#endif	/* CONFIG_CMD_FLASH */
+
+/*-----------------------------------------------------------------------
+ * NAND FLASH organization
+ */
+
+/* NAND512W3A: 64MiB  8-bit, 4096 Blocks (16KiB+512B) of 32 Pages (512+16) */
+#ifdef CONFIG_CMD_NAND				/* NAND flash present ? */
+#	define CFG_MAX_NAND_DEVICE	1
+#	define NAND_MAX_CHIPS		CFG_MAX_NAND_DEVICE
+#	define CFG_NAND0_BASE		CFG_EMI_NAND_BASE
+#	define CFG_NAND_BASE_LIST	{ CFG_NAND0_BASE }
+#	define MTDPARTS_NAND						\
+	"gen_nand.1:"		/* First NAND flash device */		\
+		"128k(env-nand0)"	/* first partition */		\
+		",4M(kernel-nand0)"					\
+		",32M(root-nand0)"					\
+		",-(RestOfNand0)"	/* last partition */
+#	define MTDIDS_NAND						\
+	"nand0=gen_nand.1"	/* First NAND flash device */
+
+	/*
+	 * Currently, there are 2 main modes to read/write from/to
+	 * NAND devices on STM SoCs:
+	 *	a) "bit-banging" (can NOT be used in boot-from-NAND)
+	 *	b) FLEX-mode (only supported means for boot-from-NAND)
+	 * If CFG_NAND_FLEX_MODE is defined, then FLEX-mode will be
+	 * used, otherwise, "bit-banging" will be used.
+	 */
+#	define CFG_NAND_FLEX_MODE	/* define to use NAND FLEX-MODE */
+
+	/*
+	 * Do we want to read/write NAND Flash compatible with the ST40's
+	 * NAND Controller H/W IP block for "boot-mode"? If we want
+	 * to read/write NAND flash that is meant to support booting
+	 * from NAND, then we need to use 3 bytes of ECC per 128 byte
+	 * record.  If so, then define the "CFG_NAND_ECC_HW3_128" macro.
+	 */
+#	define CFG_NAND_ECC_HW3_128	/* define for "boot-from-NAND" compatibility */
+
+	/*
+	 * If using CFG_NAND_ECC_HW3_128, then we must also define
+	 * where the (high watermark) boundary is. That is, the
+	 * NAND offset, below which we are in "boot-mode", and
+	 * must use 3 bytes of ECC for each 128 byte record.
+	 * For this offset (and above) we can use any supported
+	 * ECC configuration (e.g 3/256 S/W, or 3/512 H/W).
+	 */
+#	define CFG_NAND_STM_BOOT_MODE_BOUNDARY (1ul << 20)	/* 1 MiB */
+
+	/*
+	 * If we want to store the U-boot environment variables in
+	 * the NAND device, then we also need to specify *where* the
+	 * environment variables will be stored. Typically this
+	 * would be immediately after the U-boot monitor itself.
+	 * However, that *may* be a bad block. Define the following
+	 * to place the environment in an appropriate good block.
+	 */
+#	define CFG_NAND_ENV_OFFSET (CFG_MONITOR_LEN + 0x0)	/* immediately after u-boot.bin */
+#endif	/* CONFIG_CMD_NAND */
+
+#if 1 && defined(CFG_BOOT_FROM_NAND)		/* we are booting from NAND */
+	/*
+	 * If we want to store "u-boot.bin" in NAND flash starting at
+	 * physical block #0, but there are Bad Blocks in the first
+	 * few blocks that we need to "skip" over, then we need
+	 * to define CFG_NAND_SKIP_BAD_BLOCKS_ON_RELOCATING to allow
+	 * skipping of these bad blocks for u-boot to relocate itself.
+	 * In addition, we also need to tell U-boot the block size,
+	 * and provide it a local abridged copy of the master Bad Block
+	 * Table (BBT), which must also be stored in physical block #0
+	 * - see "cpu/sh/start.S" for details.
+	 * Also, CFG_NAND_SKIP_BLOCK_COUNT defines the number of blocks
+	 * stored in the abridged copy of the master BBT.
+	 */
+#	define CFG_NAND_SKIP_BAD_BLOCKS_ON_RELOCATING	/* define for skipping */
+#	define CFG_NAND_SKIP_BLOCK_SIZE		(16<<10)/* Block Size = 16 KiB */
+#	define CFG_NAND_SKIP_BLOCK_COUNT	16	/* entries in the array */
+#endif /* CFG_BOOT_FROM_NAND */
+
+/*-----------------------------------------------------------------------
+ * Address, size, & location of U-boot's Environment Sector
+ */
+
+#define CFG_ENV_SIZE			0x4000	/* 16 KiB of environment data */
+
+#ifdef CONFIG_CMD_FLASH				/* NOR flash present ? */
+#	define CFG_ENV_IS_IN_FLASH		/* environment in NOR flash */
+#	define CFG_ENV_OFFSET	CFG_MONITOR_LEN	/* immediately after u-boot.bin */
+#	define CFG_ENV_SECT_SIZE	0x20000	/* 128 KiB Sector size */
+#elif defined(CONFIG_CMD_NAND)			/* NAND flash present ? */
+#	define CFG_ENV_IS_IN_NAND		/* environment in NAND flash */
+#	define CFG_ENV_OFFSET	CFG_NAND_ENV_OFFSET
+#else
+#	define CFG_ENV_IS_NOWHERE		/* ENV is stored in volatile RAM */
+#endif	/* CONFIG_CMD_NAND */
+
+/*----------------------------------------------------------------------
+ * JFFS2 + MTD Partition support
+ */
+
+#if 1 && (defined(CONFIG_CMD_FLASH) || defined(CONFIG_CMD_NAND))
+#	define CONFIG_CMD_JFFS2			/* enable JFFS2 support */
+#endif
+
+#if defined(CONFIG_CMD_JFFS2)
+#	define CONFIG_JFFS2_CMDLINE		/* mtdparts command line support */
+#	define CONFIG_JFFS2_NAND		/* JFFS2 support on NAND Flash */
+#	if defined(CONFIG_CMD_FLASH) && defined(CONFIG_CMD_NAND) /* Both NOR + NAND */
+#		define MTDPARTS_DEFAULT						\
+		"mtdparts="							\
+			MTDPARTS_NOR	/* NOR flash devices */			\
+			";"		/* delimiter */				\
+			MTDPARTS_NAND	/* NAND flash devices */
+#		define MTDIDS_DEFAULT						\
+			MTDIDS_NOR	/* NOR flash devices */			\
+			","		/* delimiter */				\
+			MTDIDS_NAND	/* NAND flash devices */
+#	elif defined(CONFIG_CMD_FLASH)		/* Only NOR flash devices */
+#		define MTDPARTS_DEFAULT	"mtdparts=" MTDPARTS_NOR
+#		define MTDIDS_DEFAULT	MTDIDS_NOR
+#	elif defined(CONFIG_CMD_NAND)		/* Only NAND flash devices */
+#		define MTDPARTS_DEFAULT	"mtdparts=" MTDPARTS_NAND
+#		define MTDIDS_DEFAULT	MTDIDS_NAND
+#	endif	/* defined(CONFIG_CMD_FLASH) && defined(CONFIG_CMD_NAND) */
+#endif	/* CONFIG_CMD_JFFS2 */
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/mb704.h b/include/configs/mb704.h
new file mode 100644
index 0000000000..3bdd8704e3
--- /dev/null
+++ b/include/configs/mb704.h
@@ -0,0 +1,278 @@
+/*
+ * (C) Copyright 2009 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+
+#define CONFIG_SH4	1		/* This is an SH4 CPU		*/
+#define CONFIG_CPU_SUBTYPE_SH4_3XX	/* it is an SH4-300		*/
+
+
+/*-----------------------------------------------------------------------
+ * Are we booting directly from a SPI Serial Flash device ?
+ * If so, then define the "CFG_BOOT_FROM_SPI" macro,
+ * otherwise (e.g. for NOR/NAND Flash booting), do not define it.
+ * As the MB704 board only has SPI flash, then define it.
+ */
+#define CFG_BOOT_FROM_SPI		/* define to build a SPI-bootable image */
+
+
+/*-----------------------------------------------------------------------
+ * Start addresses for the final memory configuration
+ * Assume we run out of uncached memory for the moment
+ */
+
+#ifdef CONFIG_SH_SE_MODE
+#define CFG_SE_PHYSICAL_BASE	0x40000000	/* LMI Physical Address */
+#define CFG_SDRAM_BASE		0x80000000      /* LMI    Cached addr via PMB */
+#define CFG_SE_UNACHED_BASE	0x90000000	/* LMI UN-cached addr via PMB */
+#define CFG_SE_SDRAM_WINDOW	(CFG_SDRAM_SIZE-1)
+#else
+#define CFG_SDRAM_BASE		0x8C000000      /* SDRAM in P1 region */
+#endif
+
+#define CFG_SDRAM_SIZE		0x04000000	/* 64 MiB of LMI SDRAM */
+
+#define CFG_EMI_SPI_BASE	0xA0000000	/* SPI Serial FLASH in SPIBOOT-mode */
+#define CFG_MONITOR_BASE	0		/* Offset in SPI for u-boot.bin */
+#define CFG_MONITOR_LEN		0x00040000	/* Reserve 256 KiB for Monitor */
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1 MiB for malloc */
+#define CFG_BOOTPARAMS_LEN	(128 << 10)	/* 128 KiB */
+#define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
+
+#define CFG_MEMTEST_START	CFG_SDRAM_BASE
+#define CFG_MEMTEST_END		(CFG_SDRAM_BASE + CFG_SDRAM_SIZE - (3 << 20))
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define XSTR(s) STR(s)
+#define STR(s) #s
+
+#define BOARD mb704
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		"board=" XSTR(BOARD) "\0" \
+		"monitor_base=" XSTR(CFG_MONITOR_BASE) "\0" \
+		"monitor_len=" XSTR(CFG_MONITOR_LEN) "\0" \
+		"load_addr=" XSTR(CFG_LOAD_ADDR) "\0" \
+		"update=" \
+		  "eeprom write $load_addr $monitor_base $monitor_len\0"
+
+/*--------------------------------------------------------------
+ * Command line configuration.
+ */
+
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_NFS
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+
+/*--------------------------------------------------------------
+ * Serial console info
+ */
+
+/*
+ * We can use one of two methods for the "serial" console.
+ * We can either use the (normal hardware) internal ST ASC UART;
+ * OR we can use STMicroelectronics' DTF (Data Transfer Format)
+ * mechanism over a JTAG link to a remote GDB debugger.
+ */
+#if 1
+#	define CONFIG_STM_ASC_SERIAL	/* use a ST ASC UART */
+#else
+#	define CONFIG_STM_DTF_SERIAL	/* use DTF over JTAG */
+#endif
+
+#define CFG_STM_ASC2_BASE		0xfd132000ul	/* UART2 = AS0 */
+#define CFG_STM_ASC3_BASE		0xfd133000ul	/* UART3 = AS1 */
+/* choose which ST ASC UART to use */
+#if 1
+	/* Upper 9-pin Female connector */
+#	define CFG_STM_ASC_BASE	CFG_STM_ASC2_BASE	/* UART2 = AS0 */
+#else
+	/* Lower 9-pin Male connector */
+#	define CFG_STM_ASC_BASE	CFG_STM_ASC3_BASE	/* UART3 = AS1 */
+#endif
+
+/*---------------------------------------------------------------
+ * Ethernet driver config
+ */
+
+/*
+ * There are 3 options for ethernet, all use the on-chip ST MAC.
+ * The choice in PHYs are:
+ *    On-board SMSC LAN8700 PHY (on MB762 peripheral board).
+ *    External PHY connected via the MII off-board 15x2 header (MB704).
+ *    External PHY connected via the MII off-board 15x2 header (MB762).
+ */
+
+/* are we using the internal ST MAC device ? */
+#define CONFIG_DRIVER_NETSTMAC
+
+/* Config for on-chip STMAC + LAN8700 PHY */
+#ifdef CONFIG_DRIVER_NETSTMAC
+#	define CFG_STM_STMAC_BASE	0xfde00000ul	/* MAC = STM MAC */
+#	define CONFIG_STMAC_LAN8700			/* PHY = SMSC LAN8700 */
+#else
+#	undef CONFIG_CMD_NET		/* un-define if no networking at all */
+#endif	/* CONFIG_DRIVER_NETSTMAC */
+
+/*  If this board does not have eeprom for ethernet address so allow the user
+ *  to set it in the environment
+ */
+#define CONFIG_ENV_OVERWRITE
+
+/*---------------------------------------------------------------
+ * USB driver config
+ */
+
+/* Choose if we want USB Mass-Storage Support */
+#define CONFIG_SH_STB7100_USB
+
+#ifdef CONFIG_SH_STB7100_USB
+#	define CONFIG_CMD_USB
+#	define CONFIG_CMD_FAT
+#	define CONFIG_USB_OHCI_NEW
+#	define CONFIG_USB_STORAGE
+#	define CFG_USB_OHCI_CPU_INIT
+#	define CFG_USB0_BASE			0xfdd00000	/* front panel */
+#	define CFG_USB_BASE			CFG_USB0_BASE
+#	define CFG_USB_OHCI_REGS_BASE		(CFG_USB_BASE+0xffc00)
+#	define CFG_USB_OHCI_SLOT_NAME		"ohci"
+#	define CFG_USB_OHCI_MAX_ROOT_PORTS	1
+#	define LITTLEENDIAN
+#endif	/* ifdef CONFIG_SH_STB7100_USB */
+
+/*---------------------------------------------------------------
+ * IDE driver config
+ */
+
+#if defined(CONFIG_SH_STB7100_USB)
+#	define CFG_64BIT_LBA
+#	define CONFIG_LBA48
+#	define CONFIG_DOS_PARTITION
+#	define CONFIG_CMD_EXT2
+#endif
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+
+#define CFG_HUSH_PARSER		1
+#define CONFIG_AUTO_COMPLETE	1
+#define CFG_LONGHELP		1		/* undef to save memory		*/
+#define CFG_PROMPT		"MB704> "	/* Monitor Command Prompt	*/
+#define CFG_PROMPT_HUSH_PS2	"> "
+#define CFG_CBSIZE		1024
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
+#define CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_HZ			1000		/* HZ for timer ticks	*/
+#define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
+#define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
+#define CONFIG_BOOTDELAY	10		/* default delay before executing bootcmd */
+#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+#define CONFIG_CMDLINE_EDITING
+
+/*-----------------------------------------------------------------------
+ * FLASH organization
+ */
+
+/* Choose if we want FLASH Support (SPI, NAND &/or NOR devices)
+ *
+ * Note: by default CONFIG_CMD_FLASH & CONFIG_CMD_IMLS are both
+ * defined in config_cmd_default.h.
+ * However if we do not have any NOR flash, then un-define them.
+ */
+#undef CONFIG_CMD_FLASH				/* NOR-flash specific */
+#undef CONFIG_CMD_IMLS				/* NOR-flash specific */
+#define CFG_NO_FLASH				/* NOR-flash specific */
+
+/*-----------------------------------------------------------------------
+ * SPI SERIAL FLASH organization
+ */
+
+/*
+ * 	Board	Manuf	Device		Name	MB704		MB772
+ * 	-----	-----	------		----	-----		-----
+ *	MB704	Atmel	AT45DB321D	IC11	J10 1-2		n/a
+ *	MB762	ST	M25P80		IC27	J10 2-3		J9B 1-2
+ *	MB762	ST	M25P32		IC28	J10 2-3		J9B 2-3
+ *
+ *	NOTE: To use the ST flash on the MB762 peripheral board,
+ *	then the following settings are also required:
+ *
+ *		MB704	J10 2-3
+ *		MB762	J9A 2-3
+ *		MB762	SW1-1 OFF
+ *		MB762	SW1-2 OFF
+ */
+/* choose Atmel or ST SPI Serial Flash */
+#if 1
+#	define CONFIG_SPI_FLASH_ATMEL	/* ATMEL AT45DB321D, on MB704 */
+#else
+#	define CONFIG_SPI_FLASH_ST	/* ST M25Pxx, on MB762 */
+#endif
+
+#define CONFIG_SPI			/* enable the SPI driver */
+#define CONFIG_CMD_SPI			/* SPI serial bus command support */
+#define CONFIG_CMD_EEPROM		/* enable the "eeprom" command set */
+#define CFG_I2C_FRAM			/* to minimize performance degradation */
+#undef  CFG_EEPROM_PAGE_WRITE_DELAY_MS	/* to minimize performance degradation */
+
+/*
+ *	NOTE: To use the Atmel AT45DB321D serial flash for booting,
+ *	then it is required to re-program the page size to 512 bytes.
+ *	(default is 528 bytes per page). This is a once only,
+ *	irreversible programming option, and can not be undone.
+ *	This programming may be done from U-boot (booted via JTAG)
+ *
+ *		U-Boot> sspi 0 32 3D2A80A6	--> FFFFFFFF
+ *		U-Boot> sspi 0 16 D7		--> FFB4
+ *	Then power-cycle the board before using it.
+ */
+
+/*-----------------------------------------------------------------------
+ * Address, size, & location of U-boot's Environment Sector
+ */
+
+#define CFG_ENV_SIZE			0x4000	/* 16 KiB of environment data */
+
+#if 1
+#	define CFG_ENV_IS_IN_EEPROM		/* ENV is stored in SPI Serial Flash */
+#	define CFG_ENV_OFFSET	CFG_MONITOR_LEN	/* immediately after u-boot.bin */
+#else
+#	define CFG_ENV_IS_NOWHERE		/* ENV is stored in volatile RAM */
+#endif
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/pdk7105.h b/include/configs/pdk7105.h
new file mode 100644
index 0000000000..fabb105b45
--- /dev/null
+++ b/include/configs/pdk7105.h
@@ -0,0 +1,496 @@
+/*
+ * (C) Copyright 2008-2009 STMicroelectronics.
+ *
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+#define CONFIG_SH4	1		/* This is an SH4 CPU		*/
+#define CONFIG_CPU_SUBTYPE_SH4_3XX	/* it is an SH4-300		*/
+
+
+/*-----------------------------------------------------------------------
+ *	Jumper settings to select between the SoC's 3 boot-modes:
+ *		a) boot from NOR flash
+ *		b) boot from NAND flash
+ *		c) boot from SPI serial flash
+ *
+ *	With the LED display panel facing the user:
+ *
+ *	Jumper	Location	NOR	NAND	SPI
+ *	------	--------	---	----	---
+ *	JE6	top-most	EAST	EAST	WEST
+ *	JE5	below JE6	EAST	WEST	EAST
+ *	JE3	left-side	NORTH	SOUTH	SOUTH
+ *	JE2	right-side	SOUTH	NORTH	NORTH
+ */
+
+
+/*-----------------------------------------------------------------------
+ * Are we booting directly from a NAND Flash device ?
+ * If so, then define the "CFG_BOOT_FROM_NAND" macro,
+ * otherwise (e.g. NOR/SPI Flash booting), do not define it.
+ */
+#undef CFG_BOOT_FROM_NAND		/* define to build a NAND-bootable image */
+
+
+/*-----------------------------------------------------------------------
+ * Are we booting directly from a SPI Serial Flash device ?
+ * If so, then define the "CFG_BOOT_FROM_SPI" macro,
+ * otherwise (e.g. for NOR/NAND Flash booting), do not define it.
+ */
+#undef CFG_BOOT_FROM_SPI		/* define to build a SPI-bootable image */
+#define  CFG_BOOT_FROM_SPI
+
+
+/*-----------------------------------------------------------------------
+ * Start addresses for the final memory configuration
+ * Assume we run out of uncached memory for the moment
+ */
+#define CFG_NAND_YAFFS_WRITE
+
+#if defined(CFG_BOOT_FROM_SPI)		/* we are booting from SPI, so *DO* swap CSA and CSC with JE2 */
+#define CFG_EMI_SPI_BASE	0xA0000000	/* CSA: SPI Flash,  Physical 0x00000000 (64MiB) */
+#define CFG_EMI_NOR_BASE	0xA4000000	/* CSB: NOR Flash,  Physical 0x04000000 (32MiB) */
+#define CFG_EMI_NAND_BASE	0xA6000000	/* CSC: NAND Flash, Physical 0x06000000 (8MiB) */
+#define CFG_NAND_FLEX_CSn_MAP	{ 0 }		/* NAND is on Chip Select CSA */
+#elif defined(CFG_BOOT_FROM_NAND)	/* we are booting from NAND, so *DO* swap CSA and CSC with JE2 */
+#define CFG_EMI_NAND_BASE	0xA0000000	/* CSA: NAND Flash, Physical 0x00000000 (64MiB) */
+#define CFG_EMI_NOR_BASE	0xA4000000	/* CSB: NOR Flash,  Physical 0x04000000 (32MiB) */
+#define CFG_NAND_FLEX_CSn_MAP	{ 0 }		/* NAND is on Chip Select CSA */
+#else					/* else, do *NOT* swap CSA and CSC using JE2 */
+#define CFG_EMI_NOR_BASE	0xA0000000	/* CSA: NOR Flash,  Physical 0x00000000 (64MiB) */
+#define CFG_EMI_NAND_BASE	0xA6000000	/* CSC: NAND Flash, Physical 0x06000000 (8MiB) */
+#define CFG_NAND_FLEX_CSn_MAP	{ 2 }		/* NAND is on Chip Select CSC */
+#endif /* CFG_BOOT_FROM_NAND */
+
+#ifdef CONFIG_SH_SE_MODE
+#define CFG_FLASH_BASE		CFG_EMI_NOR_BASE/* NOR FLASH (uncached) via PMB */
+#define CFG_SE_PHYSICAL_BASE	0x40000000	/* LMI Physical Address */
+#define CFG_SDRAM_BASE		0x80000000      /* LMI    Cached addr via PMB */
+#define CFG_SE_UNACHED_BASE	0x90000000	/* LMI UN-cached addr via PMB */
+#define CFG_SE_SDRAM_WINDOW	(CFG_SDRAM_SIZE-1)
+#else
+#define CFG_FLASH_BASE		CFG_EMI_NOR_BASE/* NOR FLASH in P2 region */
+#define CFG_SDRAM_BASE		0x8C000000      /* SDRAM in P1 region */
+#endif
+
+#define CFG_SDRAM_SIZE		0x10000000	/* 256 MiB of LMI SDRAM */
+
+#define CFG_MONITOR_LEN		0x00040000	/* Reserve 256 KiB for Monitor */
+#define CFG_MONITOR_BASE        CFG_FLASH_BASE
+#define CFG_MALLOC_LEN		(1 << 20)	/* Reserve 1 MiB for malloc */
+#define CFG_BOOTPARAMS_LEN	(128 << 10)	/* 128 KiB */
+#define CFG_GBL_DATA_SIZE	1024		/* Global data structures */
+
+#define CFG_MEMTEST_START	CFG_SDRAM_BASE
+#define CFG_MEMTEST_END		(CFG_SDRAM_BASE + CFG_SDRAM_SIZE - (3 << 20))
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+#define XSTR(s) STR(s)
+#define STR(s) #s
+
+#define BOARD pdk7105
+
+#if CFG_MONITOR_LEN == 0x00020000		/* 128 KiB */
+#	define MONITOR_SECTORS	"1:0"		/* 1 sector */
+#elif CFG_MONITOR_LEN == 0x00040000		/* 256 KiB */
+#	define MONITOR_SECTORS	"1:0-1"		/* 2 sectors */
+#else						/* unknown */
+#	error "Unable to determine sectors for monitor"
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		"board=" XSTR(BOARD) "\0" \
+		"monitor_base=" XSTR(CFG_MONITOR_BASE) "\0" \
+		"monitor_len=" XSTR(CFG_MONITOR_LEN) "\0" \
+		"monitor_sec=" MONITOR_SECTORS "\0" \
+		"load_addr=" XSTR(CFG_LOAD_ADDR) "\0" \
+		"ipaddr=192.9.150.61\0" \
+		"serverip=192.9.150.67\0" \
+		"bootdelay=0\0" \
+	"update_uboot=" \
+               "usb start;" \
+		  "fatload usb 0 80000000 u-boot.bin;" \
+                 "update_spi_uboot \0" \
+	"unprot=" \
+		"protect off $monitor_sec\0" \
+		"update=" \
+		  "erase $monitor_sec;" \
+		  "cp.b $load_addr $monitor_base $monitor_len;" \
+		  "protect on $monitor_sec\0" \
+		  "ethaddr=12:34:56:78:06:BD\0"\
+		  "bootcmd=nboot 80000000  0  100000;bootm 80000000\0"\
+		  "bootargs= console=ttyAS0,115200 root=/dev/mtdblock1 rootfstype=yaffs2 rw nwhwconf=device:eth0,hwaddr:10:08:E2:12:06:BD phyaddr:0,watchdog:5000 mem=120M bigphysarea=2048\0"
+
+//		  "bootargs= console=ttyAS0,115200 root=/dev/mtdblock1 rootfstype=jffs2 rw nwhwconf=device:eth0,hwaddr:10:08:E2:12:06:BD phyaddr:0,watchdog:5000 ip=192.168.111.111::192.168.10.1:255.255.255.0:7105_1::off mem=120M bigphysarea=2048\0"
+/*--------------------------------------------------------------
+ * Command line configuration.
+ */
+
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_NFS
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+
+/*--------------------------------------------------------------
+ * Serial console info
+ */
+
+/*
+ * We can use one of two methods for the "serial" console.
+ * We can either use the (normal hardware) internal ST ASC UART;
+ * OR we can use STMicroelectronics' DTF (Data Transfer Format)
+ * mechanism over a JTAG link to a remote GDB debugger.
+ */
+#if 1
+#	define CONFIG_STM_ASC_SERIAL	/* use a ST ASC UART */
+#else
+#	define CONFIG_STM_DTF_SERIAL	/* use DTF over JTAG */
+#endif
+
+/* choose which ST ASC UART to use */
+#if 1
+	/* 9-pin D-type connector on STi7105-SDK-SB daughter board */
+#	define CFG_STM_ASC_BASE		ST40_ASC2_REGS_BASE	/* UART #2 */
+#else
+	/* JN5, 6-way connector - QQQ NOT TESTED */
+#	define CFG_STM_ASC_BASE		ST40_ASC3_REGS_BASE	/* UART #3 */
+#endif
+
+/*---------------------------------------------------------------
+ * Ethernet driver config
+ */
+
+/*
+ * There are 2 options for ethernet, both use the on-chip ST-GMAC.
+ * The choice in PHYs are:
+ *    The on-board Micrel KSZ8041FTL
+ *    External PHY connected via the MII off-board 15x2 header.
+ */
+
+/* are we using the internal ST GMAC device ? */
+#define CONFIG_DRIVER_NET_STM_GMAC
+
+/*
+ * Select the appropriate base address for the GMAC.
+ * Also, choose which PHY to use.
+ */
+#ifdef CONFIG_DRIVER_NET_STM_GMAC
+#	define CFG_STM_STMAC_BASE	0xfd110000ul	/* MAC = STM GMAC0 */
+//#	define CONFIG_STMAC_KSZ8041FTL			/* PHY = Micrel KSZ8041FTL */
+#	define CONFIG_CMD_MII
+#	define CONFIG_ETHADDR		DE:EA:FF:FF:01:01
+#	define CONFIG_STMAC_STE10XP
+
+#else
+#	undef CONFIG_CMD_NET		/* undefine if no networking at all */
+#endif	/* CONFIG_DRIVER_NET_STM_GMAC */
+
+/*  If this board does not have eeprom for ethernet address so allow the user
+ *  to set it in the environment
+ */
+#define CONFIG_ENV_OVERWRITE
+
+
+/*---------------------------------------------------------------
+ * USB driver config
+ */
+
+/* Choose if we want USB Mass-Storage Support */
+#define CONFIG_SH_STB7100_USB
+
+#ifdef CONFIG_SH_STB7100_USB
+#	define CONFIG_CMD_USB
+#	define CONFIG_CMD_FAT
+#	define CONFIG_USB_OHCI_NEW
+#	define CONFIG_USB_STORAGE
+#	define CFG_USB_OHCI_CPU_INIT
+#	define CFG_USB0_BASE			0xfe100000	/* rear (adjacent to RJ-45) */
+#	define CFG_USB1_BASE			0xfea00000	/* front (near corner) */
+#	define CFG_USB_BASE			CFG_USB0_BASE
+//#	define CFG_USB_BASE			CFG_USB1_BASE
+#	define CONFIG_SH_STX_STX7105_USB_PORT0		/* enable Port #0 */
+//#	define CONFIG_SH_STX_STX7105_USB_PORT1		/* enable Port #1 */
+#	define CONFIG_SH_STX_STX7105_USB_OC	1	/* use overcurrent */
+#	define CONFIG_SH_STX_STX7105_USB_PW	1	/* use power control */
+#	define CFG_USB_OHCI_REGS_BASE		(CFG_USB_BASE+0xffc00)
+
+/* JGONG 0427 MASK
+#	define USB_EXT_REGS		(CFG_USB0_BASE+0xffc00)
+#	define USB_INT_REGS		(CFG_USB1_BASE+0xffc00)
+*/
+
+#	define USB_EXT_REGS		(CFG_USB1_BASE+0xffc00)
+#	define USB_INT_REGS		(CFG_USB0_BASE+0xffc00)
+
+
+#	define CFG_USB_OHCI_SLOT_NAME		"ohci"
+#	define CFG_USB_OHCI_MAX_ROOT_PORTS	1
+#	define LITTLEENDIAN
+#endif	/* ifdef CONFIG_SH_STB7100_USB */
+
+/*---------------------------------------------------------------
+ * SATA driver config
+ */
+
+/* SATA works on cut 3.x of the STx7105 (just one port) */
+/* Choose if we want to use a SATA HDD */
+//#define CONFIG_SH_STM_SATA
+
+#ifdef CONFIG_SH_STM_SATA
+#	define CONFIG_CMD_IDE				/* enable "ide" command set */
+#	define CFG_ATA_BASE_ADDR	0xfe209000	/* E-SATA connector */
+#	define CFG_ATA_IDE0_OFFSET	0x800		/* Host Controller */
+#	define CFG_ATA_REG_OFFSET	0x0
+#	define CFG_ATA_DATA_OFFSET	0x0
+#	define CFG_ATA_STRIDE		0x4
+#	define CFG_IDE_MAXBUS		1
+#	define CFG_IDE_MAXDEVICE	1
+#endif	/* CONFIG_SH_STM_SATA */
+
+#if defined(CONFIG_SH_STM_SATA) ||	\
+    defined(CONFIG_SH_STB7100_USB)
+#	define CFG_64BIT_LBA
+#	define CONFIG_LBA48
+#	define CONFIG_DOS_PARTITION
+#	define CONFIG_CMD_EXT2
+#endif
+
+/*-----------------------------------------------------------------------
+ * Miscellaneous configurable options
+ */
+
+#define CFG_HUSH_PARSER		1
+#define CONFIG_AUTO_COMPLETE	1
+#define CFG_LONGHELP		1		/* undef to save memory		*/
+#define CFG_PROMPT		"PDK7105> "	/* Monitor Command Prompt	*/
+#define CFG_PROMPT_HUSH_PS2	"> "
+#define CFG_CBSIZE		1024
+#define CFG_PBSIZE (CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print Buffer Size	*/
+#define CFG_MAXARGS		16		/* max number of command args	*/
+#define CFG_HZ			1000		/* HZ for timer ticks	*/
+#define CFG_LOAD_ADDR		CFG_SDRAM_BASE	/* default load address		*/
+#define CFG_BOOTMAPSZ		(16 << 20)	/* initial linux memory size	*/
+#define CONFIG_BOOTDELAY	0		/* default delay before executing bootcmd */
+#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+#define CONFIG_CMDLINE_EDITING
+
+/*-----------------------------------------------------------------------
+ * FLASH organization
+ */
+
+/* Choose if we want FLASH Support (SPI, NAND &/or NOR devices)
+ * With the PDK7105 combination, we may use *both*
+ * NOR and NAND flash, at the same time, if we want.
+ *
+ * Note: by default CONFIG_CMD_FLASH is defined in config_cmd_default.h
+ */
+#undef CONFIG_CMD_FLASH		/* undefine it, define only if needed */
+//#define CONFIG_CMD_FLASH	/* define for NOR flash */
+#define CONFIG_CMD_NAND		/* define for NAND flash */
+#define CONFIG_SPI_FLASH	/* define for SPI serial flash */
+
+/*-----------------------------------------------------------------------
+ * NOR FLASH organization
+ */
+
+/* S29GL01GP: 128MiB, 1024 blocks * 128KiB block size */
+#ifdef CONFIG_CMD_FLASH				/* NOR flash present ? */
+#	define CFG_FLASH_CFI_DRIVER
+#	define CFG_FLASH_CFI
+#	define CONFIG_FLASH_PROTECT_SINGLE_CELL
+#	define CFG_FLASH_PROTECTION	1	/* use hardware flash protection	*/
+#	define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks		*/
+#	define CFG_MAX_FLASH_SECT	1024	/* max number of sectors on one chip	*/
+#	define CFG_FLASH_EMPTY_INFO		/* test if each sector is empty		*/
+#	define MTDPARTS_NOR						\
+	"physmap-flash:"	/* First NOR flash device */		\
+		"256k(U-Boot)"		/* first partition */		\
+		",128k(Environment)"					\
+		",4M(Kernel)"						\
+		",-(RestOfNor0)"	/* last partition */
+#	define MTDIDS_NOR						\
+	"nor0=physmap-flash"	/* First NOR flash device */
+#else
+#	undef CONFIG_CMD_IMLS			/* NOR-flash specific */
+#	define CFG_NO_FLASH			/* NOR-flash specific */
+#endif	/* CONFIG_CMD_FLASH */
+
+/*-----------------------------------------------------------------------
+ * NAND FLASH organization
+ */
+
+/* HY27UH08AG5B : 2GiB  8-bit, 16384 Blocks (128KiB+4KiB) of 64 Pages (2048+64) */
+#ifdef CONFIG_CMD_NAND				/* NAND flash present ? */
+#	define CFG_MAX_NAND_DEVICE	1
+#	define NAND_MAX_CHIPS		CFG_MAX_NAND_DEVICE
+#	define CFG_NAND0_BASE		CFG_EMI_NAND_BASE
+#	define CFG_NAND_BASE_LIST	{ CFG_NAND0_BASE }
+#	define MTDPARTS_NAND						\
+	"gen_nand.1:"		/* First NAND flash device */		\
+		"128k(env-nand0)"	/* first partition */		\
+		",4M(kernel-nand0)"					\
+		",32M(root-nand0)"					\
+		",-(RestOfNand0)"	/* last partition */
+#	define MTDIDS_NAND						\
+	"nand0=gen_nand.1"	/* First NAND flash device */
+
+	/*
+	 * Currently, there are 2 main modes to read/write from/to
+	 * NAND devices on STM SoCs:
+	 *	a) "bit-banging" (can NOT be used in boot-from-NAND)
+	 *	b) FLEX-mode (only supported means for boot-from-NAND)
+	 * If CFG_NAND_FLEX_MODE is defined, then FLEX-mode will be
+	 * used, otherwise, "bit-banging" will be used.
+	 */
+#	define CFG_NAND_FLEX_MODE	/* define to use NAND FLEX-MODE */
+
+	/*
+	 * Do we want to read/write NAND Flash compatible with the ST40's
+	 * NAND Controller H/W IP block for "boot-mode"? If we want
+	 * to read/write NAND flash that is meant to support booting
+	 * from NAND, then we need to use 3 bytes of ECC per 128 byte
+	 * record.  If so, then define the "CFG_NAND_ECC_HW3_128" macro.
+	 */
+#	define CFG_NAND_ECC_HW3_128	/* define for "boot-from-NAND" compatibility */
+
+	/*
+	 * If using CFG_NAND_ECC_HW3_128, then we must also define
+	 * where the (high watermark) boundary is. That is, the
+	 * NAND offset, below which we are in "boot-mode", and
+	 * must use 3 bytes of ECC for each 128 byte record.
+	 * For this offset (and above) we can use any supported
+	 * ECC configuration (e.g 3/256 S/W, or 3/512 H/W).
+	 */
+#	define CFG_NAND_STM_BOOT_MODE_BOUNDARY (1ul << 20)	/* 1 MiB */
+
+	/*
+	 * If we want to store the U-boot environment variables in
+	 * the NAND device, then we also need to specify *where* the
+	 * environment variables will be stored. Typically this
+	 * would be immediately after the U-boot monitor itself.
+	 * However, that *may* be a bad block. Define the following
+	 * to place the environment in an appropriate good block.
+	 */
+#	define CFG_NAND_ENV_OFFSET (CFG_MONITOR_LEN + 0x0)	/* immediately after u-boot.bin */
+#endif	/* CONFIG_CMD_NAND */
+
+/*-----------------------------------------------------------------------
+ * SPI SERIAL FLASH organization
+ */
+
+/*
+ *	Name	Manuf	Device
+ *	-----	-----	------
+ *	US3	ST	M25P64
+ */
+#if defined(CONFIG_SPI_FLASH)			/* SPI serial flash present ? */
+#	define CONFIG_SPI_FLASH_ST		/* ST M25Pxx (US3) */
+#	define CONFIG_SPI			/* enable the SPI driver */
+#	define CONFIG_CMD_SPI			/* SPI serial bus command support */
+#	define CONFIG_CMD_EEPROM		/* enable the "eeprom" command set */
+#	define CFG_I2C_FRAM			/* to minimize performance degradation */
+#	undef  CFG_EEPROM_PAGE_WRITE_DELAY_MS	/* to minimize performance degradation */
+#	define CONFIG_SOFT_SPI			/* Use "bit-banging" PIO (not the SSC) */
+#endif	/* CONFIG_SPI_FLASH */
+
+#if defined(CONFIG_SOFT_SPI)			/* Use "bit-banging" for SPI */
+#	define SPI_SCL(val)	do { stx7105_spi_scl((val)); } while (0)
+#	define SPI_SDA(val)	do { stx7105_spi_sda((val)); } while (0)
+#	define SPI_DELAY	do { udelay(1); } while (0)	/* QQQ: only 500 kHz ??? */
+#	define SPI_READ		stx7105_spi_read()
+#endif	/* CONFIG_SOFT_SPI */
+
+
+/*-----------------------------------------------------------------------
+ * Address, size, & location of U-boot's Environment Sector
+ */
+
+#define CFG_ENV_SIZE			0x10000	/* 64 KiB of environment data */
+
+#if 1 && defined(CONFIG_CMD_FLASH)		/* NOR flash present ? */
+#	define CFG_ENV_IS_IN_FLASH		/* environment in NOR flash */
+#	define CFG_ENV_OFFSET	CFG_MONITOR_LEN	/* immediately after u-boot.bin */
+#	define CFG_ENV_SECT_SIZE	0x20000	/* 128 KiB Sector size */
+#elif 0 && defined(CONFIG_CMD_NAND)		/* NAND flash present ? */
+#	define CFG_ENV_IS_IN_NAND		/* environment in NAND flash */
+#	define CFG_ENV_OFFSET	CFG_NAND_ENV_OFFSET
+#	if CFG_ENV_SIZE < 0x20000		/* needs to be a multiple of block-size */
+#		undef CFG_ENV_SIZE		/* give it just one large-page block */
+#		define CFG_ENV_SIZE	0x20000	/* 128 KiB of environment data */
+#	endif /* if CFG_ENV_SIZE < 0x20000 */
+#elif 1 && defined(CONFIG_SPI_FLASH)		/* SPI serial flash present ? */
+#	define CFG_ENV_IS_IN_EEPROM		/* ENV is stored in SPI Serial Flash */
+#	define CFG_ENV_OFFSET	0x80000		//CFG_MONITOR_LEN	/* immediately after u-boot.bin */
+#else
+#	define CFG_ENV_IS_NOWHERE		/* ENV is stored in volatile RAM */
+#endif	/* CONFIG_CMD_NAND */
+
+/*----------------------------------------------------------------------
+ * JFFS2 + MTD Partition support
+ */
+
+#if 1 && (defined(CONFIG_CMD_FLASH) || defined(CONFIG_CMD_NAND))
+#	define CONFIG_CMD_JFFS2			/* enable JFFS2 support */
+
+#	define CONFIG_JFFS2_DEV		"nand0"
+#	define CONFIG_JFFS2_PART_SIZE	0x6400000
+#	define CONFIG_JFFS2_PART_OFFSET	0x9b00000
+#	define CONFIG_JFFS2_LZO_LZARI
+#endif
+
+#if defined(CONFIG_CMD_JFFS2)
+//#	define CONFIG_JFFS2_CMDLINE		/* mtdparts command line support */
+#	undef CONFIG_JFFS2_CMDLINE		/* no mtdparts command line support */
+#	define CONFIG_JFFS2_NAND	 1	/* JFFS2 support on NAND Flash */
+#	if defined(CONFIG_CMD_FLASH) && defined(CONFIG_CMD_NAND) /* Both NOR + NAND */
+#		define MTDPARTS_DEFAULT						\
+		"mtdparts="							\
+			MTDPARTS_NOR	/* NOR flash devices */			\
+			";"		/* delimiter */				\
+			MTDPARTS_NAND	/* NAND flash devices */
+#		define MTDIDS_DEFAULT						\
+			MTDIDS_NOR	/* NOR flash devices */			\
+			","		/* delimiter */				\
+			MTDIDS_NAND	/* NAND flash devices */
+#	elif defined(CONFIG_CMD_FLASH)		/* Only NOR flash devices */
+#		define MTDPARTS_DEFAULT	"mtdparts=" MTDPARTS_NOR
+#		define MTDIDS_DEFAULT	MTDIDS_NOR
+#	elif defined(CONFIG_CMD_NAND)		/* Only NAND flash devices */
+#		define MTDPARTS_DEFAULT	"mtdparts=" MTDPARTS_NAND
+#		define MTDIDS_DEFAULT	MTDIDS_NAND
+#	endif	/* defined(CONFIG_CMD_FLASH) && defined(CONFIG_CMD_NAND) */
+#endif	/* CONFIG_CMD_JFFS2 */
+
+#endif	/* __CONFIG_H */
diff --git a/include/linux/mtd/mtd-abi.h b/include/linux/mtd/mtd-abi.h
index 3d1d416810..4ba5cd274d 100644
--- a/include/linux/mtd/mtd-abi.h
+++ b/include/linux/mtd/mtd-abi.h
@@ -89,11 +89,13 @@ struct region_info_user {
 #define MEMGETBADBLOCK		_IOW('M', 11, loff_t)
 #define MEMSETBADBLOCK		_IOW('M', 12, loff_t)
 
+#define MTD_NANDECC_MAX_OOBFREE	16	/* 16 for STMicroelectronics STi7xxx */
+#define MTD_NANDECC_MAX_ECCPOS	48	/* 48 for STMicroelectronics STi7xxx */
 struct nand_oobinfo {
 	uint32_t useecc;
 	uint32_t eccbytes;
-	uint32_t oobfree[8][2];
-	uint32_t eccpos[32];
+	uint32_t oobfree[MTD_NANDECC_MAX_OOBFREE][2];
+	uint32_t eccpos[MTD_NANDECC_MAX_ECCPOS];
 };
 
 #endif /* __MTD_ABI_H__ */
diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index 49ff80fd3a..95f2bd10f7 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -64,12 +64,20 @@ extern void nand_release (struct mtd_info *mtd);
 /* Read raw data from the device without ECC */
 extern int nand_read_raw (struct mtd_info *mtd, uint8_t *buf, loff_t from, size_t len, size_t ooblen);
 
+/* read/write with ECC functions */
+extern int nand_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
+			  size_t * retlen, u_char * buf, u_char * eccbuf, struct nand_oobinfo *oobsel);
+extern int nand_read_oob (struct mtd_info *mtd, loff_t from, size_t len, size_t * retlen, u_char * buf);
+extern int nand_write_ecc (struct mtd_info *mtd, loff_t to, size_t len,
+			   size_t * retlen, const u_char * buf, u_char * eccbuf, struct nand_oobinfo *oobsel);
+extern int nand_write_oob (struct mtd_info *mtd, loff_t to, size_t len, size_t * retlen, const u_char *buf);
 
 /* This constant declares the max. oobsize / page, which
  * is supported now. If you add a chip with bigger oobsize/page
  * adjust this accordingly.
  */
 #define NAND_MAX_OOBSIZE	64
+#define NAND_MAX_PAGESIZE	2048
 
 /*
  * Constants for hardware specific CLE/ALE/NCE function
@@ -135,6 +143,8 @@ extern int nand_read_raw (struct mtd_info *mtd, uint8_t *buf, loff_t from, size_
 #define NAND_ECC_HW8_512	6
 /* Hardware ECC 12 byte ECC per 2048 Byte data */
 #define NAND_ECC_HW12_2048	7
+/* Hardware ECC 3 byte ECC per 128 Byte data */
+#define NAND_ECC_HW3_128	8
 
 /*
  * Constants for Hardware ECC
diff --git a/include/linux/stat.h b/include/linux/stat.h
index 37f2924df1..397512d434 100644
--- a/include/linux/stat.h
+++ b/include/linux/stat.h
@@ -68,7 +68,7 @@ struct stat {
 #endif	/* __PPC__ */
 
 #if defined (__ARM__) || defined (__I386__) || defined (__M68K__) || defined (__bfin__) ||\
-	defined (__microblaze__)
+	defined (__microblaze__) || defined (__SH4__)
 
 struct stat {
 	unsigned short st_dev;
diff --git a/include/part.h b/include/part.h
index 37b2b6845b..a84ea4de78 100644
--- a/include/part.h
+++ b/include/part.h
@@ -42,12 +42,12 @@ typedef struct block_dev_desc {
 	char		product[20+1];	/* IDE Serial no, SCSI product */
 	char		revision[8+1];	/* firmware revision */
 	unsigned long	(*block_read)(int dev,
-				      unsigned long start,
-				      lbaint_t blkcnt,
+				      lbaint_t start,
+				      unsigned long blkcnt,
 				      void *buffer);
 	unsigned long	(*block_write)(int dev,
-				       unsigned long start,
-				       lbaint_t blkcnt,
+				       lbaint_t start,
+				       unsigned long blkcnt,
 				       const void *buffer);
 }block_dev_desc_t;
 
diff --git a/include/sh-sci.h b/include/sh-sci.h
new file mode 100644
index 0000000000..ace813b36b
--- /dev/null
+++ b/include/sh-sci.h
@@ -0,0 +1,363 @@
+/*
+ *  include/sh-sci.h
+ *
+ *  SuperH on-chip serial module support.  (SCI with no FIFO / with FIFO)
+ *  Copyright (C) 1999, 2000  Niibe Yutaka
+ *  Copyright (C) 2000  Greg Banks
+ *  Modified to support multiple serial ports. Stuart Menefy (May 2000).
+ *  Modified to support SH7300(SH-Mobile) SCIF. Takashi Kusuda (Jun 2003).
+ *  Modified for u-boot A.Sturges (Nov 2004)
+ *
+ */
+
+#include "common.h"
+#include <asm/clk.h>
+
+#include <linux/config.h>
+
+/* Values for sci_port->type */
+#define PORT_SCI  0
+#define PORT_SCIF 1
+#define PORT_IRDA 1		/* XXX: temporary assignment */
+
+/* Offsets into the sci_port->irqs array */
+#define SCIx_ERI_IRQ 0
+#define SCIx_RXI_IRQ 1
+#define SCIx_TXI_IRQ 2
+
+/*                     ERI, RXI, TXI, BRI */
+#define SCI_IRQS      { 23,  24,  25,   0 }
+#define SH3_SCIF_IRQS { 56,  57,  59,  58 }
+#define SH3_IRDA_IRQS { 52,  53,  55,  54 }
+#define SH4_SCIF_IRQS { 40,  41,  43,  42 }
+#define STB1_SCIF1_IRQS {23, 24,  26,  25 }
+#define SH7300_SCIF0_IRQS {80,  80,  80,  80 }
+
+#if defined(CONFIG_CPU_SUBTYPE_SH7708)
+# define SCI_NPORTS 1
+# define SCI_INIT { \
+  { {}, PORT_SCI,  0xfffffe80, SCI_IRQS,      sci_init_pins_sci  } \
+}
+# define SCSPTR 0xffffff7c	/* 8 bit */
+# define SCSCR_INIT(port)          0x30	/* TIE=0,RIE=0,TE=1,RE=1 */
+# define SCI_ONLY
+#elif defined(CONFIG_CPU_SUBTYPE_SH7300)
+# define SCI_NPORTS 1
+# define SCI_INIT { \
+  { {}, PORT_SCIF,  0xA4430000, SH7300_SCIF0_IRQS, sci_init_pins_scif }, \
+}
+# define SCPCR  0xA4050116	/* 16 bit SCIF */
+# define SCPDR  0xA4050136	/* 16 bit SCIF */
+# define SCSCR_INIT(port)  0x0030	/* TIE=0,RIE=0,TE=1,RE=1 */
+# define SCIF_ONLY
+
+#elif defined(CONFIG_CPU_SUBTYPE_SH7707) || defined(CONFIG_CPU_SUBTYPE_SH7709)
+# define SCI_NPORTS 3
+# define SCI_INIT { \
+  { {}, PORT_SCI,  0xfffffe80, SCI_IRQS,      sci_init_pins_sci  }, \
+  { {}, PORT_SCIF, 0xA4000150, SH3_SCIF_IRQS, sci_init_pins_scif }, \
+  { {}, PORT_SCIF, 0xA4000140, SH3_IRDA_IRQS, sci_init_pins_irda }  \
+}
+# define SCPCR  0xA4000116	/* 16 bit SCI and SCIF */
+# define SCPDR  0xA4000136	/* 8  bit SCI and SCIF */
+# define SCSCR_INIT(port)          0x30	/* TIE=0,RIE=0,TE=1,RE=1 */
+# define SCI_AND_SCIF
+#elif defined(CONFIG_CPU_SUBTYPE_SH7750) || defined(CONFIG_CPU_SUBTYPE_SH7751)
+# define SCI_NPORTS 2
+# define SCI_INIT { \
+  { {}, PORT_SCI,  0xffe00000, SCI_IRQS,      sci_init_pins_sci  }, \
+  { {}, PORT_SCIF, 0xFFE80000, SH4_SCIF_IRQS, sci_init_pins_scif }  \
+}
+# define SCSPTR1 0xffe0001c	/* 8  bit SCI */
+# define SCSPTR2 0xFFE80020	/* 16 bit SCIF */
+# define SCIF_ORER 0x0001	/* overrun error bit */
+# define SCSCR_INIT(port) (((port)->type == PORT_SCI) ? \
+	0x30 /* TIE=0,RIE=0,TE=1,RE=1 */ : \
+	0x38 /* TIE=0,RIE=0,TE=1,RE=1,REIE=1 */ )
+# define SCI_AND_SCIF
+#elif defined(CONFIG_CPU_SUBTYPE_SH4_2XX)
+# define SCI_NPORTS 1
+# define SCI_INIT { \
+  { {}, PORT_SCIF, 0xFFE80000, SH4_SCIF_IRQS, sci_init_pins_scif }  \
+}
+# define SCSPTR2 0xFFE80020	/* 16 bit SCIF */
+# define SCIF_ORER 0x0001	/* overrun error bit */
+# define SCSCR_INIT(port) 0x38	/* TIE=0,RIE=0,TE=1,RE=1,REIE=1 */
+# define SCIF_ONLY
+#elif defined(CONFIG_CPU_SUBTYPE_SH4_1XX)
+# define SCI_NPORTS 2
+# define SCI_INIT { \
+  { {}, PORT_SCIF, 0xffe00000, STB1_SCIF1_IRQS, sci_init_pins_scif }, \
+  { {}, PORT_SCIF, 0xffe80000, SH4_SCIF_IRQS,   sci_init_pins_scif }  \
+}
+# define SCSPTR1 0xffe00020	/* 16 bit SCIF */
+# define SCSPTR2 0xffe80020	/* 16 bit SCIF */
+# define SCIF_ORER 0x0001	/* overrun error bit */
+# define SCSCR_INIT(port)          0x38	/* TIE=0,RIE=0,TE=1,RE=1,REIE=1 */
+# define SCIF_ONLY
+
+#else
+# error CPU subtype not defined
+#endif
+
+/* SCSCR */
+#define SCI_CTRL_FLAGS_TIE  0x80	/* all */
+#define SCI_CTRL_FLAGS_RIE  0x40	/* all */
+#define SCI_CTRL_FLAGS_TE   0x20	/* all */
+#define SCI_CTRL_FLAGS_RE   0x10	/* all */
+/*      SCI_CTRL_FLAGS_REIE 0x08  * 7750 SCIF */
+/*      SCI_CTRL_FLAGS_MPIE 0x08  * 7707 SCI, 7708 SCI, 7709 SCI, 7750 SCI */
+/*      SCI_CTRL_FLAGS_TEIE 0x04  * 7707 SCI, 7708 SCI, 7709 SCI, 7750 SCI */
+/*      SCI_CTRL_FLAGS_CKE1 0x02  * all */
+/*      SCI_CTRL_FLAGS_CKE0 0x01  * 7707 SCI/SCIF, 7708 SCI, 7709 SCI/SCIF, 7750 SCI */
+
+/* SCxSR SCI */
+#define SCI_TDRE  0x80		/* 7707 SCI, 7708 SCI, 7709 SCI, 7750 SCI */
+#define SCI_RDRF  0x40		/* 7707 SCI, 7708 SCI, 7709 SCI, 7750 SCI */
+#define SCI_ORER  0x20		/* 7707 SCI, 7708 SCI, 7709 SCI, 7750 SCI */
+#define SCI_FER   0x10		/* 7707 SCI, 7708 SCI, 7709 SCI, 7750 SCI */
+#define SCI_PER   0x08		/* 7707 SCI, 7708 SCI, 7709 SCI, 7750 SCI */
+#define SCI_TEND  0x04		/* 7707 SCI, 7708 SCI, 7709 SCI, 7750 SCI */
+/*      SCI_MPB   0x02  * 7707 SCI, 7708 SCI, 7709 SCI, 7750 SCI */
+/*      SCI_MPBT  0x01  * 7707 SCI, 7708 SCI, 7709 SCI, 7750 SCI */
+
+#define SCI_ERRORS ( SCI_PER | SCI_FER | SCI_ORER)
+
+/* SCxSR SCIF */
+#define SCIF_ER    0x0080	/* 7707 SCIF, 7709 SCIF, 7750 SCIF */
+#define SCIF_TEND  0x0040	/* 7707 SCIF, 7709 SCIF, 7750 SCIF */
+#define SCIF_TDFE  0x0020	/* 7707 SCIF, 7709 SCIF, 7750 SCIF */
+#define SCIF_BRK   0x0010	/* 7707 SCIF, 7709 SCIF, 7750 SCIF */
+#define SCIF_FER   0x0008	/* 7707 SCIF, 7709 SCIF, 7750 SCIF */
+#define SCIF_PER   0x0004	/* 7707 SCIF, 7709 SCIF, 7750 SCIF */
+#define SCIF_RDF   0x0002	/* 7707 SCIF, 7709 SCIF, 7750 SCIF */
+#define SCIF_DR    0x0001	/* 7707 SCIF, 7709 SCIF, 7750 SCIF */
+
+#if defined(CONFIG_CPU_SUBTYPE_SH7300)
+#define SCIF_ORER    0x0200
+#define SCIF_ERRORS ( SCIF_PER | SCIF_FER | SCIF_ER | SCIF_BRK | SCIF_ORER)
+#else
+#define SCIF_ERRORS ( SCIF_PER | SCIF_FER | SCIF_ER | SCIF_BRK)
+#endif
+
+#if defined(SCI_ONLY)
+# define SCxSR_TEND(port)		SCI_TEND
+# define SCxSR_ERRORS(port)		SCI_ERRORS
+# define SCxSR_RDxF(port)               SCI_RDRF
+# define SCxSR_TDxE(port)               SCI_TDRE
+# define SCxSR_ORER(port)		SCI_ORER
+# define SCxSR_FER(port)		SCI_FER
+# define SCxSR_PER(port)		SCI_PER
+# define SCxSR_BRK(port)		0x00
+# define SCxSR_RDxF_CLEAR(port)		0xbc
+# define SCxSR_ERROR_CLEAR(port)	0xc4
+# define SCxSR_TDxE_CLEAR(port)		0x78
+# define SCxSR_BREAK_CLEAR(port)   	0xc4
+#elif defined(SCIF_ONLY)
+# define SCxSR_TEND(port)		SCIF_TEND
+# define SCxSR_ERRORS(port)		SCIF_ERRORS
+# define SCxSR_RDxF(port)               SCIF_RDF
+# define SCxSR_TDxE(port)               SCIF_TDFE
+#if defined(CONFIG_CPU_SUBTYPE_SH7300)
+# define SCxSR_ORER(port)		SCIF_ORER
+#else
+# define SCxSR_ORER(port)		0x0000
+#endif
+# define SCxSR_FER(port)		SCIF_FER
+# define SCxSR_PER(port)		SCIF_PER
+# define SCxSR_BRK(port)		SCIF_BRK
+#if defined(CONFIG_CPU_SUBTYPE_SH7300)
+# define SCxSR_RDxF_CLEAR(port)         (sci_in(port,SCxSR)&0xfffc)
+# define SCxSR_ERROR_CLEAR(port)        (sci_in(port,SCxSR)&0xfd73)
+# define SCxSR_TDxE_CLEAR(port)         (sci_in(port,SCxSR)&0xffdf)
+# define SCxSR_BREAK_CLEAR(port)        (sci_in(port,SCxSR)&0xffe3)
+#else
+# define SCxSR_RDxF_CLEAR(port)		0x00fc
+# define SCxSR_ERROR_CLEAR(port)	0x0073
+# define SCxSR_TDxE_CLEAR(port)		0x00df
+# define SCxSR_BREAK_CLEAR(port)   	0x00e3
+#endif
+#else
+# define SCxSR_TEND(port)	 (((port)->type == PORT_SCI) ? SCI_TEND   : SCIF_TEND)
+# define SCxSR_ERRORS(port)	 (((port)->type == PORT_SCI) ? SCI_ERRORS : SCIF_ERRORS)
+# define SCxSR_RDxF(port)        (((port)->type == PORT_SCI) ? SCI_RDRF   : SCIF_RDF)
+# define SCxSR_TDxE(port)        (((port)->type == PORT_SCI) ? SCI_TDRE   : SCIF_TDFE)
+# define SCxSR_ORER(port)        (((port)->type == PORT_SCI) ? SCI_ORER   : 0x0000)
+# define SCxSR_FER(port)         (((port)->type == PORT_SCI) ? SCI_FER    : SCIF_FER)
+# define SCxSR_PER(port)         (((port)->type == PORT_SCI) ? SCI_PER    : SCIF_PER)
+# define SCxSR_BRK(port)         (((port)->type == PORT_SCI) ? 0x00       : SCIF_BRK)
+# define SCxSR_RDxF_CLEAR(port)	 (((port)->type == PORT_SCI) ? 0xbc : 0x00fc)
+# define SCxSR_ERROR_CLEAR(port) (((port)->type == PORT_SCI) ? 0xc4 : 0x0073)
+# define SCxSR_TDxE_CLEAR(port)  (((port)->type == PORT_SCI) ? 0x78 : 0x00df)
+# define SCxSR_BREAK_CLEAR(port) (((port)->type == PORT_SCI) ? 0xc4 : 0x00e3)
+#endif
+
+/* SCFCR */
+#define SCFCR_RFRST 0x0002
+#define SCFCR_TFRST 0x0004
+#define SCFCR_TCRST 0x4000
+#define SCFCR_MCE   0x0008
+
+#define SCI_MAJOR		204
+#define SCI_MINOR_START		8
+
+/* Generic serial flags */
+#define SCI_RX_THROTTLE		0x0000001
+
+#define SCI_MAGIC 0xbabeface
+
+/*
+ * Events are used to schedule things to happen at timer-interrupt
+ * time, instead of at rs interrupt time.
+ */
+#define SCI_EVENT_WRITE_WAKEUP	0
+
+struct sci_port
+{
+	struct
+	{
+	} dummy;
+	int type;
+	unsigned int base;
+	unsigned char irqs[4];	/* ERI, RXI, TXI, BRI */
+	void (*init_pins) (struct sci_port * port, unsigned int cflag);
+	unsigned int old_cflag;
+	unsigned long event;
+	int break_flag;
+};
+
+#define SCI_IN(size, offset)					\
+  unsigned int addr = port->base + (offset);			\
+  if ((size) == 8) { 						\
+    return ctrl_inb(addr);					\
+  } else {					 		\
+    return ctrl_inw(addr);					\
+  }
+#define SCI_OUT(size, offset, value)				\
+  unsigned int addr = port->base + (offset);			\
+  if ((size) == 8) { 						\
+    ctrl_outb(value, addr);					\
+  } else {							\
+    ctrl_outw(value, addr);					\
+  }
+
+#define CPU_SCIx_FNS(name, sci_offset, sci_size, scif_offset, scif_size)\
+  static inline unsigned int sci_##name##_in(struct sci_port* port)	\
+  {									\
+    if (port->type == PORT_SCI) { 					\
+      SCI_IN(sci_size, sci_offset)					\
+    } else {								\
+      SCI_IN(scif_size, scif_offset);		 			\
+    }									\
+  }									\
+  static inline void sci_##name##_out(struct sci_port* port, unsigned int value) \
+  {									\
+    if (port->type == PORT_SCI) {					\
+      SCI_OUT(sci_size, sci_offset, value)				\
+    } else {								\
+      SCI_OUT(scif_size, scif_offset, value);				\
+    }									\
+  }
+
+#define CPU_SCIF_FNS(name, scif_offset, scif_size)				\
+  static inline unsigned int sci_##name##_in(struct sci_port* port)	\
+  {									\
+    SCI_IN(scif_size, scif_offset);		 			\
+  }									\
+  static inline void sci_##name##_out(struct sci_port* port, unsigned int value) \
+  {									\
+    SCI_OUT(scif_size, scif_offset, value);				\
+  }
+
+#ifdef __sh3__
+#error
+#if defined(CONFIG_CPU_SUBTYPE_SH7300)
+#define SCIF_FNS(name, scif_offset, scif_size) \
+  CPU_SCIF_FNS(name, scif_offset, scif_size)
+#else
+#define SCIx_FNS(name, sh3_sci_offset, sh3_sci_size, sh4_sci_offset, sh4_sci_size, \
+		 sh3_scif_offset, sh3_scif_size, sh4_scif_offset, sh4_scif_size) \
+  CPU_SCIx_FNS(name, sh3_sci_offset, sh3_sci_size, sh3_scif_offset, sh3_scif_size)
+#define SCIF_FNS(name, sh3_scif_offset, sh3_scif_size, sh4_scif_offset, sh4_scif_size) \
+  CPU_SCIF_FNS(name, sh3_scif_offset, sh3_scif_size)
+#endif
+#else
+#define SCIx_FNS(name, sh3_sci_offset, sh3_sci_size, sh4_sci_offset, sh4_sci_size, \
+		 sh3_scif_offset, sh3_scif_size, sh4_scif_offset, sh4_scif_size) \
+  CPU_SCIx_FNS(name, sh4_sci_offset, sh4_sci_size, sh4_scif_offset, sh4_scif_size)
+#define SCIF_FNS(name, sh3_scif_offset, sh3_scif_size, sh4_scif_offset, sh4_scif_size) \
+  CPU_SCIF_FNS(name, sh4_scif_offset, sh4_scif_size)
+#endif
+
+#if defined(CONFIG_CPU_SUBTYPE_SH7300)
+SCIF_FNS (SCSMR, 0x00, 16)
+	SCIF_FNS (SCBRR, 0x04, 8)
+	SCIF_FNS (SCSCR, 0x08, 16)
+	SCIF_FNS (SCTDSR, 0x0c, 8)
+	SCIF_FNS (SCFER, 0x10, 16)
+	SCIF_FNS (SCxSR, 0x14, 16)
+	SCIF_FNS (SCFCR, 0x18, 16)
+	SCIF_FNS (SCFDR, 0x1c, 16)
+	SCIF_FNS (SCxTDR, 0x20, 8)
+	SCIF_FNS (SCxRDR, 0x24, 8)
+#else
+/*      reg      SCI/SH3   SCI/SH4  SCIF/SH3   SCIF/SH4  */
+/*      name     off  sz   off  sz   off  sz   off  sz   */
+SCIx_FNS (SCSMR, 0x00, 8, 0x00, 8, 0x00, 8, 0x00, 16)
+	SCIx_FNS (SCBRR, 0x02, 8, 0x04, 8, 0x02, 8, 0x04, 8)
+	SCIx_FNS (SCSCR, 0x04, 8, 0x08, 8, 0x04, 8, 0x08, 16)
+	SCIx_FNS (SCxTDR, 0x06, 8, 0x0c, 8, 0x06, 8, 0x0C, 8)
+	SCIx_FNS (SCxSR, 0x08, 8, 0x10, 8, 0x08, 16, 0x10, 16)
+	SCIx_FNS (SCxRDR, 0x0a, 8, 0x14, 8, 0x0A, 8, 0x14, 8)
+	SCIF_FNS (SCFCR, 0x0c, 8, 0x18, 16)
+	SCIF_FNS (SCFDR, 0x0e, 16, 0x1C, 16)
+	SCIF_FNS (SCSPTR, 0, 0, 0x20, 16)
+	SCIF_FNS (SCLSR, 0, 0, 0x24, 16)
+#endif
+#define sci_in(port, reg) sci_##reg##_in(port)
+#define sci_out(port, reg, value) sci_##reg##_out(port, value)
+/*
+ * Values for the BitRate Register (SCBRR)
+ *
+ * The values are actually divisors for a frequency which can
+ * be internal to the SH3 (14.7456MHz) or derived from an external
+ * clock source.  This driver assumes the internal clock is used;
+ * to support using an external clock source, config options or
+ * possibly command-line options would need to be added.
+ *
+ * Also, to support speeds below 2400 (why?) the lower 2 bits of
+ * the SCSMR register would also need to be set to non-zero values.
+ *
+ * -- Greg Banks 27Feb2000
+ *
+ * Answer: The SCBRR register is only eight bits, and the value in
+ * it gets larger with lower baud rates. At around 2400 (depending on
+ * the peripherial module clock) you run out of bits. However the
+ * lower two bits of SCSMR allow the module clock to be divided down,
+ * scaling the value which is needed in SCBRR.
+ *
+ * -- Stuart Menefy - 23 May 2000
+ *
+ * I meant, why would anyone bother with bitrates below 2400.
+ *
+ * -- Greg Banks - 7Jul2000
+ *
+ * You "speedist"!  How will I use my 110bps ASR-33 teletype with paper
+ * tape reader as a console!
+ *
+ * -- Mitch Davis - 15 Jul 2000
+ */
+#if defined(CONFIG_CPU_SUBTYPE_SH7300)
+#define SCBRR_VALUE(bps) ((get_peripheral_clk_rate()+16*bps)/(16*bps)-1)
+#else
+#define SCBRR_VALUE(bps) ((get_peripheral_clk_rate()+16*bps)/(32*bps)-1)
+#endif
+#define BPS_2400       SCBRR_VALUE(2400)
+#define BPS_4800       SCBRR_VALUE(4800)
+#define BPS_9600       SCBRR_VALUE(9600)
+#define BPS_19200      SCBRR_VALUE(19200)
+#define BPS_38400      SCBRR_VALUE(38400)
+#define BPS_57600      SCBRR_VALUE(57600)
+#define BPS_115200     SCBRR_VALUE(115200)
+#define BPS_230400     SCBRR_VALUE(230400)
+
diff --git a/include/spi.h b/include/spi.h
index 03dc5bc036..9fc0e1aa4a 100644
--- a/include/spi.h
+++ b/include/spi.h
@@ -1,6 +1,7 @@
 /*
  * (C) Copyright 2001
  * Gerald Van Baren, Custom IDEAS, vanbaren@cideas.com.
+ * (C) Copyright 2009 STMicroelectronics. Sean McGoogan <Sean.McGoogan@st.com>
  *
  * See file CREDITS for list of people who contributed to this
  * project.
@@ -70,4 +71,11 @@ void spi_init(void);
  */
 int  spi_xfer(spi_chipsel_type chipsel, int bitlen, uchar *dout, uchar *din);
 
+/*
+ * External table of chip select functions (see the appropriate board
+ * support for the actual definition of the table).
+ */
+extern spi_chipsel_type spi_chipsel[];
+extern int spi_chipsel_cnt;
+
 #endif	/* _SPI_H_ */
diff --git a/include/u-boot/zlib.h b/include/u-boot/zlib.h
new file mode 100644
index 0000000000..ef9be07d60
--- /dev/null
+++ b/include/u-boot/zlib.h
@@ -0,0 +1,698 @@
+/*
+ * This file is derived from zlib.h and zconf.h from the zlib-1.2.3
+ * distribution by Jean-loup Gailly and Mark Adler, with some additions
+ * by Paul Mackerras to aid in implementing Deflate compression and
+ * decompression for PPP packets.
+ */
+
+ /*
+  * ==FILEVERSION 960122==
+  *
+  * This marker is used by the Linux installation script to determine
+  * whether an up-to-date version of this file is already installed.
+  */
+
+/* zlib.h -- interface of the 'zlib' general purpose compression library
+  version 1.2.3, July 18th, 2005
+
+  Copyright (C) 1995-2005 Jean-loup Gailly and Mark Adler
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+
+  Jean-loup Gailly        Mark Adler
+  jloup@gzip.org          madler@alumni.caltech.edu
+
+
+  The data format used by the zlib library is described by RFCs (Request for
+  Comments) 1950 to 1952 in the files http://www.ietf.org/rfc/rfc1950.txt
+  (zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format).
+*/
+
+#ifndef ZLIB_H
+#define ZLIB_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define ZLIB_VERSION "1.2.3"
+#define ZLIB_VERNUM 0x1230
+
+/* #include "zconf.h" */        /* included directly here */
+/* zconf.h -- configuration of the zlib compression library
+ * Copyright (C) 1995-2005 Jean-loup Gailly.
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/* Begin of new zconf.h */
+/*
+ * If you *really* need a unique prefix for all types and library functions,
+ * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
+ */
+#ifdef Z_PREFIX
+#  define deflateInit_          z_deflateInit_
+#  define deflate               z_deflate
+#  define deflateEnd            z_deflateEnd
+#  define inflateInit_          z_inflateInit_
+#  define inflate               z_inflate
+#  define inflateEnd            z_inflateEnd
+#  define deflateInit2_         z_deflateInit2_
+#  define deflateSetDictionary  z_deflateSetDictionary
+#  define deflateCopy           z_deflateCopy
+#  define deflateReset          z_deflateReset
+#  define deflateParams         z_deflateParams
+#  define deflateBound          z_deflateBound
+#  define deflatePrime          z_deflatePrime
+#  define inflateInit2_         z_inflateInit2_
+#  define inflateSetDictionary  z_inflateSetDictionary
+#  define inflateSync           z_inflateSync
+#  define inflateSyncPoint      z_inflateSyncPoint
+#  define inflateCopy           z_inflateCopy
+#  define inflateReset          z_inflateReset
+#  define inflateBack           z_inflateBack
+#  define inflateBackEnd        z_inflateBackEnd
+#  define compress              z_compress
+#  define compress2             z_compress2
+#  define compressBound         z_compressBound
+#  define uncompress            z_uncompress
+#  define adler32               z_adler32
+#  define crc32                 z_crc32
+#  define get_crc_table         z_get_crc_table
+#  define zError                z_zError
+
+#  define alloc_func            z_alloc_func
+#  define free_func             z_free_func
+#  define in_func               z_in_func
+#  define out_func              z_out_func
+#  define Byte                  z_Byte
+#  define uInt                  z_uInt
+#  define uLong                 z_uLong
+#  define Bytef                 z_Bytef
+#  define charf                 z_charf
+#  define intf                  z_intf
+#  define uIntf                 z_uIntf
+#  define uLongf                z_uLongf
+#  define voidpf                z_voidpf
+#  define voidp                 z_voidp
+#endif
+
+#if defined(__MSDOS__) && !defined(MSDOS)
+#  define MSDOS
+#endif
+#if (defined(OS_2) || defined(__OS2__)) && !defined(OS2)
+#  define OS2
+#endif
+#if defined(_WINDOWS) && !defined(WINDOWS)
+#  define WINDOWS
+#endif
+#if defined(_WIN32) || defined(_WIN32_WCE) || defined(__WIN32__)
+#  ifndef WIN32
+#    define WIN32
+#  endif
+#endif
+#if (defined(MSDOS) || defined(OS2) || defined(WINDOWS)) && !defined(WIN32)
+#  if !defined(__GNUC__) && !defined(__FLAT__) && !defined(__386__)
+#    ifndef SYS16BIT
+#      define SYS16BIT
+#    endif
+#  endif
+#endif
+
+/*
+ * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
+ * than 64k bytes at a time (needed on systems with 16-bit int).
+ */
+#ifdef SYS16BIT
+#  define MAXSEG_64K
+#endif
+#ifdef MSDOS
+#  define UNALIGNED_OK
+#endif
+
+#ifdef __STDC_VERSION__
+#  ifndef STDC
+#    define STDC
+#  endif
+#  if __STDC_VERSION__ >= 199901L
+#    ifndef STDC99
+#      define STDC99
+#    endif
+#  endif
+#endif
+#if !defined(STDC) && (defined(__STDC__) || defined(__cplusplus))
+#  define STDC
+#endif
+#if !defined(STDC) && (defined(__GNUC__) || defined(__BORLANDC__))
+#  define STDC
+#endif
+#if !defined(STDC) && (defined(MSDOS) || defined(WINDOWS) || defined(WIN32))
+#  define STDC
+#endif
+#if !defined(STDC) && (defined(OS2) || defined(__HOS_AIX__))
+#  define STDC
+#endif
+
+#if defined(__OS400__) && !defined(STDC)    /* iSeries (formerly AS/400). */
+#  define STDC
+#endif
+
+#ifndef STDC
+#  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */
+#    define const       /* note: need a more gentle solution here */
+#  endif
+#endif
+
+/* Some Mac compilers merge all .h files incorrectly: */
+#if defined(__MWERKS__)||defined(applec)||defined(THINK_C)||defined(__SC__)
+#  define NO_DUMMY_DECL
+#endif
+
+/* Maximum value for memLevel in deflateInit2 */
+#ifndef MAX_MEM_LEVEL
+#  ifdef MAXSEG_64K
+#    define MAX_MEM_LEVEL 8
+#  else
+#    define MAX_MEM_LEVEL 9
+#  endif
+#endif
+
+/* Maximum value for windowBits in deflateInit2 and inflateInit2.
+ * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
+ * created by gzip. (Files created by minigzip can still be extracted by
+ * gzip.)
+ */
+#ifndef MAX_WBITS
+#  define MAX_WBITS   15 /* 32K LZ77 window */
+#endif
+
+/* The memory requirements for deflate are (in bytes):
+            (1 << (windowBits+2)) +  (1 << (memLevel+9))
+ that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
+ plus a few kilobytes for small objects. For example, if you want to reduce
+ the default memory requirements from 256K to 128K, compile with
+     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
+ Of course this will generally degrade compression (there's no free lunch).
+
+   The memory requirements for inflate are (in bytes) 1 << windowBits
+ that is, 32K for windowBits=15 (default value) plus a few kilobytes
+ for small objects.
+*/
+
+                        /* Type declarations */
+
+#ifndef OF /* function prototypes */
+#  ifdef STDC
+#    define OF(args)  args
+#  else
+#    define OF(args)  ()
+#  endif
+#endif
+
+/* The following definitions for FAR are needed only for MSDOS mixed
+ * model programming (small or medium model with some far allocations).
+ * This was tested only with MSC; for other MSDOS compilers you may have
+ * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
+ * just define FAR to be empty.
+ */
+#ifdef SYS16BIT
+#  if defined(M_I86SM) || defined(M_I86MM)
+     /* MSC small or medium model */
+#    define SMALL_MEDIUM
+#    ifdef _MSC_VER
+#      define FAR _far
+#    else
+#      define FAR far
+#    endif
+#  endif
+#  if (defined(__SMALL__) || defined(__MEDIUM__))
+     /* Turbo C small or medium model */
+#    define SMALL_MEDIUM
+#    ifdef __BORLANDC__
+#      define FAR _far
+#    else
+#      define FAR far
+#    endif
+#  endif
+#endif
+
+#if defined(WINDOWS) || defined(WIN32)
+   /* If building or using zlib as a DLL, define ZLIB_DLL.
+    * This is not mandatory, but it offers a little performance increase.
+    */
+#  ifdef ZLIB_DLL
+#    if defined(WIN32) && (!defined(__BORLANDC__) || (__BORLANDC__ >= 0x500))
+#      ifdef ZLIB_INTERNAL
+#        define ZEXTERN extern __declspec(dllexport)
+#      else
+#        define ZEXTERN extern __declspec(dllimport)
+#      endif
+#    endif
+#  endif  /* ZLIB_DLL */
+   /* If building or using zlib with the WINAPI/WINAPIV calling convention,
+    * define ZLIB_WINAPI.
+    * Caution: the standard ZLIB1.DLL is NOT compiled using ZLIB_WINAPI.
+    */
+#  ifdef ZLIB_WINAPI
+#    ifdef FAR
+#      undef FAR
+#    endif
+#    include <windows.h>
+     /* No need for _export, use ZLIB.DEF instead. */
+     /* For complete Windows compatibility, use WINAPI, not __stdcall. */
+#    define ZEXPORT WINAPI
+#    ifdef WIN32
+#      define ZEXPORTVA WINAPIV
+#    else
+#      define ZEXPORTVA FAR CDECL
+#    endif
+#  endif
+#endif
+
+#if defined (__BEOS__)
+#  ifdef ZLIB_DLL
+#    ifdef ZLIB_INTERNAL
+#      define ZEXPORT   __declspec(dllexport)
+#      define ZEXPORTVA __declspec(dllexport)
+#    else
+#      define ZEXPORT   __declspec(dllimport)
+#      define ZEXPORTVA __declspec(dllimport)
+#    endif
+#  endif
+#endif
+
+#ifndef ZEXTERN
+#  define ZEXTERN extern
+#endif
+#ifndef ZEXPORT
+#  define ZEXPORT
+#endif
+#ifndef ZEXPORTVA
+#  define ZEXPORTVA
+#endif
+
+#ifndef FAR
+#  define FAR
+#endif
+
+#if !defined(__MACTYPES__)
+typedef unsigned char  Byte;  /* 8 bits */
+#endif
+typedef unsigned int   uInt;  /* 16 bits or more */
+typedef unsigned long  uLong; /* 32 bits or more */
+
+#ifdef SMALL_MEDIUM
+   /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */
+#  define Bytef Byte FAR
+#else
+   typedef Byte  FAR Bytef;
+#endif
+typedef char  FAR charf;
+typedef int   FAR intf;
+typedef uInt  FAR uIntf;
+typedef uLong FAR uLongf;
+
+#ifdef STDC
+   typedef void const *voidpc;
+   typedef void FAR   *voidpf;
+   typedef void       *voidp;
+#else
+   typedef Byte const *voidpc;
+   typedef Byte FAR   *voidpf;
+   typedef Byte       *voidp;
+#endif
+
+#  ifdef VMS
+#    include <unixio.h>   /* for off_t */
+#  endif
+#  define z_off_t off_t
+#ifndef SEEK_SET
+#  define SEEK_SET        0       /* Seek from beginning of file.  */
+#  define SEEK_CUR        1       /* Seek from current position.  */
+#  define SEEK_END        2       /* Set file pointer to EOF plus "offset" */
+#endif
+#ifndef z_off_t
+#  define z_off_t long
+#endif
+
+#if defined(__OS400__)
+#  define NO_vsnprintf
+#endif
+
+#if defined(__MVS__)
+#  define NO_vsnprintf
+#  ifdef FAR
+#    undef FAR
+#  endif
+#endif
+
+/* MVS linker does not support external names larger than 8 bytes */
+#if defined(__MVS__)
+#   pragma map(deflateInit_,"DEIN")
+#   pragma map(deflateInit2_,"DEIN2")
+#   pragma map(deflateEnd,"DEEND")
+#   pragma map(deflateBound,"DEBND")
+#   pragma map(inflateInit_,"ININ")
+#   pragma map(inflateInit2_,"ININ2")
+#   pragma map(inflateEnd,"INEND")
+#   pragma map(inflateSync,"INSY")
+#   pragma map(inflateSetDictionary,"INSEDI")
+#   pragma map(compressBound,"CMBND")
+#   pragma map(inflate_table,"INTABL")
+#   pragma map(inflate_fast,"INFA")
+#   pragma map(inflate_copyright,"INCOPY")
+#endif
+/* End of new zconf.h */
+
+/*
+     The 'zlib' compression library provides in-memory compression and
+  decompression functions, including integrity checks of the uncompressed
+  data.  This version of the library supports only one compression method
+  (deflation) but other algorithms will be added later and will have the same
+  stream interface.
+
+     Compression can be done in a single step if the buffers are large
+  enough (for example if an input file is mmap'ed), or can be done by
+  repeated calls of the compression function.  In the latter case, the
+  application must provide more input and/or consume the output
+  (providing more output space) before each call.
+
+     The compressed data format used by default by the in-memory functions is
+  the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped
+  around a deflate stream, which is itself documented in RFC 1951.
+
+     The library also supports reading and writing files in gzip (.gz) format
+  with an interface similar to that of stdio using the functions that start
+  with "gz".  The gzip format is different from the zlib format.  gzip is a
+  gzip wrapper, documented in RFC 1952, wrapped around a deflate stream.
+
+     This library can optionally read and write gzip streams in memory as well.
+
+     The zlib format was designed to be compact and fast for use in memory
+  and on communications channels.  The gzip format was designed for single-
+  file compression on file systems, has a larger header than zlib to maintain
+  directory information, and uses a different, slower check method than zlib.
+
+     The library does not install any signal handler. The decoder checks
+  the consistency of the compressed data, so the library should never
+  crash even in case of corrupted input.
+*/
+
+typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
+typedef void   (*free_func)  OF((voidpf opaque, voidpf address, uInt size));
+typedef void   (*cb_func)    OF((Bytef *buf, uInt len));
+
+struct internal_state;
+
+typedef struct z_stream_s {
+	Bytef	*next_in; /* next input byte */
+	uInt	avail_in; /* number of bytes available at next_in */
+	uLong	total_in; /* total nb of input bytes read so far */
+	Bytef	*next_out; /* next output byte should be put there */
+	uInt	avail_out; /* remaining free space at next_out */
+	uLong	total_out; /* total nb of bytes output so far */
+	char	*msg;	/* last error message, NULL if no error */
+	struct	internal_state FAR *state; /* not visible by applications */
+	alloc_func	zalloc;	/* used to allocate the internal state */
+	free_func	zfree;	/* used to free the internal state */
+	voidpf	opaque;	/* private data object passed to zalloc and zfree */
+	int	data_type;	/* best guess about the data type:
+					binary or text */
+	cb_func	outcb;	/* called regularly just before blocks of output */
+	uLong	adler;	/* adler32 value of the uncompressed data */
+	uLong	reserved;	/* reserved for future use */
+} z_stream;
+
+typedef z_stream FAR *z_streamp;
+
+/*
+     gzip header information passed to and from zlib routines.  See RFC 1952
+  for more details on the meanings of these fields.
+*/
+typedef struct gz_header_s {
+	int	text;	/* true if compressed data believed to be text */
+	uLong	time;	/* modification time */
+	int	xflags;	/* extra flags (not used when writing a gzip file) */
+	int	os;	/* operating system */
+	Bytef	*extra;	/* pointer to extra field or Z_NULL if none */
+	uInt	extra_len; /* extra field length (valid if extra != Z_NULL) */
+	uInt	extra_max; /* space at extra (only when reading header) */
+	Bytef	*name; /* pointer to zero-terminated file name or Z_NULL */
+	uInt	name_max; /* space at name (only when reading header) */
+	Bytef	*comment; /* pointer to zero-terminated comment or Z_NULL */
+	uInt	comm_max; /* space at comment (only when reading header) */
+	int	hcrc; /* true if there was or will be a header crc */
+	int	done; /* true when done reading gzip header (not used
+			when writing a gzip file) */
+} gz_header;
+
+typedef gz_header FAR *gz_headerp;
+
+                        /* constants */
+#define Z_NO_FLUSH      0
+#define Z_PARTIAL_FLUSH 1 /* will be removed, use Z_SYNC_FLUSH instead */
+#define Z_SYNC_FLUSH    2
+#define Z_FULL_FLUSH    3
+#define Z_FINISH        4
+#define Z_BLOCK         5
+/* Allowed flush values; see deflate() and inflate() below for details */
+
+#define Z_OK            0
+#define Z_STREAM_END    1
+#define Z_NEED_DICT     2
+#define Z_ERRNO        (-1)
+#define Z_STREAM_ERROR (-2)
+#define Z_DATA_ERROR   (-3)
+#define Z_MEM_ERROR    (-4)
+#define Z_BUF_ERROR    (-5)
+#define Z_VERSION_ERROR (-6)
+/* Return codes for the compression/decompression functions. Negative
+ * values are errors, positive values are used for special but normal events.
+ */
+
+#define Z_NO_COMPRESSION         0
+#define Z_BEST_SPEED             1
+#define Z_BEST_COMPRESSION       9
+#define Z_DEFAULT_COMPRESSION  (-1)
+/* compression levels */
+
+#define Z_FILTERED            1
+#define Z_HUFFMAN_ONLY        2
+#define Z_RLE                 3
+#define Z_FIXED               4
+#define Z_DEFAULT_STRATEGY    0
+/* compression strategy; see deflateInit2() below for details */
+
+#define Z_BINARY   0
+#define Z_TEXT     1
+#define Z_ASCII    Z_TEXT   /* for compatibility with 1.2.2 and earlier */
+#define Z_UNKNOWN  2
+/* Possible values of the data_type field (though see inflate()) */
+
+#define Z_DEFLATED   8
+/* The deflate compression method (the only one supported in this version) */
+
+#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */
+
+                        /* basic functions */
+
+/* The application can compare zlibVersion and ZLIB_VERSION for consistency.
+   If the first character differs, the library code actually used is
+   not compatible with the zlib.h header file used by the application.
+   This check is automatically made by deflateInit and inflateInit.
+ */
+
+ZEXTERN int ZEXPORT inflateInit_ OF((z_streamp strm, const char *version,
+				int stream_size));
+
+ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));
+/*
+    inflate decompresses as much data as possible, and stops when the input
+  buffer becomes empty or the output buffer becomes full. It may introduce
+  some output latency (reading input without producing any output) except when
+  forced to flush.
+
+  The detailed semantics are as follows. inflate performs one or both of the
+  following actions:
+
+  - Decompress more input starting at next_in and update next_in and avail_in
+    accordingly. If not all input can be processed (because there is not
+    enough room in the output buffer), next_in is updated and processing
+    will resume at this point for the next call of inflate().
+
+  - Provide more output starting at next_out and update next_out and avail_out
+    accordingly.  inflate() provides as much output as possible, until there
+    is no more input data or no more space in the output buffer (see below
+    about the flush parameter).
+
+  Before the call of inflate(), the application should ensure that at least
+  one of the actions is possible, by providing more input and/or consuming
+  more output, and updating the next_* and avail_* values accordingly.
+  The application can consume the uncompressed output when it wants, for
+  example when the output buffer is full (avail_out == 0), or after each
+  call of inflate(). If inflate returns Z_OK and with zero avail_out, it
+  must be called again after making room in the output buffer because there
+  might be more output pending.
+
+    The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH,
+  Z_FINISH, or Z_BLOCK. Z_SYNC_FLUSH requests that inflate() flush as much
+  output as possible to the output buffer. Z_BLOCK requests that inflate() stop
+  if and when it gets to the next deflate block boundary. When decoding the
+  zlib or gzip format, this will cause inflate() to return immediately after
+  the header and before the first block. When doing a raw inflate, inflate()
+  will go ahead and process the first block, and will return when it gets to
+  the end of that block, or when it runs out of data.
+
+    The Z_BLOCK option assists in appending to or combining deflate streams.
+  Also to assist in this, on return inflate() will set strm->data_type to the
+  number of unused bits in the last byte taken from strm->next_in, plus 64
+  if inflate() is currently decoding the last block in the deflate stream,
+  plus 128 if inflate() returned immediately after decoding an end-of-block
+  code or decoding the complete header up to just before the first byte of the
+  deflate stream. The end-of-block will not be indicated until all of the
+  uncompressed data from that block has been written to strm->next_out.  The
+  number of unused bits may in general be greater than seven, except when
+  bit 7 of data_type is set, in which case the number of unused bits will be
+  less than eight.
+
+    inflate() should normally be called until it returns Z_STREAM_END or an
+  error. However if all decompression is to be performed in a single step
+  (a single call of inflate), the parameter flush should be set to
+  Z_FINISH. In this case all pending input is processed and all pending
+  output is flushed; avail_out must be large enough to hold all the
+  uncompressed data. (The size of the uncompressed data may have been saved
+  by the compressor for this purpose.) The next operation on this stream must
+  be inflateEnd to deallocate the decompression state. The use of Z_FINISH
+  is never required, but can be used to inform inflate that a faster approach
+  may be used for the single inflate() call.
+
+     In this implementation, inflate() always flushes as much output as
+  possible to the output buffer, and always uses the faster approach on the
+  first call. So the only effect of the flush parameter in this implementation
+  is on the return value of inflate(), as noted below, or when it returns early
+  because Z_BLOCK is used.
+
+     If a preset dictionary is needed after this call (see inflateSetDictionary
+  below), inflate sets strm->adler to the adler32 checksum of the dictionary
+  chosen by the compressor and returns Z_NEED_DICT; otherwise it sets
+  strm->adler to the adler32 checksum of all output produced so far (that is,
+  total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described
+  below. At the end of the stream, inflate() checks that its computed adler32
+  checksum is equal to that saved by the compressor and returns Z_STREAM_END
+  only if the checksum is correct.
+
+    inflate() will decompress and check either zlib-wrapped or gzip-wrapped
+  deflate data.  The header type is detected automatically.  Any information
+  contained in the gzip header is not retained, so applications that need that
+  information should instead use raw inflate, see inflateInit2() below, or
+  inflateBack() and perform their own processing of the gzip header and
+  trailer.
+
+    inflate() returns Z_OK if some progress has been made (more input processed
+  or more output produced), Z_STREAM_END if the end of the compressed data has
+  been reached and all uncompressed output has been produced, Z_NEED_DICT if a
+  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was
+  corrupted (input stream not conforming to the zlib format or incorrect check
+  value), Z_STREAM_ERROR if the stream structure was inconsistent (for example
+  if next_in or next_out was NULL), Z_MEM_ERROR if there was not enough memory,
+  Z_BUF_ERROR if no progress is possible or if there was not enough room in the
+  output buffer when Z_FINISH is used. Note that Z_BUF_ERROR is not fatal, and
+  inflate() can be called again with more input and more output space to
+  continue decompressing. If Z_DATA_ERROR is returned, the application may then
+  call inflateSync() to look for a good compression block if a partial recovery
+  of the data is desired.
+*/
+
+ZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));
+/*
+     All dynamically allocated data structures for this stream are freed.
+   This function discards any unprocessed input and does not flush any
+   pending output.
+
+     inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state
+   was inconsistent. In the error case, msg may be set but then points to a
+   static string (which must not be deallocated).
+*/
+
+                        /* Advanced functions */
+
+ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));
+
+                        /* utility functions */
+
+/*
+     The following utility functions are implemented on top of the
+   basic stream-oriented functions. To simplify the interface, some
+   default options are assumed (compression level and memory usage,
+   standard memory allocation functions). The source code of these
+   utility functions can easily be modified if you need special options.
+*/
+
+ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));
+/*
+     Update a running Adler-32 checksum with the bytes buf[0..len-1] and
+   return the updated checksum. If buf is NULL, this function returns
+   the required initial value for the checksum.
+   An Adler-32 checksum is almost as reliable as a CRC32 but can be computed
+   much faster. Usage example:
+
+     uLong adler = adler32(0L, Z_NULL, 0);
+
+     while (read_buffer(buffer, length) != EOF) {
+       adler = adler32(adler, buffer, length);
+     }
+     if (adler != original_adler) error();
+*/
+
+/*
+     Combine two Adler-32 checksums into one.  For two sequences of bytes, seq1
+   and seq2 with lengths len1 and len2, Adler-32 checksums were calculated for
+   each, adler1 and adler2.  adler32_combine() returns the Adler-32 checksum of
+   seq1 and seq2 concatenated, requiring only adler1, adler2, and len2.
+*/
+
+ZEXTERN uLong ZEXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));
+/*
+     Update a running CRC-32 with the bytes buf[0..len-1] and return the
+   updated CRC-32. If buf is NULL, this function returns the required initial
+   value for the for the crc. Pre- and post-conditioning (one's complement) is
+   performed within this function so it shouldn't be done by the application.
+   Usage example:
+
+     uLong crc = crc32(0L, Z_NULL, 0);
+
+     while (read_buffer(buffer, length) != EOF) {
+       crc = crc32(crc, buffer, length);
+     }
+     if (crc != original_crc) error();
+*/
+
+ZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,
+                                      const char *version, int stream_size));
+#define inflateInit(strm) \
+	inflateInit_((strm), ZLIB_VERSION, sizeof(z_stream))
+#define inflateInit2(strm, windowBits) \
+	inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof(z_stream))
+
+#if !defined(ZUTIL_H) && !defined(NO_DUMMY_DECL)
+	struct internal_state {int dummy;}; /* hack for buggy compilers */
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* ZLIB_H */
diff --git a/include/usb.h b/include/usb.h
index 4e1539fa88..0f42b45008 100644
--- a/include/usb.h
+++ b/include/usb.h
@@ -223,7 +223,17 @@ int usb_submit_int_msg(struct usb_device *dev, unsigned long pipe,
 			void *buffer,int transfer_len, int interval);
 void usb_disable_asynch(int disable);
 int usb_maxpacket(struct usb_device *dev,unsigned long pipe);
-void __inline__ wait_ms(unsigned long ms);
+
+/***********************************************************************
+ * wait_ms
+ */
+
+void __inline__ wait_ms(unsigned long ms)
+{
+	while(ms-->0)
+		udelay(1000);
+}
+
 int usb_get_configuration_no(struct usb_device *dev,unsigned char *buffer,int cfgno);
 int usb_get_report(struct usb_device *dev, int ifnum, unsigned char type, unsigned char id, void *buf, int size);
 int usb_get_class_descriptor(struct usb_device *dev, int ifnum,
diff --git a/include/zlib.h b/include/zlib.h
deleted file mode 100644
index e441494d0d..0000000000
--- a/include/zlib.h
+++ /dev/null
@@ -1,434 +0,0 @@
-/*
- * This file is derived from zlib.h and zconf.h from the zlib-0.95
- * distribution by Jean-loup Gailly and Mark Adler, with some additions
- * by Paul Mackerras to aid in implementing Deflate compression and
- * decompression for PPP packets.
- */
-
-/*
- *  ==FILEVERSION 960122==
- *
- * This marker is used by the Linux installation script to determine
- * whether an up-to-date version of this file is already installed.
- */
-
-/* zlib.h -- interface of the 'zlib' general purpose compression library
-  version 0.95, Aug 16th, 1995.
-
-  Copyright (C) 1995 Jean-loup Gailly and Mark Adler
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the authors be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-  Jean-loup Gailly        Mark Adler
-  gzip@prep.ai.mit.edu    madler@alumni.caltech.edu
- */
-
-#ifndef _ZLIB_H
-#define _ZLIB_H
-
-/* #include "zconf.h" */	/* included directly here */
-
-/* zconf.h -- configuration of the zlib compression library
- * Copyright (C) 1995 Jean-loup Gailly.
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* From: zconf.h,v 1.12 1995/05/03 17:27:12 jloup Exp */
-
-/*
-     The library does not install any signal handler. It is recommended to
-  add at least a handler for SIGSEGV when decompressing; the library checks
-  the consistency of the input data whenever possible but may go nuts
-  for some forms of corrupted input.
- */
-
-/*
- * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
- * than 64k bytes at a time (needed on systems with 16-bit int).
- * Compile with -DUNALIGNED_OK if it is OK to access shorts or ints
- * at addresses which are not a multiple of their size.
- * Under DOS, -DFAR=far or -DFAR=__far may be needed.
- */
-
-#ifndef STDC
-#  if defined(MSDOS) || defined(__STDC__) || defined(__cplusplus)
-#    define STDC
-#  endif
-#endif
-
-#ifdef	__MWERKS__ /* Metrowerks CodeWarrior declares fileno() in unix.h */
-#  include <unix.h>
-#endif
-
-/* Maximum value for memLevel in deflateInit2 */
-#ifndef MAX_MEM_LEVEL
-#  ifdef MAXSEG_64K
-#    define MAX_MEM_LEVEL 8
-#  else
-#    define MAX_MEM_LEVEL 9
-#  endif
-#endif
-
-#ifndef FAR
-#  define FAR
-#endif
-
-/* Maximum value for windowBits in deflateInit2 and inflateInit2 */
-#ifndef MAX_WBITS
-#  define MAX_WBITS   15 /* 32K LZ77 window */
-#endif
-
-/* The memory requirements for deflate are (in bytes):
-	    1 << (windowBits+2)   +  1 << (memLevel+9)
- that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
- plus a few kilobytes for small objects. For example, if you want to reduce
- the default memory requirements from 256K to 128K, compile with
-     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
- Of course this will generally degrade compression (there's no free lunch).
-
-   The memory requirements for inflate are (in bytes) 1 << windowBits
- that is, 32K for windowBits=15 (default value) plus a few kilobytes
- for small objects.
-*/
-
-			/* Type declarations */
-
-#ifndef OF /* function prototypes */
-#  ifdef STDC
-#    define OF(args)  args
-#  else
-#    define OF(args)  ()
-#  endif
-#endif
-
-typedef unsigned char  Byte;  /* 8 bits */
-typedef unsigned int   uInt;  /* 16 bits or more */
-typedef unsigned long  uLong; /* 32 bits or more */
-
-typedef Byte FAR Bytef;
-typedef char FAR charf;
-typedef int FAR intf;
-typedef uInt FAR uIntf;
-typedef uLong FAR uLongf;
-
-#ifdef STDC
-   typedef void FAR *voidpf;
-   typedef void     *voidp;
-#else
-   typedef Byte FAR *voidpf;
-   typedef Byte     *voidp;
-#endif
-
-/* end of original zconf.h */
-
-#define ZLIB_VERSION "0.95P"
-
-/*
-     The 'zlib' compression library provides in-memory compression and
-  decompression functions, including integrity checks of the uncompressed
-  data.  This version of the library supports only one compression method
-  (deflation) but other algorithms may be added later and will have the same
-  stream interface.
-
-     For compression the application must provide the output buffer and
-  may optionally provide the input buffer for optimization. For decompression,
-  the application must provide the input buffer and may optionally provide
-  the output buffer for optimization.
-
-     Compression can be done in a single step if the buffers are large
-  enough (for example if an input file is mmap'ed), or can be done by
-  repeated calls of the compression function.  In the latter case, the
-  application must provide more input and/or consume the output
-  (providing more output space) before each call.
-*/
-
-typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
-typedef void   (*free_func)  OF((voidpf opaque, voidpf address, uInt nbytes));
-
-typedef void   (*cb_func)    OF((Bytef *buf, uInt len));
-
-struct internal_state;
-
-typedef struct z_stream_s {
-    Bytef    *next_in;  /* next input byte */
-    uInt     avail_in;  /* number of bytes available at next_in */
-    uLong    total_in;  /* total nb of input bytes read so far */
-
-    Bytef    *next_out; /* next output byte should be put there */
-    uInt     avail_out; /* remaining free space at next_out */
-    uLong    total_out; /* total nb of bytes output so far */
-
-    char     *msg;      /* last error message, NULL if no error */
-    struct internal_state FAR *state; /* not visible by applications */
-
-    alloc_func zalloc;  /* used to allocate the internal state */
-    free_func  zfree;   /* used to free the internal state */
-    voidp      opaque;  /* private data object passed to zalloc and zfree */
-
-    Byte     data_type; /* best guess about the data type: ascii or binary */
-
-    cb_func  outcb;	/* called regularly just before blocks of output */
-
-} z_stream;
-
-/*
-   The application must update next_in and avail_in when avail_in has
-   dropped to zero. It must update next_out and avail_out when avail_out
-   has dropped to zero. The application must initialize zalloc, zfree and
-   opaque before calling the init function. All other fields are set by the
-   compression library and must not be updated by the application.
-
-   The opaque value provided by the application will be passed as the first
-   parameter for calls of zalloc and zfree. This can be useful for custom
-   memory management. The compression library attaches no meaning to the
-   opaque value.
-
-   zalloc must return Z_NULL if there is not enough memory for the object.
-   On 16-bit systems, the functions zalloc and zfree must be able to allocate
-   exactly 65536 bytes, but will not be required to allocate more than this
-   if the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS,
-   pointers returned by zalloc for objects of exactly 65536 bytes *must*
-   have their offset normalized to zero. The default allocation function
-   provided by this library ensures this (see zutil.c). To reduce memory
-   requirements and avoid any allocation of 64K objects, at the expense of
-   compression ratio, compile the library with -DMAX_WBITS=14 (see zconf.h).
-
-   The fields total_in and total_out can be used for statistics or
-   progress reports. After compression, total_in holds the total size of
-   the uncompressed data and may be saved for use in the decompressor
-   (particularly if the decompressor wants to decompress everything in
-   a single step).
-*/
-
-			/* constants */
-
-#define Z_NO_FLUSH      0
-#define Z_PARTIAL_FLUSH 1
-#define Z_FULL_FLUSH    2
-#define Z_SYNC_FLUSH    3 /* experimental: partial_flush + byte align */
-#define Z_FINISH        4
-#define Z_PACKET_FLUSH	5
-/* See deflate() below for the usage of these constants */
-
-#define Z_OK            0
-#define Z_STREAM_END    1
-#define Z_ERRNO        (-1)
-#define Z_STREAM_ERROR (-2)
-#define Z_DATA_ERROR   (-3)
-#define Z_MEM_ERROR    (-4)
-#define Z_BUF_ERROR    (-5)
-/* error codes for the compression/decompression functions */
-
-#define Z_BEST_SPEED             1
-#define Z_BEST_COMPRESSION       9
-#define Z_DEFAULT_COMPRESSION  (-1)
-/* compression levels */
-
-#define Z_FILTERED            1
-#define Z_HUFFMAN_ONLY        2
-#define Z_DEFAULT_STRATEGY    0
-
-#define Z_BINARY   0
-#define Z_ASCII    1
-#define Z_UNKNOWN  2
-/* Used to set the data_type field */
-
-#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */
-
-extern char *zlib_version;
-/* The application can compare zlib_version and ZLIB_VERSION for consistency.
-   If the first character differs, the library code actually used is
-   not compatible with the zlib.h header file used by the application.
- */
-
-			/* basic functions */
-
-extern int inflateInit OF((z_stream *strm));
-/*
-     Initializes the internal stream state for decompression. The fields
-   zalloc and zfree must be initialized before by the caller.  If zalloc and
-   zfree are set to Z_NULL, inflateInit updates them to use default allocation
-   functions.
-
-     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not
-   enough memory.  msg is set to null if there is no error message.
-   inflateInit does not perform any decompression: this will be done by
-   inflate().
-*/
-
-
-extern int inflate OF((z_stream *strm, int flush));
-/*
-  Performs one or both of the following actions:
-
-  - Decompress more input starting at next_in and update next_in and avail_in
-    accordingly. If not all input can be processed (because there is not
-    enough room in the output buffer), next_in is updated and processing
-    will resume at this point for the next call of inflate().
-
-  - Provide more output starting at next_out and update next_out and avail_out
-    accordingly.  inflate() always provides as much output as possible
-    (until there is no more input data or no more space in the output buffer).
-
-  Before the call of inflate(), the application should ensure that at least
-  one of the actions is possible, by providing more input and/or consuming
-  more output, and updating the next_* and avail_* values accordingly.
-  The application can consume the uncompressed output when it wants, for
-  example when the output buffer is full (avail_out == 0), or after each
-  call of inflate().
-
-    If the parameter flush is set to Z_PARTIAL_FLUSH or Z_PACKET_FLUSH,
-  inflate flushes as much output as possible to the output buffer. The
-  flushing behavior of inflate is not specified for values of the flush
-  parameter other than Z_PARTIAL_FLUSH, Z_PACKET_FLUSH or Z_FINISH, but the
-  current implementation actually flushes as much output as possible
-  anyway.  For Z_PACKET_FLUSH, inflate checks that once all the input data
-  has been consumed, it is expecting to see the length field of a stored
-  block; if not, it returns Z_DATA_ERROR.
-
-    inflate() should normally be called until it returns Z_STREAM_END or an
-  error. However if all decompression is to be performed in a single step
-  (a single call of inflate), the parameter flush should be set to
-  Z_FINISH. In this case all pending input is processed and all pending
-  output is flushed; avail_out must be large enough to hold all the
-  uncompressed data. (The size of the uncompressed data may have been saved
-  by the compressor for this purpose.) The next operation on this stream must
-  be inflateEnd to deallocate the decompression state. The use of Z_FINISH
-  is never required, but can be used to inform inflate that a faster routine
-  may be used for the single inflate() call.
-
-    inflate() returns Z_OK if some progress has been made (more input
-  processed or more output produced), Z_STREAM_END if the end of the
-  compressed data has been reached and all uncompressed output has been
-  produced, Z_DATA_ERROR if the input data was corrupted, Z_STREAM_ERROR if
-  the stream structure was inconsistent (for example if next_in or next_out
-  was NULL), Z_MEM_ERROR if there was not enough memory, Z_BUF_ERROR if no
-  progress is possible or if there was not enough room in the output buffer
-  when Z_FINISH is used. In the Z_DATA_ERROR case, the application may then
-  call inflateSync to look for a good compression block.  */
-
-
-extern int inflateEnd OF((z_stream *strm));
-/*
-     All dynamically allocated data structures for this stream are freed.
-   This function discards any unprocessed input and does not flush any
-   pending output.
-
-     inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state
-   was inconsistent. In the error case, msg may be set but then points to a
-   static string (which must not be deallocated).
-*/
-
-			/* advanced functions */
-
-extern int inflateInit2 OF((z_stream *strm,
-			    int  windowBits));
-/*
-     This is another version of inflateInit with more compression options. The
-   fields next_out, zalloc and zfree must be initialized before by the caller.
-
-     The windowBits parameter is the base two logarithm of the maximum window
-   size (the size of the history buffer).  It should be in the range 8..15 for
-   this version of the library (the value 16 will be allowed soon). The
-   default value is 15 if inflateInit is used instead. If a compressed stream
-   with a larger window size is given as input, inflate() will return with
-   the error code Z_DATA_ERROR instead of trying to allocate a larger window.
-
-     If next_out is not null, the library will use this buffer for the history
-   buffer; the buffer must either be large enough to hold the entire output
-   data, or have at least 1<<windowBits bytes.  If next_out is null, the
-   library will allocate its own buffer (and leave next_out null). next_in
-   need not be provided here but must be provided by the application for the
-   next call of inflate().
-
-     If the history buffer is provided by the application, next_out must
-   never be changed by the application since the decompressor maintains
-   history information inside this buffer from call to call; the application
-   can only reset next_out to the beginning of the history buffer when
-   avail_out is zero and all output has been consumed.
-
-      inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was
-   not enough memory, Z_STREAM_ERROR if a parameter is invalid (such as
-   windowBits < 8). msg is set to null if there is no error message.
-   inflateInit2 does not perform any decompression: this will be done by
-   inflate().
-*/
-
-extern int inflateSync OF((z_stream *strm));
-/*
-    Skips invalid compressed data until the special marker (see deflate()
-  above) can be found, or until all available input is skipped. No output
-  is provided.
-
-    inflateSync returns Z_OK if the special marker has been found, Z_BUF_ERROR
-  if no more input was provided, Z_DATA_ERROR if no marker has been found,
-  or Z_STREAM_ERROR if the stream structure was inconsistent. In the success
-  case, the application may save the current current value of total_in which
-  indicates where valid compressed data was found. In the error case, the
-  application may repeatedly call inflateSync, providing more input each time,
-  until success or end of the input data.
-*/
-
-extern int inflateReset OF((z_stream *strm));
-/*
-     This function is equivalent to inflateEnd followed by inflateInit,
-   but does not free and reallocate all the internal decompression state.
-   The stream will keep attributes that may have been set by inflateInit2.
-
-      inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent (such as zalloc or state being NULL).
-*/
-
-extern int inflateIncomp OF((z_stream *strm));
-/*
-     This function adds the data at next_in (avail_in bytes) to the output
-   history without performing any output.  There must be no pending output,
-   and the decompressor must be expecting to see the start of a block.
-   Calling this function is equivalent to decompressing a stored block
-   containing the data at next_in (except that the data is not output).
-*/
-
-			/* checksum functions */
-
-/*
-     This function is not related to compression but is exported
-   anyway because it might be useful in applications using the
-   compression library.
-*/
-
-extern uLong adler32 OF((uLong adler, Bytef *buf, uInt len));
-
-/*
-     Update a running Adler-32 checksum with the bytes buf[0..len-1] and
-   return the updated checksum. If buf is NULL, this function returns
-   the required initial value for the checksum.
-   An Adler-32 checksum is almost as reliable as a CRC32 but can be computed
-   much faster. Usage example:
-
-     uLong adler = adler32(0L, Z_NULL, 0);
-
-     while (read_buffer(buffer, length) != EOF) {
-       adler = adler32(adler, buffer, length);
-     }
-     if (adler != original_adler) error();
-*/
-
-#ifndef _Z_UTIL_H
-    struct internal_state {int dummy;}; /* hack for buggy compilers */
-#endif
-
-#endif /* _ZLIB_H */
diff --git a/lib_arm/armlinux.c b/lib_arm/armlinux.c
index 6d32a411fd..24ba39b0f6 100644
--- a/lib_arm/armlinux.c
+++ b/lib_arm/armlinux.c
@@ -24,7 +24,7 @@
 #include <common.h>
 #include <command.h>
 #include <image.h>
-#include <zlib.h>
+#include <u-boot/zlib.h>
 #include <asm/byteorder.h>
 #ifdef CONFIG_HAS_DATAFLASH
 #include <dataflash.h>
diff --git a/lib_avr32/avr32_linux.c b/lib_avr32/avr32_linux.c
index 62afbd2497..6e85923659 100644
--- a/lib_avr32/avr32_linux.c
+++ b/lib_avr32/avr32_linux.c
@@ -22,7 +22,7 @@
 #include <common.h>
 #include <command.h>
 #include <image.h>
-#include <zlib.h>
+#include <u-boot/zlib.h>
 #include <asm/byteorder.h>
 #include <asm/addrspace.h>
 #include <asm/io.h>
diff --git a/lib_blackfin/bf533_linux.c b/lib_blackfin/bf533_linux.c
index 80a3dc7d6e..d666cfd216 100644
--- a/lib_blackfin/bf533_linux.c
+++ b/lib_blackfin/bf533_linux.c
@@ -30,7 +30,7 @@
 #include <common.h>
 #include <command.h>
 #include <image.h>
-#include <zlib.h>
+#include <u-boot/zlib.h>
 #include <asm/byteorder.h>
 
 #define	LINUX_MAX_ENVS		256
diff --git a/lib_generic/Makefile b/lib_generic/Makefile
index 9713353ddf..52db2dcb37 100644
--- a/lib_generic/Makefile
+++ b/lib_generic/Makefile
@@ -38,14 +38,16 @@ COBJS-y += ldiv.o
 COBJS-y += sha1.o
 COBJS-y += string.o
 COBJS-y += vsprintf.o
-COBJS-y += zlib.o
 
 COBJS	:= $(COBJS-y)
 SRCS 	:= $(COBJS:.o=.c)
 OBJS	:= $(addprefix $(obj),$(COBJS))
+OBJS	+= $(addprefix $(obj),zlib.o)
 
 $(LIB):	$(obj).depend $(OBJS)
 	$(AR) $(ARFLAGS) $@ $(OBJS)
+zlib.o: zlib.c
+	$(CC) $(CFLAGS) -O2 -c -o $@ $<
 
 #########################################################################
 
diff --git a/lib_generic/crc32.c b/lib_generic/crc32.c
index df0dbca346..16e43f6c7c 100644
--- a/lib_generic/crc32.c
+++ b/lib_generic/crc32.c
@@ -12,7 +12,7 @@
 #include <common.h>
 #endif
 
-#include "zlib.h"
+#include "u-boot/zlib.h"
 
 #define local static
 #define ZEXPORT	/* empty */
diff --git a/lib_generic/display_options.c b/lib_generic/display_options.c
index 5ddd94fd5a..25af4d50af 100644
--- a/lib_generic/display_options.c
+++ b/lib_generic/display_options.c
@@ -39,17 +39,17 @@ int display_options (void)
 }
 
 /*
- * print sizes as "xxx kB", "xxx.y kB", "xxx MB" or "xxx.y MB" as needed;
+ * print sizes as "xxx KiB", "xxx.y KiB", "xxx MiB" or "xxx.y MiB" as needed;
  * allow for optional trailing string (like "\n")
  */
 void print_size (ulong size, const char *s)
 {
 	ulong m, n;
-	ulong d = 1 << 20;		/* 1 MB */
+	ulong d = 1 << 20;		/* 1 MiB */
 	char  c = 'M';
 
-	if (size < d) {			/* print in kB */
-		c = 'k';
+	if (size < d) {			/* print in KiB */
+		c = 'K';
 		d = 1 << 10;
 	}
 
@@ -62,11 +62,11 @@ void print_size (ulong size, const char *s)
 		n += 1;
 	}
 
-	printf ("%2ld", n);
+	printf ("%3ld", n);
 	if (m) {
 		printf (".%ld", m);
 	}
-	printf (" %cB%s", c, s);
+	printf (" %ciB%s", c, s);
 }
 
 /*
diff --git a/lib_generic/sha1.c b/lib_generic/sha1.c
index 08ffa6b9ba..5690d2904a 100644
--- a/lib_generic/sha1.c
+++ b/lib_generic/sha1.c
@@ -29,7 +29,12 @@
 #define _CRT_SECURE_NO_DEPRECATE 1
 #endif
 
+#ifdef USE_HOSTCC
+#include <string.h>
+#else
 #include <linux/string.h>
+#endif
+
 #include "sha1.h"
 
 /*
diff --git a/lib_generic/zlib.c b/lib_generic/zlib.c
index 668ac8f808..8fe3bd0dd1 100644
--- a/lib_generic/zlib.c
+++ b/lib_generic/zlib.c
@@ -1,5 +1,5 @@
 /*
- * This file is derived from various .h and .c files from the zlib-0.95
+ * This file is derived from various .h and .c files from the zlib-1.2.3
  * distribution by Jean-loup Gailly and Mark Adler, with some additions
  * by Paul Mackerras to aid in implementing Deflate compression and
  * decompression for PPP packets.  See zlib.h for conditions of
@@ -14,7 +14,7 @@
 
 /*+++++*/
 /* zutil.h -- internal interface and configuration of the compression library
- * Copyright (C) 1995 Jean-loup Gailly.
+ * Copyright (C) 1995-2005 Jean-loup Gailly.
  * For conditions of distribution and use, see copyright notice in zlib.h
  */
 
@@ -23,28 +23,29 @@
    subject to change. Applications should only use zlib.h.
  */
 
-/* From: zutil.h,v 1.9 1995/05/03 17:27:12 jloup Exp */
+#define ZUTIL_H
+#define ZLIB_INTERNAL
 
-#define _Z_UTIL_H
-
-#include "zlib.h"
+#include "u-boot/zlib.h"
+#include <common.h>
+/* To avoid a build time warning */
+#ifdef STDC
+#include <malloc.h>
+#endif
 
 #ifndef local
-#  define local static
+#define local static
 #endif
 /* compile with -Dlocal if your debugger can't find static symbols */
 
-#define FAR
-
-typedef unsigned char  uch;
+typedef unsigned char uch;
 typedef uch FAR uchf;
 typedef unsigned short ush;
 typedef ush FAR ushf;
-typedef unsigned long  ulg;
+typedef unsigned long ulg;
 
-extern char *z_errmsg[]; /* indexed by 1-zlib_error */
-
-#define ERR_RETURN(strm,err) return (strm->msg=z_errmsg[1-err], err)
+#define ERR_MSG(err) z_errmsg[Z_NEED_DICT-(err)]
+#define ERR_RETURN(strm,err) return (strm->msg = (char*)ERR_MSG(err), (err))
 /* To be used only when the state is known to be valid */
 
 #ifndef NULL
@@ -53,17 +54,15 @@ extern char *z_errmsg[]; /* indexed by 1-zlib_error */
 
 	/* common constants */
 
-#define DEFLATED   8
-
 #ifndef DEF_WBITS
-#  define DEF_WBITS MAX_WBITS
+#define DEF_WBITS MAX_WBITS
 #endif
 /* default windowBits for decompression. MAX_WBITS is for compression only */
 
 #if MAX_MEM_LEVEL >= 8
-#  define DEF_MEM_LEVEL 8
+#define DEF_MEM_LEVEL 8
 #else
-#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL
+#define DEF_MEM_LEVEL  MAX_MEM_LEVEL
 #endif
 /* default memLevel */
 
@@ -72,103 +71,47 @@ extern char *z_errmsg[]; /* indexed by 1-zlib_error */
 #define DYN_TREES    2
 /* The three kinds of block type */
 
-#define MIN_MATCH  3
-#define MAX_MATCH  258
+#define MIN_MATCH 3
+#define MAX_MATCH 258
 /* The minimum and maximum match lengths */
 
 	 /* functions */
 
 #include <linux/string.h>
 #define zmemcpy memcpy
-#define zmemzero(dest, len)	memset(dest, 0, len)
+#define zmemcmp memcmp
+#define zmemzero(dest, len) memset(dest, 0, len)
 
 /* Diagnostic functions */
-#ifdef DEBUG_ZLIB
-#  include <stdio.h>
-#  ifndef verbose
-#    define verbose 0
-#  endif
-#  define Assert(cond,msg) {if(!(cond)) z_error(msg);}
-#  define Trace(x) fprintf x
-#  define Tracev(x) {if (verbose) fprintf x ;}
-#  define Tracevv(x) {if (verbose>1) fprintf x ;}
-#  define Tracec(c,x) {if (verbose && (c)) fprintf x ;}
-#  define Tracecv(c,x) {if (verbose>1 && (c)) fprintf x ;}
+#ifdef DEBUG
+	extern int z_verbose;
+	extern void z_error    OF((char *m));
+#define Assert(cond,msg) {if(!(cond)) z_error(msg);}
+#define fprintf(fp,...)	printf(__VA_ARGS__)
+#define Trace(x) {if (z_verbose>=0) fprintf x ;}
+#define Tracev(x) {if (z_verbose>0) fprintf x ;}
+#define Tracevv(x) {if (z_verbose>1) fprintf x ;}
+#define Tracec(c,x) {if (z_verbose>0 && (c)) fprintf x ;}
+#define Tracecv(c,x) {if (z_verbose>1 && (c)) fprintf x ;}
 #else
-#  define Assert(cond,msg)
-#  define Trace(x)
-#  define Tracev(x)
-#  define Tracevv(x)
-#  define Tracec(c,x)
-#  define Tracecv(c,x)
+#define Assert(cond,msg)
+#define Trace(x)
+#define Tracev(x)
+#define Tracevv(x)
+#define Tracec(c,x)
+#define Tracecv(c,x)
 #endif
 
-
-typedef uLong (*check_func) OF((uLong check, Bytef *buf, uInt len));
-
-/* voidpf zcalloc OF((voidpf opaque, unsigned items, unsigned size)); */
-/* void   zcfree  OF((voidpf opaque, voidpf ptr)); */
+voidpf zcalloc OF((voidpf opaque, unsigned items, unsigned size));
+void zcfree  OF((voidpf opaque, voidpf ptr, unsigned size));
 
 #define ZALLOC(strm, items, size) \
-	   (*((strm)->zalloc))((strm)->opaque, (items), (size))
-#define ZFREE(strm, addr, size)	\
-	   (*((strm)->zfree))((strm)->opaque, (voidpf)(addr), (size))
-#define TRY_FREE(s, p, n) {if (p) ZFREE(s, p, n);}
-
-/* deflate.h -- internal compression state
- * Copyright (C) 1995 Jean-loup Gailly
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-
-/*+++++*/
-/* infblock.h -- header to use infblock.c
- * Copyright (C) 1995 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-
-struct inflate_blocks_state;
-typedef struct inflate_blocks_state FAR inflate_blocks_statef;
-
-local inflate_blocks_statef * inflate_blocks_new OF((
-    z_stream *z,
-    check_func c,               /* check function */
-    uInt w));                   /* window size */
-
-local int inflate_blocks OF((
-    inflate_blocks_statef *,
-    z_stream *,
-    int));                      /* initial return code */
-
-local void inflate_blocks_reset OF((
-    inflate_blocks_statef *,
-    z_stream *,
-    uLongf *));                  /* check value on output */
-
-local int inflate_blocks_free OF((
-    inflate_blocks_statef *,
-    z_stream *,
-    uLongf *));                  /* check value on output */
-
-local int inflate_addhistory OF((
-    inflate_blocks_statef *,
-    z_stream *));
-
-local int inflate_packet_flush OF((
-    inflate_blocks_statef *));
+	(*((strm)->zalloc))((strm)->opaque, (items), (size))
+#define ZFREE(strm, addr)  (*((strm)->zfree))((strm)->opaque, (voidpf)(addr), 0)
 
 /*+++++*/
 /* inftrees.h -- header to use inftrees.c
- * Copyright (C) 1995 Mark Adler
+ * Copyright (C) 1995-2005 Mark Adler
  * For conditions of distribution and use, see copyright notice in zlib.h
  */
 
@@ -177,60 +120,47 @@ local int inflate_packet_flush OF((
    subject to change. Applications should only use zlib.h.
  */
 
-/* Huffman code lookup table entry--this entry is four bytes for machines
-   that have 16-bit pointers (e.g. PC's in the small or medium model). */
-
-typedef struct inflate_huft_s FAR inflate_huft;
-
-struct inflate_huft_s {
-  union {
-    struct {
-      Byte Exop;        /* number of extra bits or operation */
-      Byte Bits;        /* number of bits in this code or subcode */
-    } what;
-    uInt Nalloc;	/* number of these allocated here */
-    Bytef *pad;         /* pad structure to a power of 2 (4 bytes for */
-  } word;               /*  16-bit, 8 bytes for 32-bit machines) */
-  union {
-    uInt Base;          /* literal, length base, or distance base */
-    inflate_huft *Next; /* pointer to next level of table */
-  } more;
-};
-
-#ifdef DEBUG_ZLIB
-  local uInt inflate_hufts;
-#endif
-
-local int inflate_trees_bits OF((
-    uIntf *,                    /* 19 code lengths */
-    uIntf *,                    /* bits tree desired/actual depth */
-    inflate_huft * FAR *,       /* bits tree result */
-    z_stream *));               /* for zalloc, zfree functions */
-
-local int inflate_trees_dynamic OF((
-    uInt,                       /* number of literal/length codes */
-    uInt,                       /* number of distance codes */
-    uIntf *,                    /* that many (total) code lengths */
-    uIntf *,                    /* literal desired/actual bit depth */
-    uIntf *,                    /* distance desired/actual bit depth */
-    inflate_huft * FAR *,       /* literal/length tree result */
-    inflate_huft * FAR *,       /* distance tree result */
-    z_stream *));               /* for zalloc, zfree functions */
-
-local int inflate_trees_fixed OF((
-    uIntf *,                    /* literal desired/actual bit depth */
-    uIntf *,                    /* distance desired/actual bit depth */
-    inflate_huft * FAR *,       /* literal/length tree result */
-    inflate_huft * FAR *));     /* distance tree result */
-
-local int inflate_trees_free OF((
-    inflate_huft *,             /* tables to free */
-    z_stream *));               /* for zfree function */
-
-
+/* Structure for decoding tables.  Each entry provides either the
+   information needed to do the operation requested by the code that
+   indexed that table entry, or it provides a pointer to another
+   table that indexes more bits of the code.  op indicates whether
+   the entry is a pointer to another table, a literal, a length or
+   distance, an end-of-block, or an invalid code.  For a table
+   pointer, the low four bits of op is the number of index bits of
+   that table.  For a length or distance, the low four bits of op
+   is the number of extra bits to get after the code.  bits is
+   the number of bits in this code or part of the code to drop off
+   of the bit buffer.  val is the actual byte to output in the case
+   of a literal, the base length or distance, or the offset from
+   the current table to the next table.  Each entry is four bytes. */
+
+typedef struct {
+	unsigned char op;           /* operation, extra bits, table bits */
+	unsigned char bits;         /* bits in this part of the code */
+	unsigned short val;         /* offset in table or code value */
+} code;
+
+/* Maximum size of dynamic tree.  The maximum found in a long but non-
+   exhaustive search was 1444 code structures (852 for length/literals
+   and 592 for distances, the latter actually the result of an
+   exhaustive search).  The true maximum is not known, but the value
+   below is more than safe. */
+#define ENOUGH 2048
+#define MAXD 592
+
+/* Type of code to build for inftable() */
+typedef enum {
+	CODES,
+	LENS,
+	DISTS
+} codetype;
+
+extern int inflate_table OF((codetype type, unsigned short FAR *lens,
+				unsigned codes, code FAR * FAR *table,
+				unsigned FAR *bits, unsigned short FAR *work));
 /*+++++*/
-/* infcodes.h -- header to use infcodes.c
- * Copyright (C) 1995 Mark Adler
+/* inflate.h -- internal inflate state definition
+ * Copyright (C) 1995-2004 Mark Adler
  * For conditions of distribution and use, see copyright notice in zlib.h
  */
 
@@ -239,437 +169,113 @@ local int inflate_trees_free OF((
    subject to change. Applications should only use zlib.h.
  */
 
-struct inflate_codes_state;
-typedef struct inflate_codes_state FAR inflate_codes_statef;
-
-local inflate_codes_statef *inflate_codes_new OF((
-    uInt, uInt,
-    inflate_huft *, inflate_huft *,
-    z_stream *));
-
-local int inflate_codes OF((
-    inflate_blocks_statef *,
-    z_stream *,
-    int));
-
-local void inflate_codes_free OF((
-    inflate_codes_statef *,
-    z_stream *));
-
-
-/*+++++*/
-/* inflate.c -- zlib interface to inflate modules
- * Copyright (C) 1995 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* inflate private state */
-struct internal_state {
-
-  /* mode */
-  enum {
-      METHOD,   /* waiting for method byte */
-      FLAG,     /* waiting for flag byte */
-      BLOCKS,   /* decompressing blocks */
-      CHECK4,   /* four check bytes to go */
-      CHECK3,   /* three check bytes to go */
-      CHECK2,   /* two check bytes to go */
-      CHECK1,   /* one check byte to go */
-      DONE,     /* finished check, done */
-      BAD}      /* got an error--stay here */
-    mode;               /* current inflate mode */
-
-  /* mode dependent information */
-  union {
-    uInt method;        /* if FLAGS, method byte */
-    struct {
-      uLong was;                /* computed check value */
-      uLong need;               /* stream check value */
-    } check;            /* if CHECK, check values to compare */
-    uInt marker;        /* if BAD, inflateSync's marker bytes count */
-  } sub;        /* submode */
-
-  /* mode independent information */
-  int  nowrap;          /* flag for no wrapper */
-  uInt wbits;           /* log2(window size)  (8..15, defaults to 15) */
-  inflate_blocks_statef
-    *blocks;            /* current inflate_blocks state */
-
-};
-
-
-int inflateReset(z)
-z_stream *z;
-{
-  uLong c;
-
-  if (z == Z_NULL || z->state == Z_NULL)
-    return Z_STREAM_ERROR;
-  z->total_in = z->total_out = 0;
-  z->msg = Z_NULL;
-  z->state->mode = z->state->nowrap ? BLOCKS : METHOD;
-  inflate_blocks_reset(z->state->blocks, z, &c);
-  Trace((stderr, "inflate: reset\n"));
-  return Z_OK;
-}
-
-
-int inflateEnd(z)
-z_stream *z;
-{
-  uLong c;
-
-  if (z == Z_NULL || z->state == Z_NULL || z->zfree == Z_NULL)
-    return Z_STREAM_ERROR;
-  if (z->state->blocks != Z_NULL)
-    inflate_blocks_free(z->state->blocks, z, &c);
-  ZFREE(z, z->state, sizeof(struct internal_state));
-  z->state = Z_NULL;
-  Trace((stderr, "inflate: end\n"));
-  return Z_OK;
-}
-
-
-int inflateInit2(z, w)
-z_stream *z;
-int w;
-{
-  /* initialize state */
-  if (z == Z_NULL)
-    return Z_STREAM_ERROR;
-/*  if (z->zalloc == Z_NULL) z->zalloc = zcalloc; */
-/*  if (z->zfree == Z_NULL) z->zfree = zcfree; */
-  if ((z->state = (struct internal_state FAR *)
-       ZALLOC(z,1,sizeof(struct internal_state))) == Z_NULL)
-    return Z_MEM_ERROR;
-  z->state->blocks = Z_NULL;
-
-  /* handle undocumented nowrap option (no zlib header or check) */
-  z->state->nowrap = 0;
-  if (w < 0)
-  {
-    w = - w;
-    z->state->nowrap = 1;
-  }
-
-  /* set window size */
-  if (w < 8 || w > 15)
-  {
-    inflateEnd(z);
-    return Z_STREAM_ERROR;
-  }
-  z->state->wbits = (uInt)w;
-
-  /* create inflate_blocks state */
-  if ((z->state->blocks =
-       inflate_blocks_new(z, z->state->nowrap ? Z_NULL : adler32, 1 << w))
-      == Z_NULL)
-  {
-    inflateEnd(z);
-    return Z_MEM_ERROR;
-  }
-  Trace((stderr, "inflate: allocated\n"));
-
-  /* reset state */
-  inflateReset(z);
-  return Z_OK;
-}
-
-
-int inflateInit(z)
-z_stream *z;
-{
-  return inflateInit2(z, DEF_WBITS);
-}
-
-
-#define NEEDBYTE {if(z->avail_in==0)goto empty;r=Z_OK;}
-#define NEXTBYTE (z->avail_in--,z->total_in++,*z->next_in++)
-
-int inflate(z, f)
-z_stream *z;
-int f;
-{
-  int r;
-  uInt b;
-
-  if (z == Z_NULL || z->next_in == Z_NULL)
-    return Z_STREAM_ERROR;
-  r = Z_BUF_ERROR;
-  while (1) switch (z->state->mode)
-  {
-    case METHOD:
-      NEEDBYTE
-      if (((z->state->sub.method = NEXTBYTE) & 0xf) != DEFLATED)
-      {
-	z->state->mode = BAD;
-	z->msg = "unknown compression method";
-	z->state->sub.marker = 5;       /* can't try inflateSync */
-	break;
-      }
-      if ((z->state->sub.method >> 4) + 8 > z->state->wbits)
-      {
-	z->state->mode = BAD;
-	z->msg = "invalid window size";
-	z->state->sub.marker = 5;       /* can't try inflateSync */
-	break;
-      }
-      z->state->mode = FLAG;
-    case FLAG:
-      NEEDBYTE
-      if ((b = NEXTBYTE) & 0x20)
-      {
-	z->state->mode = BAD;
-	z->msg = "invalid reserved bit";
-	z->state->sub.marker = 5;       /* can't try inflateSync */
-	break;
-      }
-      if (((z->state->sub.method << 8) + b) % 31)
-      {
-	z->state->mode = BAD;
-	z->msg = "incorrect header check";
-	z->state->sub.marker = 5;       /* can't try inflateSync */
-	break;
-      }
-      Trace((stderr, "inflate: zlib header ok\n"));
-      z->state->mode = BLOCKS;
-    case BLOCKS:
-      r = inflate_blocks(z->state->blocks, z, r);
-      if (f == Z_PACKET_FLUSH && z->avail_in == 0 && z->avail_out != 0)
-	  r = inflate_packet_flush(z->state->blocks);
-      if (r == Z_DATA_ERROR)
-      {
-	z->state->mode = BAD;
-	z->state->sub.marker = 0;       /* can try inflateSync */
-	break;
-      }
-      if (r != Z_STREAM_END)
-	return r;
-      r = Z_OK;
-      inflate_blocks_reset(z->state->blocks, z, &z->state->sub.check.was);
-      if (z->state->nowrap)
-      {
-	z->state->mode = DONE;
-	break;
-      }
-      z->state->mode = CHECK4;
-    case CHECK4:
-      NEEDBYTE
-      z->state->sub.check.need = (uLong)NEXTBYTE << 24;
-      z->state->mode = CHECK3;
-    case CHECK3:
-      NEEDBYTE
-      z->state->sub.check.need += (uLong)NEXTBYTE << 16;
-      z->state->mode = CHECK2;
-    case CHECK2:
-      NEEDBYTE
-      z->state->sub.check.need += (uLong)NEXTBYTE << 8;
-      z->state->mode = CHECK1;
-    case CHECK1:
-      NEEDBYTE
-      z->state->sub.check.need += (uLong)NEXTBYTE;
-
-      if (z->state->sub.check.was != z->state->sub.check.need)
-      {
-	z->state->mode = BAD;
-	z->msg = "incorrect data check";
-	z->state->sub.marker = 5;       /* can't try inflateSync */
-	break;
-      }
-      Trace((stderr, "inflate: zlib check ok\n"));
-      z->state->mode = DONE;
-    case DONE:
-      return Z_STREAM_END;
-    case BAD:
-      return Z_DATA_ERROR;
-    default:
-      return Z_STREAM_ERROR;
-  }
-
- empty:
-  if (f != Z_PACKET_FLUSH)
-    return r;
-  z->state->mode = BAD;
-  z->state->sub.marker = 0;       /* can try inflateSync */
-  return Z_DATA_ERROR;
-}
+#define GUNZIP
+
+/* Possible inflate modes between inflate() calls */
+typedef enum {
+	HEAD, /* i: waiting for magic header */
+	FLAGS, /* i: waiting for method and flags (gzip) */
+	TIME, /* i: waiting for modification time (gzip) */
+	OS, /* i: waiting for extra flags and operating system (gzip) */
+	EXLEN, /* i: waiting for extra length (gzip) */
+	EXTRA, /* i: waiting for extra bytes (gzip) */
+	NAME, /* i: waiting for end of file name (gzip) */
+	COMMENT, /* i: waiting for end of comment (gzip) */
+	HCRC, /* i: waiting for header crc (gzip) */
+	DICTID, /* i: waiting for dictionary check value */
+	DICT, /* waiting for inflateSetDictionary() call */
+	TYPE, /* i: waiting for type bits, including last-flag bit */
+	TYPEDO, /* i: same, but skip check to exit inflate on new block */
+	STORED, /* i: waiting for stored size (length and complement) */
+	COPY, /* i/o: waiting for input or output to copy stored block */
+	TABLE, /* i: waiting for dynamic block table lengths */
+	LENLENS, /* i: waiting for code length code lengths */
+	CODELENS, /* i: waiting for length/lit and distance code lengths */
+	LEN, /* i: waiting for length/lit code */
+	LENEXT, /* i: waiting for length extra bits */
+	DIST, /* i: waiting for distance code */
+	DISTEXT, /* i: waiting for distance extra bits */
+	MATCH, /* o: waiting for output space to copy string */
+	LIT, /* o: waiting for output space to write literal */
+	CHECK, /* i: waiting for 32-bit check value */
+	LENGTH, /* i: waiting for 32-bit length (gzip) */
+	DONE, /* finished check, done -- remain here until reset */
+	BAD, /* got a data error -- remain here until reset */
+	MEM, /* got an inflate() memory error -- remain here until reset */
+	SYNC, /* looking for synchronization bytes to restart inflate() */
+	START,
+	WASH,
+	END,
+	BADCODE
+} inflate_mode;
 
 /*
- * This subroutine adds the data at next_in/avail_in to the output history
- * without performing any output.  The output buffer must be "caught up";
- * i.e. no pending output (hence s->read equals s->write), and the state must
- * be BLOCKS (i.e. we should be willing to see the start of a series of
- * BLOCKS).  On exit, the output will also be caught up, and the checksum
- * will have been updated if need be.
- */
-
-int inflateIncomp(z)
-z_stream *z;
-{
-    if (z->state->mode != BLOCKS)
-	return Z_DATA_ERROR;
-    return inflate_addhistory(z->state->blocks, z);
-}
-
-
-int inflateSync(z)
-z_stream *z;
-{
-  uInt n;       /* number of bytes to look at */
-  Bytef *p;     /* pointer to bytes */
-  uInt m;       /* number of marker bytes found in a row */
-  uLong r, w;   /* temporaries to save total_in and total_out */
-
-  /* set up */
-  if (z == Z_NULL || z->state == Z_NULL)
-    return Z_STREAM_ERROR;
-  if (z->state->mode != BAD)
-  {
-    z->state->mode = BAD;
-    z->state->sub.marker = 0;
-  }
-  if ((n = z->avail_in) == 0)
-    return Z_BUF_ERROR;
-  p = z->next_in;
-  m = z->state->sub.marker;
-
-  /* search */
-  while (n && m < 4)
-  {
-    if (*p == (Byte)(m < 2 ? 0 : 0xff))
-      m++;
-    else if (*p)
-      m = 0;
-    else
-      m = 4 - m;
-    p++, n--;
-  }
-
-  /* restore */
-  z->total_in += p - z->next_in;
-  z->next_in = p;
-  z->avail_in = n;
-  z->state->sub.marker = m;
-
-  /* return no joy or set up to restart on a new block */
-  if (m != 4)
-    return Z_DATA_ERROR;
-  r = z->total_in;  w = z->total_out;
-  inflateReset(z);
-  z->total_in = r;  z->total_out = w;
-  z->state->mode = BLOCKS;
-  return Z_OK;
-}
-
-#undef NEEDBYTE
-#undef NEXTBYTE
-
-/*+++++*/
-/* infutil.h -- types and macros common to blocks and codes
- * Copyright (C) 1995 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
+    State transitions between above modes -
+
+    (most modes can go to the BAD or MEM mode -- not shown for clarity)
+
+    Process header:
+        HEAD -> (gzip) or (zlib)
+        (gzip) -> FLAGS -> TIME -> OS -> EXLEN -> EXTRA -> NAME
+        NAME -> COMMENT -> HCRC -> TYPE
+        (zlib) -> DICTID or TYPE
+        DICTID -> DICT -> TYPE
+    Read deflate blocks:
+            TYPE -> STORED or TABLE or LEN or CHECK
+            STORED -> COPY -> TYPE
+            TABLE -> LENLENS -> CODELENS -> LEN
+    Read deflate codes:
+                LEN -> LENEXT or LIT or TYPE
+                LENEXT -> DIST -> DISTEXT -> MATCH -> LEN
+                LIT -> LEN
+    Process trailer:
+        CHECK -> LENGTH -> DONE
  */
 
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-
-/* inflate blocks semi-private state */
-struct inflate_blocks_state {
-
-  /* mode */
-  enum {
-      TYPE,     /* get type bits (3, including end bit) */
-      LENS,     /* get lengths for stored */
-      STORED,   /* processing stored block */
-      TABLE,    /* get table lengths */
-      BTREE,    /* get bit lengths tree for a dynamic block */
-      DTREE,    /* get length, distance trees for a dynamic block */
-      CODES,    /* processing fixed or dynamic block */
-      DRY,      /* output remaining window bytes */
-      DONEB,     /* finished last block, done */
-      BADB}      /* got a data error--stuck here */
-    mode;               /* current inflate_block mode */
-
-  /* mode dependent information */
-  union {
-    uInt left;          /* if STORED, bytes left to copy */
-    struct {
-      uInt table;               /* table lengths (14 bits) */
-      uInt index;               /* index into blens (or border) */
-      uIntf *blens;             /* bit lengths of codes */
-      uInt bb;                  /* bit length tree depth */
-      inflate_huft *tb;         /* bit length decoding tree */
-      int nblens;		/* # elements allocated at blens */
-    } trees;            /* if DTREE, decoding info for trees */
-    struct {
-      inflate_huft *tl, *td;    /* trees to free */
-      inflate_codes_statef
-	 *codes;
-    } decode;           /* if CODES, current state */
-  } sub;                /* submode */
-  uInt last;            /* true if this block is the last block */
-
-  /* mode independent information */
-  uInt bitk;            /* bits in bit buffer */
-  uLong bitb;           /* bit buffer */
-  Bytef *window;        /* sliding window */
-  Bytef *end;           /* one byte after sliding window */
-  Bytef *read;          /* window read pointer */
-  Bytef *write;         /* window write pointer */
-  check_func checkfn;   /* check function */
-  uLong check;          /* check on output */
-
+/* state maintained between inflate() calls.  Approximately 7K bytes. */
+struct inflate_state {
+	inflate_mode mode; /* current inflate mode */
+	int last; /* true if processing last block */
+	int wrap; /* bit 0 true for zlib, bit 1 true for gzip */
+	int havedict; /* true if dictionary provided */
+	int flags; /* gzip header method and flags (0 if zlib) */
+	unsigned dmax; /* zlib header max distance (INFLATE_STRICT) */
+	unsigned long check; /* protected copy of check value */
+	unsigned long total; /* protected copy of output count */
+	gz_headerp head; /* where to save gzip header information */
+        /* sliding window */
+	unsigned wbits; /* log base 2 of requested window size */
+	unsigned wsize; /* window size or zero if not using window */
+	unsigned whave; /* valid bytes in the window */
+	unsigned write; /* window write index */
+	unsigned char FAR *window; /* allocated sliding window, if needed */
+        /* bit accumulator */
+	unsigned long hold; /* input bit accumulator */
+	unsigned bits; /* number of bits in "in" */
+        /* for string and stored block copying */
+	unsigned length; /* literal or length of data to copy */
+	unsigned offset; /* distance back to copy string from */
+        /* for table and code decoding */
+	unsigned extra; /* extra bits needed */
+        /* fixed and dynamic code tables */
+	code const FAR *lencode; /* starting table for length/literal codes */
+	code const FAR *distcode; /* starting table for distance codes */
+	unsigned lenbits; /* index bits for lencode */
+	unsigned distbits; /* index bits for distcode */
+        /* dynamic table building */
+	unsigned ncode; /* number of code length code lengths */
+	unsigned nlen; /* number of length code lengths */
+	unsigned ndist; /* number of distance code lengths */
+	unsigned have; /* number of code lengths in lens[] */
+	code FAR *next; /* next available space in codes[] */
+	unsigned short lens[320]; /* temporary storage for code lengths */
+	unsigned short work[288]; /* work area for code table building */
+	code codes[ENOUGH]; /* space for code tables */
 };
 
-
-/* defines for inflate input/output */
-/*   update pointers and return */
-#define UPDBITS {s->bitb=b;s->bitk=k;}
-#define UPDIN {z->avail_in=n;z->total_in+=p-z->next_in;z->next_in=p;}
-#define UPDOUT {s->write=q;}
-#define UPDATE {UPDBITS UPDIN UPDOUT}
-#define LEAVE {UPDATE return inflate_flush(s,z,r);}
-/*   get bytes and bits */
-#define LOADIN {p=z->next_in;n=z->avail_in;b=s->bitb;k=s->bitk;}
-#define NEEDBYTE {if(n)r=Z_OK;else LEAVE}
-#define NEXTBYTE (n--,*p++)
-#define NEEDBITS(j) {while(k<(j)){NEEDBYTE;b|=((uLong)NEXTBYTE)<<k;k+=8;}}
-#define DUMPBITS(j) {b>>=(j);k-=(j);}
-/*   output bytes */
-#define WAVAIL (q<s->read?s->read-q-1:s->end-q)
-#define LOADOUT {q=s->write;m=WAVAIL;}
-#define WRAP {if(q==s->end&&s->read!=s->window){q=s->window;m=WAVAIL;}}
-#define FLUSH {UPDOUT r=inflate_flush(s,z,r); LOADOUT}
-#define NEEDOUT {if(m==0){WRAP if(m==0){FLUSH WRAP if(m==0) LEAVE}}r=Z_OK;}
-#define OUTBYTE(a) {*q++=(Byte)(a);m--;}
-/*   load local pointers */
-#define LOAD {LOADIN LOADOUT}
-
-/*
- * The IBM 150 firmware munges the data right after _etext[].  This
- * protects it. -- Cort
- */
-#if 0
-local uInt protect_mask[] = {0, 0, 0, 0, 0, 0, 0, 0, 0 ,0 ,0 ,0};
-#endif
-/* And'ing with mask[n] masks the lower n bits */
-local uInt inflate_mask[] = {
-    0x0000,
-    0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,
-    0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff
-};
-
-/* copy as much as possible from the sliding window to the output area */
-local int inflate_flush OF((
-    inflate_blocks_statef *,
-    z_stream *,
-    int));
-
 /*+++++*/
 /* inffast.h -- header to use inffast.c
- * Copyright (C) 1995 Mark Adler
+ * Copyright (C) 1995-2003 Mark Adler
  * For conditions of distribution and use, see copyright notice in zlib.h
  */
 
@@ -678,1484 +284,1902 @@ local int inflate_flush OF((
    subject to change. Applications should only use zlib.h.
  */
 
-local int inflate_fast OF((
-    uInt,
-    uInt,
-    inflate_huft *,
-    inflate_huft *,
-    inflate_blocks_statef *,
-    z_stream *));
+void inflate_fast OF((z_streamp strm, unsigned start));
+/*+++++*/
+    /* inffixed.h -- table for decoding fixed codes
+     * Generated automatically by makefixed().
+     */
+
+    /* WARNING: this file should *not* be used by applications. It
+       is part of the implementation of the compression library and
+       is subject to change. Applications should only use zlib.h.
+     */
+
+	static const code lenfix[512] = {
+	{96,7,0},{0,8,80},{0,8,16},{20,8,115},{18,7,31},{0,8,112},{0,8,48},
+	{0,9,192},{16,7,10},{0,8,96},{0,8,32},{0,9,160},{0,8,0},{0,8,128},
+	{0,8,64},{0,9,224},{16,7,6},{0,8,88},{0,8,24},{0,9,144},{19,7,59},
+	{0,8,120},{0,8,56},{0,9,208},{17,7,17},{0,8,104},{0,8,40},{0,9,176},
+	{0,8,8},{0,8,136},{0,8,72},{0,9,240},{16,7,4},{0,8,84},{0,8,20},
+	{21,8,227},{19,7,43},{0,8,116},{0,8,52},{0,9,200},{17,7,13},{0,8,100},
+	{0,8,36},{0,9,168},{0,8,4},{0,8,132},{0,8,68},{0,9,232},{16,7,8},
+	{0,8,92},{0,8,28},{0,9,152},{20,7,83},{0,8,124},{0,8,60},{0,9,216},
+	{18,7,23},{0,8,108},{0,8,44},{0,9,184},{0,8,12},{0,8,140},{0,8,76},
+	{0,9,248},{16,7,3},{0,8,82},{0,8,18},{21,8,163},{19,7,35},{0,8,114},
+	{0,8,50},{0,9,196},{17,7,11},{0,8,98},{0,8,34},{0,9,164},{0,8,2},
+	{0,8,130},{0,8,66},{0,9,228},{16,7,7},{0,8,90},{0,8,26},{0,9,148},
+	{20,7,67},{0,8,122},{0,8,58},{0,9,212},{18,7,19},{0,8,106},{0,8,42},
+	{0,9,180},{0,8,10},{0,8,138},{0,8,74},{0,9,244},{16,7,5},{0,8,86},
+	{0,8,22},{64,8,0},{19,7,51},{0,8,118},{0,8,54},{0,9,204},{17,7,15},
+	{0,8,102},{0,8,38},{0,9,172},{0,8,6},{0,8,134},{0,8,70},{0,9,236},
+	{16,7,9},{0,8,94},{0,8,30},{0,9,156},{20,7,99},{0,8,126},{0,8,62},
+	{0,9,220},{18,7,27},{0,8,110},{0,8,46},{0,9,188},{0,8,14},{0,8,142},
+	{0,8,78},{0,9,252},{96,7,0},{0,8,81},{0,8,17},{21,8,131},{18,7,31},
+	{0,8,113},{0,8,49},{0,9,194},{16,7,10},{0,8,97},{0,8,33},{0,9,162},
+	{0,8,1},{0,8,129},{0,8,65},{0,9,226},{16,7,6},{0,8,89},{0,8,25},
+	{0,9,146},{19,7,59},{0,8,121},{0,8,57},{0,9,210},{17,7,17},{0,8,105},
+	{0,8,41},{0,9,178},{0,8,9},{0,8,137},{0,8,73},{0,9,242},{16,7,4},
+	{0,8,85},{0,8,21},{16,8,258},{19,7,43},{0,8,117},{0,8,53},{0,9,202},
+	{17,7,13},{0,8,101},{0,8,37},{0,9,170},{0,8,5},{0,8,133},{0,8,69},
+	{0,9,234},{16,7,8},{0,8,93},{0,8,29},{0,9,154},{20,7,83},{0,8,125},
+	{0,8,61},{0,9,218},{18,7,23},{0,8,109},{0,8,45},{0,9,186},{0,8,13},
+	{0,8,141},{0,8,77},{0,9,250},{16,7,3},{0,8,83},{0,8,19},{21,8,195},
+	{19,7,35},{0,8,115},{0,8,51},{0,9,198},{17,7,11},{0,8,99},{0,8,35},
+	{0,9,166},{0,8,3},{0,8,131},{0,8,67},{0,9,230},{16,7,7},{0,8,91},
+	{0,8,27},{0,9,150},{20,7,67},{0,8,123},{0,8,59},{0,9,214},{18,7,19},
+	{0,8,107},{0,8,43},{0,9,182},{0,8,11},{0,8,139},{0,8,75},{0,9,246},
+	{16,7,5},{0,8,87},{0,8,23},{64,8,0},{19,7,51},{0,8,119},{0,8,55},
+	{0,9,206},{17,7,15},{0,8,103},{0,8,39},{0,9,174},{0,8,7},{0,8,135},
+	{0,8,71},{0,9,238},{16,7,9},{0,8,95},{0,8,31},{0,9,158},{20,7,99},
+	{0,8,127},{0,8,63},{0,9,222},{18,7,27},{0,8,111},{0,8,47},{0,9,190},
+	{0,8,15},{0,8,143},{0,8,79},{0,9,254},{96,7,0},{0,8,80},{0,8,16},
+	{20,8,115},{18,7,31},{0,8,112},{0,8,48},{0,9,193},{16,7,10},{0,8,96},
+	{0,8,32},{0,9,161},{0,8,0},{0,8,128},{0,8,64},{0,9,225},{16,7,6},
+	{0,8,88},{0,8,24},{0,9,145},{19,7,59},{0,8,120},{0,8,56},{0,9,209},
+	{17,7,17},{0,8,104},{0,8,40},{0,9,177},{0,8,8},{0,8,136},{0,8,72},
+	{0,9,241},{16,7,4},{0,8,84},{0,8,20},{21,8,227},{19,7,43},{0,8,116},
+	{0,8,52},{0,9,201},{17,7,13},{0,8,100},{0,8,36},{0,9,169},{0,8,4},
+	{0,8,132},{0,8,68},{0,9,233},{16,7,8},{0,8,92},{0,8,28},{0,9,153},
+	{20,7,83},{0,8,124},{0,8,60},{0,9,217},{18,7,23},{0,8,108},{0,8,44},
+	{0,9,185},{0,8,12},{0,8,140},{0,8,76},{0,9,249},{16,7,3},{0,8,82},
+	{0,8,18},{21,8,163},{19,7,35},{0,8,114},{0,8,50},{0,9,197},{17,7,11},
+	{0,8,98},{0,8,34},{0,9,165},{0,8,2},{0,8,130},{0,8,66},{0,9,229},
+	{16,7,7},{0,8,90},{0,8,26},{0,9,149},{20,7,67},{0,8,122},{0,8,58},
+	{0,9,213},{18,7,19},{0,8,106},{0,8,42},{0,9,181},{0,8,10},{0,8,138},
+	{0,8,74},{0,9,245},{16,7,5},{0,8,86},{0,8,22},{64,8,0},{19,7,51},
+	{0,8,118},{0,8,54},{0,9,205},{17,7,15},{0,8,102},{0,8,38},{0,9,173},
+	{0,8,6},{0,8,134},{0,8,70},{0,9,237},{16,7,9},{0,8,94},{0,8,30},
+	{0,9,157},{20,7,99},{0,8,126},{0,8,62},{0,9,221},{18,7,27},{0,8,110},
+	{0,8,46},{0,9,189},{0,8,14},{0,8,142},{0,8,78},{0,9,253},{96,7,0},
+	{0,8,81},{0,8,17},{21,8,131},{18,7,31},{0,8,113},{0,8,49},{0,9,195},
+	{16,7,10},{0,8,97},{0,8,33},{0,9,163},{0,8,1},{0,8,129},{0,8,65},
+	{0,9,227},{16,7,6},{0,8,89},{0,8,25},{0,9,147},{19,7,59},{0,8,121},
+	{0,8,57},{0,9,211},{17,7,17},{0,8,105},{0,8,41},{0,9,179},{0,8,9},
+	{0,8,137},{0,8,73},{0,9,243},{16,7,4},{0,8,85},{0,8,21},{16,8,258},
+	{19,7,43},{0,8,117},{0,8,53},{0,9,203},{17,7,13},{0,8,101},{0,8,37},
+	{0,9,171},{0,8,5},{0,8,133},{0,8,69},{0,9,235},{16,7,8},{0,8,93},
+	{0,8,29},{0,9,155},{20,7,83},{0,8,125},{0,8,61},{0,9,219},{18,7,23},
+	{0,8,109},{0,8,45},{0,9,187},{0,8,13},{0,8,141},{0,8,77},{0,9,251},
+	{16,7,3},{0,8,83},{0,8,19},{21,8,195},{19,7,35},{0,8,115},{0,8,51},
+	{0,9,199},{17,7,11},{0,8,99},{0,8,35},{0,9,167},{0,8,3},{0,8,131},
+	{0,8,67},{0,9,231},{16,7,7},{0,8,91},{0,8,27},{0,9,151},{20,7,67},
+	{0,8,123},{0,8,59},{0,9,215},{18,7,19},{0,8,107},{0,8,43},{0,9,183},
+	{0,8,11},{0,8,139},{0,8,75},{0,9,247},{16,7,5},{0,8,87},{0,8,23},
+	{64,8,0},{19,7,51},{0,8,119},{0,8,55},{0,9,207},{17,7,15},{0,8,103},
+	{0,8,39},{0,9,175},{0,8,7},{0,8,135},{0,8,71},{0,9,239},{16,7,9},
+	{0,8,95},{0,8,31},{0,9,159},{20,7,99},{0,8,127},{0,8,63},{0,9,223},
+	{18,7,27},{0,8,111},{0,8,47},{0,9,191},{0,8,15},{0,8,143},{0,8,79},
+	{0,9,255}
+	};
 
+	static const code distfix[32] = {
+	{16,5,1},{23,5,257},{19,5,17},{27,5,4097},{17,5,5},{25,5,1025},
+	{21,5,65},{29,5,16385},{16,5,3},{24,5,513},{20,5,33},{28,5,8193},
+	{18,5,9},{26,5,2049},{22,5,129},{64,5,0},{16,5,2},{23,5,385},
+	{19,5,25},{27,5,6145},{17,5,7},{25,5,1537},{21,5,97},{29,5,24577},
+	{16,5,4},{24,5,769},{20,5,49},{28,5,12289},{18,5,13},{26,5,3073},
+	{22,5,193},{64,5,0}
+	};
 
 /*+++++*/
-/* infblock.c -- interpret and process block types to last block
- * Copyright (C) 1995 Mark Adler
+/* inffast.c -- fast decoding
+ * Copyright (C) 1995-2004 Mark Adler
  * For conditions of distribution and use, see copyright notice in zlib.h
  */
 
-/* Table for deflate from PKZIP's appnote.txt. */
-local uInt border[] = { /* Order of the bit length code lengths */
-	16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
+/* Allow machine dependent optimization for post-increment or pre-increment.
+   Based on testing to date,
+   Pre-increment preferred for:
+   - PowerPC G3 (Adler)
+   - MIPS R5000 (Randers-Pehrson)
+   Post-increment preferred for:
+   - none
+   No measurable difference:
+   - Pentium III (Anderson)
+   - M68060 (Nikl)
+ */
+#define OFF 1
+#define PUP(a) *++(a)
 
 /*
-   Notes beyond the 1.93a appnote.txt:
-
-   1. Distance pointers never point before the beginning of the output
-      stream.
-   2. Distance pointers can point back across blocks, up to 32k away.
-   3. There is an implied maximum of 7 bits for the bit length table and
-      15 bits for the actual data.
-   4. If only one code exists, then it is encoded using one bit.  (Zero
-      would be more efficient, but perhaps a little confusing.)  If two
-      codes exist, they are coded using one bit each (0 and 1).
-   5. There is no way of sending zero distance codes--a dummy must be
-      sent if there are none.  (History: a pre 2.0 version of PKZIP would
-      store blocks with no distance codes, but this was discovered to be
-      too harsh a criterion.)  Valid only for 1.93a.  2.04c does allow
-      zero distance codes, which is sent as one code of zero bits in
-      length.
-   6. There are up to 286 literal/length codes.  Code 256 represents the
-      end-of-block.  Note however that the static length tree defines
-      288 codes just to fill out the Huffman codes.  Codes 286 and 287
-      cannot be used though, since there is no length base or extra bits
-      defined for them.  Similarily, there are up to 30 distance codes.
-      However, static trees define 32 codes (all 5 bits) to fill out the
-      Huffman codes, but the last two had better not show up in the data.
-   7. Unzip can check dynamic Huffman blocks for complete code sets.
-      The exception is that a single code would not be complete (see #4).
-   8. The five bits following the block type is really the number of
-      literal codes sent minus 257.
-   9. Length codes 8,16,16 are interpreted as 13 length codes of 8 bits
-      (1+6+6).  Therefore, to output three times the length, you output
-      three codes (1+1+1), whereas to output four times the same length,
-      you only need two codes (1+3).  Hmm.
-  10. In the tree reconstruction algorithm, Code = Code + Increment
-      only if BitLength(i) is not zero.  (Pretty obvious.)
-  11. Correction: 4 Bits: # of Bit Length codes - 4     (4 - 19)
-  12. Note: length code 284 can represent 227-258, but length code 285
-      really is 258.  The last length deserves its own, short code
-      since it gets used a lot in very redundant files.  The length
-      258 is special since 258 - 3 (the min match length) is 255.
-  13. The literal/length and distance code bit lengths are read as a
-      single stream of lengths.  It is possible (and advantageous) for
-      a repeat code (16, 17, or 18) to go across the boundary between
-      the two sets of lengths.
- */
+   Decode literal, length, and distance codes and write out the resulting
+   literal and match bytes until either not enough input or output is
+   available, an end-of-block is encountered, or a data error is encountered.
+   When large enough input and output buffers are supplied to inflate(), for
+   example, a 16K input buffer and a 64K output buffer, more than 95% of the
+   inflate execution time is spent in this routine.
 
+   Entry assumptions:
 
-local void inflate_blocks_reset(s, z, c)
-inflate_blocks_statef *s;
-z_stream *z;
-uLongf *c;
-{
-  if (s->checkfn != Z_NULL)
-    *c = s->check;
-  if (s->mode == BTREE || s->mode == DTREE)
-    ZFREE(z, s->sub.trees.blens, s->sub.trees.nblens * sizeof(uInt));
-  if (s->mode == CODES)
-  {
-    inflate_codes_free(s->sub.decode.codes, z);
-    inflate_trees_free(s->sub.decode.td, z);
-    inflate_trees_free(s->sub.decode.tl, z);
-  }
-  s->mode = TYPE;
-  s->bitk = 0;
-  s->bitb = 0;
-  s->read = s->write = s->window;
-  if (s->checkfn != Z_NULL)
-    s->check = (*s->checkfn)(0L, Z_NULL, 0);
-  if (z->outcb != Z_NULL)
-    (*z->outcb)(Z_NULL, 0);
-  Trace((stderr, "inflate:   blocks reset\n"));
-}
+        state->mode == LEN
+        strm->avail_in >= 6
+        strm->avail_out >= 258
+        start >= strm->avail_out
+        state->bits < 8
+
+   On return, state->mode is one of:
+
+        LEN -- ran out of enough output space or enough available input
+        TYPE -- reached end of block code, inflate() to interpret next block
+        BAD -- error in block data
 
+   Notes:
 
-local inflate_blocks_statef *inflate_blocks_new(z, c, w)
-z_stream *z;
-check_func c;
-uInt w;
+    - The maximum input bits used by a length/distance pair is 15 bits for the
+      length code, 5 bits for the length extra, 15 bits for the distance code,
+      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
+      Therefore if strm->avail_in >= 6, then there is enough input to avoid
+      checking for available input while decoding.
+
+    - The maximum bytes that a single length/distance pair can output is 258
+      bytes, which is the maximum length that can be coded.  inflate_fast()
+      requires strm->avail_out >= 258 for each loop to avoid checking for
+      output space.
+ */
+void inflate_fast(strm, start)
+z_streamp strm;
+unsigned start;         /* inflate()'s starting value for strm->avail_out */
 {
-  inflate_blocks_statef *s;
-
-  if ((s = (inflate_blocks_statef *)ZALLOC
-       (z,1,sizeof(struct inflate_blocks_state))) == Z_NULL)
-    return s;
-  if ((s->window = (Bytef *)ZALLOC(z, 1, w)) == Z_NULL)
-  {
-    ZFREE(z, s, sizeof(struct inflate_blocks_state));
-    return Z_NULL;
-  }
-  s->end = s->window + w;
-  s->checkfn = c;
-  s->mode = TYPE;
-  Trace((stderr, "inflate:   blocks allocated\n"));
-  inflate_blocks_reset(s, z, &s->check);
-  return s;
+    struct inflate_state FAR *state;
+    unsigned char FAR *in;      /* local strm->next_in */
+    unsigned char FAR *last;    /* while in < last, enough input available */
+    unsigned char FAR *out;     /* local strm->next_out */
+    unsigned char FAR *beg;     /* inflate()'s initial strm->next_out */
+    unsigned char FAR *end;     /* while out < end, enough space available */
+#ifdef INFLATE_STRICT
+    unsigned dmax;              /* maximum distance from zlib header */
+#endif
+    unsigned wsize;             /* window size or zero if not using window */
+    unsigned whave;             /* valid bytes in the window */
+    unsigned write;             /* window write index */
+    unsigned char FAR *window;  /* allocated sliding window, if wsize != 0 */
+    unsigned long hold;         /* local strm->hold */
+    unsigned bits;              /* local strm->bits */
+    code const FAR *lcode;      /* local strm->lencode */
+    code const FAR *dcode;      /* local strm->distcode */
+    unsigned lmask;             /* mask for first level of length codes */
+    unsigned dmask;             /* mask for first level of distance codes */
+    code this;                  /* retrieved table entry */
+    unsigned op;                /* code bits, operation, extra bits, or */
+                                /*  window position, window bytes to copy */
+    unsigned len;               /* match length, unused bytes */
+    unsigned dist;              /* match distance */
+    unsigned char FAR *from;    /* where to copy match from */
+
+    /* copy state to local variables */
+    state = (struct inflate_state FAR *)strm->state;
+    in = strm->next_in - OFF;
+    last = in + (strm->avail_in - 5);
+    out = strm->next_out - OFF;
+    beg = out - (start - strm->avail_out);
+    end = out + (strm->avail_out - 257);
+#ifdef INFLATE_STRICT
+    dmax = state->dmax;
+#endif
+    wsize = state->wsize;
+    whave = state->whave;
+    write = state->write;
+    window = state->window;
+    hold = state->hold;
+    bits = state->bits;
+    lcode = state->lencode;
+    dcode = state->distcode;
+    lmask = (1U << state->lenbits) - 1;
+    dmask = (1U << state->distbits) - 1;
+
+    /* decode literals and length/distances until end-of-block or not enough
+       input data or output space */
+    do {
+        if (bits < 15) {
+            hold += (unsigned long)(PUP(in)) << bits;
+            bits += 8;
+            hold += (unsigned long)(PUP(in)) << bits;
+            bits += 8;
+        }
+        this = lcode[hold & lmask];
+      dolen:
+        op = (unsigned)(this.bits);
+        hold >>= op;
+        bits -= op;
+        op = (unsigned)(this.op);
+        if (op == 0) {                          /* literal */
+            Tracevv((stderr, this.val >= 0x20 && this.val < 0x7f ?
+                    "inflate:         literal '%c'\n" :
+                    "inflate:         literal 0x%02x\n", this.val));
+            PUP(out) = (unsigned char)(this.val);
+        }
+        else if (op & 16) {                     /* length base */
+            len = (unsigned)(this.val);
+            op &= 15;                           /* number of extra bits */
+            if (op) {
+                if (bits < op) {
+                    hold += (unsigned long)(PUP(in)) << bits;
+                    bits += 8;
+                }
+                len += (unsigned)hold & ((1U << op) - 1);
+                hold >>= op;
+                bits -= op;
+            }
+            Tracevv((stderr, "inflate:         length %u\n", len));
+            if (bits < 15) {
+                hold += (unsigned long)(PUP(in)) << bits;
+                bits += 8;
+                hold += (unsigned long)(PUP(in)) << bits;
+                bits += 8;
+            }
+            this = dcode[hold & dmask];
+          dodist:
+            op = (unsigned)(this.bits);
+            hold >>= op;
+            bits -= op;
+            op = (unsigned)(this.op);
+            if (op & 16) {                      /* distance base */
+                dist = (unsigned)(this.val);
+                op &= 15;                       /* number of extra bits */
+                if (bits < op) {
+                    hold += (unsigned long)(PUP(in)) << bits;
+                    bits += 8;
+                    if (bits < op) {
+                        hold += (unsigned long)(PUP(in)) << bits;
+                        bits += 8;
+                    }
+                }
+                dist += (unsigned)hold & ((1U << op) - 1);
+#ifdef INFLATE_STRICT
+                if (dist > dmax) {
+                    strm->msg = (char *)"invalid distance too far back";
+                    state->mode = BAD;
+                    break;
+                }
+#endif
+                hold >>= op;
+                bits -= op;
+                Tracevv((stderr, "inflate:         distance %u\n", dist));
+                op = (unsigned)(out - beg);     /* max distance in output */
+                if (dist > op) {                /* see if copy from window */
+                    op = dist - op;             /* distance back in window */
+                    if (op > whave) {
+                        strm->msg = (char *)"invalid distance too far back";
+                        state->mode = BAD;
+                        break;
+                    }
+                    from = window - OFF;
+                    if (write == 0) {           /* very common case */
+                        from += wsize - op;
+                        if (op < len) {         /* some from window */
+                            len -= op;
+                            do {
+                                PUP(out) = PUP(from);
+                            } while (--op);
+                            from = out - dist;  /* rest from output */
+                        }
+                    }
+                    else if (write < op) {      /* wrap around window */
+                        from += wsize + write - op;
+                        op -= write;
+                        if (op < len) {         /* some from end of window */
+                            len -= op;
+                            do {
+                                PUP(out) = PUP(from);
+                            } while (--op);
+                            from = window - OFF;
+                            if (write < len) {  /* some from start of window */
+                                op = write;
+                                len -= op;
+                                do {
+                                    PUP(out) = PUP(from);
+                                } while (--op);
+                                from = out - dist;      /* rest from output */
+                            }
+                        }
+                    }
+                    else {                      /* contiguous in window */
+                        from += write - op;
+                        if (op < len) {         /* some from window */
+                            len -= op;
+                            do {
+                                PUP(out) = PUP(from);
+                            } while (--op);
+                            from = out - dist;  /* rest from output */
+                        }
+                    }
+                    while (len > 2) {
+                        PUP(out) = PUP(from);
+                        PUP(out) = PUP(from);
+                        PUP(out) = PUP(from);
+                        len -= 3;
+                    }
+                    if (len) {
+                        PUP(out) = PUP(from);
+                        if (len > 1)
+                            PUP(out) = PUP(from);
+                    }
+                }
+                else {
+                    from = out - dist;          /* copy direct from output */
+                    do {                        /* minimum length is three */
+                        PUP(out) = PUP(from);
+                        PUP(out) = PUP(from);
+                        PUP(out) = PUP(from);
+                        len -= 3;
+                    } while (len > 2);
+                    if (len) {
+                        PUP(out) = PUP(from);
+                        if (len > 1)
+                            PUP(out) = PUP(from);
+                    }
+                }
+            }
+            else if ((op & 64) == 0) {          /* 2nd level distance code */
+                this = dcode[this.val + (hold & ((1U << op) - 1))];
+                goto dodist;
+            }
+            else {
+                strm->msg = (char *)"invalid distance code";
+                state->mode = BAD;
+                break;
+            }
+        }
+        else if ((op & 64) == 0) {              /* 2nd level length code */
+            this = lcode[this.val + (hold & ((1U << op) - 1))];
+            goto dolen;
+        }
+        else if (op & 32) {                     /* end-of-block */
+            Tracevv((stderr, "inflate:         end of block\n"));
+            state->mode = TYPE;
+            break;
+        }
+        else {
+            strm->msg = (char *)"invalid literal/length code";
+            state->mode = BAD;
+            break;
+        }
+    } while (in < last && out < end);
+
+    /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
+    len = bits >> 3;
+    in -= len;
+    bits -= len << 3;
+    hold &= (1U << bits) - 1;
+
+    /* update state and return */
+    strm->next_in = in + OFF;
+    strm->next_out = out + OFF;
+    strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));
+    strm->avail_out = (unsigned)(out < end ?
+                                 257 + (end - out) : 257 - (out - end));
+    state->hold = hold;
+    state->bits = bits;
+    return;
 }
 
+/*
+   inflate_fast() speedups that turned out slower (on a PowerPC G3 750CXe):
+   - Using bit fields for code structure
+   - Different op definition to avoid & for extra bits (do & for table bits)
+   - Three separate decoding do-loops for direct, window, and write == 0
+   - Special case for distance > 1 copies to do overlapped load and store copy
+   - Explicit branch predictions (based on measured branch probabilities)
+   - Deferring match copy and interspersed it with decoding subsequent codes
+   - Swapping literal/length else
+   - Swapping window/direct else
+   - Larger unrolled copy loops (three is about right)
+   - Moving len -= 3 statement into middle of loop
+ */
+
+/*+++++*/
+/* inftrees.c -- generate Huffman trees for efficient decoding
+ * Copyright (C) 1995-2005 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
 
-local int inflate_blocks(s, z, r)
-inflate_blocks_statef *s;
-z_stream *z;
-int r;
+#define MAXBITS 15
+/*
+  If you use the zlib library in a product, an acknowledgment is welcome
+  in the documentation of your product. If for some reason you cannot
+  include such an acknowledgment, I would appreciate that you keep this
+  copyright string in the executable of your product.
+ */
+
+/*
+   Build a set of tables to decode the provided canonical Huffman code.
+   The code lengths are lens[0..codes-1].  The result starts at *table,
+   whose indices are 0..2^bits-1.  work is a writable array of at least
+   lens shorts, which is used as a work area.  type is the type of code
+   to be generated, CODES, LENS, or DISTS.  On return, zero is success,
+   -1 is an invalid code, and +1 means that ENOUGH isn't enough.  table
+   on return points to the next available entry's address.  bits is the
+   requested root table index bits, and on return it is the actual root
+   table index bits.  It will differ if the request is greater than the
+   longest code or if it is less than the shortest code.
+ */
+int inflate_table(type, lens, codes, table, bits, work)
+codetype type;
+unsigned short FAR *lens;
+unsigned codes;
+code FAR * FAR *table;
+unsigned FAR *bits;
+unsigned short FAR *work;
 {
-  uInt t;               /* temporary storage */
-  uLong b;              /* bit buffer */
-  uInt k;               /* bits in bit buffer */
-  Bytef *p;             /* input data pointer */
-  uInt n;               /* bytes available there */
-  Bytef *q;             /* output window write pointer */
-  uInt m;               /* bytes to end of window or read pointer */
-
-  /* copy input/output information to locals (UPDATE macro restores) */
-  LOAD
-
-  /* process input based on current state */
-  while (1) switch (s->mode)
-  {
-    case TYPE:
-      NEEDBITS(3)
-      t = (uInt)b & 7;
-      s->last = t & 1;
-      switch (t >> 1)
-      {
-	case 0:                         /* stored */
-	  Trace((stderr, "inflate:     stored block%s\n",
-		 s->last ? " (last)" : ""));
-	  DUMPBITS(3)
-	  t = k & 7;                    /* go to byte boundary */
-	  DUMPBITS(t)
-	  s->mode = LENS;               /* get length of stored block */
-	  break;
-	case 1:                         /* fixed */
-	  Trace((stderr, "inflate:     fixed codes block%s\n",
-		 s->last ? " (last)" : ""));
-	  {
-	    uInt bl, bd;
-	    inflate_huft *tl, *td;
-
-	    inflate_trees_fixed(&bl, &bd, &tl, &td);
-	    s->sub.decode.codes = inflate_codes_new(bl, bd, tl, td, z);
-	    if (s->sub.decode.codes == Z_NULL)
-	    {
-	      r = Z_MEM_ERROR;
-	      LEAVE
-	    }
-	    s->sub.decode.tl = Z_NULL;  /* don't try to free these */
-	    s->sub.decode.td = Z_NULL;
-	  }
-	  DUMPBITS(3)
-	  s->mode = CODES;
-	  break;
-	case 2:                         /* dynamic */
-	  Trace((stderr, "inflate:     dynamic codes block%s\n",
-		 s->last ? " (last)" : ""));
-	  DUMPBITS(3)
-	  s->mode = TABLE;
-	  break;
-	case 3:                         /* illegal */
-	  DUMPBITS(3)
-	  s->mode = BADB;
-	  z->msg = "invalid block type";
-	  r = Z_DATA_ERROR;
-	  LEAVE
-      }
-      break;
+    unsigned len;               /* a code's length in bits */
+    unsigned sym;               /* index of code symbols */
+    unsigned min, max;          /* minimum and maximum code lengths */
+    unsigned root;              /* number of index bits for root table */
+    unsigned curr;              /* number of index bits for current table */
+    unsigned drop;              /* code bits to drop for sub-table */
+    int left;                   /* number of prefix codes available */
+    unsigned used;              /* code entries in table used */
+    unsigned huff;              /* Huffman code */
+    unsigned incr;              /* for incrementing code, index */
+    unsigned fill;              /* index for replicating entries */
+    unsigned low;               /* low bits for current root entry */
+    unsigned mask;              /* mask for low root bits */
+    code this;                  /* table entry for duplication */
+    code FAR *next;             /* next available space in table */
+    const unsigned short FAR *base;     /* base value table to use */
+    const unsigned short FAR *extra;    /* extra bits table to use */
+    int end;                    /* use base and extra for symbol > end */
+    unsigned short count[MAXBITS+1];    /* number of codes of each length */
+    unsigned short offs[MAXBITS+1];     /* offsets in table for each length */
+    static const unsigned short lbase[31] = { /* Length codes 257..285 base */
+        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
+        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
+    static const unsigned short lext[31] = { /* Length codes 257..285 extra */
+        16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
+        19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 201, 196};
+    static const unsigned short dbase[32] = { /* Distance codes 0..29 base */
+        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
+        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
+        8193, 12289, 16385, 24577, 0, 0};
+    static const unsigned short dext[32] = { /* Distance codes 0..29 extra */
+        16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
+        23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
+        28, 28, 29, 29, 64, 64};
+
+    /*
+       Process a set of code lengths to create a canonical Huffman code.  The
+       code lengths are lens[0..codes-1].  Each length corresponds to the
+       symbols 0..codes-1.  The Huffman code is generated by first sorting the
+       symbols by length from short to long, and retaining the symbol order
+       for codes with equal lengths.  Then the code starts with all zero bits
+       for the first code of the shortest length, and the codes are integer
+       increments for the same length, and zeros are appended as the length
+       increases.  For the deflate format, these bits are stored backwards
+       from their more natural integer increment ordering, and so when the
+       decoding tables are built in the large loop below, the integer codes
+       are incremented backwards.
+
+       This routine assumes, but does not check, that all of the entries in
+       lens[] are in the range 0..MAXBITS.  The caller must assure this.
+       1..MAXBITS is interpreted as that code length.  zero means that that
+       symbol does not occur in this code.
+
+       The codes are sorted by computing a count of codes for each length,
+       creating from that a table of starting indices for each length in the
+       sorted table, and then entering the symbols in order in the sorted
+       table.  The sorted table is work[], with that space being provided by
+       the caller.
+
+       The length counts are used for other purposes as well, i.e. finding
+       the minimum and maximum length codes, determining if there are any
+       codes at all, checking for a valid set of lengths, and looking ahead
+       at length counts to determine sub-table sizes when building the
+       decoding tables.
+     */
+
+    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
+    for (len = 0; len <= MAXBITS; len++)
+        count[len] = 0;
+    for (sym = 0; sym < codes; sym++)
+        count[lens[sym]]++;
+
+    /* bound code lengths, force root to be within code lengths */
+    root = *bits;
+    for (max = MAXBITS; max >= 1; max--)
+        if (count[max] != 0) break;
+    if (root > max) root = max;
+    if (max == 0) {                     /* no symbols to code at all */
+        this.op = (unsigned char)64;    /* invalid code marker */
+        this.bits = (unsigned char)1;
+        this.val = (unsigned short)0;
+        *(*table)++ = this;             /* make a table to force an error */
+        *(*table)++ = this;
+        *bits = 1;
+        return 0;     /* no symbols, but wait for decoding to report error */
+    }
+    for (min = 1; min <= MAXBITS; min++)
+        if (count[min] != 0) break;
+    if (root < min) root = min;
+
+    /* check for an over-subscribed or incomplete set of lengths */
+    left = 1;
+    for (len = 1; len <= MAXBITS; len++) {
+        left <<= 1;
+        left -= count[len];
+        if (left < 0) return -1;        /* over-subscribed */
+    }
+    if (left > 0 && (type == CODES || max != 1))
+        return -1;                      /* incomplete set */
+
+    /* generate offsets into symbol table for each length for sorting */
+    offs[1] = 0;
+    for (len = 1; len < MAXBITS; len++)
+        offs[len + 1] = offs[len] + count[len];
+
+    /* sort symbols by length, by symbol order within each length */
+    for (sym = 0; sym < codes; sym++)
+        if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;
+
+    /*
+       Create and fill in decoding tables.  In this loop, the table being
+       filled is at next and has curr index bits.  The code being used is huff
+       with length len.  That code is converted to an index by dropping drop
+       bits off of the bottom.  For codes where len is less than drop + curr,
+       those top drop + curr - len bits are incremented through all values to
+       fill the table with replicated entries.
+
+       root is the number of index bits for the root table.  When len exceeds
+       root, sub-tables are created pointed to by the root entry with an index
+       of the low root bits of huff.  This is saved in low to check for when a
+       new sub-table should be started.  drop is zero when the root table is
+       being filled, and drop is root when sub-tables are being filled.
+
+       When a new sub-table is needed, it is necessary to look ahead in the
+       code lengths to determine what size sub-table is needed.  The length
+       counts are used for this, and so count[] is decremented as codes are
+       entered in the tables.
+
+       used keeps track of how many table entries have been allocated from the
+       provided *table space.  It is checked when a LENS table is being made
+       against the space in *table, ENOUGH, minus the maximum space needed by
+       the worst case distance code, MAXD.  This should never happen, but the
+       sufficiency of ENOUGH has not been proven exhaustively, hence the check.
+       This assumes that when type == LENS, bits == 9.
+
+       sym increments through all symbols, and the loop terminates when
+       all codes of length max, i.e. all codes, have been processed.  This
+       routine permits incomplete codes, so another loop after this one fills
+       in the rest of the decoding tables with invalid code markers.
+     */
+
+    /* set up for code type */
+    switch (type) {
+    case CODES:
+        base = extra = work;    /* dummy value--not used */
+        end = 19;
+        break;
     case LENS:
-      NEEDBITS(32)
-      if (((~b) >> 16) != (b & 0xffff))
-      {
-	s->mode = BADB;
-	z->msg = "invalid stored block lengths";
-	r = Z_DATA_ERROR;
-	LEAVE
-      }
-      s->sub.left = (uInt)b & 0xffff;
-      b = k = 0;                      /* dump bits */
-      Tracev((stderr, "inflate:       stored length %u\n", s->sub.left));
-      s->mode = s->sub.left ? STORED : TYPE;
-      break;
-    case STORED:
-      if (n == 0)
-	LEAVE
-      NEEDOUT
-      t = s->sub.left;
-      if (t > n) t = n;
-      if (t > m) t = m;
-      zmemcpy(q, p, t);
-      p += t;  n -= t;
-      q += t;  m -= t;
-      if ((s->sub.left -= t) != 0)
-	break;
-      Tracev((stderr, "inflate:       stored end, %lu total out\n",
-	      z->total_out + (q >= s->read ? q - s->read :
-	      (s->end - s->read) + (q - s->window))));
-      s->mode = s->last ? DRY : TYPE;
-      break;
-    case TABLE:
-      NEEDBITS(14)
-      s->sub.trees.table = t = (uInt)b & 0x3fff;
+        base = lbase;
+        base -= 257;
+        extra = lext;
+        extra -= 257;
+        end = 256;
+        break;
+    default:            /* DISTS */
+        base = dbase;
+        extra = dext;
+        end = -1;
+    }
+
+    /* initialize state for loop */
+    huff = 0;                   /* starting code */
+    sym = 0;                    /* starting code symbol */
+    len = min;                  /* starting code length */
+    next = *table;              /* current table to fill in */
+    curr = root;                /* current table index bits */
+    drop = 0;                   /* current bits to drop from code for index */
+    low = (unsigned)(-1);       /* trigger new sub-table when len > root */
+    used = 1U << root;          /* use root table entries */
+    mask = used - 1;            /* mask for comparing low */
+
+    /* check available table space */
+    if (type == LENS && used >= ENOUGH - MAXD)
+        return 1;
+
+    /* process all codes and make table entries */
+    for (;;) {
+        /* create table entry */
+        this.bits = (unsigned char)(len - drop);
+        if ((int)(work[sym]) < end) {
+            this.op = (unsigned char)0;
+            this.val = work[sym];
+        }
+        else if ((int)(work[sym]) > end) {
+            this.op = (unsigned char)(extra[work[sym]]);
+            this.val = base[work[sym]];
+        }
+        else {
+            this.op = (unsigned char)(32 + 64);         /* end of block */
+            this.val = 0;
+        }
+
+        /* replicate for those indices with low len bits equal to huff */
+        incr = 1U << (len - drop);
+        fill = 1U << curr;
+        min = fill;                 /* save offset to next table */
+        do {
+            fill -= incr;
+            next[(huff >> drop) + fill] = this;
+        } while (fill != 0);
+
+        /* backwards increment the len-bit code huff */
+        incr = 1U << (len - 1);
+        while (huff & incr)
+            incr >>= 1;
+        if (incr != 0) {
+            huff &= incr - 1;
+            huff += incr;
+        }
+        else
+            huff = 0;
+
+        /* go to next symbol, update count, len */
+        sym++;
+        if (--(count[len]) == 0) {
+            if (len == max) break;
+            len = lens[work[sym]];
+        }
+
+        /* create new sub-table if needed */
+        if (len > root && (huff & mask) != low) {
+            /* if first time, transition to sub-tables */
+            if (drop == 0)
+                drop = root;
+
+            /* increment past last table */
+            next += min;            /* here min is 1 << curr */
+
+            /* determine length of next table */
+            curr = len - drop;
+            left = (int)(1 << curr);
+            while (curr + drop < max) {
+                left -= count[curr + drop];
+                if (left <= 0) break;
+                curr++;
+                left <<= 1;
+            }
+
+            /* check for enough space */
+            used += 1U << curr;
+            if (type == LENS && used >= ENOUGH - MAXD)
+                return 1;
+
+            /* point entry in root table to sub-table */
+            low = huff & mask;
+            (*table)[low].op = (unsigned char)curr;
+            (*table)[low].bits = (unsigned char)root;
+            (*table)[low].val = (unsigned short)(next - *table);
+        }
+    }
+
+    /*
+       Fill in rest of table for incomplete codes.  This loop is similar to the
+       loop above in incrementing huff for table indices.  It is assumed that
+       len is equal to curr + drop, so there is no loop needed to increment
+       through high index bits.  When the current sub-table is filled, the loop
+       drops back to the root table to fill in any remaining entries there.
+     */
+    this.op = (unsigned char)64;                /* invalid code marker */
+    this.bits = (unsigned char)(len - drop);
+    this.val = (unsigned short)0;
+    while (huff != 0) {
+        /* when done with sub-table, drop back to root table */
+        if (drop != 0 && (huff & mask) != low) {
+            drop = 0;
+            len = root;
+            next = *table;
+            this.bits = (unsigned char)len;
+        }
+
+        /* put invalid code marker in table */
+        next[huff >> drop] = this;
+
+        /* backwards increment the len-bit code huff */
+        incr = 1U << (len - 1);
+        while (huff & incr)
+            incr >>= 1;
+        if (incr != 0) {
+            huff &= incr - 1;
+            huff += incr;
+        }
+        else
+            huff = 0;
+    }
+
+    /* set return parameters */
+    *table += used;
+    *bits = root;
+    return 0;
+}
+
+/*+++++*/
+/* inflate.c -- zlib decompression
+ * Copyright (C) 1995-2005 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+local void fixedtables OF((struct inflate_state FAR *state));
+local int updatewindow OF((z_streamp strm, unsigned out));
+
+int ZEXPORT inflateReset(strm)
+z_streamp strm;
+{
+    struct inflate_state FAR *state;
+
+    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+    state = (struct inflate_state FAR *)strm->state;
+    strm->total_in = strm->total_out = state->total = 0;
+    strm->msg = Z_NULL;
+    strm->adler = 1;        /* to support ill-conceived Java test suite */
+    state->mode = HEAD;
+    state->last = 0;
+    state->havedict = 0;
+    state->dmax = 32768U;
+    state->head = Z_NULL;
+    state->wsize = 0;
+    state->whave = 0;
+    state->write = 0;
+    state->hold = 0;
+    state->bits = 0;
+    state->lencode = state->distcode = state->next = state->codes;
+    if (strm->outcb != Z_NULL)
+	(*strm->outcb)(Z_NULL, 0);
+    Tracev((stderr, "inflate: reset\n"));
+    return Z_OK;
+}
+
+int ZEXPORT inflateInit2_(strm, windowBits, version, stream_size)
+z_streamp strm;
+int windowBits;
+const char *version;
+int stream_size;
+{
+    struct inflate_state FAR *state;
+
+    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
+        stream_size != (int)(sizeof(z_stream)))
+        return Z_VERSION_ERROR;
+    if (strm == Z_NULL) return Z_STREAM_ERROR;
+    strm->msg = Z_NULL;                 /* in case we return an error */
+    if (strm->zalloc == (alloc_func)0) {
+        strm->zalloc = zcalloc;
+        strm->opaque = (voidpf)0;
+    }
+    if (strm->zfree == (free_func)0) strm->zfree = zcfree;
+    state = (struct inflate_state FAR *)
+            ZALLOC(strm, 1, sizeof(struct inflate_state));
+    if (state == Z_NULL) return Z_MEM_ERROR;
+    Tracev((stderr, "inflate: allocated\n"));
+    strm->state = (struct internal_state FAR *)state;
+    if (windowBits < 0) {
+        state->wrap = 0;
+        windowBits = -windowBits;
+    }
+    else {
+        state->wrap = (windowBits >> 4) + 1;
+#ifdef GUNZIP
+        if (windowBits < 48) windowBits &= 15;
+#endif
+    }
+    if (windowBits < 8 || windowBits > 15) {
+        ZFREE(strm, state);
+        strm->state = Z_NULL;
+        return Z_STREAM_ERROR;
+    }
+    state->wbits = (unsigned)windowBits;
+    state->window = Z_NULL;
+    return inflateReset(strm);
+}
+
+int ZEXPORT inflateInit_(strm, version, stream_size)
+z_streamp strm;
+const char *version;
+int stream_size;
+{
+    return inflateInit2_(strm, DEF_WBITS, version, stream_size);
+}
+
+local void fixedtables(state)
+struct inflate_state FAR *state;
+{
+    state->lencode = lenfix;
+    state->lenbits = 9;
+    state->distcode = distfix;
+    state->distbits = 5;
+}
+
+/*
+   Update the window with the last wsize (normally 32K) bytes written before
+   returning.  If window does not exist yet, create it.  This is only called
+   when a window is already in use, or when output has been written during this
+   inflate call, but the end of the deflate stream has not been reached yet.
+   It is also called to create a window for dictionary data when a dictionary
+   is loaded.
+
+   Providing output buffers larger than 32K to inflate() should provide a speed
+   advantage, since only the last 32K of output is copied to the sliding window
+   upon return from inflate(), and since all distances after the first 32K of
+   output will fall in the output data, making match copies simpler and faster.
+   The advantage may be dependent on the size of the processor's data caches.
+ */
+local int updatewindow(strm, out)
+z_streamp strm;
+unsigned out;
+{
+    struct inflate_state FAR *state;
+    unsigned copy, dist;
+
+    state = (struct inflate_state FAR *)strm->state;
+
+    /* if it hasn't been done already, allocate space for the window */
+    if (state->window == Z_NULL) {
+        state->window = (unsigned char FAR *)
+                        ZALLOC(strm, 1U << state->wbits,
+                               sizeof(unsigned char));
+        if (state->window == Z_NULL) return 1;
+    }
+
+    /* if window not in use yet, initialize */
+    if (state->wsize == 0) {
+        state->wsize = 1U << state->wbits;
+        state->write = 0;
+        state->whave = 0;
+    }
+
+    /* copy state->wsize or less output bytes into the circular window */
+    copy = out - strm->avail_out;
+    if (copy >= state->wsize) {
+        zmemcpy(state->window, strm->next_out - state->wsize, state->wsize);
+        state->write = 0;
+        state->whave = state->wsize;
+    }
+    else {
+        dist = state->wsize - state->write;
+        if (dist > copy) dist = copy;
+        zmemcpy(state->window + state->write, strm->next_out - copy, dist);
+        copy -= dist;
+        if (copy) {
+            zmemcpy(state->window, strm->next_out - copy, copy);
+            state->write = copy;
+            state->whave = state->wsize;
+        }
+        else {
+            state->write += dist;
+            if (state->write == state->wsize) state->write = 0;
+            if (state->whave < state->wsize) state->whave += dist;
+        }
+    }
+    return 0;
+}
+
+/* Macros for inflate(): */
+
+/* check function to use adler32() for zlib or crc32() for gzip */
+#define UPDATE(check, buf, len) \
+	(state->flags ? crc32(check, buf, len) : adler32(check, buf, len))
+
+/* check macros for header crc */
+#define CRC2(check, word) \
+	do { \
+		hbuf[0] = (unsigned char)(word); \
+		hbuf[1] = (unsigned char)((word) >> 8); \
+		check = crc32(check, hbuf, 2); \
+	} while (0)
+
+#define CRC4(check, word) \
+	do { \
+		hbuf[0] = (unsigned char)(word); \
+		hbuf[1] = (unsigned char)((word) >> 8); \
+		hbuf[2] = (unsigned char)((word) >> 16); \
+		hbuf[3] = (unsigned char)((word) >> 24); \
+		check = crc32(check, hbuf, 4); \
+	} while (0)
+
+/* Load registers with state in inflate() for speed */
+#define LOAD() \
+	do { \
+		put = strm->next_out; \
+		left = strm->avail_out; \
+		next = strm->next_in; \
+		have = strm->avail_in; \
+		hold = state->hold; \
+		bits = state->bits; \
+	} while (0)
+
+/* Restore state from registers in inflate() */
+#define RESTORE() \
+	do { \
+		strm->next_out = put; \
+		strm->avail_out = left; \
+		strm->next_in = next; \
+		strm->avail_in = have; \
+		state->hold = hold; \
+		state->bits = bits; \
+	} while (0)
+
+/* Clear the input bit accumulator */
+#define INITBITS() \
+	do { \
+		hold = 0; \
+		bits = 0; \
+	} while (0)
+
+/* Get a byte of input into the bit accumulator, or return from inflate()
+   if there is no input available. */
+#define PULLBYTE() \
+	do { \
+		if (have == 0) goto inf_leave; \
+		have--; \
+		hold += (unsigned long)(*next++) << bits; \
+		bits += 8; \
+	} while (0)
+
+/* Assure that there are at least n bits in the bit accumulator.  If there is
+   not enough available input to do that, then return from inflate(). */
+#define NEEDBITS(n) \
+	do { \
+		while (bits < (unsigned)(n)) \
+			PULLBYTE(); \
+	} while (0)
+
+/* Return the low n bits of the bit accumulator (n < 16) */
+#define BITS(n) \
+	((unsigned)hold & ((1U << (n)) - 1))
+
+/* Remove n bits from the bit accumulator */
+#define DROPBITS(n) \
+	do { \
+		hold >>= (n); \
+		bits -= (unsigned)(n); \
+	} while (0)
+
+/* Remove zero to seven bits as needed to go to a byte boundary */
+#define BYTEBITS() \
+	do { \
+		hold >>= bits & 7; \
+		bits -= bits & 7; \
+	} while (0)
+
+/* Reverse the bytes in a 32-bit value */
+#define REVERSE(q) \
+	((((q) >> 24) & 0xff) + (((q) >> 8) & 0xff00) + \
+		(((q) & 0xff00) << 8) + (((q) & 0xff) << 24))
+
+/*
+   inflate() uses a state machine to process as much input data and generate as
+   much output data as possible before returning.  The state machine is
+   structured roughly as follows:
+
+    for (;;) switch (state) {
+    ...
+    case STATEn:
+        if (not enough input data or output space to make progress)
+            return;
+        ... make progress ...
+        state = STATEm;
+        break;
+    ...
+    }
+
+   so when inflate() is called again, the same case is attempted again, and
+   if the appropriate resources are provided, the machine proceeds to the
+   next state.  The NEEDBITS() macro is usually the way the state evaluates
+   whether it can proceed or should return.  NEEDBITS() does the return if
+   the requested bits are not available.  The typical use of the BITS macros
+   is:
+
+        NEEDBITS(n);
+        ... do something with BITS(n) ...
+        DROPBITS(n);
+
+   where NEEDBITS(n) either returns from inflate() if there isn't enough
+   input left to load n bits into the accumulator, or it continues.  BITS(n)
+   gives the low n bits in the accumulator.  When done, DROPBITS(n) drops
+   the low n bits off the accumulator.  INITBITS() clears the accumulator
+   and sets the number of available bits to zero.  BYTEBITS() discards just
+   enough bits to put the accumulator on a byte boundary.  After BYTEBITS()
+   and a NEEDBITS(8), then BITS(8) would return the next byte in the stream.
+
+   NEEDBITS(n) uses PULLBYTE() to get an available byte of input, or to return
+   if there is no input available.  The decoding of variable length codes uses
+   PULLBYTE() directly in order to pull just enough bytes to decode the next
+   code, and no more.
+
+   Some states loop until they get enough input, making sure that enough
+   state information is maintained to continue the loop where it left off
+   if NEEDBITS() returns in the loop.  For example, want, need, and keep
+   would all have to actually be part of the saved state in case NEEDBITS()
+   returns:
+
+    case STATEw:
+        while (want < need) {
+            NEEDBITS(n);
+            keep[want++] = BITS(n);
+            DROPBITS(n);
+        }
+        state = STATEx;
+    case STATEx:
+
+   As shown above, if the next state is also the next case, then the break
+   is omitted.
+
+   A state may also return if there is not enough output space available to
+   complete that state.  Those states are copying stored data, writing a
+   literal byte, and copying a matching string.
+
+   When returning, a "goto inf_leave" is used to update the total counters,
+   update the check value, and determine whether any progress has been made
+   during that inflate() call in order to return the proper return code.
+   Progress is defined as a change in either strm->avail_in or strm->avail_out.
+   When there is a window, goto inf_leave will update the window with the last
+   output written.  If a goto inf_leave occurs in the middle of decompression
+   and there is no window currently, goto inf_leave will create one and copy
+   output to the window for the next call of inflate().
+
+   In this implementation, the flush parameter of inflate() only affects the
+   return code (per zlib.h).  inflate() always writes as much as possible to
+   strm->next_out, given the space available and the provided input--the effect
+   documented in zlib.h of Z_SYNC_FLUSH.  Furthermore, inflate() always defers
+   the allocation of and copying into a sliding window until necessary, which
+   provides the effect documented in zlib.h for Z_FINISH when the entire input
+   stream available.  So the only thing the flush parameter actually does is:
+   when flush is set to Z_FINISH, inflate() cannot return Z_OK.  Instead it
+   will return Z_BUF_ERROR if it has not reached the end of the stream.
+ */
+int ZEXPORT inflate(strm, flush)
+z_streamp strm;
+int flush;
+{
+    struct inflate_state FAR *state;
+    unsigned char FAR *next;    /* next input */
+    unsigned char FAR *put;     /* next output */
+    unsigned have, left;        /* available input and output */
+    unsigned long hold;         /* bit buffer */
+    unsigned bits;              /* bits in bit buffer */
+    unsigned in, out;           /* save starting available input and output */
+    unsigned copy;              /* number of stored or match bytes to copy */
+    unsigned char FAR *from;    /* where to copy match bytes from */
+    code this;                  /* current decoding table entry */
+    code last;                  /* parent table entry */
+    unsigned len;               /* length to copy for repeats, bits to drop */
+    int ret;                    /* return code */
+#ifdef GUNZIP
+    unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
+#endif
+    static const unsigned short order[19] = /* permutation of code lengths */
+        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
+
+    if (strm == Z_NULL || strm->state == Z_NULL ||
+        (strm->next_in == Z_NULL && strm->avail_in != 0))
+        return Z_STREAM_ERROR;
+
+    state = (struct inflate_state FAR *)strm->state;
+    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
+    LOAD();
+    in = have;
+    out = left;
+    ret = Z_OK;
+    for (;;)
+        switch (state->mode) {
+        case HEAD:
+            if (state->wrap == 0) {
+                state->mode = TYPEDO;
+                break;
+            }
+            NEEDBITS(16);
+#ifdef GUNZIP
+            if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */
+                state->check = crc32(0L, Z_NULL, 0);
+                CRC2(state->check, hold);
+                INITBITS();
+                state->mode = FLAGS;
+                break;
+            }
+            state->flags = 0;           /* expect zlib header */
+            if (state->head != Z_NULL)
+                state->head->done = -1;
+            if (!(state->wrap & 1) ||   /* check if zlib header allowed */
+#else
+            if (
+#endif
+                ((BITS(8) << 8) + (hold >> 8)) % 31) {
+                strm->msg = (char *)"incorrect header check";
+                state->mode = BAD;
+                break;
+            }
+            if (BITS(4) != Z_DEFLATED) {
+                strm->msg = (char *)"unknown compression method";
+                state->mode = BAD;
+                break;
+            }
+            DROPBITS(4);
+            len = BITS(4) + 8;
+            if (len > state->wbits) {
+                strm->msg = (char *)"invalid window size";
+                state->mode = BAD;
+                break;
+            }
+            state->dmax = 1U << len;
+            Tracev((stderr, "inflate:   zlib header ok\n"));
+            strm->adler = state->check = adler32(0L, Z_NULL, 0);
+            state->mode = hold & 0x200 ? DICTID : TYPE;
+            INITBITS();
+            break;
+#ifdef GUNZIP
+        case FLAGS:
+            NEEDBITS(16);
+            state->flags = (int)(hold);
+            if ((state->flags & 0xff) != Z_DEFLATED) {
+                strm->msg = (char *)"unknown compression method";
+                state->mode = BAD;
+                break;
+            }
+            if (state->flags & 0xe000) {
+                strm->msg = (char *)"unknown header flags set";
+                state->mode = BAD;
+                break;
+            }
+            if (state->head != Z_NULL)
+                state->head->text = (int)((hold >> 8) & 1);
+            if (state->flags & 0x0200) CRC2(state->check, hold);
+            INITBITS();
+            state->mode = TIME;
+        case TIME:
+            NEEDBITS(32);
+            if (state->head != Z_NULL)
+                state->head->time = hold;
+            if (state->flags & 0x0200) CRC4(state->check, hold);
+            INITBITS();
+            state->mode = OS;
+        case OS:
+            NEEDBITS(16);
+            if (state->head != Z_NULL) {
+                state->head->xflags = (int)(hold & 0xff);
+                state->head->os = (int)(hold >> 8);
+            }
+            if (state->flags & 0x0200) CRC2(state->check, hold);
+            INITBITS();
+            state->mode = EXLEN;
+        case EXLEN:
+            if (state->flags & 0x0400) {
+                NEEDBITS(16);
+                state->length = (unsigned)(hold);
+                if (state->head != Z_NULL)
+                    state->head->extra_len = (unsigned)hold;
+                if (state->flags & 0x0200) CRC2(state->check, hold);
+                INITBITS();
+            }
+            else if (state->head != Z_NULL)
+                state->head->extra = Z_NULL;
+            state->mode = EXTRA;
+        case EXTRA:
+            if (state->flags & 0x0400) {
+                copy = state->length;
+                if (copy > have) copy = have;
+                if (copy) {
+                    if (state->head != Z_NULL &&
+                        state->head->extra != Z_NULL) {
+                        len = state->head->extra_len - state->length;
+                        zmemcpy(state->head->extra + len, next,
+                                len + copy > state->head->extra_max ?
+                                state->head->extra_max - len : copy);
+                    }
+                    if (state->flags & 0x0200)
+                        state->check = crc32(state->check, next, copy);
+                    have -= copy;
+                    next += copy;
+                    state->length -= copy;
+                }
+                if (state->length) goto inf_leave;
+            }
+            state->length = 0;
+            state->mode = NAME;
+        case NAME:
+            if (state->flags & 0x0800) {
+                if (have == 0) goto inf_leave;
+                copy = 0;
+                do {
+                    len = (unsigned)(next[copy++]);
+                    if (state->head != Z_NULL &&
+                            state->head->name != Z_NULL &&
+                            state->length < state->head->name_max)
+                        state->head->name[state->length++] = len;
+                } while (len && copy < have);
+                if (state->flags & 0x0200)
+                    state->check = crc32(state->check, next, copy);
+                have -= copy;
+                next += copy;
+                if (len) goto inf_leave;
+            }
+            else if (state->head != Z_NULL)
+                state->head->name = Z_NULL;
+            state->length = 0;
+            state->mode = COMMENT;
+        case COMMENT:
+            if (state->flags & 0x1000) {
+                if (have == 0) goto inf_leave;
+                copy = 0;
+                do {
+                    len = (unsigned)(next[copy++]);
+                    if (state->head != Z_NULL &&
+                            state->head->comment != Z_NULL &&
+                            state->length < state->head->comm_max)
+                        state->head->comment[state->length++] = len;
+                } while (len && copy < have);
+                if (state->flags & 0x0200)
+                    state->check = crc32(state->check, next, copy);
+                have -= copy;
+                next += copy;
+                if (len) goto inf_leave;
+            }
+            else if (state->head != Z_NULL)
+                state->head->comment = Z_NULL;
+            state->mode = HCRC;
+        case HCRC:
+            if (state->flags & 0x0200) {
+                NEEDBITS(16);
+                if (hold != (state->check & 0xffff)) {
+                    strm->msg = (char *)"header crc mismatch";
+                    state->mode = BAD;
+                    break;
+                }
+                INITBITS();
+            }
+            if (state->head != Z_NULL) {
+                state->head->hcrc = (int)((state->flags >> 9) & 1);
+                state->head->done = 1;
+            }
+            strm->adler = state->check = crc32(0L, Z_NULL, 0);
+            state->mode = TYPE;
+            break;
+#endif
+        case DICTID:
+            NEEDBITS(32);
+            strm->adler = state->check = REVERSE(hold);
+            INITBITS();
+            state->mode = DICT;
+        case DICT:
+            if (state->havedict == 0) {
+                RESTORE();
+                return Z_NEED_DICT;
+            }
+            strm->adler = state->check = adler32(0L, Z_NULL, 0);
+            state->mode = TYPE;
+        case TYPE:
+            if (flush == Z_BLOCK) goto inf_leave;
+        case TYPEDO:
+            if (state->last) {
+                BYTEBITS();
+                state->mode = CHECK;
+                break;
+            }
+            NEEDBITS(3);
+            state->last = BITS(1);
+            DROPBITS(1);
+            switch (BITS(2)) {
+            case 0:                             /* stored block */
+                Tracev((stderr, "inflate:     stored block%s\n",
+                        state->last ? " (last)" : ""));
+                state->mode = STORED;
+                break;
+            case 1:                             /* fixed block */
+                fixedtables(state);
+                Tracev((stderr, "inflate:     fixed codes block%s\n",
+                        state->last ? " (last)" : ""));
+                state->mode = LEN;              /* decode codes */
+                break;
+            case 2:                             /* dynamic block */
+                Tracev((stderr, "inflate:     dynamic codes block%s\n",
+                        state->last ? " (last)" : ""));
+                state->mode = TABLE;
+                break;
+            case 3:
+                strm->msg = (char *)"invalid block type";
+                state->mode = BAD;
+            }
+            DROPBITS(2);
+            break;
+        case STORED:
+            BYTEBITS();                         /* go to byte boundary */
+            NEEDBITS(32);
+            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {
+                strm->msg = (char *)"invalid stored block lengths";
+                state->mode = BAD;
+                break;
+            }
+            state->length = (unsigned)hold & 0xffff;
+            Tracev((stderr, "inflate:       stored length %u\n",
+                    state->length));
+            INITBITS();
+            state->mode = COPY;
+        case COPY:
+            copy = state->length;
+            if (copy) {
+                if (copy > have) copy = have;
+                if (copy > left) copy = left;
+                if (copy == 0) goto inf_leave;
+                zmemcpy(put, next, copy);
+                have -= copy;
+                next += copy;
+                left -= copy;
+                put += copy;
+                state->length -= copy;
+                break;
+            }
+            Tracev((stderr, "inflate:       stored end\n"));
+            state->mode = TYPE;
+            break;
+        case TABLE:
+            NEEDBITS(14);
+            state->nlen = BITS(5) + 257;
+            DROPBITS(5);
+            state->ndist = BITS(5) + 1;
+            DROPBITS(5);
+            state->ncode = BITS(4) + 4;
+            DROPBITS(4);
 #ifndef PKZIP_BUG_WORKAROUND
-      if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)
-      {
-	s->mode = BADB;
-	z->msg = "too many length or distance symbols";
-	r = Z_DATA_ERROR;
-	LEAVE
-      }
+            if (state->nlen > 286 || state->ndist > 30) {
+                strm->msg = (char *)"too many length or distance symbols";
+                state->mode = BAD;
+                break;
+            }
 #endif
-      t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);
-      if (t < 19)
-	t = 19;
-      if ((s->sub.trees.blens = (uIntf*)ZALLOC(z, t, sizeof(uInt))) == Z_NULL)
-      {
-	r = Z_MEM_ERROR;
-	LEAVE
-      }
-      s->sub.trees.nblens = t;
-      DUMPBITS(14)
-      s->sub.trees.index = 0;
-      Tracev((stderr, "inflate:       table sizes ok\n"));
-      s->mode = BTREE;
-    case BTREE:
-      while (s->sub.trees.index < 4 + (s->sub.trees.table >> 10))
-      {
-	NEEDBITS(3)
-	s->sub.trees.blens[border[s->sub.trees.index++]] = (uInt)b & 7;
-	DUMPBITS(3)
-      }
-      while (s->sub.trees.index < 19)
-	s->sub.trees.blens[border[s->sub.trees.index++]] = 0;
-      s->sub.trees.bb = 7;
-      t = inflate_trees_bits(s->sub.trees.blens, &s->sub.trees.bb,
-			     &s->sub.trees.tb, z);
-      if (t != Z_OK)
-      {
-	r = t;
-	if (r == Z_DATA_ERROR)
-	  s->mode = BADB;
-	LEAVE
-      }
-      s->sub.trees.index = 0;
-      Tracev((stderr, "inflate:       bits tree ok\n"));
-      s->mode = DTREE;
-    case DTREE:
-      while (t = s->sub.trees.table,
-	     s->sub.trees.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))
-      {
-	inflate_huft *h;
-	uInt i, j, c;
+            Tracev((stderr, "inflate:       table sizes ok\n"));
+            state->have = 0;
+            state->mode = LENLENS;
+        case LENLENS:
+            while (state->have < state->ncode) {
+                NEEDBITS(3);
+                state->lens[order[state->have++]] = (unsigned short)BITS(3);
+                DROPBITS(3);
+            }
+            while (state->have < 19)
+                state->lens[order[state->have++]] = 0;
+            state->next = state->codes;
+            state->lencode = (code const FAR *)(state->next);
+            state->lenbits = 7;
+            ret = inflate_table(CODES, state->lens, 19, &(state->next),
+                                &(state->lenbits), state->work);
+            if (ret) {
+                strm->msg = (char *)"invalid code lengths set";
+                state->mode = BAD;
+                break;
+            }
+            Tracev((stderr, "inflate:       code lengths ok\n"));
+            state->have = 0;
+            state->mode = CODELENS;
+        case CODELENS:
+            while (state->have < state->nlen + state->ndist) {
+                for (;;) {
+                    this = state->lencode[BITS(state->lenbits)];
+                    if ((unsigned)(this.bits) <= bits) break;
+                    PULLBYTE();
+                }
+                if (this.val < 16) {
+                    NEEDBITS(this.bits);
+                    DROPBITS(this.bits);
+                    state->lens[state->have++] = this.val;
+                }
+                else {
+                    if (this.val == 16) {
+                        NEEDBITS(this.bits + 2);
+                        DROPBITS(this.bits);
+                        if (state->have == 0) {
+                            strm->msg = (char *)"invalid bit length repeat";
+                            state->mode = BAD;
+                            break;
+                        }
+                        len = state->lens[state->have - 1];
+                        copy = 3 + BITS(2);
+                        DROPBITS(2);
+                    }
+                    else if (this.val == 17) {
+                        NEEDBITS(this.bits + 3);
+                        DROPBITS(this.bits);
+                        len = 0;
+                        copy = 3 + BITS(3);
+                        DROPBITS(3);
+                    }
+                    else {
+                        NEEDBITS(this.bits + 7);
+                        DROPBITS(this.bits);
+                        len = 0;
+                        copy = 11 + BITS(7);
+                        DROPBITS(7);
+                    }
+                    if (state->have + copy > state->nlen + state->ndist) {
+                        strm->msg = (char *)"invalid bit length repeat";
+                        state->mode = BAD;
+                        break;
+                    }
+                    while (copy--)
+                        state->lens[state->have++] = (unsigned short)len;
+                }
+            }
 
-	t = s->sub.trees.bb;
-	NEEDBITS(t)
-	h = s->sub.trees.tb + ((uInt)b & inflate_mask[t]);
-	t = h->word.what.Bits;
-	c = h->more.Base;
-	if (c < 16)
-	{
-	  DUMPBITS(t)
-	  s->sub.trees.blens[s->sub.trees.index++] = c;
-	}
-	else /* c == 16..18 */
-	{
-	  i = c == 18 ? 7 : c - 14;
-	  j = c == 18 ? 11 : 3;
-	  NEEDBITS(t + i)
-	  DUMPBITS(t)
-	  j += (uInt)b & inflate_mask[i];
-	  DUMPBITS(i)
-	  i = s->sub.trees.index;
-	  t = s->sub.trees.table;
-	  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) ||
-	      (c == 16 && i < 1))
-	  {
-	    s->mode = BADB;
-	    z->msg = "invalid bit length repeat";
-	    r = Z_DATA_ERROR;
-	    LEAVE
-	  }
-	  c = c == 16 ? s->sub.trees.blens[i - 1] : 0;
-	  do {
-	    s->sub.trees.blens[i++] = c;
-	  } while (--j);
-	  s->sub.trees.index = i;
-	}
-      }
-      inflate_trees_free(s->sub.trees.tb, z);
-      s->sub.trees.tb = Z_NULL;
-      {
-	uInt bl, bd;
-	inflate_huft *tl, *td;
-	inflate_codes_statef *c;
+            /* handle error breaks in while */
+            if (state->mode == BAD) break;
 
-	bl = 9;         /* must be <= 9 for lookahead assumptions */
-	bd = 6;         /* must be <= 9 for lookahead assumptions */
-	t = s->sub.trees.table;
-	t = inflate_trees_dynamic(257 + (t & 0x1f), 1 + ((t >> 5) & 0x1f),
-				  s->sub.trees.blens, &bl, &bd, &tl, &td, z);
-	if (t != Z_OK)
-	{
-	  if (t == (uInt)Z_DATA_ERROR)
-	    s->mode = BADB;
-	  r = t;
-	  LEAVE
-	}
-	Tracev((stderr, "inflate:       trees ok\n"));
-	if ((c = inflate_codes_new(bl, bd, tl, td, z)) == Z_NULL)
-	{
-	  inflate_trees_free(td, z);
-	  inflate_trees_free(tl, z);
-	  r = Z_MEM_ERROR;
-	  LEAVE
-	}
-	ZFREE(z, s->sub.trees.blens, s->sub.trees.nblens * sizeof(uInt));
-	s->sub.decode.codes = c;
-	s->sub.decode.tl = tl;
-	s->sub.decode.td = td;
-      }
-      s->mode = CODES;
-    case CODES:
-      UPDATE
-      if ((r = inflate_codes(s, z, r)) != Z_STREAM_END)
-	return inflate_flush(s, z, r);
-      r = Z_OK;
-      inflate_codes_free(s->sub.decode.codes, z);
-      inflate_trees_free(s->sub.decode.td, z);
-      inflate_trees_free(s->sub.decode.tl, z);
-      LOAD
-      Tracev((stderr, "inflate:       codes end, %lu total out\n",
-	      z->total_out + (q >= s->read ? q - s->read :
-	      (s->end - s->read) + (q - s->window))));
-      if (!s->last)
-      {
-	s->mode = TYPE;
-	break;
-      }
-      if (k > 7)              /* return unused byte, if any */
-      {
-	Assert(k < 16, "inflate_codes grabbed too many bytes")
-	k -= 8;
-	n++;
-	p--;                    /* can always return one */
-      }
-      s->mode = DRY;
-    case DRY:
-      FLUSH
-      if (s->read != s->write)
-	LEAVE
-      s->mode = DONEB;
-    case DONEB:
-      r = Z_STREAM_END;
-      LEAVE
-    case BADB:
-      r = Z_DATA_ERROR;
-      LEAVE
-    default:
-      r = Z_STREAM_ERROR;
-      LEAVE
-  }
-}
-
-
-local int inflate_blocks_free(s, z, c)
-inflate_blocks_statef *s;
-z_stream *z;
-uLongf *c;
-{
-  inflate_blocks_reset(s, z, c);
-  ZFREE(z, s->window, s->end - s->window);
-  ZFREE(z, s, sizeof(struct inflate_blocks_state));
-  Trace((stderr, "inflate:   blocks freed\n"));
-  return Z_OK;
-}
-
-/*
- * This subroutine adds the data at next_in/avail_in to the output history
- * without performing any output.  The output buffer must be "caught up";
- * i.e. no pending output (hence s->read equals s->write), and the state must
- * be BLOCKS (i.e. we should be willing to see the start of a series of
- * BLOCKS).  On exit, the output will also be caught up, and the checksum
- * will have been updated if need be.
- */
-local int inflate_addhistory(s, z)
-inflate_blocks_statef *s;
-z_stream *z;
-{
-    uLong b;              /* bit buffer */  /* NOT USED HERE */
-    uInt k;               /* bits in bit buffer */ /* NOT USED HERE */
-    uInt t;               /* temporary storage */
-    Bytef *p;             /* input data pointer */
-    uInt n;               /* bytes available there */
-    Bytef *q;             /* output window write pointer */
-    uInt m;               /* bytes to end of window or read pointer */
-
-    if (s->read != s->write)
-	return Z_STREAM_ERROR;
-    if (s->mode != TYPE)
-	return Z_DATA_ERROR;
+            /* build code tables */
+            state->next = state->codes;
+            state->lencode = (code const FAR *)(state->next);
+            state->lenbits = 9;
+            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
+                                &(state->lenbits), state->work);
+            if (ret) {
+                strm->msg = (char *)"invalid literal/lengths set";
+                state->mode = BAD;
+                break;
+            }
+            state->distcode = (code const FAR *)(state->next);
+            state->distbits = 6;
+            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
+                            &(state->next), &(state->distbits), state->work);
+            if (ret) {
+                strm->msg = (char *)"invalid distances set";
+                state->mode = BAD;
+                break;
+            }
+            Tracev((stderr, "inflate:       codes ok\n"));
+            state->mode = LEN;
+        case LEN:
+            if (strm->outcb != Z_NULL) /* for watchdog (U-Boot) */
+                (*strm->outcb)(Z_NULL, 0);
+            if (have >= 6 && left >= 258) {
+                RESTORE();
+                inflate_fast(strm, out);
+                LOAD();
+                break;
+            }
+            for (;;) {
+                this = state->lencode[BITS(state->lenbits)];
+                if ((unsigned)(this.bits) <= bits) break;
+                PULLBYTE();
+            }
+            if (this.op && (this.op & 0xf0) == 0) {
+                last = this;
+                for (;;) {
+                    this = state->lencode[last.val +
+                            (BITS(last.bits + last.op) >> last.bits)];
+                    if ((unsigned)(last.bits + this.bits) <= bits) break;
+                    PULLBYTE();
+                }
+                DROPBITS(last.bits);
+            }
+            DROPBITS(this.bits);
+            state->length = (unsigned)this.val;
+            if ((int)(this.op) == 0) {
+                Tracevv((stderr, this.val >= 0x20 && this.val < 0x7f ?
+                        "inflate:         literal '%c'\n" :
+                        "inflate:         literal 0x%02x\n", this.val));
+                state->mode = LIT;
+                break;
+            }
+            if (this.op & 32) {
+                Tracevv((stderr, "inflate:         end of block\n"));
+                state->mode = TYPE;
+                break;
+            }
+            if (this.op & 64) {
+                strm->msg = (char *)"invalid literal/length code";
+                state->mode = BAD;
+                break;
+            }
+            state->extra = (unsigned)(this.op) & 15;
+            state->mode = LENEXT;
+        case LENEXT:
+            if (state->extra) {
+                NEEDBITS(state->extra);
+                state->length += BITS(state->extra);
+                DROPBITS(state->extra);
+            }
+            Tracevv((stderr, "inflate:         length %u\n", state->length));
+            state->mode = DIST;
+        case DIST:
+            for (;;) {
+                this = state->distcode[BITS(state->distbits)];
+                if ((unsigned)(this.bits) <= bits) break;
+                PULLBYTE();
+            }
+            if ((this.op & 0xf0) == 0) {
+                last = this;
+                for (;;) {
+                    this = state->distcode[last.val +
+                            (BITS(last.bits + last.op) >> last.bits)];
+                    if ((unsigned)(last.bits + this.bits) <= bits) break;
+                    PULLBYTE();
+                }
+                DROPBITS(last.bits);
+            }
+            DROPBITS(this.bits);
+            if (this.op & 64) {
+                strm->msg = (char *)"invalid distance code";
+                state->mode = BAD;
+                break;
+            }
+            state->offset = (unsigned)this.val;
+            state->extra = (unsigned)(this.op) & 15;
+            state->mode = DISTEXT;
+        case DISTEXT:
+            if (state->extra) {
+                NEEDBITS(state->extra);
+                state->offset += BITS(state->extra);
+                DROPBITS(state->extra);
+            }
+#ifdef INFLATE_STRICT
+            if (state->offset > state->dmax) {
+                strm->msg = (char *)"invalid distance too far back";
+                state->mode = BAD;
+                break;
+            }
+#endif
+            if (state->offset > state->whave + out - left) {
+                strm->msg = (char *)"invalid distance too far back";
+                state->mode = BAD;
+                break;
+            }
+            Tracevv((stderr, "inflate:         distance %u\n", state->offset));
+            state->mode = MATCH;
+        case MATCH:
+            if (left == 0) goto inf_leave;
+            copy = out - left;
+            if (state->offset > copy) {         /* copy from window */
+                copy = state->offset - copy;
+                if (copy > state->write) {
+                    copy -= state->write;
+                    from = state->window + (state->wsize - copy);
+                }
+                else
+                    from = state->window + (state->write - copy);
+                if (copy > state->length) copy = state->length;
+            }
+            else {                              /* copy from output */
+                from = put - state->offset;
+                copy = state->length;
+            }
+            if (copy > left) copy = left;
+            left -= copy;
+            state->length -= copy;
+            do {
+                *put++ = *from++;
+            } while (--copy);
+            if (state->length == 0) state->mode = LEN;
+            break;
+        case LIT:
+            if (left == 0) goto inf_leave;
+            *put++ = (unsigned char)(state->length);
+            left--;
+            state->mode = LEN;
+            break;
+        case CHECK:
+            if (state->wrap) {
+                NEEDBITS(32);
+                out -= left;
+                strm->total_out += out;
+                state->total += out;
+                if (out)
+                    strm->adler = state->check =
+                        UPDATE(state->check, put - out, out);
+                out = left;
+                if ((
+#ifdef GUNZIP
+                     state->flags ? hold :
+#endif
+                     REVERSE(hold)) != state->check) {
+                    strm->msg = (char *)"incorrect data check";
+                    state->mode = BAD;
+                    break;
+                }
+                INITBITS();
+                Tracev((stderr, "inflate:   check matches trailer\n"));
+            }
+#ifdef GUNZIP
+            state->mode = LENGTH;
+        case LENGTH:
+            if (state->wrap && state->flags) {
+                NEEDBITS(32);
+                if (hold != (state->total & 0xffffffffUL)) {
+                    strm->msg = (char *)"incorrect length check";
+                    state->mode = BAD;
+                    break;
+                }
+                INITBITS();
+                Tracev((stderr, "inflate:   length matches trailer\n"));
+            }
+#endif
+            state->mode = DONE;
+        case DONE:
+            ret = Z_STREAM_END;
+            goto inf_leave;
+        case BAD:
+            ret = Z_DATA_ERROR;
+            goto inf_leave;
+        case MEM:
+            return Z_MEM_ERROR;
+        case SYNC:
+        default:
+            return Z_STREAM_ERROR;
+        }
 
-    /* we're ready to rock */
-    LOAD
-    /* while there is input ready, copy to output buffer, moving
-     * pointers as needed.
+    /*
+       Return from inflate(), updating the total counts and the check value.
+       If there was no progress during the inflate() call, return a buffer
+       error.  Call updatewindow() to create and/or update the window state.
+       Note: a memory error from inflate() is non-recoverable.
      */
-    while (n) {
-	t = n;  /* how many to do */
-	/* is there room until end of buffer? */
-	if (t > m) t = m;
-	/* update check information */
-	if (s->checkfn != Z_NULL)
-	    s->check = (*s->checkfn)(s->check, q, t);
-	/* output callback */
-	if (z->outcb != Z_NULL)
-	    (*z->outcb)(q, t);
-	zmemcpy(q, p, t);
-	q += t;
-	p += t;
-	n -= t;
-	z->total_out += t;
-	s->read = q;    /* drag read pointer forward */
-/*      WRAP  */ 	/* expand WRAP macro by hand to handle s->read */
-	if (q == s->end) {
-	    s->read = q = s->window;
-	    m = WAVAIL;
-	}
+  inf_leave:
+    RESTORE();
+    if (state->wsize || (state->mode < CHECK && out != strm->avail_out))
+        if (updatewindow(strm, out)) {
+            state->mode = MEM;
+            return Z_MEM_ERROR;
+        }
+    in -= strm->avail_in;
+    out -= strm->avail_out;
+    strm->total_in += in;
+    strm->total_out += out;
+    state->total += out;
+    if (state->wrap && out)
+        strm->adler = state->check =
+            UPDATE(state->check, strm->next_out - out, out);
+    strm->data_type = state->bits + (state->last ? 64 : 0) +
+                      (state->mode == TYPE ? 128 : 0);
+    if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)
+        ret = Z_BUF_ERROR;
+    return ret;
+}
+
+int ZEXPORT inflateEnd(strm)
+z_streamp strm;
+{
+    struct inflate_state FAR *state;
+    if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)
+        return Z_STREAM_ERROR;
+    state = (struct inflate_state FAR *)strm->state;
+    if (state->window != Z_NULL) {
+	if (strm->outcb != Z_NULL)
+		(*strm->outcb)(Z_NULL, 0);
+	ZFREE(strm, state->window);
     }
-    UPDATE
+    ZFREE(strm, strm->state);
+    strm->state = Z_NULL;
+    Tracev((stderr, "inflate: end\n"));
     return Z_OK;
 }
 
-
-/*
- * At the end of a Deflate-compressed PPP packet, we expect to have seen
- * a `stored' block type value but not the (zero) length bytes.
- */
-local int inflate_packet_flush(s)
-    inflate_blocks_statef *s;
-{
-    if (s->mode != LENS)
-	return Z_DATA_ERROR;
-    s->mode = TYPE;
-    return Z_OK;
-}
-
-
-/*+++++*/
-/* inftrees.c -- generate Huffman trees for efficient decoding
- * Copyright (C) 1995 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* simplify the use of the inflate_huft type with some defines */
-#define base more.Base
-#define next more.Next
-#define exop word.what.Exop
-#define bits word.what.Bits
-
-
-local int huft_build OF((
-    uIntf *,            /* code lengths in bits */
-    uInt,               /* number of codes */
-    uInt,               /* number of "simple" codes */
-    uIntf *,            /* list of base values for non-simple codes */
-    uIntf *,            /* list of extra bits for non-simple codes */
-    inflate_huft * FAR*,/* result: starting table */
-    uIntf *,            /* maximum lookup bits (returns actual) */
-    z_stream *));       /* for zalloc function */
-
-local voidpf falloc OF((
-    voidpf,             /* opaque pointer (not used) */
-    uInt,               /* number of items */
-    uInt));             /* size of item */
-
-local void ffree OF((
-    voidpf q,           /* opaque pointer (not used) */
-    voidpf p,           /* what to free (not used) */
-    uInt n));		/* number of bytes (not used) */
-
-/* Tables for deflate from PKZIP's appnote.txt. */
-local uInt cplens[] = { /* Copy lengths for literal codes 257..285 */
-	3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
-	35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
-	/* actually lengths - 2; also see note #13 above about 258 */
-local uInt cplext[] = { /* Extra bits for literal codes 257..285 */
-	0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
-	3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 192, 192}; /* 192==invalid */
-local uInt cpdist[] = { /* Copy offsets for distance codes 0..29 */
-	1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
-	257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
-	8193, 12289, 16385, 24577};
-local uInt cpdext[] = { /* Extra bits for distance codes */
-	0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
-	7, 7, 8, 8, 9, 9, 10, 10, 11, 11,
-	12, 12, 13, 13};
-
-/*
-   Huffman code decoding is performed using a multi-level table lookup.
-   The fastest way to decode is to simply build a lookup table whose
-   size is determined by the longest code.  However, the time it takes
-   to build this table can also be a factor if the data being decoded
-   is not very long.  The most common codes are necessarily the
-   shortest codes, so those codes dominate the decoding time, and hence
-   the speed.  The idea is you can have a shorter table that decodes the
-   shorter, more probable codes, and then point to subsidiary tables for
-   the longer codes.  The time it costs to decode the longer codes is
-   then traded against the time it takes to make longer tables.
-
-   This results of this trade are in the variables lbits and dbits
-   below.  lbits is the number of bits the first level table for literal/
-   length codes can decode in one step, and dbits is the same thing for
-   the distance codes.  Subsequent tables are also less than or equal to
-   those sizes.  These values may be adjusted either when all of the
-   codes are shorter than that, in which case the longest code length in
-   bits is used, or when the shortest code is *longer* than the requested
-   table size, in which case the length of the shortest code in bits is
-   used.
-
-   There are two different values for the two tables, since they code a
-   different number of possibilities each.  The literal/length table
-   codes 286 possible values, or in a flat code, a little over eight
-   bits.  The distance table codes 30 possible values, or a little less
-   than five bits, flat.  The optimum values for speed end up being
-   about one bit more than those, so lbits is 8+1 and dbits is 5+1.
-   The optimum values may differ though from machine to machine, and
-   possibly even between compilers.  Your mileage may vary.
- */
-
-
-/* If BMAX needs to be larger than 16, then h and x[] should be uLong. */
-#define BMAX 15         /* maximum bit length of any code */
-#define N_MAX 288       /* maximum number of codes in any set */
-
-#ifdef DEBUG_ZLIB
-  uInt inflate_hufts;
-#endif
-
-local int huft_build(b, n, s, d, e, t, m, zs)
-uIntf *b;               /* code lengths in bits (all assumed <= BMAX) */
-uInt n;                 /* number of codes (assumed <= N_MAX) */
-uInt s;                 /* number of simple-valued codes (0..s-1) */
-uIntf *d;               /* list of base values for non-simple codes */
-uIntf *e;               /* list of extra bits for non-simple codes */
-inflate_huft * FAR *t;  /* result: starting table */
-uIntf *m;               /* maximum lookup bits, returns actual */
-z_stream *zs;           /* for zalloc function */
-/* Given a list of code lengths and a maximum table size, make a set of
-   tables to decode that set of codes.  Return Z_OK on success, Z_BUF_ERROR
-   if the given code set is incomplete (the tables are still built in this
-   case), Z_DATA_ERROR if the input is invalid (all zero length codes or an
-   over-subscribed set of lengths), or Z_MEM_ERROR if not enough memory. */
-{
-
-  uInt a;                       /* counter for codes of length k */
-  uInt c[BMAX+1];               /* bit length count table */
-  uInt f;                       /* i repeats in table every f entries */
-  int g;                        /* maximum code length */
-  int h;                        /* table level */
-  register uInt i;              /* counter, current code */
-  register uInt j;              /* counter */
-  register int k;               /* number of bits in current code */
-  int l;                        /* bits per table (returned in m) */
-  register uIntf *p;            /* pointer into c[], b[], or v[] */
-  inflate_huft *q;              /* points to current table */
-  struct inflate_huft_s r;      /* table entry for structure assignment */
-  inflate_huft *u[BMAX];        /* table stack */
-  uInt v[N_MAX];                /* values in order of bit length */
-  register int w;               /* bits before this table == (l * h) */
-  uInt x[BMAX+1];               /* bit offsets, then code stack */
-  uIntf *xp;                    /* pointer into x */
-  int y;                        /* number of dummy codes added */
-  uInt z;                       /* number of entries in current table */
-
-
-  /* Generate counts for each bit length */
-  p = c;
-#define C0 *p++ = 0;
-#define C2 C0 C0 C0 C0
-#define C4 C2 C2 C2 C2
-  C4                            /* clear c[]--assume BMAX+1 is 16 */
-  p = b;  i = n;
-  do {
-    c[*p++]++;                  /* assume all entries <= BMAX */
-  } while (--i);
-  if (c[0] == n)                /* null input--all zero length codes */
-  {
-    *t = (inflate_huft *)Z_NULL;
-    *m = 0;
-    return Z_OK;
-  }
-
-
-  /* Find minimum and maximum length, bound *m by those */
-  l = *m;
-  for (j = 1; j <= BMAX; j++)
-    if (c[j])
-      break;
-  k = j;                        /* minimum code length */
-  if ((uInt)l < j)
-    l = j;
-  for (i = BMAX; i; i--)
-    if (c[i])
-      break;
-  g = i;                        /* maximum code length */
-  if ((uInt)l > i)
-    l = i;
-  *m = l;
-
-
-  /* Adjust last length count to fill out codes, if needed */
-  for (y = 1 << j; j < i; j++, y <<= 1)
-    if ((y -= c[j]) < 0)
-      return Z_DATA_ERROR;
-  if ((y -= c[i]) < 0)
-    return Z_DATA_ERROR;
-  c[i] += y;
-
-
-  /* Generate starting offsets into the value table for each length */
-  x[1] = j = 0;
-  p = c + 1;  xp = x + 2;
-  while (--i) {                 /* note that i == g from above */
-    *xp++ = (j += *p++);
-  }
-
-
-  /* Make a table of values in order of bit lengths */
-  p = b;  i = 0;
-  do {
-    if ((j = *p++) != 0)
-      v[x[j]++] = i;
-  } while (++i < n);
-
-
-  /* Generate the Huffman codes and for each, make the table entries */
-  x[0] = i = 0;                 /* first Huffman code is zero */
-  p = v;                        /* grab values in bit order */
-  h = -1;                       /* no tables yet--level -1 */
-  w = -l;                       /* bits decoded == (l * h) */
-  u[0] = (inflate_huft *)Z_NULL;        /* just to keep compilers happy */
-  q = (inflate_huft *)Z_NULL;   /* ditto */
-  z = 0;                        /* ditto */
-
-  /* go through the bit lengths (k already is bits in shortest code) */
-  for (; k <= g; k++)
-  {
-    a = c[k];
-    while (a--)
-    {
-      /* here i is the Huffman code of length k bits for value *p */
-      /* make tables up to required level */
-      while (k > w + l)
-      {
-	h++;
-	w += l;                 /* previous table always l bits */
-
-	/* compute minimum size table less than or equal to l bits */
-	z = (z = g - w) > (uInt)l ? l : z;      /* table size upper limit */
-	if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */
-	{                       /* too few codes for k-w bit table */
-	  f -= a + 1;           /* deduct codes from patterns left */
-	  xp = c + k;
-	  if (j < z)
-	    while (++j < z)     /* try smaller tables up to z bits */
-	    {
-	      if ((f <<= 1) <= *++xp)
-		break;          /* enough codes to use up j bits */
-	      f -= *xp;         /* else deduct codes from patterns */
-	    }
-	}
-	z = 1 << j;             /* table entries for j-bit table */
-
-	/* allocate and link in new table */
-	if ((q = (inflate_huft *)ZALLOC
-	     (zs,z + 1,sizeof(inflate_huft))) == Z_NULL)
-	{
-	  if (h)
-	    inflate_trees_free(u[0], zs);
-	  return Z_MEM_ERROR;   /* not enough memory */
-	}
-	q->word.Nalloc = z + 1;
-#ifdef DEBUG_ZLIB
-	inflate_hufts += z + 1;
-#endif
-	*t = q + 1;             /* link to list for huft_free() */
-	*(t = &(q->next)) = Z_NULL;
-	u[h] = ++q;             /* table starts after link */
-
-	/* connect to last table, if there is one */
-	if (h)
-	{
-	  x[h] = i;             /* save pattern for backing up */
-	  r.bits = (Byte)l;     /* bits to dump before this table */
-	  r.exop = (Byte)j;     /* bits in this table */
-	  r.next = q;           /* pointer to this table */
-	  j = i >> (w - l);     /* (get around Turbo C bug) */
-	  u[h-1][j] = r;        /* connect to last table */
-	}
-      }
-
-      /* set up table entry in r */
-      r.bits = (Byte)(k - w);
-      if (p >= v + n)
-	r.exop = 128 + 64;      /* out of values--invalid code */
-      else if (*p < s)
-      {
-	r.exop = (Byte)(*p < 256 ? 0 : 32 + 64);     /* 256 is end-of-block */
-	r.base = *p++;          /* simple code is just the value */
-      }
-      else
-      {
-	r.exop = (Byte)e[*p - s] + 16 + 64; /* non-simple--look up in lists */
-	r.base = d[*p++ - s];
-      }
-
-      /* fill code-like entries with r */
-      f = 1 << (k - w);
-      for (j = i >> w; j < z; j += f)
-	q[j] = r;
-
-      /* backwards increment the k-bit code i */
-      for (j = 1 << (k - 1); i & j; j >>= 1)
-	i ^= j;
-      i ^= j;
-
-      /* backup over finished tables */
-      while ((i & ((1 << w) - 1)) != x[h])
-      {
-	h--;                    /* don't need to update q */
-	w -= l;
-      }
-    }
-  }
-
-
-  /* Return Z_BUF_ERROR if we were given an incomplete table */
-  return y != 0 && g != 1 ? Z_BUF_ERROR : Z_OK;
-}
-
-
-local int inflate_trees_bits(c, bb, tb, z)
-uIntf *c;               /* 19 code lengths */
-uIntf *bb;              /* bits tree desired/actual depth */
-inflate_huft * FAR *tb; /* bits tree result */
-z_stream *z;            /* for zfree function */
-{
-  int r;
-
-  r = huft_build(c, 19, 19, (uIntf*)Z_NULL, (uIntf*)Z_NULL, tb, bb, z);
-  if (r == Z_DATA_ERROR)
-    z->msg = "oversubscribed dynamic bit lengths tree";
-  else if (r == Z_BUF_ERROR)
-  {
-    inflate_trees_free(*tb, z);
-    z->msg = "incomplete dynamic bit lengths tree";
-    r = Z_DATA_ERROR;
-  }
-  return r;
-}
-
-
-local int inflate_trees_dynamic(nl, nd, c, bl, bd, tl, td, z)
-uInt nl;                /* number of literal/length codes */
-uInt nd;                /* number of distance codes */
-uIntf *c;               /* that many (total) code lengths */
-uIntf *bl;              /* literal desired/actual bit depth */
-uIntf *bd;              /* distance desired/actual bit depth */
-inflate_huft * FAR *tl; /* literal/length tree result */
-inflate_huft * FAR *td; /* distance tree result */
-z_stream *z;            /* for zfree function */
-{
-  int r;
-
-  /* build literal/length tree */
-  if ((r = huft_build(c, nl, 257, cplens, cplext, tl, bl, z)) != Z_OK)
-  {
-    if (r == Z_DATA_ERROR)
-      z->msg = "oversubscribed literal/length tree";
-    else if (r == Z_BUF_ERROR)
-    {
-      inflate_trees_free(*tl, z);
-      z->msg = "incomplete literal/length tree";
-      r = Z_DATA_ERROR;
-    }
-    return r;
-  }
-
-  /* build distance tree */
-  if ((r = huft_build(c + nl, nd, 0, cpdist, cpdext, td, bd, z)) != Z_OK)
-  {
-    if (r == Z_DATA_ERROR)
-      z->msg = "oversubscribed literal/length tree";
-    else if (r == Z_BUF_ERROR) {
-#ifdef PKZIP_BUG_WORKAROUND
-      r = Z_OK;
-    }
-#else
-      inflate_trees_free(*td, z);
-      z->msg = "incomplete literal/length tree";
-      r = Z_DATA_ERROR;
-    }
-    inflate_trees_free(*tl, z);
-    return r;
-#endif
-  }
-
-  /* done */
-  return Z_OK;
-}
-
-
-/* build fixed tables only once--keep them here */
-local int fixed_lock = 0;
-local int fixed_built = 0;
-#define FIXEDH 530      /* number of hufts used by fixed tables */
-local uInt fixed_left = FIXEDH;
-local inflate_huft fixed_mem[FIXEDH];
-local uInt fixed_bl;
-local uInt fixed_bd;
-local inflate_huft *fixed_tl;
-local inflate_huft *fixed_td;
-
-
-local voidpf falloc(q, n, s)
-voidpf q;        /* opaque pointer (not used) */
-uInt n;         /* number of items */
-uInt s;         /* size of item */
-{
-  Assert(s == sizeof(inflate_huft) && n <= fixed_left,
-	 "inflate_trees falloc overflow");
-  if (q) s++; /* to make some compilers happy */
-  fixed_left -= n;
-  return (voidpf)(fixed_mem + fixed_left);
-}
-
-
-local void ffree(q, p, n)
-voidpf q;
-voidpf p;
-uInt n;
-{
-  Assert(0, "inflate_trees ffree called!");
-  if (q) q = p; /* to make some compilers happy */
-}
-
-
-local int inflate_trees_fixed(bl, bd, tl, td)
-uIntf *bl;               /* literal desired/actual bit depth */
-uIntf *bd;               /* distance desired/actual bit depth */
-inflate_huft * FAR *tl;  /* literal/length tree result */
-inflate_huft * FAR *td;  /* distance tree result */
-{
-  /* build fixed tables if not built already--lock out other instances */
-  while (++fixed_lock > 1)
-    fixed_lock--;
-  if (!fixed_built)
-  {
-    int k;              /* temporary variable */
-    unsigned c[288];    /* length list for huft_build */
-    z_stream z;         /* for falloc function */
-
-    /* set up fake z_stream for memory routines */
-    z.zalloc = falloc;
-    z.zfree = ffree;
-    z.opaque = Z_NULL;
-
-    /* literal table */
-    for (k = 0; k < 144; k++)
-      c[k] = 8;
-    for (; k < 256; k++)
-      c[k] = 9;
-    for (; k < 280; k++)
-      c[k] = 7;
-    for (; k < 288; k++)
-      c[k] = 8;
-    fixed_bl = 7;
-    huft_build(c, 288, 257, cplens, cplext, &fixed_tl, &fixed_bl, &z);
-
-    /* distance table */
-    for (k = 0; k < 30; k++)
-      c[k] = 5;
-    fixed_bd = 5;
-    huft_build(c, 30, 0, cpdist, cpdext, &fixed_td, &fixed_bd, &z);
-
-    /* done */
-    fixed_built = 1;
-  }
-  fixed_lock--;
-  *bl = fixed_bl;
-  *bd = fixed_bd;
-  *tl = fixed_tl;
-  *td = fixed_td;
-  return Z_OK;
-}
-
-
-local int inflate_trees_free(t, z)
-inflate_huft *t;        /* table to free */
-z_stream *z;            /* for zfree function */
-/* Free the malloc'ed tables built by huft_build(), which makes a linked
-   list of the tables it made, with the links in a dummy first entry of
-   each table. */
-{
-  register inflate_huft *p, *q;
-
-  /* Go through linked list, freeing from the malloced (t[-1]) address. */
-  p = t;
-  while (p != Z_NULL)
-  {
-    q = (--p)->next;
-    ZFREE(z, p, p->word.Nalloc * sizeof(inflate_huft));
-    p = q;
-  }
-  return Z_OK;
-}
-
-/*+++++*/
-/* infcodes.c -- process literals and length/distance pairs
- * Copyright (C) 1995 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* simplify the use of the inflate_huft type with some defines */
-#define base more.Base
-#define next more.Next
-#define exop word.what.Exop
-#define bits word.what.Bits
-
-/* inflate codes private state */
-struct inflate_codes_state {
-
-  /* mode */
-  enum {        /* waiting for "i:"=input, "o:"=output, "x:"=nothing */
-      START,    /* x: set up for LEN */
-      LEN,      /* i: get length/literal/eob next */
-      LENEXT,   /* i: getting length extra (have base) */
-      DIST,     /* i: get distance next */
-      DISTEXT,  /* i: getting distance extra */
-      COPY,     /* o: copying bytes in window, waiting for space */
-      LIT,      /* o: got literal, waiting for output space */
-      WASH,     /* o: got eob, possibly still output waiting */
-      END,      /* x: got eob and all data flushed */
-      BADCODE}  /* x: got error */
-    mode;               /* current inflate_codes mode */
-
-  /* mode dependent information */
-  uInt len;
-  union {
-    struct {
-      inflate_huft *tree;       /* pointer into tree */
-      uInt need;                /* bits needed */
-    } code;             /* if LEN or DIST, where in tree */
-    uInt lit;           /* if LIT, literal */
-    struct {
-      uInt get;                 /* bits to get for extra */
-      uInt dist;                /* distance back to copy from */
-    } copy;             /* if EXT or COPY, where and how much */
-  } sub;                /* submode */
-
-  /* mode independent information */
-  Byte lbits;           /* ltree bits decoded per branch */
-  Byte dbits;           /* dtree bits decoder per branch */
-  inflate_huft *ltree;          /* literal/length/eob tree */
-  inflate_huft *dtree;          /* distance tree */
-
-};
-
-
-local inflate_codes_statef *inflate_codes_new(bl, bd, tl, td, z)
-uInt bl, bd;
-inflate_huft *tl, *td;
-z_stream *z;
-{
-  inflate_codes_statef *c;
-
-  if ((c = (inflate_codes_statef *)
-       ZALLOC(z,1,sizeof(struct inflate_codes_state))) != Z_NULL)
-  {
-    c->mode = START;
-    c->lbits = (Byte)bl;
-    c->dbits = (Byte)bd;
-    c->ltree = tl;
-    c->dtree = td;
-    Tracev((stderr, "inflate:       codes new\n"));
-  }
-  return c;
-}
-
-
-local int inflate_codes(s, z, r)
-inflate_blocks_statef *s;
-z_stream *z;
-int r;
-{
-  uInt j;               /* temporary storage */
-  inflate_huft *t;      /* temporary pointer */
-  uInt e;               /* extra bits or operation */
-  uLong b;              /* bit buffer */
-  uInt k;               /* bits in bit buffer */
-  Bytef *p;             /* input data pointer */
-  uInt n;               /* bytes available there */
-  Bytef *q;             /* output window write pointer */
-  uInt m;               /* bytes to end of window or read pointer */
-  Bytef *f;             /* pointer to copy strings from */
-  inflate_codes_statef *c = s->sub.decode.codes;  /* codes state */
-
-  /* copy input/output information to locals (UPDATE macro restores) */
-  LOAD
-
-  /* process input and output based on current state */
-  while (1) switch (c->mode)
-  {             /* waiting for "i:"=input, "o:"=output, "x:"=nothing */
-    case START:         /* x: set up for LEN */
-#ifndef SLOW
-      if (m >= 258 && n >= 10)
-      {
-	UPDATE
-	r = inflate_fast(c->lbits, c->dbits, c->ltree, c->dtree, s, z);
-	LOAD
-	if (r != Z_OK)
-	{
-	  c->mode = r == Z_STREAM_END ? WASH : BADCODE;
-	  break;
-	}
-      }
-#endif /* !SLOW */
-      c->sub.code.need = c->lbits;
-      c->sub.code.tree = c->ltree;
-      c->mode = LEN;
-    case LEN:           /* i: get length/literal/eob next */
-      j = c->sub.code.need;
-      NEEDBITS(j)
-      t = c->sub.code.tree + ((uInt)b & inflate_mask[j]);
-      DUMPBITS(t->bits)
-      e = (uInt)(t->exop);
-      if (e == 0)               /* literal */
-      {
-	c->sub.lit = t->base;
-	Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
-		 "inflate:         literal '%c'\n" :
-		 "inflate:         literal 0x%02x\n", t->base));
-	c->mode = LIT;
-	break;
-      }
-      if (e & 16)               /* length */
-      {
-	c->sub.copy.get = e & 15;
-	c->len = t->base;
-	c->mode = LENEXT;
-	break;
-      }
-      if ((e & 64) == 0)        /* next table */
-      {
-	c->sub.code.need = e;
-	c->sub.code.tree = t->next;
-	break;
-      }
-      if (e & 32)               /* end of block */
-      {
-	Tracevv((stderr, "inflate:         end of block\n"));
-	c->mode = WASH;
-	break;
-      }
-      c->mode = BADCODE;        /* invalid code */
-      z->msg = "invalid literal/length code";
-      r = Z_DATA_ERROR;
-      LEAVE
-    case LENEXT:        /* i: getting length extra (have base) */
-      j = c->sub.copy.get;
-      NEEDBITS(j)
-      c->len += (uInt)b & inflate_mask[j];
-      DUMPBITS(j)
-      c->sub.code.need = c->dbits;
-      c->sub.code.tree = c->dtree;
-      Tracevv((stderr, "inflate:         length %u\n", c->len));
-      c->mode = DIST;
-    case DIST:          /* i: get distance next */
-      j = c->sub.code.need;
-      NEEDBITS(j)
-      t = c->sub.code.tree + ((uInt)b & inflate_mask[j]);
-      DUMPBITS(t->bits)
-      e = (uInt)(t->exop);
-      if (e & 16)               /* distance */
-      {
-	c->sub.copy.get = e & 15;
-	c->sub.copy.dist = t->base;
-	c->mode = DISTEXT;
-	break;
-      }
-      if ((e & 64) == 0)        /* next table */
-      {
-	c->sub.code.need = e;
-	c->sub.code.tree = t->next;
-	break;
-      }
-      c->mode = BADCODE;        /* invalid code */
-      z->msg = "invalid distance code";
-      r = Z_DATA_ERROR;
-      LEAVE
-    case DISTEXT:       /* i: getting distance extra */
-      j = c->sub.copy.get;
-      NEEDBITS(j)
-      c->sub.copy.dist += (uInt)b & inflate_mask[j];
-      DUMPBITS(j)
-      Tracevv((stderr, "inflate:         distance %u\n", c->sub.copy.dist));
-      c->mode = COPY;
-    case COPY:          /* o: copying bytes in window, waiting for space */
-#ifndef __TURBOC__ /* Turbo C bug for following expression */
-      f = (uInt)(q - s->window) < c->sub.copy.dist ?
-	  s->end - (c->sub.copy.dist - (q - s->window)) :
-	  q - c->sub.copy.dist;
-#else
-      f = q - c->sub.copy.dist;
-      if ((uInt)(q - s->window) < c->sub.copy.dist)
-	f = s->end - (c->sub.copy.dist - (q - s->window));
-#endif
-      while (c->len)
-      {
-	NEEDOUT
-	OUTBYTE(*f++)
-	if (f == s->end)
-	  f = s->window;
-	c->len--;
-      }
-      c->mode = START;
-      break;
-    case LIT:           /* o: got literal, waiting for output space */
-      NEEDOUT
-      OUTBYTE(c->sub.lit)
-      c->mode = START;
-      break;
-    case WASH:          /* o: got eob, possibly more output */
-      FLUSH
-      if (s->read != s->write)
-	LEAVE
-      c->mode = END;
-    case END:
-      r = Z_STREAM_END;
-      LEAVE
-    case BADCODE:       /* x: got error */
-      r = Z_DATA_ERROR;
-      LEAVE
-    default:
-      r = Z_STREAM_ERROR;
-      LEAVE
-  }
-}
-
-
-local void inflate_codes_free(c, z)
-inflate_codes_statef *c;
-z_stream *z;
-{
-  ZFREE(z, c, sizeof(struct inflate_codes_state));
-  Tracev((stderr, "inflate:       codes free\n"));
-}
-
-/*+++++*/
-/* inflate_util.c -- data and routines common to blocks and codes
- * Copyright (C) 1995 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* copy as much as possible from the sliding window to the output area */
-local int inflate_flush(s, z, r)
-inflate_blocks_statef *s;
-z_stream *z;
-int r;
-{
-  uInt n;
-  Bytef *p, *q;
-
-  /* local copies of source and destination pointers */
-  p = z->next_out;
-  q = s->read;
-
-  /* compute number of bytes to copy as far as end of window */
-  n = (uInt)((q <= s->write ? s->write : s->end) - q);
-  if (n > z->avail_out) n = z->avail_out;
-  if (n && r == Z_BUF_ERROR) r = Z_OK;
-
-  /* update counters */
-  z->avail_out -= n;
-  z->total_out += n;
-
-  /* update check information */
-  if (s->checkfn != Z_NULL)
-    s->check = (*s->checkfn)(s->check, q, n);
-
-  /* output callback */
-  if (z->outcb != Z_NULL)
-    (*z->outcb)(q, n);
-
-  /* copy as far as end of window */
-  zmemcpy(p, q, n);
-  p += n;
-  q += n;
-
-  /* see if more to copy at beginning of window */
-  if (q == s->end)
-  {
-    /* wrap pointers */
-    q = s->window;
-    if (s->write == s->end)
-      s->write = s->window;
-
-    /* compute bytes to copy */
-    n = (uInt)(s->write - q);
-    if (n > z->avail_out) n = z->avail_out;
-    if (n && r == Z_BUF_ERROR) r = Z_OK;
-
-    /* update counters */
-    z->avail_out -= n;
-    z->total_out += n;
-
-    /* update check information */
-    if (s->checkfn != Z_NULL)
-      s->check = (*s->checkfn)(s->check, q, n);
-
-    /* output callback */
-    if (z->outcb != Z_NULL)
-	(*z->outcb)(q, n);
-
-    /* copy */
-    zmemcpy(p, q, n);
-    p += n;
-    q += n;
-  }
-
-  /* update pointers */
-  z->next_out = p;
-  s->read = q;
-
-  /* done */
-  return r;
-}
-
-
-/*+++++*/
-/* inffast.c -- process literals and length/distance pairs fast
- * Copyright (C) 1995 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* simplify the use of the inflate_huft type with some defines */
-#define base more.Base
-#define next more.Next
-#define exop word.what.Exop
-#define bits word.what.Bits
-
-/* macros for bit input with no checking and for returning unused bytes */
-#define GRABBITS(j) {while(k<(j)){b|=((uLong)NEXTBYTE)<<k;k+=8;}}
-#define UNGRAB {n+=(c=k>>3);p-=c;k&=7;}
-
-/* Called with number of bytes left to write in window at least 258
-   (the maximum string length) and number of input bytes available
-   at least ten.  The ten bytes are six bytes for the longest length/
-   distance pair plus four bytes for overloading the bit buffer. */
-
-local int inflate_fast(bl, bd, tl, td, s, z)
-uInt bl, bd;
-inflate_huft *tl, *td;
-inflate_blocks_statef *s;
-z_stream *z;
-{
-  inflate_huft *t;      /* temporary pointer */
-  uInt e;               /* extra bits or operation */
-  uLong b;              /* bit buffer */
-  uInt k;               /* bits in bit buffer */
-  Bytef *p;             /* input data pointer */
-  uInt n;               /* bytes available there */
-  Bytef *q;             /* output window write pointer */
-  uInt m;               /* bytes to end of window or read pointer */
-  uInt ml;              /* mask for literal/length tree */
-  uInt md;              /* mask for distance tree */
-  uInt c;               /* bytes to copy */
-  uInt d;               /* distance back to copy from */
-  Bytef *r;             /* copy source pointer */
-
-  /* load input, output, bit values */
-  LOAD
-
-  /* initialize masks */
-  ml = inflate_mask[bl];
-  md = inflate_mask[bd];
-
-  /* do until not enough input or output space for fast loop */
-  do {                          /* assume called with m >= 258 && n >= 10 */
-    /* get literal/length code */
-    GRABBITS(20)                /* max bits for literal/length code */
-    if ((e = (t = tl + ((uInt)b & ml))->exop) == 0)
-    {
-      DUMPBITS(t->bits)
-      Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
-		"inflate:         * literal '%c'\n" :
-		"inflate:         * literal 0x%02x\n", t->base));
-      *q++ = (Byte)t->base;
-      m--;
-      continue;
-    }
-    do {
-      DUMPBITS(t->bits)
-      if (e & 16)
-      {
-	/* get extra bits for length */
-	e &= 15;
-	c = t->base + ((uInt)b & inflate_mask[e]);
-	DUMPBITS(e)
-	Tracevv((stderr, "inflate:         * length %u\n", c));
-
-	/* decode distance base of block to copy */
-	GRABBITS(15);           /* max bits for distance code */
-	e = (t = td + ((uInt)b & md))->exop;
-	do {
-	  DUMPBITS(t->bits)
-	  if (e & 16)
-	  {
-	    /* get extra bits to add to distance base */
-	    e &= 15;
-	    GRABBITS(e)         /* get extra bits (up to 13) */
-	    d = t->base + ((uInt)b & inflate_mask[e]);
-	    DUMPBITS(e)
-	    Tracevv((stderr, "inflate:         * distance %u\n", d));
-
-	    /* do the copy */
-	    m -= c;
-	    if ((uInt)(q - s->window) >= d)     /* offset before dest */
-	    {                                   /*  just copy */
-	      r = q - d;
-	      *q++ = *r++;  c--;        /* minimum count is three, */
-	      *q++ = *r++;  c--;        /*  so unroll loop a little */
-	    }
-	    else                        /* else offset after destination */
-	    {
-	      e = d - (q - s->window);  /* bytes from offset to end */
-	      r = s->end - e;           /* pointer to offset */
-	      if (c > e)                /* if source crosses, */
-	      {
-		c -= e;                 /* copy to end of window */
-		do {
-		  *q++ = *r++;
-		} while (--e);
-		r = s->window;          /* copy rest from start of window */
-	      }
-	    }
-	    do {                        /* copy all or what's left */
-	      *q++ = *r++;
-	    } while (--c);
-	    break;
-	  }
-	  else if ((e & 64) == 0)
-	    e = (t = t->next + ((uInt)b & inflate_mask[e]))->exop;
-	  else
-	  {
-	    z->msg = "invalid distance code";
-	    UNGRAB
-	    UPDATE
-	    return Z_DATA_ERROR;
-	  }
-	} while (1);
-	break;
-      }
-      if ((e & 64) == 0)
-      {
-	if ((e = (t = t->next + ((uInt)b & inflate_mask[e]))->exop) == 0)
-	{
-	  DUMPBITS(t->bits)
-	  Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
-		    "inflate:         * literal '%c'\n" :
-		    "inflate:         * literal 0x%02x\n", t->base));
-	  *q++ = (Byte)t->base;
-	  m--;
-	  break;
-	}
-      }
-      else if (e & 32)
-      {
-	Tracevv((stderr, "inflate:         * end of block\n"));
-	UNGRAB
-	UPDATE
-	return Z_STREAM_END;
-      }
-      else
-      {
-	z->msg = "invalid literal/length code";
-	UNGRAB
-	UPDATE
-	return Z_DATA_ERROR;
-      }
-    } while (1);
-  } while (m >= 258 && n >= 10);
-
-  /* not enough input or output--restore pointers and return */
-  UNGRAB
-  UPDATE
-  return Z_OK;
-}
-
-
 /*+++++*/
 /* zutil.c -- target dependent utility functions for the compression library
- * Copyright (C) 1995 Jean-loup Gailly.
+ * Copyright (C) 1995-2005 Jean-loup Gailly.
  * For conditions of distribution and use, see copyright notice in zlib.h
  */
 
-/* From: zutil.c,v 1.8 1995/05/03 17:27:12 jloup Exp */
+/* @(#) $Id$ */
 
-char *zlib_version = ZLIB_VERSION;
+#ifndef NO_DUMMY_DECL
+struct internal_state	{int dummy;}; /* for buggy compilers */
+#endif
 
-char *z_errmsg[] = {
-"stream end",          /* Z_STREAM_END    1 */
-"",                    /* Z_OK            0 */
-"file error",          /* Z_ERRNO        (-1) */
-"stream error",        /* Z_STREAM_ERROR (-2) */
-"data error",          /* Z_DATA_ERROR   (-3) */
-"insufficient memory", /* Z_MEM_ERROR    (-4) */
-"buffer error",        /* Z_BUF_ERROR    (-5) */
+const char * const z_errmsg[10] = {
+"need dictionary",     /* Z_NEED_DICT       2  */
+"stream end",          /* Z_STREAM_END      1  */
+"",                    /* Z_OK              0  */
+"file error",          /* Z_ERRNO         (-1) */
+"stream error",        /* Z_STREAM_ERROR  (-2) */
+"data error",          /* Z_DATA_ERROR    (-3) */
+"insufficient memory", /* Z_MEM_ERROR     (-4) */
+"buffer error",        /* Z_BUF_ERROR     (-5) */
+"incompatible version",/* Z_VERSION_ERROR (-6) */
 ""};
 
+#ifdef DEBUG
 
+#ifndef verbose
+#define verbose 0
+#endif
+int z_verbose = verbose;
+
+void z_error (m)
+    char *m;
+{
+	fprintf(stderr, "%s\n", m);
+	hang ();
+}
+#endif
+
+/* exported to allow conversion of error code to string for compress() and
+ * uncompress()
+ */
+#ifndef MY_ZCALLOC /* Any system without a special alloc function */
+
+#ifndef STDC
+extern voidp    malloc OF((uInt size));
+extern voidp    calloc OF((uInt items, uInt size));
+extern void     free   OF((voidpf ptr));
+#endif
+
+voidpf zcalloc (opaque, items, size)
+	voidpf opaque;
+	unsigned items;
+	unsigned size;
+{
+	if (opaque)
+		items += size - size; /* make compiler happy */
+	return sizeof(uInt) > 2 ? (voidpf)malloc(items * size) :
+		(voidpf)calloc(items, size);
+}
+
+void  zcfree (opaque, ptr, nb)
+	voidpf opaque;
+	voidpf ptr;
+	unsigned nb;
+{
+	free(ptr);
+	if (opaque)
+		return; /* make compiler happy */
+}
+
+#endif /* MY_ZCALLOC */
 /*+++++*/
 /* adler32.c -- compute the Adler-32 checksum of a data stream
- * Copyright (C) 1995 Mark Adler
+ * Copyright (C) 1995-2004 Mark Adler
  * For conditions of distribution and use, see copyright notice in zlib.h
  */
 
-/* From: adler32.c,v 1.6 1995/05/03 17:27:08 jloup Exp */
+/* @(#) $Id$ */
 
-#define BASE 65521L /* largest prime smaller than 65536 */
+#define BASE 65521UL    /* largest prime smaller than 65536 */
 #define NMAX 5552
 /* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */
 
-#define DO1(buf)  {s1 += *buf++; s2 += s1;}
-#define DO2(buf)  DO1(buf); DO1(buf);
-#define DO4(buf)  DO2(buf); DO2(buf);
-#define DO8(buf)  DO4(buf); DO4(buf);
-#define DO16(buf) DO8(buf); DO8(buf);
+#define DO1(buf,i)  {adler += (buf)[i]; sum2 += adler;}
+#define DO2(buf,i)  DO1(buf,i); DO1(buf,i+1);
+#define DO4(buf,i)  DO2(buf,i); DO2(buf,i+2);
+#define DO8(buf,i)  DO4(buf,i); DO4(buf,i+4);
+#define DO16(buf)   DO8(buf,0); DO8(buf,8);
+
+/* use NO_DIVIDE if your processor does not do division in hardware */
+#ifdef NO_DIVIDE
+#define MOD(a) \
+	do { \
+		if (a >= (BASE << 16)) \
+			a -= (BASE << 16); \
+		if (a >= (BASE << 15)) \
+			a -= (BASE << 15); \
+		if (a >= (BASE << 14)) \
+			a -= (BASE << 14); \
+		if (a >= (BASE << 13)) \
+			a -= (BASE << 13); \
+		if (a >= (BASE << 12)) \
+			a -= (BASE << 12); \
+		if (a >= (BASE << 11)) \
+			a -= (BASE << 11); \
+		if (a >= (BASE << 10)) \
+			a -= (BASE << 10); \
+		if (a >= (BASE << 9)) \
+			a -= (BASE << 9); \
+		if (a >= (BASE << 8)) \
+			a -= (BASE << 8); \
+		if (a >= (BASE << 7)) \
+			a -= (BASE << 7); \
+		if (a >= (BASE << 6)) \
+			a -= (BASE << 6); \
+		if (a >= (BASE << 5)) \
+			a -= (BASE << 5); \
+		if (a >= (BASE << 4)) \
+			a -= (BASE << 4); \
+		if (a >= (BASE << 3)) \
+			a -= (BASE << 3); \
+		if (a >= (BASE << 2)) \
+			a -= (BASE << 2); \
+		if (a >= (BASE << 1)) \
+			a -= (BASE << 1); \
+		if (a >= BASE) \
+			a -= BASE; \
+	} while (0)
+#define MOD4(a) \
+	do { \
+		if (a >= (BASE << 4)) \
+			a -= (BASE << 4); \
+		if (a >= (BASE << 3)) \
+			a -= (BASE << 3); \
+		if (a >= (BASE << 2)) \
+			a -= (BASE << 2); \
+		if (a >= (BASE << 1)) \
+			a -= (BASE << 1); \
+		if (a >= BASE) \
+			a -= BASE; \
+	} while (0)
+#else
+#define MOD(a) a %= BASE
+#define MOD4(a) a %= BASE
+#endif
 
 /* ========================================================================= */
-uLong adler32(adler, buf, len)
+uLong ZEXPORT adler32(adler, buf, len)
     uLong adler;
-    Bytef *buf;
+    const Bytef *buf;
     uInt len;
 {
-    unsigned long s1 = adler & 0xffff;
-    unsigned long s2 = (adler >> 16) & 0xffff;
-    int k;
+    unsigned long sum2;
+    unsigned n;
 
-    if (buf == Z_NULL) return 1L;
+    /* split Adler-32 into component sums */
+    sum2 = (adler >> 16) & 0xffff;
+    adler &= 0xffff;
 
-    while (len > 0) {
-	k = len < NMAX ? len : NMAX;
-	len -= k;
-	while (k >= 16) {
-	    DO16(buf);
-	    k -= 16;
-	}
-	if (k != 0) do {
-	    DO1(buf);
-	} while (--k);
-	s1 %= BASE;
-	s2 %= BASE;
+    /* in case user likes doing a byte at a time, keep it fast */
+    if (len == 1) {
+        adler += buf[0];
+        if (adler >= BASE)
+            adler -= BASE;
+        sum2 += adler;
+        if (sum2 >= BASE)
+            sum2 -= BASE;
+        return adler | (sum2 << 16);
     }
-    return (s2 << 16) | s1;
+
+    /* initial Adler-32 value (deferred check for len == 1 speed) */
+    if (buf == Z_NULL)
+        return 1L;
+
+    /* in case short lengths are provided, keep it somewhat fast */
+    if (len < 16) {
+        while (len--) {
+            adler += *buf++;
+            sum2 += adler;
+        }
+        if (adler >= BASE)
+            adler -= BASE;
+        MOD4(sum2);             /* only added so many BASE's */
+        return adler | (sum2 << 16);
+    }
+
+    /* do length NMAX blocks -- requires just one modulo operation */
+    while (len >= NMAX) {
+        len -= NMAX;
+        n = NMAX / 16;          /* NMAX is divisible by 16 */
+        do {
+            DO16(buf);          /* 16 sums unrolled */
+            buf += 16;
+        } while (--n);
+        MOD(adler);
+        MOD(sum2);
+    }
+
+    /* do remaining bytes (less than NMAX, still just one modulo) */
+    if (len) {                  /* avoid modulos if none remaining */
+        while (len >= 16) {
+            len -= 16;
+            DO16(buf);
+            buf += 16;
+        }
+        while (len--) {
+            adler += *buf++;
+            sum2 += adler;
+        }
+        MOD(adler);
+        MOD(sum2);
+    }
+
+    /* return recombined sums */
+    return adler | (sum2 << 16);
 }
diff --git a/lib_i386/i386_linux.c b/lib_i386/i386_linux.c
index b4a6f5a3cd..2c4c786ef8 100644
--- a/lib_i386/i386_linux.c
+++ b/lib_i386/i386_linux.c
@@ -24,7 +24,7 @@
 #include <common.h>
 #include <command.h>
 #include <image.h>
-#include <zlib.h>
+#include <u-boot/zlib.h>
 #include <asm/byteorder.h>
 #include <asm/zimage.h>
 
diff --git a/lib_m68k/m68k_linux.c b/lib_m68k/m68k_linux.c
index cc974c2d60..a938e263a2 100644
--- a/lib_m68k/m68k_linux.c
+++ b/lib_m68k/m68k_linux.c
@@ -24,7 +24,7 @@
 #include <common.h>
 #include <command.h>
 #include <image.h>
-#include <zlib.h>
+#include <u-boot/zlib.h>
 #include <bzlib.h>
 #include <watchdog.h>
 #include <environment.h>
diff --git a/lib_microblaze/microblaze_linux.c b/lib_microblaze/microblaze_linux.c
index 68b58d4be8..fbc1ab7f81 100644
--- a/lib_microblaze/microblaze_linux.c
+++ b/lib_microblaze/microblaze_linux.c
@@ -27,7 +27,7 @@
 #include <common.h>
 #include <command.h>
 #include <image.h>
-#include <zlib.h>
+#include <u-boot/zlib.h>
 #include <asm/byteorder.h>
 
 DECLARE_GLOBAL_DATA_PTR;
diff --git a/lib_mips/mips_linux.c b/lib_mips/mips_linux.c
index 556b1804e0..c2f9e42ada 100644
--- a/lib_mips/mips_linux.c
+++ b/lib_mips/mips_linux.c
@@ -24,7 +24,7 @@
 #include <common.h>
 #include <command.h>
 #include <image.h>
-#include <zlib.h>
+#include <u-boot/zlib.h>
 #include <asm/byteorder.h>
 #include <asm/addrspace.h>
 
diff --git a/lib_sh/Makefile b/lib_sh/Makefile
new file mode 100644
index 0000000000..6241503445
--- /dev/null
+++ b/lib_sh/Makefile
@@ -0,0 +1,46 @@
+#
+# (C) Copyright 2003-2004
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(ARCH).a
+
+SOBJS	= memchr.o memcpy.o memmove.o memset.o strlen.o cacheops.o div64.o
+
+COBJS-y = board.o sh_linux.o time.o io_generic.o udivdi3.o sconsole.o
+COBJS-$(CONFIG_CMD_STTESTS) += cmd_sttests.o st_mtests.o
+
+SRCS 	:= $(SOBJS:.o=.S) $(COBJS-y:.o=.c)
+OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS-y))
+
+$(LIB):	$(obj).depend $(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/lib_sh/board.c b/lib_sh/board.c
new file mode 100644
index 0000000000..ce551699ec
--- /dev/null
+++ b/lib_sh/board.c
@@ -0,0 +1,362 @@
+/*
+ * (C) Copyright 2004-2009 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <malloc.h>
+#include <version.h>
+#include <devices.h>
+#include <version.h>
+#include <net.h>
+#include <environment.h>
+#if defined(CONFIG_CMD_NAND)
+#include <nand.h>
+#endif
+#if defined(CONFIG_SPI)
+#include <spi.h>
+#endif
+#include <asm/socregs.h>
+#include <asm/st40reg.h>
+
+extern ulong _uboot_end_data;
+extern ulong _uboot_end;
+
+ulong monitor_flash_len;
+
+#ifndef CONFIG_IDENT_STRING
+#define CONFIG_IDENT_STRING ""
+#endif
+
+const char version_string[] =
+	U_BOOT_VERSION" (" __DATE__ " - " __TIME__ ") - " CONFIG_IDENT_STRING ;
+
+/*
+ * Begin and End of memory area for malloc(), and current "brk"
+ */
+
+#define	TOTAL_MALLOC_LEN	CFG_MALLOC_LEN
+
+static ulong mem_malloc_start;
+static ulong mem_malloc_end;
+static ulong mem_malloc_brk;
+
+extern int soc_init (void); 	/* Detect/set SOC settings  */
+extern int board_init (void);   /* Set up board             */
+extern int timer_init (void);
+extern int checkboard (void);   /* Give info about board    */
+extern int env_init_after_spi_done (void);
+
+static void mem_malloc_init (void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	ulong dest_addr = TEXT_BASE + gd->reloc_off;
+
+	mem_malloc_end = dest_addr;
+	mem_malloc_start = dest_addr - TOTAL_MALLOC_LEN;
+	mem_malloc_brk = mem_malloc_start;
+
+	memset ((void *) mem_malloc_start,
+		0, mem_malloc_end - mem_malloc_start);
+}
+
+void *sbrk (ptrdiff_t increment)
+{
+	ulong old = mem_malloc_brk;
+	ulong new = old + increment;
+
+	if ((new < mem_malloc_start) || (new > mem_malloc_end)) {
+		return (NULL);
+	}
+	mem_malloc_brk = new;
+	return ((void *) old);
+}
+
+static int init_func_ram (void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+#ifdef	CONFIG_BOARD_TYPES
+	int board_type = gd->board_type;
+#endif
+
+	gd->ram_size = CFG_SDRAM_SIZE;
+	puts ("DRAM:  ");
+	print_size (gd->ram_size, "\n");
+
+	return (0);
+}
+
+static int display_banner (void)
+{
+
+	printf ("\n\n%s\n\n", version_string);
+	return (0);
+}
+
+#ifndef CFG_NO_FLASH
+static void display_flash_config (ulong size)
+{
+	//puts ("NOR:   ");
+	print_size (size, "\n");
+}
+#endif /* CFG_NO_FLASH */
+
+
+static int init_baudrate (void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	char tmp[64];		/* long enough for environment variables */
+	int i = getenv_r ("baudrate", tmp, sizeof (tmp));
+
+	gd->baudrate = (i > 0)
+		? (int) simple_strtoul (tmp, NULL, 10)
+		: CONFIG_BAUDRATE;
+
+	return (0);
+}
+
+void flashWriteEnable(void);
+
+/*
+ * All attempts to come up with a "common" initialization sequence
+ * that works for all boards and architectures failed: some of the
+ * requirements are just _too_ different. To get rid of the resulting
+ * mess of board dependend #ifdef'ed code we now make the whole
+ * initialization sequence configurable to the user.
+ *
+ * The requirements for any new initalization function is simple: it
+ * receives a pointer to the "global data" structure as it's only
+ * argument, and returns an integer return code, where 0 means
+ * "continue" and != 0 means "fatal error, hang the system".
+ */
+typedef int (init_fnc_t) (void);
+
+init_fnc_t *init_sequence[] = {
+	soc_init,
+	timer_init,
+	board_init,
+	env_init,		/* initialize environment */
+	init_baudrate,		/* initialze baudrate settings */
+	serial_init,		/* serial communications setup */
+	console_init_f,		/* Initial console             */
+	checkboard,
+	display_banner,		/* say that we are here */
+	init_func_ram,
+	NULL,
+};
+
+
+/* U-BOOT START */
+void start_sh4boot (void)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	bd_t *bd;
+	ulong addr;
+	init_fnc_t **init_fnc_ptr;
+#ifndef CFG_NO_FLASH
+	ulong size;
+#endif /* CFG_NO_FLASH */
+
+	char *s, *e;
+	int i;
+
+	addr = TEXT_BASE;
+	/* Reserve memory for malloc() arena. */
+	addr -= TOTAL_MALLOC_LEN;
+	/* (permanently) allocate a Board Info struct
+	 * and a permanent copy of the "global" data
+	 */
+	addr -= sizeof (gd_t);
+	gd = (gd_t *) addr;
+	memset ((void *) gd, 0, sizeof (gd_t));
+	addr -= sizeof (bd_t);
+	bd = (bd_t *) addr;
+	gd->bd = bd;
+
+	/* Reserve memory for boot params.
+	 */
+
+	addr -= CFG_BOOTPARAMS_LEN;
+	for (init_fnc_ptr = init_sequence; *init_fnc_ptr; ++init_fnc_ptr) {
+		if ((*init_fnc_ptr) () != 0) {
+			hang ();
+		}
+	}
+
+	gd->reloc_off = 0;
+	gd->flags |= GD_FLG_RELOC;	/* tell others: relocation done */
+
+	monitor_flash_len = (ulong) & _uboot_end_data - TEXT_BASE;
+
+	/* configure available FLASH banks */
+	flashWriteEnable();
+#ifndef CFG_NO_FLASH
+	size = flash_init ();
+	display_flash_config (size);
+#endif /* CFG_NO_FLASH */
+
+	bd = gd->bd;
+	bd->bi_boot_params = addr;
+	bd->bi_memstart = CFG_SDRAM_BASE;	/* start of  DRAM memory */
+	bd->bi_memsize = gd->ram_size;	/* size  of  DRAM memory in bytes */
+	bd->bi_baudrate = gd->baudrate;	/* Console Baudrate */
+#ifndef CFG_NO_FLASH
+	bd->bi_flashstart = CFG_FLASH_BASE;
+	bd->bi_flashsize = size;
+#if CFG_MONITOR_BASE == CFG_FLASH_BASE
+	bd->bi_flashoffset = monitor_flash_len;	/* reserved area for U-Boot */
+#else
+	bd->bi_flashoffset = 0;
+#endif
+#endif /* CFG_NO_FLASH */
+
+	/* initialize malloc() area */
+	mem_malloc_init ();
+
+#if defined(CONFIG_SPI)
+	//puts ("SPI:  ");
+	spi_init ();		/* go init the SPI */
+#if defined(CFG_ENV_IS_IN_EEPROM) && !defined(CFG_BOOT_FROM_SPI)
+	env_init_after_spi_done ();
+#endif
+#endif	/* defined(CONFIG_SPI) */
+
+	/* Allocate environment function pointers etc. */
+	env_relocate ();
+
+	/* board MAC address */
+	s = getenv ("ethaddr");
+	for (i = 0; i < 6; ++i) {
+		bd->bi_enetaddr[i] = (s ? simple_strtoul (s, &e, 16) : 0)
+			&& 0xff;
+		if (s)
+			s = (*e) ? e + 1 : e;
+	}
+
+	/* IP Address */
+	bd->bi_ip_addr = getenv_IPaddr ("ipaddr");
+
+#if defined(CONFIG_PCI)
+	/*
+	 * Do pci configuration
+	 */
+	pci_init ();
+#endif
+
+/** leave this here (after malloc(), environment and PCI are working) **/
+	/* Initialize devices */
+	devices_init ();
+
+	jumptable_init ();
+
+	/* Initialize the console (after the relocation and devices init) */
+	console_init_r ();
+
+/** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** **/
+	serial_init_pio5();
+	F450_enable();
+	/* Initialize from environment */
+	if ((s = getenv ("loadaddr")) != NULL) {
+		load_addr = simple_strtoul (s, NULL, 16);
+	}
+#if defined(CONFIG_CMD_NET)
+	if ((s = getenv ("bootfile")) != NULL) {
+		copy_filename (BootFile, s, sizeof (BootFile));
+	}
+#endif /* CONFIG_CMD_NET */
+
+#if defined(CONFIG_MISC_INIT_R)
+	/* miscellaneous platform dependent initialisations */
+	misc_init_r ();
+#endif
+
+#if defined(CONFIG_CMD_NET)
+#if defined(CONFIG_NET_MULTI)
+	//puts ("Net:   ");
+#endif
+	eth_initialize(gd->bd);
+#endif
+
+	/* iptv project */
+	update_process();
+
+	/* main_loop() can return to retry autoboot, if so just run it again. */
+	for (;;) {
+		main_loop ();
+	}
+
+	/* NOTREACHED - no way out of command loop except booting */
+}
+
+
+void hang (void)
+{
+	//puts ("### ERROR ### Please RESET the board ###\n");
+	for (;;);
+}
+
+
+static void sh_reset (void) __attribute__ ((noreturn));
+static void sh_reset (void)
+{
+	/*
+	 * We will use the on-chip watchdog timer to force a
+	 * power-on-reset of the device.
+	 * A power-on-reset is required to guarantee all SH4-200 cores
+	 * will reset back into 29-bit mode, if they were in SE mode.
+	 * However, on SH4-300 series parts, issuing a TRAP instruction
+	 * with SR.BL=1 is sufficient. However, we will use a "one size fits
+	 * all" solution here, and use the watchdog for all SH parts.
+	 */
+
+		/* WTCNT          = FF	counter to overflow next tick */
+	*ST40_CPG_WTCNT = 0x5AFF;
+
+		/* WTCSR2.CKS[3]  = 0	use legacy clock dividers */
+	*ST40_CPG_WTCSR2 = 0xAA00;
+
+		/* WTCSR.TME      = 1	enable up-count counter */
+		/* WTCSR.WT       = 1	watchdog timer mode */
+		/* WTCSR.RSTS     = 0	enable power-on reset */
+		/* WTCSR.CKS[2:0] = 2	clock division ratio 1:128 */
+		/* NOTE: we need CKS to be big enough to allow
+		 * U-boot to disable the watchdog, AFTER the reset,
+		 * otherwise, we enter an infinite-loop of resetting! */
+	*ST40_CPG_WTCSR = 0xA5C2;
+
+	/* wait for H/W reset to kick in ... */
+	for (;;);
+}
+
+
+extern int do_reset (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{
+	sh_reset();
+	/*NOTREACHED*/
+	return (0);
+}
diff --git a/lib_sh/cacheops.S b/lib_sh/cacheops.S
new file mode 100644
index 0000000000..efeabcb477
--- /dev/null
+++ b/lib_sh/cacheops.S
@@ -0,0 +1,205 @@
+/*
+ * (C) Copyright 2004-2009 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include "asm/regdef.h"
+#include "asm/addrspace.h"
+#include "asm/asmdefs.h"
+#include "asm/linkage.h"
+#include "asm/sh4reg.h"
+#include "asm/pmb.h"
+
+	.section .text.init, "ax"
+
+	/*
+	 * void sh_cache_set_op (ulong op)
+	 * set bits in ccn.cr
+	 */
+ENTRY(sh_cache_set_op)
+	/* get ccn.cr address into r0 (0xff00001c) */
+	MOV_CONST32_R0	SH4_CCN_CCR
+	mov.l	@r0, r1
+	or	a0, r1
+	mov.l	r1, @r0
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	rts
+	  nop
+
+
+	/*
+	 * void sh_cache_clear_op (ulong op)
+	 * clears bits in ccn.cr
+	 */
+ENTRY(sh_cache_clear_op)
+	/* get ccn.cr address into r0 (0xff00001c) */
+	MOV_CONST32_R0	SH4_CCN_CCR
+	mov.l	@r0, r1
+	not	a0, a0	/* invert op */
+	and	a0, r1	/* clear bits */
+	mov.l	r1, @r0
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	rts
+	  nop
+
+
+#ifdef CONFIG_SH_SE_MODE
+/* Move the PC from one PMB region to another, by masking.
+Note: This macro will clobber r0.
+Usage: .SWITCH_PMB <opcode> <mask_reg>
+where	<opcode> should be the masking opcode: "and" or "or".
+	<mask_reg> register name, containing the mask to use. */
+.macro	SWITCH_PMB opcode:req, mask_reg:req
+	mova	1f, r0
+	\opcode	\mask_reg, r0
+	ldc	r0, spc		/* SPC = PC op mask */
+	stc	sr, r0
+	ldc	r0, ssr		/* SSR = SR */
+	rte			/* do it */
+	  nop
+.balign 4
+1:
+.endm
+
+	/*
+	 * void sh_toggle_pmb_cacheability (void)
+	 *
+	 * Toggles the cacheability for PMB index #0, and
+	 * possibly PMB index #1 as well.
+	 *
+	 * We do this by changing the PC to run out of an
+	 * aliased PMB entry (not #0, or #1), which is UN-cached.
+	 * From here we 'toggle' the cacheability of the
+	 * appropriate PMB array entries, then invalidate
+	 * the ITLB.  Finally we switch back the PC to the
+	 * region we were originally running from.
+	 *
+	 * We only toggle the UB and the C flags of PMB[0],
+	 * and possibly PMB[1].
+	 *
+	 * i.e. this function does:
+	 * {
+	 *	PC        = PC | 0x10000000;
+	 *	PMB[0].C  = ~PMB[0].C;
+	 *	PMB[0].UB = ~PMB[0].UB;
+	 * #if CFG_SH_LMI_NEEDS_2_PMB_ENTRIES
+	 *	PMB[1].C  = ~PMB[1].C;
+	 *	PMB[1].UB = ~PMB[1].UB;
+	 * #endif
+	 *      MMUCR.TI  = 1;
+	 *	PC        = PC & ~0x10000000;
+	 * }
+	 *
+	 * Assumptions:
+	 * 0) We use 'Z' to mean 0 or 1.
+	 * 1) We assume that the PC (on entry) in running in
+	 *    the virtual address space controlled by
+	 *    array index #Z of the PMB.
+	 *    i.e. PC is in VA defined by PMB[Z].
+	 * 2) PMB[Z] may be cached or UN-cached on entry.
+	 *    The cacheability on exit will be inverted,
+	 *    (i.e. toggled) w.r.t the cacheability on entry.
+	 * 3) We assume that an UN-cached PMB entry already
+	 *    exists which is an alias to the same physical
+	 *    address as the PMB entry we are currently running in.
+	 *    i.e. PMB[x] is an UN-cached alias for PMB[Z].
+	 *    so, PMB[Z].PPN == PMB[x].PPN
+	 * 4) The un-cached PMB entry 'x' must not be:
+	 *    a) Index #Z as this is the one we are changing
+	 *    b) Index #15 as the linux kernel uses this on entry.
+	 *    i.e. x is in the range 2 .. 14
+	 *    Typically, x will be 2 (or 3), but this function
+	 *    does not require this assignment.
+	 * 5) We assume that the transition into the
+	 *    UN-cached area PMB[x] can be achieved by setting
+	 *    bit #28 of the PC.  i.e. OR-ing it with 0x10000000.
+	 *    so, PMB[Z].VPN | 0x10000000 == PMB[x].VPN
+	 *    i.e. PMB[Z] has VA 0x80000000 ... 0x8fffffff
+	 *         PMB[x] has VA 0x90000000 ... 0x9fffffff
+	 * 6) We assume both PMB arrays are enabled, valid, and
+	 *    will not result in an expection when dereferecned.
+	 *    i.e. PMB[Z].V == PMB[x].V == 1
+	 */
+ENTRY(sh_toggle_pmb_cacheability)
+	/* use PMB entry arrays #0, and #1 */
+	.set index0, 0		/* PMB array #0 */
+	.set index1, 1		/* PMB array #1 */
+
+	/* set PC mask as bit #28 */
+	.set mask, 0x10000000	/* 0x80000000 ^ 0x90000000 */
+
+	/* set bits to toggle: PMB[n].C and PMB[n].UB */
+	.set toggle, (SH4_PMB_C|SH4_PMB_UB)
+
+	/* switch PC, to run from an UN-cached PMB region */
+	MOV_CONST32_R0 mask	/* Mask */
+	mov	r0, r2
+	SWITCH_PMB or, r2	/* PC = PC | 0x10000000 */
+
+	/* now toggle the cacheability of PMB[0] */
+	MOV_CONST32_R0	(toggle)
+	mov	r0, r3
+	MOV_CONST32_R0	(P4SEG_PMB_DATA|(index0<<8))
+	mov.l	@r0, r1		/* read it */
+	xor	r3, r1		/* xor it */
+	mov.l	r1, @r0		/* write it */
+
+#if CFG_SH_LMI_NEEDS_2_PMB_ENTRIES
+	/* now toggle the cacheability of PMB[1] */
+	MOV_CONST32_R0	(P4SEG_PMB_DATA|(index1<<8))
+	mov.l	@r0, r1		/* read it */
+	xor	r3, r1		/* xor it */
+	mov.l	r1, @r0		/* write it */
+#endif
+
+	/* Invalidate the ITLB, by setting MMUCR.TI */
+	MOV_CONST32_R0 SH4_CCN_MMUCR
+	mov.l	@r0, r1
+	mov	#(SH4_MMUCR_TI), r3
+	or	r3, r1
+	mov.l	r1, @r0
+
+	/* switch PC, to run from original PMB region */
+	not	r2, r2		/* invert the mask */
+	SWITCH_PMB and, r2	/* PC = PC & ~0x10000000 */
+
+	/* return to the caller */
+	rts
+	  nop
+#endif	/* CONFIG_SH_SE_MODE */
+
diff --git a/lib_sh/cmd_sttests.c b/lib_sh/cmd_sttests.c
new file mode 100644
index 0000000000..e113484739
--- /dev/null
+++ b/lib_sh/cmd_sttests.c
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2006
+ * Pierre Morel, WYPLAY, pmorel@wyplay.com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+
+extern int do_st_memory_test(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
+
+int do_st_mtest(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	ulong i, count;
+
+	if (argc !=4) {
+		printf("Usage:\n%s\n", cmdtp->usage);
+		return 1;
+	}
+
+	count = simple_strtoul(argv[3], NULL, 10);
+
+	for (;;) {
+		do_st_memory_test(NULL, 0, 3, argv);
+
+		printf("Type CTRL-C to Abort...");
+		/* delay for <count> ms... */
+		for (i = 0; i < count; i++)
+		{
+			udelay(1000);	/* 1 ms */
+			/* check for ctrl-c to abort... */
+			if (ctrlc()) {
+				puts("Abort\n");
+				return 0;
+			}
+		}
+	}
+
+	return 0;
+}
+
+U_BOOT_CMD(
+	st_mtest, 4, 1, do_st_mtest,
+	"st_mtest- STMicro Memory tests\n",
+	"start length delay\n"
+	"    - STMicro memory tests\n"
+	"      all values in decimal (prepend '0x' for hex)\n"
+	"      delay specified in ms\n"
+);
diff --git a/lib_sh/div64.S b/lib_sh/div64.S
new file mode 100644
index 0000000000..836d99ed50
--- /dev/null
+++ b/lib_sh/div64.S
@@ -0,0 +1,46 @@
+/*
+ * unsigned long long __xdiv64_32(unsigned long long n, unsigned long d);
+ */
+
+#include "asm/linkage.h"
+
+.text
+ENTRY(__xdiv64_32)
+#ifdef  __LITTLE_ENDIAN__
+	mov	r4, r0
+	mov	r5, r1
+#else
+	mov	r4, r1
+	mov	r5, r0
+#endif
+	cmp/hs	r6, r1
+	bf.s	1f
+	 mov	#0, r2
+
+	mov	r1, r2
+	mov	#0, r3
+	div0u
+	.rept	32
+	rotcl	r2
+	div1	r6, r3
+	.endr
+	rotcl	r2
+	mul.l	r6, r2
+	sts	macl, r3
+	sub	r3, r1
+1:
+	div0u
+	.rept	32
+	rotcl	r0
+	div1	r6, r1
+	.endr
+#ifdef  __LITTLE_ENDIAN__
+	mov	r2, r1
+	rts
+	 rotcl	r0
+#else
+	rotcl	r0
+	mov	r0, r1
+	rts
+	 mov	r2, r0
+#endif
diff --git a/lib_sh/io_generic.c b/lib_sh/io_generic.c
new file mode 100644
index 0000000000..79a13b9304
--- /dev/null
+++ b/lib_sh/io_generic.c
@@ -0,0 +1,61 @@
+/*
+ * lib_sh/io_generic.c
+ *
+ * Copyright (C) 2000  Niibe Yutaka
+ *
+ * Generic I/O routine. These can be used where a machine specific version
+ * is not required.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ */
+
+#include <asm/io.h>
+
+void _insb (unsigned long port, void *buffer, unsigned long count)
+{
+	unsigned char *buf = buffer;
+	while (count--)
+		*buf++ = inb (port);
+}
+
+void _insw (unsigned long port, void *buffer, unsigned long count)
+{
+	unsigned short *buf = buffer;
+	while (count--)
+		*buf++ = inw (port);
+}
+
+void _insl (unsigned long port, void *buffer, unsigned long count)
+{
+	unsigned long *buf = buffer;
+	while (count--)
+		*buf++ = inl (port);
+}
+
+void _outsb (unsigned long port, const void *buffer,
+		    unsigned long count)
+{
+	const unsigned char *buf = buffer;
+	while (count--)
+		outb (*buf++, port);
+}
+
+void _outsw (unsigned long port, const void *buffer,
+		    unsigned long count)
+{
+	const unsigned short *buf = buffer;
+	while (count--)
+		outw (*buf++, port);
+}
+
+void _outsl (unsigned long port, const void *buffer,
+		    unsigned long count)
+{
+	const unsigned long *buf = buffer;
+	while (count--)
+		outl (*buf++, port);
+}
+
diff --git a/lib_sh/memchr.S b/lib_sh/memchr.S
new file mode 100644
index 0000000000..801f8344da
--- /dev/null
+++ b/lib_sh/memchr.S
@@ -0,0 +1,27 @@
+/*
+ * lib_sh/memchr.S
+ *
+ * "memchr" implementation of SuperH
+ *
+ * Copyright (C) 1999  Niibe Yutaka
+ *
+ */
+
+/*
+ * void *memchr(const void *s, int c, size_t n);
+ */
+
+#include "asm/linkage.h"
+ENTRY(memchr)
+	tst	r6,r6
+	bt/s	2f
+	 exts.b	r5,r5
+1:	mov.b	@r4,r1
+	cmp/eq	r1,r5
+	bt/s	3f
+	 dt	r6
+	bf/s	1b
+	 add	#1,r4
+2:	mov	#0,r4
+3:	rts
+	 mov	r4,r0
diff --git a/lib_sh/memcpy.S b/lib_sh/memcpy.S
new file mode 100644
index 0000000000..5a87b31ae0
--- /dev/null
+++ b/lib_sh/memcpy.S
@@ -0,0 +1,228 @@
+/*
+ * lib_sh/memcpy.S
+ *
+ * "memcpy" implementation of SuperH
+ *
+ * Copyright (C) 1999  Niibe Yutaka
+ *
+ */
+
+/*
+ * void *memcpy(void *dst, const void *src, size_t n);
+ * No overlap between the memory of DST and of SRC are assumed.
+ */
+
+#include "asm/linkage.h"
+ENTRY(memcpy)
+	tst	r6,r6
+	bt/s	9f		! if n=0, do nothing
+	 mov	r4,r0
+	sub	r4,r5		! From here, r5 has the distance to r0
+	add	r6,r0		! From here, r0 points the end of copying point
+	mov	#12,r1
+	cmp/gt	r6,r1
+	bt/s	7f		! if it's too small, copy a byte at once
+	 add	#-1,r5
+	add	#1,r5
+	!			From here, r6 is free
+	!
+	!      r4   -->  [ ...  ] DST             [ ...  ] SRC
+	!	         [ ...  ]                 [ ...  ]
+	!	           :                        :
+	!      r0   -->  [ ...  ]       r0+r5 --> [ ...  ]
+	!
+	!
+	mov	r5,r1
+	mov	#3,r2
+	and	r2,r1
+	shll2	r1
+	mov	r0,r3		! Save the value on R0 to R3
+	mova	jmptable,r0
+	add	r1,r0
+	mov.l	@r0,r1
+	jmp	@r1
+	 mov	r3,r0		! and back to R0
+	.balign	4
+jmptable:
+	.long	case0
+	.long	case1
+	.long	case2
+	.long	case3
+
+	! copy a byte at once
+7:	mov	r4,r2
+	add	#1,r2
+8:
+	cmp/hi	r2,r0
+	mov.b	@(r0,r5),r1
+	bt/s	8b			! while (r0>r2)
+	 mov.b	r1,@-r0
+9:
+	rts
+	 nop
+
+case0:
+	!
+	!	GHIJ KLMN OPQR -->  GHIJ KLMN OPQR
+	!
+	! First, align to long word boundary
+	mov	r0,r3
+	and	r2,r3
+	tst	r3,r3
+	bt/s	2f
+	 add	#-4,r5
+	add	#3,r5
+1:	dt	r3
+	mov.b	@(r0,r5),r1
+	bf/s	1b
+	 mov.b	r1,@-r0
+	!
+	add	#-3,r5
+2:	! Second, copy a long word at once
+	mov	r4,r2
+	add	#7,r2
+3:	mov.l	@(r0,r5),r1
+	cmp/hi	r2,r0
+	bt/s	3b
+	 mov.l	r1,@-r0
+	!
+	! Third, copy a byte at once, if necessary
+	cmp/eq	r4,r0
+	bt/s	9b
+	 add	#3,r5
+	bra	8b
+	 add	#-6,r2
+
+case1:
+	!
+	!	GHIJ KLMN OPQR -->  ...G HIJK LMNO PQR.
+	!
+	! First, align to long word boundary
+	mov	r0,r3
+	and	r2,r3
+	tst	r3,r3
+	bt/s	2f
+	 add	#-1,r5
+1:	dt	r3
+	mov.b	@(r0,r5),r1
+	bf/s	1b
+	 mov.b	r1,@-r0
+	!
+2:	! Second, read a long word and write a long word at once
+	mov.l	@(r0,r5),r1
+	add	#-4,r5
+	mov	r4,r2
+	add	#7,r2
+	!
+#ifdef __LITTLE_ENDIAN__
+3:	mov	r1,r3		! RQPO
+	shll16	r3
+	shll8	r3		! Oxxx
+	mov.l	@(r0,r5),r1	! NMLK
+	mov	r1,r6
+	shlr8	r6		! xNML
+	or	r6,r3		! ONML
+	cmp/hi	r2,r0
+	bt/s	3b
+	 mov.l	r3,@-r0
+#else
+3:	mov	r1,r3		! OPQR
+	shlr16	r3
+	shlr8	r3		! xxxO
+	mov.l	@(r0,r5),r1	! KLMN
+	mov	r1,r6
+	shll8	r6		! LMNx
+	or	r6,r3		! LMNO
+	cmp/hi	r2,r0
+	bt/s	3b
+	 mov.l	r3,@-r0
+#endif
+	!
+	! Third, copy a byte at once, if necessary
+	cmp/eq	r4,r0
+	bt/s	9b
+	 add	#4,r5
+	bra	8b
+	 add	#-6,r2
+
+case2:
+	!
+	!	GHIJ KLMN OPQR -->  ..GH IJKL MNOP QR..
+	!
+	! First, align to word boundary
+	tst	#1,r0
+	bt/s	2f
+	 add	#-1,r5
+	mov.b	@(r0,r5),r1
+	mov.b	r1,@-r0
+	!
+2:	! Second, read a word and write a word at once
+	add	#-1,r5
+	mov	r4,r2
+	add	#3,r2
+	!
+3:	mov.w	@(r0,r5),r1
+	cmp/hi	r2,r0
+	bt/s	3b
+	 mov.w	r1,@-r0
+	!
+	! Third, copy a byte at once, if necessary
+	cmp/eq	r4,r0
+	bt/s	9b
+	 add	#1,r5
+	mov.b	@(r0,r5),r1
+	rts
+	 mov.b	r1,@-r0
+
+case3:
+	!
+	!	GHIJ KLMN OPQR -->  .GHI JKLM NOPQ R...
+	!
+	! First, align to long word boundary
+	mov	r0,r3
+	and	r2,r3
+	tst	r3,r3
+	bt/s	2f
+	 add	#-1,r5
+1:	dt	r3
+	mov.b	@(r0,r5),r1
+	bf/s	1b
+	 mov.b	r1,@-r0
+	!
+2:	! Second, read a long word and write a long word at once
+	add	#-2,r5
+	mov.l	@(r0,r5),r1
+	add	#-4,r5
+	mov	r4,r2
+	add	#7,r2
+	!
+#ifdef __LITTLE_ENDIAN__
+3:	mov	r1,r3		! RQPO
+	shll8	r3		! QPOx
+	mov.l	@(r0,r5),r1	! NMLK
+	mov	r1,r6
+	shlr16	r6
+	shlr8	r6		! xxxN
+	or	r6,r3		! QPON
+	cmp/hi	r2,r0
+	bt/s	3b
+	 mov.l	r3,@-r0
+#else
+3:	mov	r1,r3		! OPQR
+	shlr8	r3		! xOPQ
+	mov.l	@(r0,r5),r1	! KLMN
+	mov	r1,r6
+	shll16	r6
+	shll8	r6		! Nxxx
+	or	r6,r3		! NOPQ
+	cmp/hi	r2,r0
+	bt/s	3b
+	 mov.l	r3,@-r0
+#endif
+	!
+	! Third, copy a byte at once, if necessary
+	cmp/eq	r4,r0
+	bt/s	9b
+	 add	#6,r5
+	bra	8b
+	 add	#-6,r2
diff --git a/lib_sh/memmove.S b/lib_sh/memmove.S
new file mode 100644
index 0000000000..7a99e22fa6
--- /dev/null
+++ b/lib_sh/memmove.S
@@ -0,0 +1,255 @@
+/*
+ * lib_sh/memmove.S
+ *
+ * "memmove" implementation of SuperH
+ *
+ * Copyright (C) 1999  Niibe Yutaka
+ *
+ */
+
+/*
+ * void *memmove(void *dst, const void *src, size_t n);
+ * The memory areas may overlap.
+ */
+#include "asm/linkage.h"
+
+ENTRY(memmove)
+	! if dest > src, call memcpy (it copies in decreasing order)
+	cmp/hi	r5,r4
+	bf	1f
+	mov.l	2f,r0
+	jmp	@r0
+	 nop
+	.balign 4
+2:	.long	SYMBOL_NAME(memcpy)
+1:
+	sub	r5,r4		! From here, r4 has the distance to r0
+	tst	r6,r6
+	bt/s	9f		! if n=0, do nothing
+	 mov	r5,r0
+	add	r6,r5
+	mov	#12,r1
+	cmp/gt	r6,r1
+	bt/s	8f		! if it's too small, copy a byte at once
+	 add	#-1,r4
+	add	#1,r4
+	!
+	!                [ ...  ] DST             [ ...  ] SRC
+	!	         [ ...  ]                 [ ...  ]
+	!	           :                        :
+	!      r0+r4-->  [ ...  ]       r0    --> [ ...  ]
+	!	           :                        :
+	!	         [ ...  ]                 [ ...  ]
+	!			        r5    -->
+	!
+	mov	r4,r1
+	mov	#3,r2
+	and	r2,r1
+	shll2	r1
+	mov	r0,r3		! Save the value on R0 to R3
+	mova	jmptable,r0
+	add	r1,r0
+	mov.l	@r0,r1
+	jmp	@r1
+	 mov	r3,r0		! and back to R0
+	.balign	4
+jmptable:
+	.long	case0
+	.long	case1
+	.long	case2
+	.long	case3
+
+	! copy a byte at once
+8:	mov.b	@r0+,r1
+	cmp/hs	r5,r0
+	bf/s	8b			! while (r0<r5)
+	 mov.b	r1,@(r0,r4)
+	add	#1,r4
+9:
+	add	r4,r0
+	rts
+	 sub	r6,r0
+
+case_none:
+	bra	8b
+	 add	#-1,r4
+
+case0:
+	!
+	!	GHIJ KLMN OPQR -->  GHIJ KLMN OPQR
+	!
+	! First, align to long word boundary
+	mov	r0,r3
+	and	r2,r3
+	tst	r3,r3
+	bt/s	2f
+	 add	#-1,r4
+	mov	#4,r2
+	sub	r3,r2
+1:	dt	r2
+	mov.b	@r0+,r1
+	bf/s	1b
+	 mov.b	r1,@(r0,r4)
+	!
+2:	! Second, copy a long word at once
+	add	#-3,r4
+	add	#-3,r5
+3:	mov.l	@r0+,r1
+	cmp/hs	r5,r0
+	bf/s	3b
+	 mov.l	r1,@(r0,r4)
+	add	#3,r5
+	!
+	! Third, copy a byte at once, if necessary
+	cmp/eq	r5,r0
+	bt/s	9b
+	 add	#4,r4
+	bra	8b
+	 add	#-1,r4
+
+case3:
+	!
+	!	GHIJ KLMN OPQR -->  ...G HIJK LMNO PQR.
+	!
+	! First, align to long word boundary
+	mov	r0,r3
+	and	r2,r3
+	tst	r3,r3
+	bt/s	2f
+	 add	#-1,r4
+	mov	#4,r2
+	sub	r3,r2
+1:	dt	r2
+	mov.b	@r0+,r1
+	bf/s	1b
+	 mov.b	r1,@(r0,r4)
+	!
+2:	! Second, read a long word and write a long word at once
+	add	#-2,r4
+	mov.l	@(r0,r4),r1
+	add	#-7,r5
+	add	#-4,r4
+	!
+#ifdef __LITTLE_ENDIAN__
+	shll8	r1
+3:	mov	r1,r3		! JIHG
+	shlr8	r3		! xJIH
+	mov.l	@r0+,r1		! NMLK
+	mov	r1,r2
+	shll16	r2
+	shll8	r2		! Kxxx
+	or	r2,r3		! KJIH
+	cmp/hs	r5,r0
+	bf/s	3b
+	 mov.l	r3,@(r0,r4)
+#else
+	shlr8	r1
+3:	mov	r1,r3		! GHIJ
+	shll8	r3		! HIJx
+	mov.l	@r0+,r1		! KLMN
+	mov	r1,r2
+	shlr16	r2
+	shlr8	r2		! xxxK
+	or	r2,r3		! HIJK
+	cmp/hs	r5,r0
+	bf/s	3b
+	 mov.l	r3,@(r0,r4)
+#endif
+	add	#7,r5
+	!
+	! Third, copy a byte at once, if necessary
+	cmp/eq	r5,r0
+	bt/s	9b
+	 add	#7,r4
+	add	#-3,r0
+	bra	8b
+	 add	#-1,r4
+
+case2:
+	!
+	!	GHIJ KLMN OPQR -->  ..GH IJKL MNOP QR..
+	!
+	! First, align to word boundary
+	tst	#1,r0
+	bt/s	2f
+	 add	#-1,r4
+	mov.b	@r0+,r1
+	mov.b	r1,@(r0,r4)
+	!
+2:	! Second, read a word and write a word at once
+	add	#-1,r4
+	add	#-1,r5
+	!
+3:	mov.w	@r0+,r1
+	cmp/hs	r5,r0
+	bf/s	3b
+	 mov.w	r1,@(r0,r4)
+	add	#1,r5
+	!
+	! Third, copy a byte at once, if necessary
+	cmp/eq	r5,r0
+	bt/s	9b
+	 add	#2,r4
+	mov.b	@r0,r1
+	mov.b	r1,@(r0,r4)
+	bra	9b
+	 add	#1,r0
+
+case1:
+	!
+	!	GHIJ KLMN OPQR -->  .GHI JKLM NOPQ R...
+	!
+	! First, align to long word boundary
+	mov	r0,r3
+	and	r2,r3
+	tst	r3,r3
+	bt/s	2f
+	 add	#-1,r4
+	mov	#4,r2
+	sub	r3,r2
+1:	dt	r2
+	mov.b	@r0+,r1
+	bf/s	1b
+	 mov.b	r1,@(r0,r4)
+	!
+2:	! Second, read a long word and write a long word at once
+	mov.l	@(r0,r4),r1
+	add	#-7,r5
+	add	#-4,r4
+	!
+#ifdef __LITTLE_ENDIAN__
+	shll16	r1
+	shll8	r1
+3:	mov	r1,r3		! JIHG
+	shlr16	r3
+	shlr8	r3		! xxxJ
+	mov.l	@r0+,r1		! NMLK
+	mov	r1,r2
+	shll8	r2		! MLKx
+	or	r2,r3		! MLKJ
+	cmp/hs	r5,r0
+	bf/s	3b
+	 mov.l	r3,@(r0,r4)
+#else
+	shlr16	r1
+	shlr8	r1
+3:	mov	r1,r3		! GHIJ
+	shll16	r3
+	shll8	r3		! Jxxx
+	mov.l	@r0+,r1		! KLMN
+	mov	r1,r2
+	shlr8	r2		! xKLM
+	or	r2,r3		! JKLM
+	cmp/hs	r5,r0
+	bf/s	3b		! while(r0<r5)
+	 mov.l	r3,@(r0,r4)
+#endif
+	add	#7,r5
+	!
+	! Third, copy a byte at once, if necessary
+	cmp/eq	r5,r0
+	bt/s	9b
+	 add	#5,r4
+	add	#-3,r0
+	bra	8b
+	 add	#-1,r4
diff --git a/lib_sh/memset.S b/lib_sh/memset.S
new file mode 100644
index 0000000000..3b705b61e1
--- /dev/null
+++ b/lib_sh/memset.S
@@ -0,0 +1,58 @@
+/*
+ * lib_sh/memset.S
+ *
+ * "memset" implementation of SuperH
+ *
+ * Copyright (C) 1999  Niibe Yutaka
+ *
+ */
+
+/*
+ *            void *memset(void *s, int c, size_t n);
+ */
+
+#include "asm/linkage.h"
+
+ENTRY(memset)
+	tst	r6,r6
+	bt/s	5f		! if n=0, do nothing
+	 add	r6,r4
+	mov	#12,r0
+	cmp/gt	r6,r0
+	bt/s	4f		! if it's too small, set a byte at once
+	 mov	r4,r0
+	and	#3,r0
+	cmp/eq	#0,r0
+	bt/s	2f		! It's aligned
+	 sub	r0,r6
+1:
+	dt	r0
+	bf/s	1b
+	 mov.b	r5,@-r4
+2:				! make VVVV
+	swap.b	r5,r0		!   V0
+	or	r0,r5		!   VV
+	swap.w	r5,r0		! VV00
+	or	r0,r5		! VVVV
+	!
+	mov	r6,r0
+	shlr2	r0
+	shlr	r0		! r0 = r6 >> 3
+3:
+	dt	r0
+	mov.l	r5,@-r4		! set 8-byte at once
+	bf/s	3b
+	 mov.l	r5,@-r4
+	!
+	mov	#7,r0
+	and	r0,r6
+	tst	r6,r6
+	bt	5f
+	! fill bytes
+4:
+	dt	r6
+	bf/s	4b
+	 mov.b	r5,@-r4
+5:
+	rts
+	 mov	r4,r0
diff --git a/lib_sh/sconsole.c b/lib_sh/sconsole.c
new file mode 100644
index 0000000000..4408e8681c
--- /dev/null
+++ b/lib_sh/sconsole.c
@@ -0,0 +1,127 @@
+/*
+ * (C) Copyright 2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * (C) Copyright 2009 STMicroelectronics.
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <common.h>
+
+#include "sconsole.h"
+
+#if	!defined(CONFIG_SH_SCIF_SERIAL) &&	\
+	!defined(CONFIG_STM_ASC_SERIAL) &&	\
+	!defined(CONFIG_STM_DTF_SERIAL)
+
+int serial_init (void)
+{
+	sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+	sb->pos = 0;
+	sb->size = 0;
+	sb->max_size = CFG_SCONSOLE_SIZE - sizeof (sconsole_buffer_t);
+
+	return (0);
+}
+
+void serial_putc (char c)
+{
+	if (sconsole_putc) {
+		(*sconsole_putc) (c);
+	} else {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+		if (c) {
+			sb->data[sb->pos++] = c;
+			if (sb->pos == sb->max_size) {
+				sb->pos = 0;
+			}
+			if (sb->size < sb->max_size) {
+				sb->size++;
+			}
+		}
+	}
+}
+
+void serial_puts (const char *s)
+{
+	if (sconsole_puts) {
+		(*sconsole_puts) (s);
+	} else {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+
+		while (*s) {
+			sb->data[sb->pos++] = *s++;
+			if (sb->pos == sb->max_size) {
+				sb->pos = 0;
+			}
+			if (sb->size < sb->max_size) {
+				sb->size++;
+			}
+		}
+	}
+}
+
+int serial_getc (void)
+{
+	if (sconsole_getc) {
+		return (*sconsole_getc) ();
+	} else {
+		return 0;
+	}
+}
+
+int serial_tstc (void)
+{
+	if (sconsole_tstc) {
+		return (*sconsole_tstc) ();
+	} else {
+		return 0;
+	}
+}
+
+void serial_setbrg (void)
+{
+	if (sconsole_setbrg) {
+		(*sconsole_setbrg) ();
+	}
+}
+
+void sconsole_flush (void)
+{
+	if (sconsole_putc) {
+		sconsole_buffer_t *sb = SCONSOLE_BUFFER;
+		unsigned int end = sb->pos < sb->size
+			? sb->pos + sb->max_size - sb->size
+			: sb->pos - sb->size;
+
+		while (sb->size) {
+			(*sconsole_putc) (sb->data[end++]);
+			if (end == sb->max_size) {
+				end = 0;
+			}
+			sb->size--;
+		}
+	}
+}
+#endif
diff --git a/lib_sh/sconsole.h b/lib_sh/sconsole.h
new file mode 100644
index 0000000000..a387584165
--- /dev/null
+++ b/lib_sh/sconsole.h
@@ -0,0 +1,63 @@
+/*
+ * (C) Copyright 2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * (C) Copyright 2009 STMicroelectronics.
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _SCONSOLE_H_
+#define _SCONSOLE_H_
+
+#include <config.h>
+
+
+/*
+ * set the address and size of the SCONSOLE_BUFFER,
+ * if not explicitly defined in the config.h file.
+ */
+#ifndef CFG_SCONSOLE_ADDR
+#define CFG_SCONSOLE_ADDR		CFG_SDRAM_BASE
+#endif	/* CFG_SCONSOLE_ADDR */
+#ifndef CFG_SCONSOLE_SIZE
+#define CFG_SCONSOLE_SIZE		0x2000	/* 8 KiB */
+#endif	/* CFG_SCONSOLE_SIZE */
+
+
+typedef struct sconsole_buffer_s
+{
+	unsigned long size;
+	unsigned long max_size;
+	unsigned long pos;
+	char data[1];
+} sconsole_buffer_t;
+
+#define SCONSOLE_BUFFER		((sconsole_buffer_t *) CFG_SCONSOLE_ADDR)
+
+extern void (*sconsole_putc) (char);
+extern void (*sconsole_puts) (const char *);
+extern int (*sconsole_getc) (void);
+extern int (*sconsole_tstc) (void);
+extern void (*sconsole_setbrg) (void);
+
+extern void sconsole_flush (void);
+
+#endif
diff --git a/lib_sh/sh_linux.c b/lib_sh/sh_linux.c
new file mode 100644
index 0000000000..1137cd02a1
--- /dev/null
+++ b/lib_sh/sh_linux.c
@@ -0,0 +1,412 @@
+/*
+ * (C) Copyright 2004-2008 STMicroelectronics.
+ *
+ * Andy Sturges <andy.sturges@st.com>
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/cache.h>
+#include <asm/io.h>
+#include <asm/sh4reg.h>
+#include <asm/addrspace.h>
+#include <asm/pmb.h>
+
+#ifdef CONFIG_SHOW_BOOT_PROGRESS
+# include <status_led.h>
+# define SHOW_BOOT_PROGRESS(arg)	show_boot_progress(arg)
+#else
+# define SHOW_BOOT_PROGRESS(arg)
+#endif
+
+int gunzip (void *, int, unsigned char *, int *);
+
+extern image_header_t header;	/* from cmd_bootm.c */
+
+extern int do_reset (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[]);
+
+#define PAGE_OFFSET 0x1000
+
+#define MOUNT_ROOT_RDONLY	((unsigned long *) (param+0x000))
+#define RAMDISK_FLAGS		((unsigned long *) (param+0x004))
+#define ORIG_ROOT_DEV		((unsigned long *) (param+0x008))
+#define LOADER_TYPE		((unsigned long *) (param+0x00c))
+#define INITRD_START		((unsigned long *) (param+0x010))
+#define INITRD_SIZE		((unsigned long *) (param+0x014))
+#define SE_MODE			((const unsigned long *) (param+0x018))
+/* ... */
+#define COMMAND_LINE		((char *) (param+0x100))
+
+
+extern void sh_cache_set_op(ulong);
+extern void flashWriteDisable(void);
+#ifdef CONFIG_SH_SE_MODE
+extern void sh_toggle_pmb_cacheability(void);
+#endif	/* CONFIG_SH_SE_MODE */
+
+#ifdef CONFIG_SH_SE_MODE
+#define CURRENT_SE_MODE 32	/* 32-bit (Space Enhanced) Mode */
+#define	PMB_ADDR(i)	((volatile unsigned long*)(P4SEG_PMB_ADDR+((i)<<8)))
+#else
+#define CURRENT_SE_MODE 29	/* 29-bit (Traditional) Mode */
+#endif	/* CONFIG_SH_SE_MODE */
+
+void do_bootm_linux (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[],
+		     ulong addr, ulong * len_ptr, int verify)
+{
+	DECLARE_GLOBAL_DATA_PTR;
+
+	ulong len = 0, checksum;
+	ulong initrd_start;
+	ulong data, param;
+	void (*theKernel) (void);
+	image_header_t *hdr = &header;
+	char *commandline = getenv ("bootargs");
+	char extra[128];	/* Extra command line args */
+	extra[0] = 0;
+#ifdef CONFIG_SH_SE_MODE
+	size_t i;
+#endif	/* CONFIG_SH_SE_MODE */
+
+	theKernel = (void (*)(void)) ntohl (hdr->ih_ep);
+	param = ntohl (hdr->ih_load);
+
+	/*
+	 * Check if there is an initrd image
+	 */
+	if (argc >= 3) {
+		SHOW_BOOT_PROGRESS (9);
+
+		addr = simple_strtoul (argv[2], NULL, 16);
+
+		/* Copy header so we can blank CRC field for re-calculation */
+		memcpy (&header, (char *) addr, sizeof (image_header_t));
+
+		if (ntohl (hdr->ih_magic) != IH_MAGIC) {
+			printf ("Bad Magic Number\n");
+			SHOW_BOOT_PROGRESS (-10);
+			do_reset (cmdtp, flag, argc, argv);
+		}
+
+		data = (ulong) & header;
+		len = sizeof (image_header_t);
+
+		checksum = ntohl (hdr->ih_hcrc);
+		hdr->ih_hcrc = 0;
+
+		if (crc32 (0, (unsigned char *) data, len) != checksum) {
+			printf ("Bad Header Checksum\n");
+			SHOW_BOOT_PROGRESS (-11);
+			do_reset (cmdtp, flag, argc, argv);
+		}
+
+		SHOW_BOOT_PROGRESS (10);
+
+		print_image_hdr (hdr);
+
+		data = addr + sizeof (image_header_t);
+		len = ntohl (hdr->ih_size);
+
+		if (verify) {
+			ulong csum = 0;
+
+			printf ("   Verifying Checksum ... ");
+			csum = crc32 (0, (unsigned char *) data, len);
+			if (csum != ntohl (hdr->ih_dcrc)) {
+				printf ("Bad Data CRC\n");
+				SHOW_BOOT_PROGRESS (-12);
+				do_reset (cmdtp, flag, argc, argv);
+			}
+			printf ("OK\n");
+		}
+
+		SHOW_BOOT_PROGRESS (11);
+
+		if ((hdr->ih_os != IH_OS_LINUX) ||
+		    (hdr->ih_arch != IH_CPU_SH) ||
+		    (hdr->ih_type != IH_TYPE_RAMDISK)) {
+			printf ("No Linux SH Ramdisk Image\n");
+			SHOW_BOOT_PROGRESS (-13);
+			do_reset (cmdtp, flag, argc, argv);
+		}
+
+
+		/*
+		 * Now check if we have a multifile image
+		 */
+	} else if ((hdr->ih_type == IH_TYPE_MULTI) && (len_ptr[1])) {
+		ulong tail = ntohl (len_ptr[0]) % 4;
+		int i;
+
+		SHOW_BOOT_PROGRESS (13);
+
+		/* skip kernel length and terminator */
+		data = (ulong) (&len_ptr[2]);
+		/* skip any additional image length fields */
+		for (i = 1; len_ptr[i]; ++i)
+			data += 4;
+		/* add kernel length, and align */
+		data += ntohl (len_ptr[0]);
+		if (tail) {
+			data += 4 - tail;
+		}
+
+		len = ntohl (len_ptr[1]);
+
+	} else {
+		/*
+		 * no initrd image
+		 */
+		SHOW_BOOT_PROGRESS (14);
+
+		data = 0;
+	}
+
+#ifdef	DEBUG
+	if (!data) {
+		printf ("No initrd\n");
+	}
+#endif
+
+	if (data) {
+		/*
+		 * Copy ramdisk image into place
+		 * data points to start of image
+		 * len gives length of image
+		 * we will copy image onto end of kernel aligned on a page
+		 * boundary
+		 *
+		 */
+		ulong sp;
+	      asm ("mov r15, %0": "=r" (sp):);
+				/* read stack pointer */
+		debug ("## Current stack ends at 0x%08lX ", sp);
+
+		sp -= 2048;	/* just to be sure */
+		if (sp > (CFG_SDRAM_BASE + CFG_BOOTMAPSZ))
+			sp = (CFG_SDRAM_BASE + CFG_BOOTMAPSZ);
+		sp &= ~0xF;
+		initrd_start = (sp - len) & ~(4096 - 1);
+
+		SHOW_BOOT_PROGRESS (12);
+
+		debug ("## initrd at 0x%08lX ... 0x%08lX (len=%ld=0x%lX)\n",
+		       data, data + len - 1, len, len);
+
+		printf ("   Loading Ramdisk to %08lx, length %08lx ... ",
+			initrd_start, len);
+#if defined(CONFIG_HW_WATCHDOG) || defined(CONFIG_WATCHDOG)
+		{
+			size_t l = len;
+			void *to = (void *) initrd_start;
+			void *from = (void *) data;
+
+			while (l > 0) {
+				size_t tail = (l > CHUNKSZ) ? CHUNKSZ : l;
+				WATCHDOG_RESET ();
+				memmove (to, from, tail);
+				to += tail;
+				from += tail;
+				l -= tail;
+			}
+		}
+#else /* !(CONFIG_HW_WATCHDOG || CONFIG_WATCHDOG) */
+		memmove ((void *) initrd_start, (void *) data, len);
+#endif /* CONFIG_HW_WATCHDOG || CONFIG_WATCHDOG */
+		puts ("OK\n");
+
+
+		*LOADER_TYPE = 1;
+		*INITRD_START = (initrd_start - (param - PAGE_OFFSET)) ;	/* passed of offset from memory base */
+		*INITRD_SIZE = len;
+	} else {
+		*LOADER_TYPE = 0;
+		*INITRD_START = 0;
+		*INITRD_SIZE = 0;
+	}
+
+	SHOW_BOOT_PROGRESS (15);
+
+	/* try and detect if the kernel is incompatible with U-boot */
+	if ((*SE_MODE & 0xFFFFFF00) != 0x53453F00)	/* 'SE?.' */
+	{
+		printf("\nWarning: Unable to determine if kernel is built for 29- or 32-bit mode!\n");
+	}
+	else if ((*SE_MODE & 0xFF) != CURRENT_SE_MODE)
+	{
+		printf("\n"
+			"Error: A %2u-bit Kernel is incompatible with this %2u-bit U-Boot!\n"
+			"Please re-configure and re-build vmlinux or u-boot.\n"
+			"Aborting the Boot process - Boot FAILED.  (SE_MODE=0x%08x)\n",
+			CURRENT_SE_MODE ^ (32 ^ 29),
+			CURRENT_SE_MODE,
+			*SE_MODE);
+		return;
+	}
+
+#ifdef DEBUG
+	printf ("## Transferring control to Linux (at address %08lx) initrd =  %08lx ...\n",
+		(ulong) theKernel, *INITRD_START);
+#endif
+
+	strcpy (COMMAND_LINE, commandline);
+
+	{
+		char *CMDHeader;
+		unsigned int CMDLen, i;
+		unsigned char Buffer[30] = {0};
+		unsigned int StartAddr = 0xa0000 + 19;
+		unsigned char MacAddr[13] = {0};
+
+		CMDHeader = COMMAND_LINE;
+		CMDLen = strlen(CMDHeader);
+
+		printf("CMDLen=%d\n", CMDLen);
+		for(i = 0; i < (CMDLen-6); i++) {
+			if(0 == strncmp(&CMDHeader[i], "hwaddr", 6))
+				break;
+			else
+				continue;
+		}
+
+		if(i == (CMDLen-6)) {
+			printf("There is no \"hwaddr\" keywords!\n");
+		} else {
+			printf("There is  \"hwaddr\" keywords! Position=%d\n", i);
+		}
+
+		ReadSPIFlashDataToBuffer(StartAddr, MacAddr, 12);
+
+		MacAddr[12] = 0;
+		printf("Read MacAddr=%s\n", MacAddr);
+		memset(Buffer, 0, 30);
+
+		if(MacAddr[0]==0xff && MacAddr[1]==0xff && MacAddr[2]==0xff ) {
+			printf("There is no valid MAC in spi Flash!\n");
+			//sprintf(Buffer,"hwaddr:%s", "10:08:E2:12:06:BD" );
+		} else {
+			sprintf(Buffer,"hwaddr:%c%c:%c%c:%c%c:%c%c:%c%c:%c%c", MacAddr[0],MacAddr[1],MacAddr[2],MacAddr[3], \
+							MacAddr[4],MacAddr[5],MacAddr[6],MacAddr[7],MacAddr[8],MacAddr[9],MacAddr[10],MacAddr[11]);
+		}
+
+		//sprintf(Buffer,"hwaddr:%c%c:%c%c:%c%c:%c%c:%c%c:%c%c", MacAddr[0],MacAddr[1],MacAddr[2],MacAddr[3], \
+		//				MacAddr[4],MacAddr[5],MacAddr[6],MacAddr[7],MacAddr[8],MacAddr[9],MacAddr[10],MacAddr[11]);
+		memcpy(&CMDHeader[i], Buffer, strlen(Buffer));
+	}
+
+	if (*extra)
+		strcpy (COMMAND_LINE + strlen (commandline), extra);
+
+	/* linux_params_init (gd->bd->bi_boot_params, commandline); */
+
+	printf ("\n[iptv_kernel]:Starting kernel %s - 0x%08x - %d ...\n\n", COMMAND_LINE,
+		*INITRD_START, *INITRD_SIZE);
+
+	/*
+	 * remove Vpp from the FLASH, so that no further writes can occur.
+	 */
+	flashWriteDisable();
+
+	/*
+	 * Flush the operand caches, to ensure that there is no unwritten
+	 * data residing only in the caches, before the kernel invalidates
+	 * them.
+	 */
+	sh_flush_cache_all();
+
+	/* Invalidate both instruction and data caches */
+	sh_cache_set_op(SH4_CCR_OCI|SH4_CCR_ICI);
+
+#ifdef CONFIG_SH_SE_MODE
+	/*
+	 * Before we can jump into the kernel, we need to invalidate all
+	 * (bar one, or two) of the PMB array entries we are currently using.
+	 * Failure to do this, can result in the kernel creating a
+	 * new PMB entry with an overlapping virtual address, which
+	 * when accessed may result in a ITLBMULTIHIT or OTLBMULTIHIT
+	 * exception being raised.
+	 *
+	 * We also need to enter the kernel running out of an UNCACHED
+	 * PMB entry. To perform this mode switch, we actually need to
+	 * have 2 PMB entries (#0, #2) both valid for the duration of
+	 * this mode switching. However, we invalidate all the others,
+	 * prior to this mode switch. Only after the mode switch, can
+	 * we then invalidate PMB[2], leaving just one (uncached) PMB
+	 * still valid - the one mapping the kernel itself (PMB[0]).
+	 *
+	 * Note: if CFG_SH_LMI_NEEDS_2_PMB_ENTRIES is true, then
+	 * please read the previous comment as:
+	 *
+	 * We also need to enter the kernel running out of an UNCACHED
+	 * PMB entry. To perform this mode switch, we actually need to
+	 * have 4 PMB entries (#0, #1, #2 & #3) valid for the duration of
+	 * this mode switching. However, we invalidate all the others,
+	 * prior to this mode switch. Only after the mode switch, can
+	 * we then invalidate PMB[2:3], leaving just two (uncached) PMB
+	 * still valid - the two mapping the kernel itself (PMB[0:1]).
+	 *
+	 * Note: after this point, U-boot may lose access to
+	 * peripherals, including the serial console - so we can not
+	 * safely call puts(), printf(), etc. from this point onwards.
+	 */
+#if CFG_SH_LMI_NEEDS_2_PMB_ENTRIES
+	/* set PMB[n].V = 0, for n == 4..15 */
+	for(i = 4; i < 16; i++)
+	{
+		*PMB_ADDR(i) = 0;	/* PMB[i].V = 0 */
+	}
+#else	/* CFG_SH_LMI_NEEDS_2_PMB_ENTRIES */
+	/* set PMB[n].V = 0, for n == 1, 3..15 */
+	*PMB_ADDR(1) = 0;		/* PMB[1].V = 0 */
+	for(i = 3; i < 16; i++)
+	{
+		*PMB_ADDR(i) = 0;	/* PMB[i].V = 0 */
+	}
+#endif	/* CFG_SH_LMI_NEEDS_2_PMB_ENTRIES */
+
+	/*
+	 * Now run out of the UN-cached PMB array #0 (and #1).
+	 * For 32-bit mode, our contract with the kernel requires
+	 * that the kernel starts running out of an uncached PMB mapping.
+	 */
+	sh_toggle_pmb_cacheability();
+
+#if CFG_SH_LMI_NEEDS_2_PMB_ENTRIES
+	/* now invalidate PMB entry #2, #3, leaving just PMB #0, #1 valid */
+	*PMB_ADDR(2) = 0;	/* PMB[2].V = 0 */
+	*PMB_ADDR(3) = 0;	/* PMB[3].V = 0 */
+#else	/* CFG_SH_LMI_NEEDS_2_PMB_ENTRIES */
+	/* now invalidate PMB entry #2, leaving just PMB #0 valid */
+	*PMB_ADDR(2) = 0;	/* PMB[2].V = 0 */
+#endif	/* CFG_SH_LMI_NEEDS_2_PMB_ENTRIES */
+
+	/*
+	 * we need to ensure that the ITLB is flushed, and not
+	 * harbouring any mappings from the recently invalidated
+	 * PMB entries.
+	 */
+	 *(volatile unsigned long*)SH4_CCN_MMUCR |= SH4_MMUCR_TI;
+#endif	/* CONFIG_SH_SE_MODE */
+
+	/* now, finally, we pass control to the kernel itself ... */
+	theKernel ();
+}
diff --git a/lib_sh/st_mtests.c b/lib_sh/st_mtests.c
new file mode 100644
index 0000000000..dd992f9049
--- /dev/null
+++ b/lib_sh/st_mtests.c
@@ -0,0 +1,755 @@
+/*
+ * (C) Copyright 2006
+ * Pierre Morel, WYPLAY, pmorel@wyplay.com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+
+#define STATS_ON
+
+int memory_test(unsigned long *block_start, unsigned long block_length);
+
+int do_st_memory_test(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	unsigned long *start;
+	unsigned long length;
+	int ret;
+
+	start = (unsigned long *)simple_strtoul(argv[1], NULL, 10);
+	length = simple_strtoul(argv[2], NULL, 10);
+
+	printf("\ndo_st_memory_test: Start: 0x%08x - Length: 0x%08x\n",
+	       start, length);
+	ret = memory_test(start, length);
+	return(ret);
+}
+
+#define CONTROL_BITS(x) ((unsigned long)(x) & 0xFFF80000ul)
+#define ADDRESS_BITS(x) ((unsigned long)(x) & 0x00F7FFFFul)
+
+#define ALL_ZERO 0x00000000ul
+#define ALL_FIVE 0x55555555ul
+#define ALL_AAAA 0xAAAAAAAAul
+#define ALL_ONES 0xFFFFFFFFul
+
+#ifdef STATS_ON
+static int stats_run_fails;
+static int stats_run_pattern_fails;
+static int stats_run_no_write_fails;
+static int stats_run_write_00000000_fails;
+static int stats_run_write_FFFFFFFF_fails;
+static int stats_run_write_AAAAAAAA_fails;
+static int stats_run_wrote_00000000_fails;
+static int stats_run_move_00000000_fails;
+static int stats_run_move_FFFFFFFF_fails;
+
+static int stats_adj_move_00000000_fails;
+static int stats_adj_move_FFFFFFFF_fails;
+
+static int stats_total_fails;
+static int stats_total_pattern_fails;
+static int stats_total_no_write_fails;
+static int stats_total_write_00000000_fails;
+static int stats_total_write_FFFFFFFF_fails;
+static int stats_total_write_AAAAAAAA_fails;
+static int stats_total_wrote_00000000_fails;
+static int stats_total_move_00000000_fails;
+static int stats_total_move_FFFFFFFF_fails;
+static int stats_total_adj_move_00000000_fails;
+static int stats_total_adj_move_FFFFFFFF_fails;
+static int stats_runs;
+
+static int stats_first_test = 0;
+#endif
+
+/*{{{ void Report(*Address, Pattern, Value, *Message)*/
+void report(volatile unsigned long *address, unsigned long pattern,
+	    unsigned long value, char *message)
+{
+	printf("\r@ 0x%08x  W 0x%08x  R 0x%08x  D 0x%08x   %s\n",
+	       address, pattern, value, (pattern ^ value), message);
+}
+/*}}}  */
+
+/*{{{  int TestPattern(unsigned long *BlockStart, unsigned long BlockLength, unsigned long Pattern, char *Message)*/
+int test_pattern(unsigned long *block_start, unsigned long block_length,
+		 unsigned long pattern, char *message)
+{
+	volatile unsigned long *address;
+	volatile unsigned long *start_address;
+	volatile unsigned long *end_address;
+	unsigned long value;
+	int error = 0;
+
+	start_address = block_start;
+	end_address = start_address + (block_length / sizeof (unsigned int));
+
+	printf("Data Bus Pattern test (0x%08lx) Address from 0x%08x to 0x%08x\n",
+		pattern, start_address, end_address);
+
+	/* Write Pattern */
+	for (address = start_address; address < end_address - 1; address++)
+		*address = pattern;
+
+	*(address) = ~pattern ;	/* To change value on the bus */
+	/* Verify Pattern */
+	for (address = start_address; address < end_address-1; address++) {
+		value = *address;
+		if (value != pattern) {
+			if(error < 5)
+				report(address, pattern, value, message);
+			error++;
+			/*{{{  stats*/
+#ifdef STATS_ON
+			stats_run_fails++;
+			stats_run_pattern_fails++;
+#endif
+			/*}}}  */
+		}
+	}
+	printf ("Found %X errors for Pattern %x\n", error, pattern);
+	return error;
+}
+/*}}}  */
+
+/*{{{  int SlidingTest(unsigned long *BlockStart, int Buswidth)*/
+int sliding_test(unsigned long *block_start, int buswidth)
+{
+	volatile unsigned long *address;
+	unsigned long value;
+	unsigned long pattern;
+	int error = 0;
+	int i;
+
+	address = block_start;
+	/*Sliding One*/
+	printf("Sliding one test\n");
+	pattern = 0x1;
+	for (i = 0; i < buswidth; i++) {
+		*address = pattern;
+		*(address + 1) = 0;
+		value = *address;
+		if (pattern != value) {
+			if(error < 20)
+				report(address, pattern, value, "sliding one");
+			error++;
+		}
+		pattern = pattern << 1;
+	}
+
+	/*Sliding Zero*/
+	printf("Sliding zero test\n");
+	pattern = 0xFFFFFFFE;
+	for (i = 0; i < buswidth; i++) {
+		*address = pattern;
+		*(address +1) = ~pattern;
+		value = *address;
+		if (pattern != value) {
+			if(error < 20)
+				report(address, pattern, value, "sliding zero");
+			error++;
+		/*{{{  stats*/
+#ifdef STATS_ON
+			stats_run_fails++;
+			stats_run_pattern_fails++;
+#endif
+		/*}}}  */
+		}
+		pattern = (pattern << 1) | 1;
+	}
+	return error;
+}
+/*}}}  */
+
+
+/*{{{  int AddressTests(unsigned long *BlockStart, unsigned long BlockLength)*/
+int address_tests(unsigned long *block_start, unsigned long block_length)
+{
+	volatile unsigned long *address;
+	volatile unsigned long *start_address;
+	volatile unsigned long *end_address;
+	unsigned long memory_size;
+	unsigned long value, pattern;
+	int error = 0, error_verify =0;
+	int dot_count;
+
+	/* Work out start and end addresses */
+	start_address = block_start;
+	memory_size = block_length;
+	end_address = start_address + (memory_size / sizeof (unsigned int));
+	printf("Testing memory address bus from 0x%08x to 0x%08x\n",
+	       start_address, end_address);
+
+	/*Alternate location */
+	printf("Alternate address test\n");
+	*start_address = ALL_FIVE;
+	*(start_address + 1) = ALL_AAAA;
+	value = *start_address;
+	if (value != ALL_FIVE) {
+		if(error < 20)
+			report(start_address, ALL_FIVE, value, "Alternate address test");
+	/*{{{  stats*/
+#ifdef STATS_ON
+		stats_run_fails++;
+		stats_run_pattern_fails++;
+#endif
+	/*}}}  */
+		error++;
+	}
+	value = *(start_address + 1);
+	if (value != ALL_AAAA) {
+		if(error < 20)
+			report((start_address + 1), ALL_AAAA, value, "Alternate address test");
+	/*{{{  stats*/
+#ifdef STATS_ON
+		stats_run_fails++;
+		stats_run_pattern_fails++;
+#endif
+	/*}}}  */
+		error++;
+	}
+#ifdef FAST_TEST
+
+	/*Fast Address Test */
+	printf("Fast address test\n");
+
+	address = start_address +1 ;
+
+	for (address = start_address + 1; address < end_address;
+	     address = (unsigned long *)(start_address + (ADDRESS_BITS(Address) << 2))) {
+/*	     address = (unsigned long *)(CONTROL_BITS(address) | (ADDRESS_BITS(address) << 2))) {*/
+		*address = ~(unsigned long)address;
+		printf("checking address 0x%X\n", Address);
+	}
+	for (address = start_address + 1; address < end_address;
+	     address = (unsigned long *)(start_address + (ADDRESS_BITS(address) << 2))) {
+/*	     address = (unsigned long *)(CONTROL_BITS(address) | (ADDRESS_BITS(address) << 2))) {*/
+		pattern = ~((unsigned long)address);
+		value = *address;
+		if (pattern != value) {
+			if(error < 20)
+				report(address, pattern, value, "Fast address test");
+		/*{{{  stats*/
+#ifdef STATS_ON
+			stats_run_fails++;
+			stats_run_pattern_fails++;
+#endif
+		/*}}}  */
+			error++;
+		}
+	}
+#endif
+
+	/* Address Test */
+	printf("Address test ... may take a while ...\n");
+	dot_count = 0;
+	for (address = start_address; address < end_address; address += 0x20) {
+		*address = ~((unsigned long)address);
+		pattern = ~((unsigned long)address);
+		value = *address ;
+		if (value != pattern) {
+			if(error_verify < 20)
+				report(address, pattern, value, "Address test");
+			error_verify++;
+		}
+		dot_count++;
+		if (dot_count >= 0x4000) {
+			dot_count = 0;
+			printf("w");
+		}
+	}
+	printf("\n");
+	if (error_verify !=0)
+		printf("Immediate verify after write show %x error(s)\n", error_verify) ;
+
+	dot_count = 0;
+	for (address = start_address; address < end_address; address += 0x20) {
+		pattern = ~((unsigned long)address);
+		value = *address;
+		if (pattern != value) {
+			if(error < 20)
+				report(address, pattern, value, "Address test");
+			error++;
+		}
+		dot_count++;
+		if (dot_count >= 0x4000) {
+			dot_count = 0;
+			printf("r");
+		}
+	}
+
+	return error;
+}
+/*}}}  */
+
+/*{{{  int BlockMoveTests(unsigned long *BlockStart, unsigned long BlockLength)*/
+int block_move_tests(unsigned long *block_start, unsigned long block_length)
+{
+	volatile unsigned long *address;
+	volatile unsigned long *start_address;
+	volatile unsigned long *end_address;
+	volatile unsigned long *src_start;
+	volatile unsigned long *src_end;
+	volatile unsigned long *dst_start;
+	volatile unsigned long *dst_end;
+	unsigned long memory_size, pattern, value;
+	int error = 0;
+	int totalerrors = 0;
+	int dot_count;
+	/*int i;
+	int seed=5;*/
+
+	/*Block Move Test */
+	printf("\nBlock Move test ---------------------------------------------\n");
+	/*Set up Block address pointers*/
+	start_address = block_start;
+	end_address = (start_address + (block_length / sizeof (unsigned int))-1);
+	memory_size = block_length / 2 / sizeof(long);
+	src_start = start_address;
+	src_end = (start_address + memory_size) - 1;
+	dst_start = (src_end + 1);
+	dst_end = end_address;
+	printf("Source Block from 0x%08x to 0x%08x\n", src_start, src_end);
+	printf("Destination Block from 0x%08x to 0x%08x\n", dst_start, dst_end);
+
+	/*{{{	Initialise Memory*/
+	/*Initialise Memory*/
+	printf("Fill Memory with 0x01020304\n");
+	dot_count = 0;
+	for (address = start_address; address < end_address; address++) {
+		*address = 0x01020304;
+		dot_count++;
+		if (dot_count >= 0x40000) {
+			dot_count = 0;
+			printf("w");
+		}
+	}
+	/*}}}	*/
+	/*{{{	Verify Memory*/
+	printf("\n");
+	dot_count = 0;
+	for (address = start_address; address < end_address; address++) {
+		pattern = 0x01020304;
+		value = *address;
+		if (pattern != value) {
+			if(error < 20)
+				report(address, pattern, value, "Block Move test init 0x01020304");
+			/*{{{	stats*/
+#ifdef STATS_ON
+			stats_run_fails++;
+			if (value == 0)
+				stats_run_write_00000000_fails++;
+#endif
+			/*}}}	*/
+			error++;
+		}
+		dot_count++;
+		if (dot_count >= 0x40000) {
+			dot_count = 0;
+			printf("r");
+		}
+	}
+	/*}}}	*/
+
+	/*{{{	Fill source block with alternating F's and 0's*/
+	/*Fill Source Block*/
+	printf("\nFill Source Block of Memory with F's and 0's\n");
+	dot_count = 0;
+	for (address = src_start; address < src_end;) {
+		*address++ = 0x0;
+		*address++ = 0x0;
+		*address++ = 0xFFFFFFFF;
+		*address++ = 0xFFFFFFFF;
+		dot_count+=4;
+		if (dot_count >= 0x40000) {
+			dot_count = 0;
+			printf("w");
+		}
+	}
+	/*}}}	*/
+
+	/*{{{	Fill destination block with A's*/
+	/*Fill Destination Block*/
+	printf("\nFill Destination Block of Memory with A's\n");
+	dot_count = 0;
+	for (address = dst_start; address < dst_end;) {
+		*address++ = 0xAAAAAAAA;
+		dot_count++;
+		if (dot_count >= 0x40000) {
+			dot_count = 0;
+			printf("w");
+		}
+	}
+	/*}}}	*/
+
+	printf("\n");
+
+	/*{{{	Verify source block with alternating F's and 0's*/
+	/*Verify Source block*/
+	printf("Verifying source block F's and 0's\n");
+	dot_count = 0;
+	for (address = src_start; address < src_end;) {
+		pattern = 0x0;
+		value = *address++;
+		if (pattern != value) {
+			if(error < 20)
+				report(address, pattern, value, "Source block initialisation error");
+			/*{{{	stats*/
+#ifdef STATS_ON
+			stats_run_fails++;
+			stats_run_write_00000000_fails++;
+			if (value == 0x01020304)
+				stats_run_no_write_fails++;
+#endif
+			/*}}}	*/
+			error++;
+		}
+		value = *address++;
+		if (pattern != value) {
+			if(error < 20)
+				report(address, pattern, value, "Source block initialisation error");
+			/*{{{	stats*/
+#ifdef STATS_ON
+			stats_run_fails++;
+			stats_run_write_00000000_fails++;
+			if (value == 0x01020304)
+				stats_run_no_write_fails++;
+#endif
+			/*}}}	*/
+			error++;
+		}
+		pattern = 0xFFFFFFFF;
+		value = *address++;
+		if (pattern != value) {
+			if(error < 20)
+				report(address, pattern, value, "Source block initialisation error");
+			/*{{{	stats*/
+#ifdef STATS_ON
+			stats_run_fails++;
+			stats_run_write_FFFFFFFF_fails++;
+			if (value == 0)
+				stats_run_wrote_00000000_fails++;
+			if (value == 0x01020304)
+				stats_run_no_write_fails++;
+#endif
+			/*}}}	*/
+			error++;
+		}
+		value = *address++;
+		if (pattern != value) {
+			if(error < 20)
+				report(address, pattern, value, "Source block initialisation error");
+			/*{{{	stats*/
+#ifdef STATS_ON
+			stats_run_fails++;
+			stats_run_write_FFFFFFFF_fails++;
+			if (value == 0)
+				stats_run_wrote_00000000_fails++;
+			if (value == 0x01020304)
+				stats_run_no_write_fails++;
+#endif
+			/*}}}	*/
+			error++;
+		}
+		dot_count += 4;
+		if (dot_count >= 0x40000) {
+			dot_count = 0;
+			printf("r");
+		}
+	}
+	totalerrors = error;
+	error = 0;
+	/*}}}	*/
+
+	/*{{{	Verify destination block with A's*/
+	/*Verify destination block*/
+	printf("\n");
+	printf("Verifying Destination block with A's\n");
+	dot_count = 0;
+	for (address = dst_start; address < dst_end;) {
+		pattern = 0xAAAAAAAA;
+		value = *address++;
+		if (pattern != value) {
+			if(error < 20)
+				report(address, pattern, value, "Destination block initialisation error");
+			/*{{{	stats*/
+#ifdef STATS_ON
+			stats_run_fails++;
+			stats_run_write_AAAAAAAA_fails++;
+			if (value == 0)
+				stats_run_wrote_00000000_fails++;
+			if (value == 0x01020304)
+				stats_run_no_write_fails++;
+#endif
+			/*}}}	*/
+			error++;
+		}
+		dot_count++;
+		if (dot_count >= 0x40000) {
+			dot_count = 0;
+			printf("r");
+		}
+	}
+	totalerrors += error;
+	error = 0;
+	/*}}}	*/
+
+
+	/*{{{	move source block to destination block*/
+	/*Move Block*/
+	printf("\nMove Block of Memory\n");
+	memcpy((unsigned long *)dst_start, (unsigned long *)src_start, (int)block_length / 2);
+	/*}}}	*/
+
+	/*{{{	Verify destination block with F's and 0's*/
+	/*Verify Destination Block*/
+	printf("Verify Destination Block F's and 0's\n");
+	dot_count = 0;
+	for (address = dst_start; address < dst_end;) {
+		pattern = 0x0;
+		value = *address++;
+		if (pattern != value) {
+			if(error < 20 )
+				report(address, pattern, value, "Block Move test F's and 0's fill");
+			/*{{{	stats*/
+#ifdef STATS_ON
+			stats_run_fails++;
+			stats_run_move_00000000_fails++;
+			if (value == 0x01020304)
+				stats_run_no_write_fails++;
+			if (value == 0xAAAAAAAA)
+				stats_run_no_write_fails++;
+#endif
+			/*}}}	*/
+			error++;
+		}
+		value = *address++;
+		if (pattern != value) {
+			if(error < 20 )
+				report(address, pattern, value, "Block Move test F's and 0's fill");
+			/*{{{	stats*/
+#ifdef STATS_ON
+			stats_run_fails++;
+			stats_run_move_00000000_fails++;
+			if (value == 0x01020304)
+				stats_run_no_write_fails++;
+			if (value == 0xAAAAAAAA)
+				stats_run_no_write_fails++;
+#endif
+			/*}}}	*/
+			error++;
+		}
+		pattern = 0xFFFFFFFF;
+		value = *address++;
+		if (pattern != value) {
+			if(error < 20 )
+				report(address, pattern, value, "Block Move test F's and 0's fill");
+			/*{{{	stats*/
+#ifdef STATS_ON
+			stats_run_fails++;
+			stats_run_move_FFFFFFFF_fails++;
+			if (value == 0)
+				stats_run_wrote_00000000_fails++;
+			if (value == 0x01020304)
+				stats_run_no_write_fails++;
+			if (value == 0xAAAAAAAA)
+				stats_run_no_write_fails++;
+#endif
+			/*}}}	*/
+			error++;
+		}
+		value = *address++;
+		if (pattern != value) {
+			if(error < 20 )
+				report(address, pattern, value, "Block Move test F's and 0's fill");
+			/*{{{	stats*/
+#ifdef STATS_ON
+			stats_run_fails++;
+			stats_run_move_FFFFFFFF_fails++;
+			if (value == 0)
+				stats_run_wrote_00000000_fails++;
+			if (value == 0x01020304)
+				stats_run_no_write_fails++;
+			if (value == 0xAAAAAAAA)
+				stats_run_no_write_fails++;
+#endif
+			/*}}}	*/
+			error++;
+		}
+		dot_count += 4;
+		if (dot_count >= 0x40000) {
+			dot_count = 0;
+			printf("r");
+		}
+	}
+	totalerrors += error;
+	error = 0;
+	/*}}}	*/
+
+	return totalerrors;
+}
+
+/*}}}	*/
+
+/*{{{	int MemoryTest(unsigned long *BlockStart, unsigned long BlockLength)*/
+int memory_test(unsigned long *block_start, unsigned long block_length)
+{
+	unsigned long error = 0;
+	unsigned long *start_address;
+	unsigned long *end_address;
+	unsigned long memory_size;
+	int buswidth;
+
+
+	printf("\nRunning memory tester ... V1.1\n\n");
+
+#ifdef STATS_ON
+	/*{{{	init stats*/
+	if (stats_first_test == 0) {
+		printf("STATS: Initialising stat counters ... \n\n");
+		stats_first_test = 1;
+		stats_runs = 0;
+
+		stats_total_fails = 0;
+		stats_total_pattern_fails = 0;
+		stats_total_no_write_fails = 0;
+		stats_total_write_00000000_fails = 0;
+		stats_total_write_FFFFFFFF_fails = 0;
+		stats_total_write_AAAAAAAA_fails = 0;
+		stats_total_wrote_00000000_fails = 0;
+		stats_total_move_00000000_fails = 0;
+		stats_total_move_FFFFFFFF_fails = 0;
+
+	}
+	stats_run_fails = 0;
+	stats_run_pattern_fails = 0;
+	stats_run_no_write_fails = 0;
+	stats_run_write_00000000_fails = 0;
+	stats_run_write_FFFFFFFF_fails = 0;
+	stats_run_write_AAAAAAAA_fails = 0;
+	stats_run_wrote_00000000_fails = 0;
+	stats_run_move_00000000_fails = 0;
+	stats_run_move_FFFFFFFF_fails = 0;
+	/*}}}	*/
+#endif
+
+/*{{{	data bus tests*/
+#ifndef NO_PATTERN_TEST
+	/* Work out start and end addresses */
+	start_address = block_start;
+	memory_size = 1024;
+	end_address = start_address + (memory_size / sizeof (unsigned int));
+
+	/* Pattern Tests */
+	error += test_pattern(start_address, memory_size, 0x00000000, "Test pattern (00)");
+	error += test_pattern(start_address, memory_size, 0xFFFFFFFF, "Test pattern (FF)");
+	error += test_pattern(start_address, memory_size, 0x55555555, "Test pattern (55)");
+	error += test_pattern(start_address, memory_size, 0xAAAAAAAA, "Test pattern (AA)");
+#endif
+/*}}}	*/
+
+#ifdef MANUFTEST
+	if (error !=0)
+		return ((int) (error=1)) ;
+#endif
+
+/*{{{	Sliding tests*/
+#ifndef NO_SLIDING_TEST
+	start_address = block_start;
+	buswidth = 32;
+	error+=sliding_test(start_address, buswidth);
+#endif
+/*}}}	*/
+
+#ifdef MANUFTEST
+	if (error !=0)
+		return ((int)(error=1)) ;
+#endif
+
+/*{{{	address tests*/
+#ifndef NO_ADDRESS_TEST
+	start_address = block_start;
+	memory_size = block_length;
+	error += address_tests(start_address, memory_size);
+#endif
+/*}}}	*/
+
+#ifdef MANUFTEST
+	printf("\nMemory test completed with [%ld] errors!\n\n",error);
+	if (error !=0)
+		return ((int)(error=1)) ;
+	else return ((int)(error=0)) ;
+#endif
+
+/*{{{	Block move tests*/
+#ifndef NO_BLOCK_MOVE_TEST
+	start_address = block_start;
+	memory_size = block_length;
+	error += block_move_tests(start_address, memory_size);
+#endif
+/*}}}	*/
+
+	printf("\nMemory test completed with [%ld] errors!\n\n",error);
+	/*{{{	print stats*/
+	#ifdef STATS_ON
+	stats_runs++;
+	stats_total_fails += stats_run_fails;
+	stats_total_pattern_fails += stats_run_pattern_fails;
+	stats_total_no_write_fails += stats_run_no_write_fails;
+	stats_total_write_00000000_fails += stats_run_write_00000000_fails;
+	stats_total_write_FFFFFFFF_fails += stats_run_write_FFFFFFFF_fails;
+	stats_total_write_AAAAAAAA_fails += stats_run_write_AAAAAAAA_fails;
+	stats_total_wrote_00000000_fails += stats_run_wrote_00000000_fails;
+	stats_total_move_00000000_fails	+= stats_run_move_00000000_fails;
+	stats_total_move_FFFFFFFF_fails	+= stats_run_move_FFFFFFFF_fails;
+
+	stats_adj_move_00000000_fails =	stats_run_move_00000000_fails - stats_run_write_00000000_fails;
+	stats_adj_move_FFFFFFFF_fails =	stats_run_move_FFFFFFFF_fails - stats_run_write_FFFFFFFF_fails;
+	stats_total_adj_move_00000000_fails += stats_adj_move_00000000_fails;
+	stats_total_adj_move_FFFFFFFF_fails += stats_adj_move_FFFFFFFF_fails;
+
+
+	printf("============================================================================================\n");
+	printf("STATS:                        \tLast\tTotal\tAverage(over %d runs)\n", stats_runs);
+	printf("STATS:                        \t    \t     \tNumber\t%%\n");
+	printf("STATS: Total fails:           \t%d\t%d\t%d\n", stats_run_fails, stats_total_fails, (stats_total_fails / stats_runs));
+	if (stats_total_fails != 0)	/* ensure we avoid divide by zero! */
+	{
+		printf("STATS: Pattern fails:         \t%d\t%d\t%d\t%d\n", stats_run_pattern_fails, stats_total_pattern_fails, (stats_total_pattern_fails / stats_runs), ((stats_total_pattern_fails * 100) / stats_total_fails));
+		printf("STATS: No write fails:        \t%d\t%d\t%d\t%d\n", stats_run_no_write_fails, stats_total_no_write_fails, (stats_total_no_write_fails / stats_runs), ((stats_total_no_write_fails * 100) / stats_total_fails));
+		printf("STATS: Fail writing 0x00000000\t%d\t%d\t%d\t%d\n", stats_run_write_00000000_fails, stats_total_write_00000000_fails, (stats_total_write_00000000_fails / stats_runs), ((stats_total_write_00000000_fails * 100) / stats_total_fails));
+		printf("STATS: Fail writing 0xFFFFFFFF\t%d\t%d\t%d\t%d\n", stats_run_write_FFFFFFFF_fails, stats_total_write_FFFFFFFF_fails, (stats_total_write_FFFFFFFF_fails / stats_runs), ((stats_total_write_FFFFFFFF_fails * 100) / stats_total_fails));
+		printf("STATS: Fail writing 0xAAAAAAAA\t%d\t%d\t%d\t%d\n", stats_run_write_AAAAAAAA_fails, stats_total_write_AAAAAAAA_fails, (stats_total_write_AAAAAAAA_fails / stats_runs), ((stats_total_write_AAAAAAAA_fails * 100) / stats_total_fails));
+		printf("STATS: Wrote 0x00000000       \t%d\t%d\t%d\t%d\n", stats_run_wrote_00000000_fails, stats_total_wrote_00000000_fails, (stats_total_wrote_00000000_fails / stats_runs), ((stats_total_wrote_00000000_fails * 100) / stats_total_fails));
+		printf("STATS: Fail moving  0x00000000\t%d\t%d\t%d\t%d\n", stats_run_move_00000000_fails, stats_total_move_00000000_fails, (stats_total_move_00000000_fails / stats_runs), ((stats_total_move_00000000_fails * 100) / stats_total_fails) );
+		printf("STATS: Fail moving  0xFFFFFFFF\t%d\t%d\t%d\t%d\n", stats_run_move_FFFFFFFF_fails, stats_total_move_FFFFFFFF_fails, (stats_total_move_FFFFFFFF_fails / stats_runs), ((stats_total_move_FFFFFFFF_fails * 100) / stats_total_fails) );
+		printf("STATS: Adj  moving  0x00000000\t%d\t%d\t%d\t%d\n", stats_adj_move_00000000_fails, stats_total_adj_move_00000000_fails, (stats_total_adj_move_00000000_fails / stats_runs), ((stats_total_adj_move_00000000_fails * 100) / stats_total_fails) );
+		printf("STATS: Adj  moving  0xFFFFFFFF\t%d\t%d\t%d\t%d\n", stats_adj_move_FFFFFFFF_fails, stats_total_adj_move_FFFFFFFF_fails, (stats_total_adj_move_FFFFFFFF_fails / stats_runs), ((stats_total_adj_move_FFFFFFFF_fails * 100) / stats_total_fails) );
+	}
+	printf("============================================================================================\n");
+	#endif
+	/*}}}	*/
+
+	if (error >= 1)
+		return 1;
+	else
+		return 0;
+}
+
+/*}}}	*/
diff --git a/lib_sh/strlen.S b/lib_sh/strlen.S
new file mode 100644
index 0000000000..9737892ca4
--- /dev/null
+++ b/lib_sh/strlen.S
@@ -0,0 +1,71 @@
+/*
+ * lib_sh/strlen.S
+ *
+ * "strlen" implementation of SuperH
+ *
+ * Copyright (C) 1999  Kaz Kojima
+ *
+ */
+
+/* size_t strlen (const char *s)  */
+
+#include "asm/linkage.h"
+ENTRY(strlen)
+	mov	r4,r0
+	and	#3,r0
+	tst	r0,r0
+	bt/s	1f
+	 mov	#0,r2
+
+	add	#-1,r0
+	shll2	r0
+	shll	r0
+	braf	r0
+	 nop
+
+	mov.b	@r4+,r1
+	tst	r1,r1
+	bt	8f
+	add	#1,r2
+
+	mov.b	@r4+,r1
+	tst	r1,r1
+	bt	8f
+	add	#1,r2
+
+	mov.b	@r4+,r1
+	tst	r1,r1
+	bt	8f
+	add	#1,r2
+
+1:
+	mov	#0,r3
+2:
+	mov.l	@r4+,r1
+	cmp/str	r3,r1
+	bf/s	2b
+	 add	#4,r2
+
+	add	#-4,r2
+#ifndef __LITTLE_ENDIAN__
+	swap.b	r1,r1
+	swap.w	r1,r1
+	swap.b	r1,r1
+#endif
+	extu.b	r1,r0
+	tst	r0,r0
+	bt/s	8f
+	 shlr8	r1
+	add	#1,r2
+	extu.b	r1,r0
+	tst	r0,r0
+	bt/s	8f
+	 shlr8	r1
+	add	#1,r2
+	extu.b	r1,r0
+	tst	r0,r0
+	bt	8f
+	add	#1,r2
+8:
+	rts
+	 mov	r2,r0
diff --git a/lib_sh/time.c b/lib_sh/time.c
new file mode 100644
index 0000000000..1d4af56637
--- /dev/null
+++ b/lib_sh/time.c
@@ -0,0 +1,174 @@
+/*
+ * (C) Copyright 2009
+ * Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+ *
+ * (C) Copyright 2004,2009 STMicroelectronics.
+ * Andy Sturges <andy.sturges@st.com>
+ * Sean McGoogan <Sean.McGoogan@st.com>
+ *
+ * (C) Copyright 2007-2008
+ * Nobobuhiro Iwamatsu <iwamatsu@nigauri.org>
+ *
+ * (C) Copyright 2003
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/socregs.h>
+#include <div64.h>
+#include <asm/processor.h>
+#include <asm/clk.h>
+#include <asm/io.h>
+
+#define TMU_MAX_COUNTER (~0UL)
+
+#if !defined(TMU_CLK_DIVIDER)
+#define TMU_CLK_DIVIDER		4	/* Clock divided by 4 is FASTEST */
+#endif	/* TMU_CLK_DIVIDER */
+
+static ulong timer_freq;
+
+static inline unsigned long long tick_to_time(unsigned long long tick)
+{
+	tick *= CFG_HZ;
+	do_div(tick, timer_freq);
+
+	return tick;
+}
+
+static inline unsigned long long usec_to_tick(unsigned long long usec)
+{
+	usec *= timer_freq;
+	do_div(usec, 1000000);
+
+	return usec;
+}
+
+static void tmu_timer_start (unsigned int timer)
+{
+	if (timer > 2)
+		return;
+	writeb(readb(TSTR) | (1 << timer), TSTR);
+}
+
+static void tmu_timer_stop (unsigned int timer)
+{
+	if (timer > 2)
+		return;
+	writeb(readb(TSTR) & ~(1 << timer), TSTR);
+}
+
+int timer_init (void)
+{
+	/* Divide clock by TMU_CLK_DIVIDER */
+	u16 bit = 0;
+
+	switch (TMU_CLK_DIVIDER) {
+	case 1024:
+		bit = 4;
+		break;
+	case 256:
+		bit = 3;
+		break;
+	case 64:
+		bit = 2;
+		break;
+	case 16:
+		bit = 1;
+		break;
+	case 4:
+	default:
+		break;
+	}
+	writew(readw(TCR0) | bit, TCR0);
+
+	/* Clock frequency calc */
+	timer_freq = get_tmu0_clk_rate() >> ((bit + 1) * 2);
+
+	tmu_timer_stop(0);
+	tmu_timer_start(0);
+
+	return 0;
+}
+
+unsigned long long get_ticks (void)
+{
+	return 0 - readl(TCNT0);
+}
+
+static inline void tick_delay (const unsigned long long delta)
+{
+	const u64 start = get_ticks();		/* get timestamp on entry */
+	u64 tmp = start + delta;		/* calculate end timestamp */
+
+	if (delta == 0)				/* zero delay ? */
+		tmp++;				/* minimum of ONE tick */
+
+	if (tmp > TMU_MAX_COUNTER)		/* overflows 32-bits ? */
+	{
+		while (get_ticks() >= start)	/* loop till overflowed */
+			/*NOP*/;
+		tmp &= TMU_MAX_COUNTER;		/* mask off upper 32-bits */
+	}
+
+	while (get_ticks() < tmp)		/* loop till event */
+		/*NOP*/;
+}
+
+void udelay (unsigned long usec)		/* delay in micro-seconds */
+{
+	u64 delta = usec_to_tick(usec);		/* time to wait */
+
+	tick_delay (delta);			/* wait ... */
+}
+
+void ndelay (unsigned long nsec)		/* delay in nano-seconds */
+{
+	u64 delta = usec_to_tick(nsec);		/* time to wait */
+
+	delta /= 1000ull;			/* remember: nsec not usec ! */
+
+	tick_delay (delta);			/* wait ... */
+}
+
+unsigned long get_timer (unsigned long base)
+{
+	/* return msec */
+	return tick_to_time(get_ticks()) - base;
+}
+
+void set_timer (unsigned long t)
+{
+	/* Note: timer must be STOPPED to update it */
+	tmu_timer_stop(0);
+	writel((0 - t), TCNT0);
+	tmu_timer_start(0);
+}
+
+void reset_timer (void)
+{
+	set_timer (0);
+}
+
+unsigned long get_tbclk (void)
+{
+	return timer_freq;
+}
diff --git a/lib_sh/udivdi3.c b/lib_sh/udivdi3.c
new file mode 100644
index 0000000000..68f038bf3c
--- /dev/null
+++ b/lib_sh/udivdi3.c
@@ -0,0 +1,16 @@
+/*
+ * Simple __udivdi3 function which doesn't use FPU.
+ */
+
+#include <linux/types.h>
+
+extern u64 __xdiv64_32(u64 n, u32 d);
+extern void panic(const char * fmt, ...);
+
+u64 __udivdi3(u64 n, u64 d)
+{
+	if (d & ~0xffffffff)
+		panic("Need true 64-bit/64-bit division");
+	return __xdiv64_32(n, (u32)d);
+}
+
diff --git a/make_factroy_uboot b/make_factroy_uboot
new file mode 100755
index 0000000000..ba33503e4d
Binary files /dev/null and b/make_factroy_uboot differ
diff --git a/net/eth.c b/net/eth.c
index 1b56a356c4..879f10804e 100644
--- a/net/eth.c
+++ b/net/eth.c
@@ -518,7 +518,7 @@ extern int emac4xx_miiphy_initialize(bd_t *bis);
 extern int mcf52x2_miiphy_initialize(bd_t *bis);
 extern int ns7520_miiphy_initialize(bd_t *bis);
 extern int dm644x_eth_miiphy_initialize(bd_t *bis);
-
+extern int stmac_miiphy_initialize(bd_t *bis);
 
 int eth_initialize(bd_t *bis)
 {
@@ -541,6 +541,9 @@ int eth_initialize(bd_t *bis)
 #endif
 #if defined(CONFIG_DRIVER_TI_EMAC)
 	dm644x_eth_miiphy_initialize(bis);
+#endif
+#if defined(CONFIG_DRIVER_NETSTMAC) || defined(CONFIG_DRIVER_NET_STM_GMAC)
+	stmac_miiphy_initialize(bis);
 #endif
 	return 0;
 }
diff --git a/net/tftp.c b/net/tftp.c
index 8b95bcfec4..a10de80c12 100644
--- a/net/tftp.c
+++ b/net/tftp.c
@@ -315,7 +315,7 @@ TftpHandler (uchar * pkt, unsigned dest, unsigned src, unsigned len)
 		if (TftpBlock == 0) {
 			TftpBlockWrap++;
 			TftpBlockWrapOffset += TftpBlkSize * TFTP_SEQUENCE_SIZE;
-			printf ("\n\t %lu MB received\n\t ", TftpBlockWrapOffset>>20);
+			printf ("\n\t %lu MiB received\n\t ", TftpBlockWrapOffset>>20);
 		} else {
 			if (((TftpBlock - 1) % 10) == 0) {
 				putc ('#');
diff --git a/sh_config.mk b/sh_config.mk
new file mode 100644
index 0000000000..82d31100ff
--- /dev/null
+++ b/sh_config.mk
@@ -0,0 +1,33 @@
+#
+# (C) Copyright 2004-2009
+# Andy Sturges, STMicroelectronics, andy.sturges@st.com
+# Sean McGoogan STMicroelectronics, <Sean.McGoogan@st.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+# Update this for each release.
+# The SPEC file will automatically substitute the date
+# for actual build number, in the following identifier.
+# Regular Expression for string is:
+# 	"stm[2-9][0-9]-[2-9][0-9][0-9][0-9]-[01][0-9]-[0-3][0-9]"
+SH_IDENT_STRING="\"stm23_0045\""
+
+PLATFORM_CPPFLAGS += -DCONFIG_SH4 -D__SH4__ -DCONFIG_IDENT_STRING=$(SH_IDENT_STRING)
+PLATFORM_LDFLAGS  += -n
diff --git a/smit/README b/smit/README
new file mode 100644
index 0000000000..0a53c66bf6
--- /dev/null
+++ b/smit/README
@@ -0,0 +1,49 @@
+u-boot-sh4-1.3.1_stm23_0045.tar.gz
+-------------------------
+1) Unpack:
+
+	$ tar -xzvf u-boot-sh4-1.3.1_stm23_0045.tar.gz
+
+2) Change to source directory:
+
+	$ cd u-boot-sh4-1.3.1_stm23_0045
+
+3) Config:
+
+	$ make pdk7105se_config
+
+4) Compile, build u-boot.bin:
+
+	$ make
+
+5) build smit_gb620_uboot_issue.bin on the file of factory_issue
+
+	./make_factroy_uboot
+
+
+
+diff   smit_gb620_uboot_issue.bin   u-boot.bin
+----------
+	 smit_gb620_uboot_issue.bin is add app version on spi special address.
+
+uboot_update_tool
+--------
+	make uboot update file, build iptvubootupdate.bin.
+
+	1) copy u-boot.bin to uboot_update_tool
+	   cp u-boot.bin uboot_update_tool/
+
+	2) build iptvubootupdate.bin
+		 source makeupdateSW.sh
+
+release
+--------
+	u-boot.bin
+	smit_gb620_uboot_issue.bin
+	iptvubootupdate.bin
+
+	finally, put smit_gb620_uboot_issue.bin into spi flash, copy iptvubootupdate.bin to fat usb.
+
+	Good luck...
+
+	Jason <jiagong@smit.com.cn>  2010-10-10 update
diff --git a/smit/release/iptvubootupdate.bin b/smit/release/iptvubootupdate.bin
new file mode 100644
index 0000000000..e45e9c72be
Binary files /dev/null and b/smit/release/iptvubootupdate.bin differ
diff --git a/smit/release/smit_gb620_uboot_issue.bin b/smit/release/smit_gb620_uboot_issue.bin
new file mode 100644
index 0000000000..695a62bf94
Binary files /dev/null and b/smit/release/smit_gb620_uboot_issue.bin differ
diff --git a/smit/release/u-boot.bin b/smit/release/u-boot.bin
new file mode 100644
index 0000000000..7d05d9f2cf
Binary files /dev/null and b/smit/release/u-boot.bin differ
diff --git a/smit/uboot_update_tool/MakeBinFile b/smit/uboot_update_tool/MakeBinFile
new file mode 100755
index 0000000000..f54d56f5bf
Binary files /dev/null and b/smit/uboot_update_tool/MakeBinFile differ
diff --git a/smit/uboot_update_tool/makeupdateSW.sh b/smit/uboot_update_tool/makeupdateSW.sh
new file mode 100755
index 0000000000..43d3a4bcdf
--- /dev/null
+++ b/smit/uboot_update_tool/makeupdateSW.sh
@@ -0,0 +1,77 @@
+#!/bin/sh
+
+echo ""
+echo "**********"**********"**********"**********"*****"
+echo "******* Welcom to use Make Update File (for GB620) ******"
+echo "**********"**********"**********"**********"*****"
+
+echo ""
+echo "-->Need Update uboot? Set \"y\" to update,set \"n\" to ignore"
+read -p "UPDATEUBOOT =" UPDATEUBOOT
+if [ "$UPDATEUBOOT" = y ]
+	then
+		echo ""
+		echo "-->Please input uboot SW version:"
+		read -p "UBOOT_VER =" UBOOT_VER
+else
+		UPDATEUBOOT=n
+		UBOOT_VER=0
+fi
+
+
+echo ""
+echo "-->Please input HW version:"
+echo "SMIT: input \"1\" "
+read -p "HW_VER =" HW_VER
+
+echo ""
+echo "-->Please input device ID: "
+echo "GB620: input \"620\" "
+read -p "DEV_ID =" DEV_ID
+
+echo ""
+echo "-->Please input factory ID:"
+echo "SMIT: input \"101\" "
+read -p "FAC_ID =" FAC_ID
+
+echo ""
+echo "-->Please input Date:"
+echo "eg: 2010-05  input \"1005\" "
+read -p "DATE =" DATE
+
+
+echo ""
+echo ""
+echo "**************** Confirm Your Input Information *************"
+echo ""
+echo "Update uboot: $UPDATEUBOOT"
+if [ "$UBOOT_VER" != 0 ]
+	then
+echo "Uboot version: $UBOOT_VER"
+fi
+
+echo "SW_VER: $SW_VER"
+echo "HW_VER: $HW_VER"
+echo "DEV_ID: $DEV_ID"
+echo "FAC_ID: $FAC_ID"
+echo "Date  : $DATE"
+
+
+
+echo ""
+echo "****************Please Confirm above Information *************"
+echo ""
+
+echo "If the input info is no error,please input \"y\", or input \"n\"."
+read -p "InputInfoNoError =" InputInfoNoError
+
+
+if [ "$InputInfoNoError" = y ]
+	then
+	echo "Call MakeBinFile:"
+./MakeBinFile  $UPDATEUBOOT $UBOOT_VER $HW_VER $DEV_ID $FAC_ID $DATE
+
+else
+	echo "Please retry!!!"
+fi
+
diff --git a/tools/mkimage.c b/tools/mkimage.c
index 21251306ac..60e9940f00 100644
--- a/tools/mkimage.c
+++ b/tools/mkimage.c
@@ -91,6 +91,7 @@ table_entry_t arch_name[] = {
     {	IH_CPU_PPC,		"ppc",		"PowerPC",	},
     {	IH_CPU_S390,		"s390",		"IBM S390",	},
     {	IH_CPU_SH,		"sh",		"SuperH",	},
+    {	IH_CPU_ST200,		"st200",	"STMicroelectronics ST200",	},
     {	IH_CPU_SPARC,		"sparc",	"SPARC",	},
     {	IH_CPU_SPARC64,		"sparc64",	"SPARC 64 Bit",	},
     {	IH_CPU_BLACKFIN,	"blackfin",	"Blackfin",	},
@@ -626,7 +627,7 @@ print_header (image_header_t *hdr)
 	printf ("Image Name:   %.*s\n", IH_NMLEN, hdr->ih_name);
 	printf ("Created:      %s", ctime(&timestamp));
 	printf ("Image Type:   "); print_type(hdr);
-	printf ("Data Size:    %d Bytes = %.2f kB = %.2f MB\n",
+	printf ("Data Size:    %d Bytes = %.2f KiB = %.2f MiB\n",
 		size, (double)size / 1.024e3, (double)size / 1.048576e6 );
 	printf ("Load Address: 0x%08X\n", ntohl(hdr->ih_load));
 	printf ("Entry Point:  0x%08X\n", ntohl(hdr->ih_ep));
@@ -648,7 +649,7 @@ print_header (image_header_t *hdr)
 		for (i=0; len_ptr[i]; ++i) {
 			size = ntohl(len_ptr[i]);
 
-			printf ("   Image %d: %8d Bytes = %4d kB = %d MB\n",
+			printf ("   Image %d: %8d Bytes = %4d KiB = %d MiB\n",
 				i, size, size>>10, size>>20);
 			if (hdr->ih_type == IH_TYPE_SCRIPT && i > 0) {
 				/*
diff --git a/tools/scripts/define2mk.sed b/tools/scripts/define2mk.sed
index 6464627ea4..d66de86c5c 100644
--- a/tools/scripts/define2mk.sed
+++ b/tools/scripts/define2mk.sed
@@ -27,3 +27,28 @@
 	# print the line
 	p
 }
+
+# Also, add the definition for "CFG_SDRAM_BASE".
+# This is for the SH boards, where the address of SDRAM can vary
+# depending on the exact board, and if it is in 29 or 32-bit mode.
+# Used by examples/Makefile
+/^#define CFG_SDRAM_BASE/ {
+	# Strip the #define prefix
+	s/#define *//;
+	# Change to form CONFIG_*=VALUE
+	s/ \+/=/;
+	# Drop trailing spaces
+	s/ *$//;
+	# drop quotes around string values
+	s/="\(.*\)"$/=\1/;
+	# Concatenate string values
+	s/" *"//g;
+	# Wrap non-numeral values with quotes
+	s/=\(.*\?[^0-9].*\)$/=\"\1\"/;
+	# Change '1' and empty values to "y" (not perfect, but
+	# supports conditional compilation in the makefiles
+	s/=$/=y/;
+	s/=1$/=y/;
+	# print the line
+	p
+}
diff --git a/tools/updater/flash_hw.c b/tools/updater/flash_hw.c
index 2d9b8c8802..f16b2e9723 100644
--- a/tools/updater/flash_hw.c
+++ b/tools/updater/flash_hw.c
@@ -210,49 +210,49 @@ static ulong flash_get_size (ulong addr, flash_info_t *info)
 			info->flash_id += FLASH_AM400T;
 			info->sector_count = 11;
 			info->size = 0x00100000;
-			break;			/* => 1 MB		*/
+			break;			/* => 1 MiB		*/
 
 		case AMD_ID_LV400B:
 			DEBUGF("Am29LV400B\n");
 			info->flash_id += FLASH_AM400B;
 			info->sector_count = 11;
 			info->size = 0x00100000;
-			break;			/* => 1 MB		*/
+			break;			/* => 1 MiB		*/
 
 		case AMD_ID_LV800T:
 			DEBUGF("Am29LV800T\n");
 			info->flash_id += FLASH_AM800T;
 			info->sector_count = 19;
 			info->size = 0x00200000;
-			break;			/* => 2 MB		*/
+			break;			/* => 2 MiB		*/
 
 		case AMD_ID_LV800B:
 			DEBUGF("Am29LV400B\n");
 			info->flash_id += FLASH_AM800B;
 			info->sector_count = 19;
 			info->size = 0x00200000;
-			break;			/* => 2 MB		*/
+			break;			/* => 2 MiB		*/
 
 		case AMD_ID_LV160T:
 			DEBUGF("Am29LV160T\n");
 			info->flash_id += FLASH_AM160T;
 			info->sector_count = 35;
 			info->size = 0x00400000;
-			break;			/* => 4 MB		*/
+			break;			/* => 4 MiB		*/
 
 		case AMD_ID_LV160B:
 			DEBUGF("Am29LV160B\n");
 			info->flash_id += FLASH_AM160B;
 			info->sector_count = 35;
 			info->size = 0x00400000;
-			break;			/* => 4 MB		*/
+			break;			/* => 4 MiB		*/
 
 		case AMD_ID_LV320T:
 			DEBUGF("Am29LV320T\n");
 			info->flash_id += FLASH_AM320T;
 			info->sector_count = 67;
 			info->size = 0x00800000;
-			break;			/* => 8 MB		*/
+			break;			/* => 8 MiB		*/
 
 #if 0
 		/* Has the same ID as AMD_ID_LV320T, to be fixed */
@@ -261,7 +261,7 @@ static ulong flash_get_size (ulong addr, flash_info_t *info)
 			info->flash_id += FLASH_AM320B;
 			info->sector_count = 67;
 			info->size = 0x00800000;
-			break;			/* => 8 MB		*/
+			break;			/* => 8 MiB		*/
 #endif
 
 		case AMD_ID_LV033C:
@@ -613,33 +613,33 @@ void flash_print_info (flash_info_t *info)
 	}
 
 	switch (info->flash_id & FLASH_TYPEMASK) {
-	case FLASH_AM040:	printf ("29F040 or 29LV040 (4 Mbit, uniform sectors)\n");
+	case FLASH_AM040:	printf ("29F040 or 29LV040 (4 Mibit, uniform sectors)\n");
 				break;
-	case FLASH_AM400B:	printf ("AM29LV400B (4 Mbit, bottom boot sect)\n");
+	case FLASH_AM400B:	printf ("AM29LV400B (4 Mibit, bottom boot sect)\n");
 				break;
-	case FLASH_AM400T:	printf ("AM29LV400T (4 Mbit, top boot sector)\n");
+	case FLASH_AM400T:	printf ("AM29LV400T (4 Mibit, top boot sector)\n");
 				break;
-	case FLASH_AM800B:	printf ("AM29LV800B (8 Mbit, bottom boot sect)\n");
+	case FLASH_AM800B:	printf ("AM29LV800B (8 Mibit, bottom boot sect)\n");
 				break;
-	case FLASH_AM800T:	printf ("AM29LV800T (8 Mbit, top boot sector)\n");
+	case FLASH_AM800T:	printf ("AM29LV800T (8 Mibit, top boot sector)\n");
 				break;
-	case FLASH_AM160B:	printf ("AM29LV160B (16 Mbit, bottom boot sect)\n");
+	case FLASH_AM160B:	printf ("AM29LV160B (16 Mibit, bottom boot sect)\n");
 				break;
-	case FLASH_AM160T:	printf ("AM29LV160T (16 Mbit, top boot sector)\n");
+	case FLASH_AM160T:	printf ("AM29LV160T (16 Mibit, top boot sector)\n");
 				break;
-	case FLASH_AM320B:	printf ("AM29LV320B (32 Mbit, bottom boot sect)\n");
+	case FLASH_AM320B:	printf ("AM29LV320B (32 Mibit, bottom boot sect)\n");
 				break;
-	case FLASH_AM320T:	printf ("AM29LV320T (32 Mbit, top boot sector)\n");
+	case FLASH_AM320T:	printf ("AM29LV320T (32 Mibit, top boot sector)\n");
 				break;
 	default:		printf ("Unknown Chip Type\n");
 				break;
 	}
 
 	if (info->size % 0x100000 == 0) {
-		printf ("  Size: %ld MB in %d Sectors\n",
+		printf ("  Size: %ld MiB in %d Sectors\n",
 			info->size / 0x100000, info->sector_count);
 	} else if (info->size % 0x400 == 0) {
-		printf ("  Size: %ld KB in %d Sectors\n",
+		printf ("  Size: %ld KiB in %d Sectors\n",
 			info->size / 0x400, info->sector_count);
 	} else {
 		printf ("  Size: %ld B in %d Sectors\n",
